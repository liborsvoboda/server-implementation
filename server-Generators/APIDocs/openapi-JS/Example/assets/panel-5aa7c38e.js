var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
import "./modulepreload-polyfill-7faf532e.js";
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$3(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$3 && a[z$3] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$2(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$2.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$2.prototype;
function G$2(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
var H$2 = G$2.prototype = new F$1();
H$2.constructor = G$2;
C$2(H$2, E$2.prototype);
H$2.isPureReactComponent = true;
var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps)
    for (d2 in g2 = a.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$2(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$2(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape$2(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$2 = /\/+/g;
function Q$2(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape$2("" + a.key) : b2.toString(36);
}
function R$2(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$2:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a && (e2 = a.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a2) {
      return a2;
    })) : null != c2 && (O$2(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d2 + Q$2(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$3(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a)
    return a;
  var d2 = [], c2 = 0;
  R$2(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$2(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$2(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$3;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$2({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$2, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a) {
  var b2 = M$2.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$3, render: a };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a }, _init: T$2 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$2, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b2) {
  return U$2.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$2.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$2.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$2.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$2.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$2.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$2.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$2.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$2.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$2.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$2.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$2.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$3.call(a, b2) && !p$3.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a = c2.defaultProps, a)
      void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a[d2];
        if (0 < g2(e2, b2))
          a[d2] = b2, a[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a:
        for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a[d2] = x2, a[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$2[a] = new v$2(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$2[b2] = new v$2(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$2[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$2[a] = new v$2(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$2[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$2[a] = new v$2(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$2[a] = new v$2(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$2[a] = new v$2(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$2[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$2[b2] = new v$2(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$2[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$2[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$2 = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a.value || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$2(91));
  return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$2(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$2(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$2(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$2(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$2(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$2(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib)
    return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$2(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$2(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$2(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$2(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$2(190));
  }
  if (3 !== c2.tag)
    throw Error(p$2(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2)
      hd(a, b2, d2, id$2, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id$2, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a, b2, d2, null, c2);
  }
}
var id$2 = null;
function Yc(a, b2, c2, d2) {
  id$2 = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c2 = b2.tag, 13 === c2) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id$2 = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a)
      a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je$1(a, b2) {
  switch (a) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a = b2.data, a === ee$1 && fe$1 ? null : a;
    default:
      return null;
  }
}
function ke$1(a, b2) {
  if (ie)
    return "compositionend" === a || !ae && ge$1(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a.type] : "textarea" === b2 ? true : false;
}
function ne$1(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$1(a) {
  se$1(a, 0);
}
function te$1(a) {
  var b2 = ue$1(a);
  if (Wa(b2))
    return a;
}
function ve$1(a, b2) {
  if ("change" === a)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a) {
  if ("value" === a.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a, xb(a));
    Jb(re$1, b2);
  }
}
function Ce$1(a, b2, c2) {
  "focusin" === a ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a && Ae$1();
}
function De$1(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te$1(qe$1);
}
function Ee$1(a, b2) {
  if ("click" === a)
    return te$1(b2);
}
function Fe$1(a, b2) {
  if ("input" === a || "change" === a)
    return te$1(b2);
}
function Ge$1(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a, b2) {
  if (He$1(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke$1(a, b2) {
  var c2 = Je$1(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$1(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne$1(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe$1(a) {
  var b2 = Me$1(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$1(c2, f2);
        var g2 = Ke$1(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a) {
  if (Xe$1[a])
    return Xe$1[a];
  if (!We$1[a])
    return a;
  var b2 = We$1[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a] = b2[c2];
  return a;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se$1(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D$1(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge$1(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a, c2) : ke$1(a, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe$1(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2)
    throw Error(p$2(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a = Mf(a); null !== a; ) {
          if (c2 = a[Of])
            return c2;
          a = Mf(a);
        }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue$1(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$2(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E$1(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E$1(Wf);
  E$1(H$1);
}
function ag(a, b2, c2) {
  if (H$1.current !== Vf)
    throw Error(p$2(168));
  G$1(H$1, b2);
  G$1(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$2(108, Ra(a) || "Unknown", e2));
  return A$2({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$1.current;
  G$1(H$1, a);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(p$2(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E$1(Wf), E$1(H$1), G$1(H$1, a)) : E$1(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$2(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I$1 = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$2(418));
      a.flags = a.flags & -4097 | 2;
      I$1 = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I$1)
    return Fg(a), I$1 = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$2(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$2(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$2({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b2 = Mg.current;
  E$1(Mg);
  a._currentValue = b2;
}
function Sg(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2)
      break;
    a = a.return;
  }
}
function Tg(a, b2) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b2 = a._currentValue;
  if (Pg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$2(308));
      Og = a;
      Ng.dependencies = { lanes: 0, firstContext: a };
    } else
      Og = Og.next = a;
  return b2;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a, d2);
}
function Zg(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a, c2);
}
function eh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function fh(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$2({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function ih(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$2(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L$1(), e2 = lh(a), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L$1(), e2 = lh(a), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = L$1(), d2 = lh(a), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a, e2, d2);
  null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
} };
function oh(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : true;
}
function ph(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = jh;
  ah(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$2(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$2(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$2(284));
    if (!c2._owner)
      throw Error(p$2(290, a));
  }
  return a;
}
function th(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$2(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function uh(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function vh$1(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = wh(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = sh(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
      th(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      th(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$1 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$2(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$1 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d3, f3, h3);
      if (Ka(f3))
        return t2(a2, d3, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh)
    throw Error(p$2(174));
  return a;
}
function Ih(a, b2) {
  G$1(Gh, b2);
  G$1(Fh, a);
  G$1(Eh, Dh);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E$1(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G$1(Fh, a), G$1(Eh, c2));
}
function Lh(a) {
  Fh.current === a && (E$1(Eh), E$1(Fh));
}
var M$1 = Uf(0);
function Mh(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++)
    Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$2(321));
}
function Wh(a, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!He$1(a[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$2(301));
      f2 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N$1 = null;
  Sh = false;
  if (b2)
    throw Error(p$2(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$1.memoizedState = P$1 = a : P$1 = P$1.next = a;
  return P$1;
}
function di() {
  if (null === O$1) {
    var a = N$1.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = O$1.next;
  var b2 = null === P$1 ? N$1.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a;
  else {
    if (null === a)
      throw Error(p$2(310));
    O$1 = a;
    a = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N$1.memoizedState = P$1 = a : P$1 = P$1.next = a;
  }
  return P$1;
}
function ei(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function fi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$2(311));
  c2.lastRenderedReducer = a;
  var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$1.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$2(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a, b2) {
  var c2 = N$1, d2 = di(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$1)
      throw Error(p$2(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function mi(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a);
}
function ki(a, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a);
  });
}
function oi(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He$1(a, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a) {
  var b2 = Zg(a, 1);
  null !== b2 && mh(b2, a, 1, -1);
}
function qi(a) {
  var b2 = ci();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ri.bind(null, N$1, a);
  return [b2.memoizedState, a];
}
function li(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b2, c2, d2) {
  var e2 = ci();
  N$1.flags |= a;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$1.flags |= a;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a, b2) {
  return ti(8390656, 8, a, b2);
}
function ji(a, b2) {
  return ui(2048, 8, a, b2);
}
function wi(a, b2) {
  return ui(4, 2, a, b2);
}
function xi(a, b2) {
  return ui(4, 4, a, b2);
}
function yi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function zi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b2, a), c2);
}
function Ai() {
}
function Bi(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function Ci(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function Di(a, b2, c2) {
  if (0 === (Rh & 21))
    return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a.baseState = true);
  return b2;
}
function Ei(a, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b2, c2) {
  var d2 = lh(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, c2);
  else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
    var e2 = L$1();
    mh(c2, a, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a, b2, c2) {
  var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a, b2, e2, d2);
    null !== c2 && (e2 = L$1(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a) {
  var b2 = a.alternate;
  return a === N$1 || null !== b2 && b2 === N$1;
}
function Ii(a, b2) {
  Th = Sh = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Ji(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
  ci().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ti(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ti(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = Gi.bind(null, N$1, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = ci();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b2 = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = N$1, e2 = ci();
  if (I$1) {
    if (void 0 === c2)
      throw Error(p$2(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$2(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = ci(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b2 = di().memoizedState;
    return [a, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a : Di(b2, O$1.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b2 = di().memoizedState;
  return [a, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Li(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a, b2);
  };
  return c2;
}
function Ri(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
}
function Vi(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b2, c2, d2) {
  b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
}
function Zi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, d2, e2);
  return b2.child;
}
function aj(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
    a = yh(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a.ref === b2.ref)
      return $i(a, b2, e2);
  }
  b2.flags |= 1;
  a = wh(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function cj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie$1(f2, d2) && a.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a.lanes, $i(a, b2, e2);
  }
  return dj(a, b2, c2, d2, e2);
}
function ej(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a, b2, e2, c2);
  return b2.child;
}
function hj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$1.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, c2, e2);
  return b2.child;
}
function ij(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a, b2, c2, d2, f2, e2);
}
function kj(a, b2, c2, d2, e2, f2) {
  hj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  Ih(a, b2.containerInfo);
}
function mj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G$1(M$1, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function tj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a.child, null, c2);
  a = rj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function sj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$2(422))), tj(a, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$2(419));
    d2 = Li(f2, d2, void 0);
    return tj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
    }
    uj();
    d2 = Li(Error(p$2(421)));
    return tj(a, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a.return, b2, c2);
}
function xj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && wj(a, c2, b2);
          else if (19 === a.tag)
            wj(a, c2, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  G$1(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Mh(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$2(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = wh(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; )
      a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a, b2, c2);
        G$1(M$1, M$1.current & 1);
        a = $i(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G$1(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2)
          return yj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a, b2, c2);
  }
  return $i(a, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$2({}, e2, { value: void 0 });
        d2 = A$2({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a, b2) {
  if (!I$1)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Fj(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$1);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode)
        Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$2(166));
          S(b2);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$1("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          Aj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a);
                D$1("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D$1("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a
                );
                D$1("load", a);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D$1("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$2({}, d2, { value: void 0 });
                D$1("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D$1("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Dj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$2(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E$1(M$1);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$2(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$2(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E$1(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g2 = Mh(a);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                G$1(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a = Mh(g2), null !== a) {
            if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S(b2), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = M$1.current, G$1(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
function Jj(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$1), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M$1);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$2(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a, b2) {
  var c2 = a.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a, b2, d2);
  }
}
var Oj = false;
function Pj(a, b2) {
  Cf = dd;
  a = Me$1();
  if (Ne$1(a)) {
    if ("selectionStart" in a)
      var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V$1 = a;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$2(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V$1 = a;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Tj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Tj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Uj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Wj(a, b2, c2), a = a.sibling; null !== a; )
      Wj(a, b2, c2), a = a.sibling;
}
function Xj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Xj(a, b2, c2), a = a.sibling; null !== a; )
      Xj(a, b2, c2), a = a.sibling;
}
var X$1 = null, Yj = false;
function Zj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a, b2, c2), c2 = c2.sibling;
}
function ak(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a, b2, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a, b2, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a, b2, c2);
      break;
    case 21:
      Zj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a, b2, c2), U$1 = d2) : Zj(a, b2, c2);
      break;
    default:
      Zj(a, b2, c2);
  }
}
function bk(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$2(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a), b2 = b2.sibling;
}
function ek(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W$1(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W$1(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a, a.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        if (null === a.stateNode)
          throw Error(p$2(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a);
      fk(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a, a.return, t2);
        }
      break;
    case 4:
      dk(b2, a);
      fk(a);
      break;
    case 13:
      dk(b2, a);
      fk(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
      d2 & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a), U$1 = l2) : dk(b2, a);
      fk(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V$1 = a, m2 = a.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a);
      fk(a);
      d2 & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$2(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      W$1(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function ik(a, b2, c2) {
  V$1 = a;
  jk(a);
}
function jk(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$2(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$1() {
  return 0 !== (K$1 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a = C$1;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$2(185));
  Ac(a, c2, d2);
  if (0 === (K$1 & 2) || a !== R$1)
    a === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$1 && Dk(a, Z$1)), Ek(a, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === R$1 ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Hk(a, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$2(327));
  var c2 = a.callbackNode;
  if (Ik() && a.callbackNode !== c2)
    return null;
  var d2 = uc(a, a === R$1 ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
    b2 = Jk(a, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a || Z$1 !== b2)
      vk = null, Hj = B$1() + 500, Lk(a, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B$1()), c2;
    if (6 === b2)
      Dk(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
        throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B$1()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$1(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$1();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$1() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Ek(a, B$1());
  return a.callbackNode === c2 ? Hk.bind(null, a) : null;
}
function Ok(a, b2) {
  var c2 = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
  a = Jk(a, b2);
  2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a) {
  if (0 !== (K$1 & 6))
    throw Error(p$2(327));
  Ik();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Ek(a, B$1()), null;
  var c2 = Jk(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B$1()), c2;
  if (6 === c2)
    throw Error(p$2(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Qk(a, uk, vk);
  Ek(a, B$1());
  return null;
}
function Rk(a, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a)
      return a();
  } finally {
    C$1 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$1);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a;
  Y$1 = a = wh(a.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a;
}
function Nk(a, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
}
function Jk(a, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a || Z$1 !== b2)
    vk = null, Lk(a, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$2(261));
  R$1 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a) {
  var b2 = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Tk(a) : Y$1 = b2;
  ok.current = null;
}
function Tk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a, b2, c2) {
  var d2 = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a, b2, c2, d2);
  } finally {
    pk.transition = e2, C$1 = d2;
  }
  return null;
}
function Xk(a, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$2(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current)
    throw Error(p$2(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === R$1 && (Y$1 = R$1 = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a, c2);
    ek(c2, a);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a.current = c2;
  wk && (wk = false, xk = a, yk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a, B$1());
  if (null !== b2)
    for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a ? 16 : a;
      if (null === xk)
        var d2 = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$2(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V$1 = a.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a, b2, 1);
  a = dh(a, b2, 1);
  b2 = L$1();
  null !== a && (Ac(a, 1, b2), Ek(a, b2));
}
function W$1(a, b2, c2) {
  if (3 === a.tag)
    Yk(a, a, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a = Ki(c2, a);
          a = Ri(b2, a, 1);
          b2 = dh(b2, a, 1);
          a = L$1();
          null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$1();
  a.pingedLanes |= a.suspendedLanes & c2;
  R$1 === a && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk ? Lk(a, 0) : sk |= c2);
  Ek(a, b2);
}
function Zk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$1();
  a = Zg(a, b2);
  null !== a && (Ac(a, b2, c2), Ek(a, c2));
}
function vj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a, c2);
}
function ck(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a, c2);
}
var Wk;
Wk = function(a, b2, c2) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a, b2, c2);
      Ug = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H$1.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a = Lg(d2, a);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
            break a;
        }
        throw Error(p$2(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a)
          throw Error(p$2(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$2(423)), b2);
            b2 = mj(a, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$2(424)), b2);
            b2 = mj(a, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a, b2, c2);
            break a;
          }
          Yi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return pj(a, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
    case 7:
      return Yi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$2(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
    case 15:
      return cj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
    case 19:
      return yj(a, b2, c2);
    case 22:
      return ej(a, b2, c2);
  }
  throw Error(p$2(156, b2.tag));
};
function Gk(a, b2) {
  return ac(a, b2);
}
function al(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new al(a, b2, c2, d2);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a)
    return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function wh(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function yh(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a)
    bj(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$2(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function qj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function zh(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function bl(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new bl(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function el(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$2(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$2(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2))
      return bg(a, c2, b2);
  }
  return b2;
}
function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = el(null);
  c2 = a.current;
  d2 = L$1();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Ek(a, d2);
  return a;
}
function gl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = dh(e2, b2, g2);
  null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
  return g2;
}
function hl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a, b2) {
  il(a, b2);
  (a = a.alternate) && il(a, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$2(409));
  gl(a, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = hl(g2);
        f2.call(a2);
      };
    }
    var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g2;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = hl(g2);
        h2.call(a2);
      };
    }
    gl(b2, g2, a, e2);
  } else
    g2 = rl(c2, b2, a, e2, d2);
  return hl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$1()), 0 === (K$1 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a, 1);
        if (null !== b3) {
          var c3 = L$1();
          mh(b3, a, 1, c3);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = Zg(a, 134217728);
    if (null !== b2) {
      var c2 = L$1();
      mh(b2, a, 134217728, c2);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = lh(a), c2 = Zg(a, b2);
    if (null !== c2) {
      var d2 = L$1();
      mh(c2, a, b2, d2);
    }
    jl(a, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a, b2) {
  var c2 = C$1;
  try {
    return C$1 = a, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$2(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$2(200));
  return dl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!ol(a))
    throw Error(p$2(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$2(188));
    a = Object.keys(a).join(",");
    throw Error(p$2(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!pl(b2))
    throw Error(p$2(200));
  return sl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!ol(a))
    throw Error(p$2(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2)
    for (a = 0; a < d2.length; a++)
      c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!pl(b2))
    throw Error(p$2(200));
  return sl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a))
    throw Error(p$2(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$2(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$2(38));
  return sl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var createRoot;
var m$2 = reactDomExports;
{
  createRoot = m$2.createRoot;
  m$2.hydrateRoot;
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert2(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS$1 = "-ms-";
var MOZ$1 = "-moz-";
var WEBKIT$1 = "-webkit-";
var COMMENT$1 = "comm";
var RULESET$1 = "rule";
var DECLARATION$1 = "decl";
var IMPORT$1 = "@import";
var KEYFRAMES$1 = "@keyframes";
var LAYER$1 = "@layer";
var abs$1 = Math.abs;
var from$1 = String.fromCharCode;
var assign$2 = Object.assign;
function hash$4(value, length2) {
  return charat$1(value, 0) ^ 45 ? (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
}
function trim$2(value) {
  return value.trim();
}
function match$1(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof$1(value, search2) {
  return value.indexOf(search2);
}
function charat$1(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr$1(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen$1(value) {
  return value.length;
}
function sizeof$1(value) {
  return value.length;
}
function append$1(value, array2) {
  return array2.push(value), value;
}
function combine$1(array2, callback) {
  return array2.map(callback).join("");
}
var line$1 = 1;
var column$1 = 1;
var length$1 = 0;
var position$3 = 0;
var character$1 = 0;
var characters$1 = "";
function node$1(value, root, parent, type2, props, children, length2) {
  return { value, root, parent, type: type2, props, children, line: line$1, column: column$1, length: length2, return: "" };
}
function copy$3(root, props) {
  return assign$2(node$1("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char$1() {
  return character$1;
}
function prev$1() {
  character$1 = position$3 > 0 ? charat$1(characters$1, --position$3) : 0;
  if (column$1--, character$1 === 10)
    column$1 = 1, line$1--;
  return character$1;
}
function next$2() {
  character$1 = position$3 < length$1 ? charat$1(characters$1, position$3++) : 0;
  if (column$1++, character$1 === 10)
    column$1 = 1, line$1++;
  return character$1;
}
function peek$1() {
  return charat$1(characters$1, position$3);
}
function caret$1() {
  return position$3;
}
function slice$1(begin, end2) {
  return substr$1(characters$1, begin, end2);
}
function token$2(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc$1(value) {
  return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$3 = 0, [];
}
function dealloc$1(value) {
  return characters$1 = "", value;
}
function delimit$1(type2) {
  return trim$2(slice$1(position$3 - 1, delimiter$1(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace$1(type2) {
  while (character$1 = peek$1())
    if (character$1 < 33)
      next$2();
    else
      break;
  return token$2(type2) > 2 || token$2(character$1) > 3 ? "" : " ";
}
function escaping$1(index2, count2) {
  while (--count2 && next$2())
    if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
      break;
  return slice$1(index2, caret$1() + (count2 < 6 && peek$1() == 32 && next$2() == 32));
}
function delimiter$1(type2) {
  while (next$2())
    switch (character$1) {
      case type2:
        return position$3;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter$1(character$1);
        break;
      case 40:
        if (type2 === 41)
          delimiter$1(type2);
        break;
      case 92:
        next$2();
        break;
    }
  return position$3;
}
function commenter$1(type2, index2) {
  while (next$2())
    if (type2 + character$1 === 47 + 10)
      break;
    else if (type2 + character$1 === 42 + 42 && peek$1() === 47)
      break;
  return "/*" + slice$1(index2, position$3 - 1) + "*" + from$1(type2 === 47 ? type2 : next$2());
}
function identifier$1(index2) {
  while (!token$2(peek$1()))
    next$2();
  return slice$1(index2, position$3);
}
function compile$1(value) {
  return dealloc$1(parse$9("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
}
function parse$9(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules2;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next$2()) {
      case 40:
        if (previous != 108 && charat$1(characters2, length2 - 1) == 58) {
          if (indexof$1(characters2 += replace$1(delimit$1(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit$1(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      case 92:
        characters2 += escaping$1(caret$1() - 1, 7);
        continue;
      case 47:
        switch (peek$1()) {
          case 42:
          case 47:
            append$1(comment$1(commenter$1(next$2(), caret$1()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen$1(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1)
              characters2 = replace$1(characters2, /\f/g, "");
            if (property > 0 && strlen$1(characters2) - length2)
              append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1) : declaration$1(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append$1(reference2 = ruleset$1(characters2, root, parent, index2, offset2, rules2, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$9(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat$1(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$9(value, reference2, reference2, rule && append$1(ruleset$1(value, reference2, reference2, 0, 0, rules2, points, type2, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$9(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen$1(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek$1() === 45)
              characters2 += delimit$1(next$2());
            atrule = peek$1(), offset2 = length2 = strlen$1(type2 = characters2 += identifier$1(caret$1())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen$1(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset$1(value, root, parent, index2, offset2, rules2, points, type2, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules2 : [""];
  var size2 = sizeof$1(rule);
  for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr$1(value, post + 1, post = abs$1(j = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim$2(j > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root, parent, offset2 === 0 ? RULESET$1 : type2, props, children, length2);
}
function comment$1(value, root, parent) {
  return node$1(value, root, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0);
}
function declaration$1(value, root, parent, length2) {
  return node$1(value, root, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2);
}
function serialize$2(children, callback) {
  var output = "";
  var length2 = sizeof$1(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$8(element, index2, children, callback) {
  switch (element.type) {
    case LAYER$1:
      if (element.children.length)
        break;
    case IMPORT$1:
    case DECLARATION$1:
      return element.return = element.return || element.value;
    case COMMENT$1:
      return "";
    case KEYFRAMES$1:
      return element.return = element.value + "{" + serialize$2(element.children, callback) + "}";
    case RULESET$1:
      element.value = element.props.join(",");
  }
  return strlen$1(children = serialize$2(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware$1(collection) {
  var length2 = sizeof$1(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet$1(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};
function memoize$2(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek$1();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$2(character2)) {
      break;
    }
    next$2();
  }
  return slice$1(begin, position$3);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$2(character2)) {
      case 0:
        if (character2 === 38 && peek$1() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$3 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit$1(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek$1() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next$2());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc$1(toRules(alloc$1(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules2 = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules2.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules2[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules2[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash$4(value, length2)) {
    case 5103:
      return WEBKIT$1 + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT$1 + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
    case 6828:
    case 4268:
      return WEBKIT$1 + value + MS$1 + value + value;
    case 6165:
      return WEBKIT$1 + value + MS$1 + "flex-" + value + value;
    case 5187:
      return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS$1 + "flex-$1$2") + value;
    case 5443:
      return WEBKIT$1 + value + MS$1 + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT$1 + value + MS$1 + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT$1 + "box-" + replace$1(value, "-grow", "") + WEBKIT$1 + value + MS$1 + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS$1 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen$1(value) - 1 - length2 > 6)
        switch (charat$1(value, length2 + 1)) {
          case 109:
            if (charat$1(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ$1 + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof$1(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat$1(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat$1(value, strlen$1(value) - 3 - (~indexof$1(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT$1) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT$1 + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS$1 + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat$1(value, length2 + 11)) {
        case 114:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT$1 + value + MS$1 + value + value;
  }
  return value;
}
var prefixer$1 = function prefixer(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION$1:
          element["return"] = prefix$1(element.value, element.length);
          break;
        case KEYFRAMES$1:
          return serialize$2([copy$3(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT$1)
          })], callback);
        case RULESET$1:
          if (element.length)
            return combine$1(element.props, function(value) {
              switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$2([copy$3(element, {
                    props: [replace$1(value, /:(read-\w+)/, ":" + MOZ$1 + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize$2([copy$3(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")]
                  }), copy$3(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + MOZ$1 + "$1")]
                  }), copy$3(element, {
                    props: [replace$1(value, /:(plac\w+)/, MS$1 + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer$1];
var createCache = function createCache2(options2) {
  var key2 = options2.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$8, rulesheet$1(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware$1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$2(compile$1(styles2), serializer);
    };
    _insert = function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e$1 = b ? Symbol.for("react.fragment") : 60107, f$1 = b ? Symbol.for("react.strict_mode") : 60108, g$1 = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k$1 = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m$1 = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p$1 = b ? Symbol.for("react.suspense") : 60113, q$1 = b ? Symbol.for("react.suspense_list") : 60120, r$2 = b ? Symbol.for("react.memo") : 60115, t$1 = b ? Symbol.for("react.lazy") : 60116, v$1 = b ? Symbol.for("react.block") : 60121, w$1 = b ? Symbol.for("react.fundamental") : 60117, x$1 = b ? Symbol.for("react.responder") : 60118, y$1 = b ? Symbol.for("react.scope") : 60119;
function z$1(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k$1:
              case n:
              case t$1:
              case r$2:
              case h:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A$1(a) {
  return z$1(a) === m$1;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$1;
reactIs_production_min.Lazy = t$1;
reactIs_production_min.Memo = r$2;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$1;
reactIs_production_min.isAsyncMode = function(a) {
  return A$1(a) || z$1(a) === l;
};
reactIs_production_min.isConcurrentMode = A$1;
reactIs_production_min.isContextConsumer = function(a) {
  return z$1(a) === k$1;
};
reactIs_production_min.isContextProvider = function(a) {
  return z$1(a) === h;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z$1(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z$1(a) === e$1;
};
reactIs_production_min.isLazy = function(a) {
  return z$1(a) === t$1;
};
reactIs_production_min.isMemo = function(a) {
  return z$1(a) === r$2;
};
reactIs_production_min.isPortal = function(a) {
  return z$1(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z$1(a) === g$1;
};
reactIs_production_min.isStrictMode = function(a) {
  return z$1(a) === f$1;
};
reactIs_production_min.isSuspense = function(a) {
  return z$1(a) === p$1;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r$2 || a.$$typeof === h || a.$$typeof === k$1 || a.$$typeof === n || a.$$typeof === w$1 || a.$$typeof === x$1 || a.$$typeof === y$1 || a.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$2 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str2) {
  var h2 = 0;
  var k2, i = 0, len = str2.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str2.charCodeAt(i) & 255 | (str2.charCodeAt(++i) & 255) << 8 | (str2.charCodeAt(++i) & 255) << 16 | (str2.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str2.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str2.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str2.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$2(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var getTheme$1 = function getTheme(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$8({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme$1(outerTheme, theme2);
  });
});
var ThemeProvider$1 = function ThemeProvider(props) {
  var theme2 = reactExports.useContext(ThemeContext);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ reactExports.createElement(ThemeContext.Provider, {
    value: theme2
  }, props.children);
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var key2 in props) {
    if (hasOwnProperty.call(props, key2)) {
      newProps[key2] = props[key2];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion$1 = function Insertion(_ref3) {
  var cache2 = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var key2 in props) {
    if (hasOwnProperty.call(props, key2) && key2 !== "css" && key2 !== typePropName && true) {
      newProps[key2] = props[key2];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key: key2,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css$4() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes$1 = function keyframes() {
  var insertable = css$4.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var css$3 = String.raw;
var vhPolyfill = css$3`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
var CSSPolyfill = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: vhPolyfill });
var CSSReset = ({ scope = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Global,
  {
    styles: css$3`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
  }
);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext$1(options2 = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options2;
  const Context2 = reactExports.createContext(defaultValue);
  Context2.displayName = name2;
  function useContext() {
    var _a4;
    const context = reactExports.useContext(Context2);
    if (!context && strict) {
      const error = new Error(
        errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a4 = Error.captureStackTrace) == null ? void 0 : _a4.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [Context2.Provider, useContext, Context2];
}
var [PortalManagerContextProvider, usePortalManager] = createContext$1({
  strict: false,
  name: "PortalManagerContext"
});
function PortalManager(props) {
  const { children, zIndex } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalManagerContextProvider, { value: { zIndex }, children });
}
PortalManager.displayName = "PortalManager";
var useSafeLayoutEffect$2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : reactExports.useEffect;
var [PortalContextProvider, usePortalContext] = createContext$1({
  strict: false,
  name: "PortalContext"
});
var PORTAL_CLASSNAME = "chakra-portal";
var PORTAL_SELECTOR = `.chakra-portal`;
var Container = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: props.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: props.children
  }
);
var DefaultPortal = (props) => {
  const { appendToParentPortal, children } = props;
  const [tempNode, setTempNode] = reactExports.useState(null);
  const portal = reactExports.useRef(null);
  const [, forceUpdate] = reactExports.useState({});
  reactExports.useEffect(() => forceUpdate({}), []);
  const parentPortal = usePortalContext();
  const manager = usePortalManager();
  useSafeLayoutEffect$2(() => {
    if (!tempNode)
      return;
    const doc = tempNode.ownerDocument;
    const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
    if (!host)
      return;
    portal.current = doc.createElement("div");
    portal.current.className = PORTAL_CLASSNAME;
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, [tempNode]);
  const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
  return portal.current ? reactDomExports.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(PortalContextProvider, { value: portal.current, children: _children }),
    portal.current
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      ref: (el2) => {
        if (el2)
          setTempNode(el2);
      }
    }
  );
};
var ContainerPortal = (props) => {
  const { children, containerRef, appendToParentPortal } = props;
  const containerEl = containerRef.current;
  const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
  const portal = reactExports.useMemo(() => {
    const node2 = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
    if (node2)
      node2.className = PORTAL_CLASSNAME;
    return node2;
  }, [containerEl]);
  const [, forceUpdate] = reactExports.useState({});
  useSafeLayoutEffect$2(() => forceUpdate({}), []);
  useSafeLayoutEffect$2(() => {
    if (!portal || !host)
      return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  if (host && portal) {
    return reactDomExports.createPortal(
      /* @__PURE__ */ jsxRuntimeExports.jsx(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
      portal
    );
  }
  return null;
};
function Portal(props) {
  const portalProps = {
    appendToParentPortal: true,
    ...props
  };
  const { containerRef, ...rest } = portalProps;
  return containerRef ? /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerPortal, { containerRef, ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultPortal, { ...rest });
}
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";
function useTheme() {
  const theme2 = reactExports.useContext(
    ThemeContext
  );
  if (!theme2) {
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  }
  return theme2;
}
var ColorModeContext = reactExports.createContext({});
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
  const context = reactExports.useContext(ColorModeContext);
  if (context === void 0) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }
  return context;
}
var classNames$1 = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function getColorModeUtils(options2 = {}) {
  const { preventTransition = true } = options2;
  const utils2 = {
    setDataset: (value) => {
      const cleanup = preventTransition ? utils2.preventTransition() : void 0;
      document.documentElement.dataset.theme = value;
      document.documentElement.style.colorScheme = value;
      cleanup == null ? void 0 : cleanup();
    },
    setClassName(dark) {
      document.body.classList.add(dark ? classNames$1.dark : classNames$1.light);
      document.body.classList.remove(dark ? classNames$1.light : classNames$1.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(fallback) {
      var _a4;
      const dark = (_a4 = utils2.query().matches) != null ? _a4 : fallback === "dark";
      return dark ? "dark" : "light";
    },
    addListener(fn2) {
      const mql = utils2.query();
      const listener = (e2) => {
        fn2(e2.matches ? "dark" : "light");
      };
      if (typeof mql.addListener === "function")
        mql.addListener(listener);
      else
        mql.addEventListener("change", listener);
      return () => {
        if (typeof mql.removeListener === "function")
          mql.removeListener(listener);
        else
          mql.removeEventListener("change", listener);
      };
    },
    preventTransition() {
      const css4 = document.createElement("style");
      css4.appendChild(
        document.createTextNode(
          `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
        )
      );
      document.head.appendChild(css4);
      return () => {
        (() => window.getComputedStyle(document.body))();
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(css4);
          });
        });
      };
    }
  };
  return utils2;
}
var STORAGE_KEY = "chakra-ui-color-mode";
function createLocalStorageManager(key2) {
  return {
    ssr: false,
    type: "localStorage",
    get(init) {
      if (!(globalThis == null ? void 0 : globalThis.document))
        return init;
      let value;
      try {
        value = localStorage.getItem(key2) || init;
      } catch (e2) {
      }
      return value || init;
    },
    set(value) {
      try {
        localStorage.setItem(key2, value);
      } catch (e2) {
      }
    }
  };
}
var localStorageManager = createLocalStorageManager(STORAGE_KEY);
var noop$4 = () => {
};
function getTheme2(manager, fallback) {
  return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
}
function ColorModeProvider(props) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode,
      disableTransitionOnChange
    } = {},
    colorModeManager = localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  const [colorMode, rawSetColorMode] = reactExports.useState(
    () => getTheme2(colorModeManager, defaultColorMode)
  );
  const [resolvedColorMode, setResolvedColorMode] = reactExports.useState(
    () => getTheme2(colorModeManager)
  );
  const { getSystemTheme, setClassName, setDataset, addListener } = reactExports.useMemo(
    () => getColorModeUtils({ preventTransition: disableTransitionOnChange }),
    [disableTransitionOnChange]
  );
  const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
  const setColorMode = reactExports.useCallback(
    (value2) => {
      const resolved = value2 === "system" ? getSystemTheme() : value2;
      rawSetColorMode(resolved);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager.set(resolved);
    },
    [colorModeManager, getSystemTheme, setClassName, setDataset]
  );
  useSafeLayoutEffect$2(() => {
    if (initialColorMode === "system") {
      setResolvedColorMode(getSystemTheme());
    }
  }, []);
  reactExports.useEffect(() => {
    const managerValue = colorModeManager.get();
    if (managerValue) {
      setColorMode(managerValue);
      return;
    }
    if (initialColorMode === "system") {
      setColorMode("system");
      return;
    }
    setColorMode(defaultColorMode);
  }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
  const toggleColorMode = reactExports.useCallback(() => {
    setColorMode(resolvedValue === "dark" ? "light" : "dark");
  }, [resolvedValue, setColorMode]);
  reactExports.useEffect(() => {
    if (!useSystemColorMode)
      return;
    return addListener(setColorMode);
  }, [useSystemColorMode, addListener, setColorMode]);
  const context = reactExports.useMemo(
    () => ({
      colorMode: value != null ? value : resolvedValue,
      toggleColorMode: value ? noop$4 : toggleColorMode,
      setColorMode: value ? noop$4 : setColorMode,
      forced: value !== void 0
    }),
    [resolvedValue, toggleColorMode, setColorMode, value]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorModeContext.Provider, { value: context, children });
}
ColorModeProvider.displayName = "ColorModeProvider";
function useChakra() {
  const colorModeResult = useColorMode();
  const theme2 = useTheme();
  return { ...colorModeResult, theme: theme2 };
}
var cx = (...classNames2) => classNames2.filter(Boolean).join(" ");
function isObject$2(value) {
  const type2 = typeof value;
  return value != null && (type2 === "object" || type2 === "function") && !Array.isArray(value);
}
function runIfFn$2(valueOrFn, ...args) {
  return isFunction$4(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var isFunction$4 = (value) => typeof value === "function";
var dataAttr = (condition) => condition ? "" : void 0;
var ariaAttr = (condition) => condition ? true : void 0;
function callAllHandlers$1(...fns) {
  return function func(event) {
    fns.some((fn2) => {
      fn2 == null ? void 0 : fn2(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function callAll(...fns) {
  return function mergedFn(arg) {
    fns.forEach((fn2) => {
      fn2 == null ? void 0 : fn2(arg);
    });
  };
}
var lodash_mergewith = { exports: {} };
lodash_mergewith.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object2, key2) {
    return object2 == null ? void 0 : object2[key2];
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var objectCtorString = funcToString.call(Object);
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty3 = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
  var baseCreate = function() {
    function object2() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object2.prototype = proto;
      var result = new object2();
      object2.prototype = void 0;
      return result;
    };
  }();
  function Hash(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size2 = data.size;
    data.set(key2, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack2(entries2) {
    var data = this.__data__ = new ListCache(entries2);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  Stack2.prototype.clear = stackClear;
  Stack2.prototype["delete"] = stackDelete;
  Stack2.prototype.get = stackGet;
  Stack2.prototype.has = stackHas;
  Stack2.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assignMergeValue(object2, key2, value) {
    if (value !== void 0 && !eq2(object2[key2], value) || value === void 0 && !(key2 in object2)) {
      baseAssignValue(object2, key2, value);
    }
  }
  function assignValue(object2, key2, value) {
    var objValue = object2[key2];
    if (!(hasOwnProperty2.call(object2, key2) && eq2(objValue, value)) || value === void 0 && !(key2 in object2)) {
      baseAssignValue(object2, key2, value);
    }
  }
  function assocIndexOf(array2, key2) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  function baseAssignValue(object2, key2, value) {
    if (key2 == "__proto__" && defineProperty3) {
      defineProperty3(object2, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key2] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag2;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object2) {
    if (!isObject2(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key2 in object2) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object2, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function baseMerge(object2, source, srcIndex, customizer, stack) {
    if (object2 === source) {
      return;
    }
    baseFor(source, function(srcValue, key2) {
      stack || (stack = new Stack2());
      if (isObject2(srcValue)) {
        baseMergeDeep(object2, source, key2, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object2, key2), srcValue, key2 + "", object2, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object2, key2, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object2, source, key2, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object2, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object2, key2, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object2, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object2, key2, newValue);
  }
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity), func + "");
  }
  var baseSetToString = !defineProperty3 ? identity : function(func, string2) {
    return defineProperty3(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string2),
      "writable": true
    });
  };
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array2) {
    var index2 = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index2 < length2) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  function copyObject(source, props, object2, customizer) {
    var isNew = !object2;
    object2 || (object2 = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key2 = props[index2];
      var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object2, key2, newValue);
      } else {
        assignValue(object2, key2, newValue);
      }
    }
    return object2;
  }
  function createAssigner(assigner) {
    return baseRest(function(object2, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object2 = Object(object2);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object2, source, index2, customizer);
        }
      }
      return object2;
    });
  }
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key2 = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key2], key2, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  function getMapData(map3, key2) {
    var data = map3.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object2, key2) {
    var value = getValue(object2, key2);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object2) {
    return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
  }
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isIterateeCall(value, index2, object2) {
    if (!isObject2(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key2 in Object(object2)) {
        result.push(key2);
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array2);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object2, key2) {
    if (key2 === "constructor" && typeof object2[key2] === "function") {
      return;
    }
    if (key2 == "__proto__") {
      return;
    }
    return object2[key2];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  var mergeWith2 = createAssigner(function(object2, source, srcIndex, customizer) {
    baseMerge(object2, source, srcIndex, customizer);
  });
  function constant(value) {
    return function() {
      return value;
    };
  }
  function identity(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = mergeWith2;
})(lodash_mergewith, lodash_mergewith.exports);
var lodash_mergewithExports = lodash_mergewith.exports;
const mergeWith = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergewithExports);
var isImportant = (value) => /!(important)?$/.test(value);
var withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
var tokenToCSSVar = (scale2, value) => (theme2) => {
  const valueStr = String(value);
  const important2 = isImportant(valueStr);
  const valueWithoutImportant = withoutImportant(valueStr);
  const key2 = scale2 ? `${scale2}.${valueWithoutImportant}` : valueWithoutImportant;
  let transformed = isObject$2(theme2.__cssMap) && key2 in theme2.__cssMap ? theme2.__cssMap[key2].varRef : value;
  transformed = withoutImportant(transformed);
  return important2 ? `${transformed} !important` : transformed;
};
function createTransform(options2) {
  const { scale: scale2, transform: transform2, compose } = options2;
  const fn2 = (value, theme2) => {
    var _a4;
    const _value = tokenToCSSVar(scale2, value)(theme2);
    let result = (_a4 = transform2 == null ? void 0 : transform2(_value, theme2)) != null ? _a4 : _value;
    if (compose) {
      result = compose(result, theme2);
    }
    return result;
  };
  return fn2;
}
var pipe$2 = (...fns) => (v2) => fns.reduce((a, b2) => b2(a), v2);
function toConfig(scale2, transform2) {
  return (property) => {
    const result = { property, scale: scale2 };
    result.transform = createTransform({
      scale: scale2,
      transform: transform2
    });
    return result;
  };
}
var getRtl = ({ rtl, ltr }) => (theme2) => theme2.direction === "rtl" ? rtl : ltr;
function logical(options2) {
  const { property, scale: scale2, transform: transform2 } = options2;
  return {
    scale: scale2,
    property: getRtl(property),
    transform: scale2 ? createTransform({
      scale: scale2,
      compose: transform2
    }) : transform2
  };
}
var transformTemplate = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function getTransformTemplate() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...transformTemplate
  ].join(" ");
}
function getTransformGpuTemplate() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...transformTemplate
  ].join(" ");
}
var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
    "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
    "--chakra-ring-width": value,
    boxShadow: [
      `var(--chakra-ring-offset-shadow)`,
      `var(--chakra-ring-shadow)`,
      `var(--chakra-shadow, 0 0 #0000)`
    ].join(", ")
  };
}
var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]);
var trimSpace = (str2) => str2.trim();
function parseGradient(value, theme2) {
  if (value == null || globalSet.has(value))
    return value;
  const prevent = isCSSFunction(value) || globalSet.has(value);
  if (!prevent)
    return `url('${value}')`;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const results = regex.exec(value);
  const type2 = results == null ? void 0 : results[1];
  const values2 = results == null ? void 0 : results[2];
  if (!type2 || !values2)
    return value;
  const _type = type2.includes("-gradient") ? type2 : `${type2}-gradient`;
  const [maybeDirection, ...stops] = values2.split(",").map(trimSpace).filter(Boolean);
  if ((stops == null ? void 0 : stops.length) === 0)
    return value;
  const direction2 = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction2);
  const _values = stops.map((stop) => {
    if (valueSet.has(stop))
      return stop;
    const firstStop = stop.indexOf(" ");
    const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
    const key2 = `colors.${_color}`;
    const color2 = key2 in theme2.__cssMap ? theme2.__cssMap[key2].varRef : _color;
    return _stopOrFunc ? [
      color2,
      ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
    ].join(" ") : color2;
  });
  return `${_type}(${_values.join(", ")})`;
}
var isCSSFunction = (value) => {
  return typeof value === "string" && value.includes("(") && value.includes(")");
};
var gradientTransform = (value, theme2) => parseGradient(value, theme2 != null ? theme2 : {});
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
var analyzeCSSValue = (value) => {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
};
var wrap = (str2) => (value) => `${str2}(${value})`;
var transformFunctions = {
  filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip(value) {
    return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
  },
  transform(value) {
    if (value === "auto")
      return getTransformTemplate();
    if (value === "auto-gpu")
      return getTransformGpuTemplate();
    return value;
  },
  vh(value) {
    return value === "$100vh" ? "var(--chakra-vh)" : value;
  },
  px(value) {
    if (value == null)
      return value;
    const { unitless } = analyzeCSSValue(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  },
  fraction(value) {
    return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
  },
  float(value, theme2) {
    const map3 = { left: "right", right: "left" };
    return theme2.direction === "rtl" ? map3[value] : value;
  },
  degree(value) {
    if (isCssVar(value) || value == null)
      return value;
    const unitless = typeof value === "string" && !value.endsWith("deg");
    return typeof value === "number" || unitless ? `${value}deg` : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: wrap("hue-rotate"),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage(value) {
    if (value == null)
      return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? `url(${value})` : value;
  },
  outline(value) {
    const isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
  },
  flexDirection(value) {
    var _a4;
    const { space: space2, divide: divide2 } = (_a4 = flexDirectionTemplate[value]) != null ? _a4 : {};
    const result = { flexDirection: value };
    if (space2)
      result[space2] = 1;
    if (divide2)
      result[divide2] = 1;
    return result;
  }
};
var t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  gradients: toConfig("gradients", transformFunctions.gradient),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  spaceT: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  degreeT(property) {
    return { property, transform: transformFunctions.degree };
  },
  prop(property, scale2, transform2) {
    return {
      property,
      scale: scale2,
      ...scale2 && {
        transform: createTransform({ scale: scale2, transform: transform2 })
      }
    };
  },
  propT(property, transform2) {
    return { property, transform: transform2 };
  },
  sizes: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.px)),
  sizesT: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.fraction)),
  shadows: toConfig("shadows"),
  logical,
  blur: toConfig("blur", transformFunctions.blur)
};
var background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.gradients("backgroundImage"),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: { transform: transformFunctions.bgClip },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.gradients("backgroundImage"),
  bgClip: { transform: transformFunctions.bgClip }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
var border$1 = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(border$1, {
  rounded: border$1.borderRadius,
  roundedTop: border$1.borderTopRadius,
  roundedTopLeft: border$1.borderTopLeftRadius,
  roundedTopRight: border$1.borderTopRightRadius,
  roundedTopStart: border$1.borderStartStartRadius,
  roundedTopEnd: border$1.borderStartEndRadius,
  roundedBottom: border$1.borderBottomRadius,
  roundedBottomLeft: border$1.borderBottomLeftRadius,
  roundedBottomRight: border$1.borderBottomRightRadius,
  roundedBottomStart: border$1.borderEndStartRadius,
  roundedBottomEnd: border$1.borderEndEndRadius,
  roundedLeft: border$1.borderLeftRadius,
  roundedRight: border$1.borderRightRadius,
  roundedStart: border$1.borderInlineStartRadius,
  roundedEnd: border$1.borderInlineEndRadius,
  borderStart: border$1.borderInlineStart,
  borderEnd: border$1.borderInlineEnd,
  borderTopStartRadius: border$1.borderStartStartRadius,
  borderTopEndRadius: border$1.borderStartEndRadius,
  borderBottomStartRadius: border$1.borderEndStartRadius,
  borderBottomEndRadius: border$1.borderEndEndRadius,
  borderStartRadius: border$1.borderInlineStartRadius,
  borderEndRadius: border$1.borderInlineEndRadius,
  borderStartWidth: border$1.borderInlineStartWidth,
  borderEndWidth: border$1.borderInlineEndWidth,
  borderStartColor: border$1.borderInlineStartColor,
  borderEndColor: border$1.borderInlineEndColor,
  borderStartStyle: border$1.borderInlineStartStyle,
  borderEndStyle: border$1.borderInlineEndStyle
});
var color$1 = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke")
};
var effect$3 = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect$3, {
  shadow: effect$3.boxShadow
});
var filter$2 = {
  filter: { transform: transformFunctions.filter },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.degreeT("--chakra-hue-rotate"),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: { transform: transformFunctions.backdropFilter },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT(
    "--chakra-backdrop-brightness",
    transformFunctions.brightness
  ),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: { transform: transformFunctions.flexDirection },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
var grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: { transform: transformFunctions.outline },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};
var layout$1 = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  aspectRatio: true,
  hideFrom: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a4, _b3, _c2;
      const breakpoint = (_c2 = (_b3 = (_a4 = theme2.__breakpoints) == null ? void 0 : _a4.get(value)) == null ? void 0 : _b3.minW) != null ? _c2 : value;
      const mq = `@media screen and (min-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a4, _b3, _c2;
      const breakpoint = (_c2 = (_b3 = (_a4 = theme2.__breakpoints) == null ? void 0 : _a4.get(value)) == null ? void 0 : _b3._minW) != null ? _c2 : value;
      const mq = `@media screen and (max-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  float: t.propT("float", transformFunctions.float),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout$1, {
  w: layout$1.width,
  h: layout$1.height,
  minW: layout$1.minWidth,
  maxW: layout$1.maxWidth,
  minH: layout$1.minHeight,
  maxH: layout$1.maxHeight,
  overscroll: layout$1.overscrollBehavior,
  overscrollX: layout$1.overscrollBehaviorX,
  overscrollY: layout$1.overscrollBehaviorY
});
var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};
function get$5(obj, path2, fallback, index2) {
  const key2 = typeof path2 === "string" ? path2.split(".") : [path2];
  for (index2 = 0; index2 < key2.length; index2 += 1) {
    if (!obj)
      break;
    obj = obj[key2[index2]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize$1 = (fn2) => {
  const cache2 = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path2, fallback, index2) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path2, fallback);
    }
    if (!cache2.has(obj)) {
      cache2.set(obj, /* @__PURE__ */ new Map());
    }
    const map3 = cache2.get(obj);
    if (map3.has(path2)) {
      return map3.get(path2);
    }
    const value = fn2(obj, path2, fallback, index2);
    map3.set(path2, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet$1 = memoize$1(get$5);
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};
var getWithPriority = (theme2, key2, styles2) => {
  const result = {};
  const obj = memoizedGet$1(theme2, key2, {});
  for (const prop in obj) {
    const isInStyles = prop in styles2 && styles2[prop] != null;
    if (!isInStyles)
      result[prop] = obj[prop];
  }
  return result;
};
var others = {
  srOnly: {
    transform(value) {
      if (value === true)
        return srOnly;
      if (value === "focusable")
        return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `layerStyles.${value}`, styles2)
  },
  textStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `textStyles.${value}`, styles2)
  },
  apply: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, value, styles2)
  }
};
var position$2 = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(position$2, {
  insetStart: position$2.insetInlineStart,
  insetEnd: position$2.insetInlineEnd
});
var ring = {
  ring: { transform: transformFunctions.ring },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};
var space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
var textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: { property: "textDecoration" },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};
var transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};
var transition$1 = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
};
var typography$1 = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  textIndent: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  isTruncated: {
    transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
};
var scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollMargin: t.spaceT("scrollMargin"),
  scrollMarginTop: t.spaceT("scrollMarginTop"),
  scrollMarginBottom: t.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t.spaceT("scrollMarginLeft"),
  scrollMarginRight: t.spaceT("scrollMarginRight"),
  scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  scrollPadding: t.spaceT("scrollPadding"),
  scrollPaddingTop: t.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t.spaceT("scrollPaddingRight"),
  scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function resolveReference(operand) {
  if (isObject$2(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add$1 = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract$1 = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply$1 = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide$1 = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate$1 = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply$1(value, -1);
};
var calc$1 = Object.assign(
  (x2) => ({
    add: (...operands) => calc$1(add$1(x2, ...operands)),
    subtract: (...operands) => calc$1(subtract$1(x2, ...operands)),
    multiply: (...operands) => calc$1(multiply$1(x2, ...operands)),
    divide: (...operands) => calc$1(divide$1(x2, ...operands)),
    negate: () => calc$1(negate$1(x2)),
    toString: () => x2.toString()
  }),
  {
    add: add$1,
    subtract: subtract$1,
    multiply: multiply$1,
    divide: divide$1,
    negate: negate$1
  }
);
function replaceWhiteSpace$1(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape$1(value) {
  const valueStr = replaceWhiteSpace$1(value.toString());
  return escapeSymbol(escapeDot(valueStr));
}
function escapeDot(value) {
  if (value.includes("\\."))
    return value;
  const isDecimal2 = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal2 ? value.replace(".", `\\.`) : value;
}
function escapeSymbol(value) {
  return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix$1(value, prefix2 = "") {
  return [prefix2, value].filter(Boolean).join("-");
}
function toVarReference(name2, fallback) {
  return `var(${name2}${fallback ? `, ${fallback}` : ""})`;
}
function toVarDefinition(value, prefix2 = "") {
  return escape$1(`--${addPrefix$1(value, prefix2)}`);
}
function cssVar$2(name2, fallback, cssVarPrefix) {
  const cssVariable = toVarDefinition(name2, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}
function defineCssVars(scope, keys2) {
  const vars2 = {};
  for (const key2 of keys2) {
    if (Array.isArray(key2)) {
      const [name2, fallback] = key2;
      vars2[name2] = cssVar$2(`${scope}-${name2}`, fallback);
      continue;
    }
    vars2[key2] = cssVar$2(`${scope}-${key2}`);
  }
  return vars2;
}
function getLastItem(array2) {
  const length2 = array2 == null ? 0 : array2.length;
  return length2 ? array2[length2 - 1] : void 0;
}
function analyzeCSSValue2(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
}
function px$1(value) {
  if (value == null)
    return value;
  const { unitless } = analyzeCSSValue2(value);
  return unitless || typeof value === "number" ? `${value}px` : value;
}
var sortByBreakpointValue = (a, b2) => parseInt(a[1], 10) > parseInt(b2[1], 10) ? 1 : -1;
var sortBps = (breakpoints2) => Object.fromEntries(Object.entries(breakpoints2).sort(sortByBreakpointValue));
function normalize$1(breakpoints2) {
  const sorted = sortBps(breakpoints2);
  return Object.assign(Object.values(sorted), sorted);
}
function keys$1(breakpoints2) {
  const value = Object.keys(sortBps(breakpoints2));
  return new Set(value);
}
function subtract2(value) {
  var _a4;
  if (!value)
    return value;
  value = (_a4 = px$1(value)) != null ? _a4 : value;
  const OFFSET = -0.02;
  return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m2) => `${parseFloat(m2) + OFFSET}`);
}
function toMediaQueryString(min2, max2) {
  const query = ["@media screen"];
  if (min2)
    query.push("and", `(min-width: ${px$1(min2)})`);
  if (max2)
    query.push("and", `(max-width: ${px$1(max2)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints2) {
  var _a4;
  if (!breakpoints2)
    return null;
  breakpoints2.base = (_a4 = breakpoints2.base) != null ? _a4 : "0px";
  const normalized = normalize$1(breakpoints2);
  const queries = Object.entries(breakpoints2).sort(sortByBreakpointValue).map(([breakpoint, minW], index2, entry) => {
    var _a22;
    let [, maxW] = (_a22 = entry[index2 + 1]) != null ? _a22 : [];
    maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
    return {
      _minW: subtract2(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys$1(breakpoints2);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test2) {
      const keys2 = Object.keys(test2);
      return keys2.length > 0 && keys2.every((key2) => _keys.has(key2));
    },
    asObject: sortBps(breakpoints2),
    asArray: normalize$1(breakpoints2),
    details: queries,
    get(key2) {
      return queries.find((q2) => q2.breakpoint === key2);
    },
    media: [
      null,
      ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
    ],
    toArrayValue(test2) {
      if (!isObject$2(test2)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map((bp) => {
        var _a22;
        return (_a22 = test2[bp]) != null ? _a22 : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    },
    toObjectValue(test2) {
      if (!Array.isArray(test2)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test2.reduce((acc, value, index2) => {
        const key2 = _keysArr[index2];
        if (key2 != null && value != null)
          acc[key2] = value;
        return acc;
      }, {});
    }
  };
}
var state = {
  hover: (str2, post) => `${str2}:hover ${post}, ${str2}[data-hover] ${post}`,
  focus: (str2, post) => `${str2}:focus ${post}, ${str2}[data-focus] ${post}`,
  focusVisible: (str2, post) => `${str2}:focus-visible ${post}`,
  focusWithin: (str2, post) => `${str2}:focus-within ${post}`,
  active: (str2, post) => `${str2}:active ${post}, ${str2}[data-active] ${post}`,
  disabled: (str2, post) => `${str2}:disabled ${post}, ${str2}[data-disabled] ${post}`,
  invalid: (str2, post) => `${str2}:invalid ${post}, ${str2}[data-invalid] ${post}`,
  checked: (str2, post) => `${str2}:checked ${post}, ${str2}[data-checked] ${post}`,
  indeterminate: (str2, post) => `${str2}:indeterminate ${post}, ${str2}[aria-checked=mixed] ${post}, ${str2}[data-indeterminate] ${post}`,
  readOnly: (str2, post) => `${str2}:read-only ${post}, ${str2}[readonly] ${post}, ${str2}[data-read-only] ${post}`,
  expanded: (str2, post) => `${str2}:read-only ${post}, ${str2}[aria-expanded=true] ${post}, ${str2}[data-expanded] ${post}`,
  placeholderShown: (str2, post) => `${str2}:placeholder-shown ${post}`
};
var toGroup = (fn2) => merge$2((v2) => fn2(v2, "&"), "[role=group]", "[data-group]", ".group");
var toPeer = (fn2) => merge$2((v2) => fn2(v2, "~ &"), "[data-peer]", ".peer");
var merge$2 = (fn2, ...selectors) => selectors.map(fn2).join(", ");
var pseudoSelectors = {
  _hover: "&:hover, &[data-hover]",
  _active: "&:active, &[data-active]",
  _focus: "&:focus, &[data-focus]",
  _highlighted: "&[data-highlighted]",
  _focusWithin: "&:focus-within",
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  _before: "&::before",
  _after: "&::after",
  _empty: "&:empty",
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  _checked: "&[aria-checked=true], &[data-checked]",
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  _valid: "&[data-valid], &[data-state=valid]",
  _loading: "&[data-loading], &[aria-busy=true]",
  _selected: "&[aria-selected=true], &[data-selected]",
  _hidden: "&[hidden], &[data-hidden]",
  _autofill: "&:-webkit-autofill",
  _even: "&:nth-of-type(even)",
  _odd: "&:nth-of-type(odd)",
  _first: "&:first-of-type",
  _firstLetter: "&::first-letter",
  _last: "&:last-of-type",
  _notFirst: "&:not(:first-of-type)",
  _notLast: "&:not(:last-of-type)",
  _visited: "&:visited",
  _activeLink: "&[aria-current=page]",
  _activeStep: "&[aria-current=step]",
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  _groupHover: toGroup(state.hover),
  _peerHover: toPeer(state.hover),
  _groupFocus: toGroup(state.focus),
  _peerFocus: toPeer(state.focus),
  _groupFocusVisible: toGroup(state.focusVisible),
  _peerFocusVisible: toPeer(state.focusVisible),
  _groupActive: toGroup(state.active),
  _peerActive: toPeer(state.active),
  _groupDisabled: toGroup(state.disabled),
  _peerDisabled: toPeer(state.disabled),
  _groupInvalid: toGroup(state.invalid),
  _peerInvalid: toPeer(state.invalid),
  _groupChecked: toGroup(state.checked),
  _peerChecked: toPeer(state.checked),
  _groupFocusWithin: toGroup(state.focusWithin),
  _peerFocusWithin: toPeer(state.focusWithin),
  _peerPlaceholderShown: toPeer(state.placeholderShown),
  _placeholder: "&::placeholder",
  _placeholderShown: "&:placeholder-shown",
  _fullScreen: "&:fullscreen",
  _selection: "&::selection",
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  _mediaDark: "@media (prefers-color-scheme: dark)",
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  _horizontal: "&[data-orientation=horizontal]",
  _vertical: "&[data-orientation=vertical]"
};
var pseudoPropNames = Object.keys(
  pseudoSelectors
);
function tokenToCssVar(token2, prefix2) {
  return cssVar$2(String(token2).replace(/\./g, "-"), void 0, prefix2);
}
function createThemeVars(flatTokens, options2) {
  let cssVars2 = {};
  const cssMap = {};
  for (const [token2, tokenValue] of Object.entries(flatTokens)) {
    const { isSemantic, value } = tokenValue;
    const { variable, reference: reference2 } = tokenToCssVar(token2, options2 == null ? void 0 : options2.cssVarPrefix);
    if (!isSemantic) {
      if (token2.startsWith("space")) {
        const keys2 = token2.split(".");
        const [firstKey, ...referenceKeys] = keys2;
        const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
        const negativeValue = calc$1.negate(value);
        const negatedReference = calc$1.negate(reference2);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          var: variable,
          varRef: negatedReference
        };
      }
      cssVars2[variable] = value;
      cssMap[token2] = {
        value,
        var: variable,
        varRef: reference2
      };
      continue;
    }
    const lookupToken = (maybeToken) => {
      const scale2 = String(token2).split(".")[0];
      const withScale = [scale2, maybeToken].join(".");
      const resolvedTokenValue = flatTokens[withScale];
      if (!resolvedTokenValue)
        return maybeToken;
      const { reference: reference22 } = tokenToCssVar(withScale, options2 == null ? void 0 : options2.cssVarPrefix);
      return reference22;
    };
    const normalizedValue = isObject$2(value) ? value : { default: value };
    cssVars2 = mergeWith(
      cssVars2,
      Object.entries(normalizedValue).reduce(
        (acc, [conditionAlias, conditionValue]) => {
          var _a4, _b3;
          if (!conditionValue)
            return acc;
          const tokenReference = lookupToken(`${conditionValue}`);
          if (conditionAlias === "default") {
            acc[variable] = tokenReference;
            return acc;
          }
          const conditionSelector = (_b3 = (_a4 = pseudoSelectors) == null ? void 0 : _a4[conditionAlias]) != null ? _b3 : conditionAlias;
          acc[conditionSelector] = { [variable]: tokenReference };
          return acc;
        },
        {}
      )
    );
    cssMap[token2] = {
      value: reference2,
      var: variable,
      varRef: reference2
    };
  }
  return {
    cssVars: cssVars2,
    cssMap
  };
}
function omit$4(object2, keysToOmit = []) {
  const clone = Object.assign({}, object2);
  for (const key2 of keysToOmit) {
    if (key2 in clone) {
      delete clone[key2];
    }
  }
  return clone;
}
function pick$1(object2, keysToPick) {
  const result = {};
  for (const key2 of keysToPick) {
    if (key2 in object2) {
      result[key2] = object2[key2];
    }
  }
  return result;
}
function isObject5(value) {
  return typeof value === "object" && value != null && !Array.isArray(value);
}
function walkObject(target, predicate, options2 = {}) {
  const { stop, getKey } = options2;
  function inner(value, path2 = []) {
    var _a4;
    if (isObject5(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key2 = (_a4 = getKey == null ? void 0 : getKey(prop)) != null ? _a4 : prop;
        const childPath = [...path2, key2];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path2);
        }
        result[key2] = inner(child, childPath);
      }
      return result;
    }
    return predicate(value, path2);
  }
  return inner(target);
}
var tokens = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function extractTokens(theme2) {
  const _tokens = tokens;
  return pick$1(theme2, _tokens);
}
function extractSemanticTokens(theme2) {
  return theme2.semanticTokens;
}
function omitVars(rawTheme) {
  const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
  return cleanTheme;
}
var isSemanticCondition = (key2) => pseudoPropNames.includes(key2) || "default" === key2;
function flattenTokens({
  tokens: tokens2,
  semanticTokens: semanticTokens2
}) {
  const result = {};
  walkObject(tokens2, (value, path2) => {
    if (value == null)
      return;
    result[path2.join(".")] = { isSemantic: false, value };
  });
  walkObject(
    semanticTokens2,
    (value, path2) => {
      if (value == null)
        return;
      result[path2.join(".")] = { isSemantic: true, value };
    },
    {
      stop: (value) => Object.keys(value).every(isSemanticCondition)
    }
  );
  return result;
}
function toCSSVar(rawTheme) {
  var _a4;
  const theme2 = omitVars(rawTheme);
  const tokens2 = extractTokens(theme2);
  const semanticTokens2 = extractSemanticTokens(theme2);
  const flatTokens = flattenTokens({ tokens: tokens2, semanticTokens: semanticTokens2 });
  const cssVarPrefix = (_a4 = theme2.config) == null ? void 0 : _a4.cssVarPrefix;
  const {
    cssMap,
    cssVars: cssVars2
  } = createThemeVars(flatTokens, { cssVarPrefix });
  const defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme2, {
    __cssVars: { ...defaultCssVars, ...cssVars2 },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme2.breakpoints)
  });
  return theme2;
}
var systemProps = mergeWith(
  {},
  background,
  border$1,
  color$1,
  flexbox,
  layout$1,
  filter$2,
  ring,
  interactivity,
  grid,
  others,
  position$2,
  effect$3,
  space,
  scroll,
  typography$1,
  textDecoration,
  transform,
  list,
  transition$1
);
Object.assign({}, space, layout$1, flexbox, grid, position$2);
var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
var styleProps = { ...systemProps, ...pseudoSelectors };
var isStyleProp = (prop) => prop in styleProps;
var expandResponsive = (styles2) => (theme2) => {
  if (!theme2.__breakpoints)
    return styles2;
  const { isResponsive, toArrayValue, media: medias } = theme2.__breakpoints;
  const computedStyles = {};
  for (const key2 in styles2) {
    let value = runIfFn$2(styles2[key2], theme2);
    if (value == null)
      continue;
    value = isObject$2(value) && isResponsive(value) ? toArrayValue(value) : value;
    if (!Array.isArray(value)) {
      computedStyles[key2] = value;
      continue;
    }
    const queries = value.slice(0, medias.length).length;
    for (let index2 = 0; index2 < queries; index2 += 1) {
      const media = medias == null ? void 0 : medias[index2];
      if (!media) {
        computedStyles[key2] = value[index2];
        continue;
      }
      computedStyles[media] = computedStyles[media] || {};
      if (value[index2] == null) {
        continue;
      }
      computedStyles[media][key2] = value[index2];
    }
  }
  return computedStyles;
};
function splitByComma(value) {
  const chunks = [];
  let chunk = "";
  let inParens = false;
  for (let i = 0; i < value.length; i++) {
    const char2 = value[i];
    if (char2 === "(") {
      inParens = true;
      chunk += char2;
    } else if (char2 === ")") {
      inParens = false;
      chunk += char2;
    } else if (char2 === "," && !inParens) {
      chunks.push(chunk);
      chunk = "";
    } else {
      chunk += char2;
    }
  }
  chunk = chunk.trim();
  if (chunk) {
    chunks.push(chunk);
  }
  return chunks;
}
function isCssVar2(value) {
  return /^var\(--.+\)$/.test(value);
}
var isCSSVariableTokenValue = (key2, value) => key2.startsWith("--") && typeof value === "string" && !isCssVar2(value);
var resolveTokenValue = (theme2, value) => {
  var _a4, _b3;
  if (value == null)
    return value;
  const getVar = (val) => {
    var _a22, _b22;
    return (_b22 = (_a22 = theme2.__cssMap) == null ? void 0 : _a22[val]) == null ? void 0 : _b22.varRef;
  };
  const getValue = (val) => {
    var _a22;
    return (_a22 = getVar(val)) != null ? _a22 : val;
  };
  const [tokenValue, fallbackValue] = splitByComma(value);
  value = (_b3 = (_a4 = getVar(tokenValue)) != null ? _a4 : getValue(fallbackValue)) != null ? _b3 : getValue(value);
  return value;
};
function getCss(options2) {
  const { configs = {}, pseudos = {}, theme: theme2 } = options2;
  const css22 = (stylesOrFn, nested = false) => {
    var _a4, _b3, _c2;
    const _styles = runIfFn$2(stylesOrFn, theme2);
    const styles2 = expandResponsive(_styles)(theme2);
    let computedStyles = {};
    for (let key2 in styles2) {
      const valueOrFn = styles2[key2];
      let value = runIfFn$2(valueOrFn, theme2);
      if (key2 in pseudos) {
        key2 = pseudos[key2];
      }
      if (isCSSVariableTokenValue(key2, value)) {
        value = resolveTokenValue(theme2, value);
      }
      let config2 = configs[key2];
      if (config2 === true) {
        config2 = { property: key2 };
      }
      if (isObject$2(value)) {
        computedStyles[key2] = (_a4 = computedStyles[key2]) != null ? _a4 : {};
        computedStyles[key2] = mergeWith(
          {},
          computedStyles[key2],
          css22(value, true)
        );
        continue;
      }
      let rawValue = (_c2 = (_b3 = config2 == null ? void 0 : config2.transform) == null ? void 0 : _b3.call(config2, value, theme2, _styles)) != null ? _c2 : value;
      rawValue = (config2 == null ? void 0 : config2.processResult) ? css22(rawValue, true) : rawValue;
      const configProperty = runIfFn$2(config2 == null ? void 0 : config2.property, theme2);
      if (!nested && (config2 == null ? void 0 : config2.static)) {
        const staticStyles = runIfFn$2(config2.static, theme2);
        computedStyles = mergeWith({}, computedStyles, staticStyles);
      }
      if (configProperty && Array.isArray(configProperty)) {
        for (const property of configProperty) {
          computedStyles[property] = rawValue;
        }
        continue;
      }
      if (configProperty) {
        if (configProperty === "&" && isObject$2(rawValue)) {
          computedStyles = mergeWith({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }
        continue;
      }
      if (isObject$2(rawValue)) {
        computedStyles = mergeWith({}, computedStyles, rawValue);
        continue;
      }
      computedStyles[key2] = rawValue;
    }
    return computedStyles;
  };
  return css22;
}
var css$2 = (styles2) => (theme2) => {
  const cssFn = getCss({
    theme: theme2,
    pseudos: pseudoSelectors,
    configs: systemProps
  });
  return cssFn(styles2);
};
function defineStyle(styles2) {
  return styles2;
}
function defineStyleConfig(config2) {
  return config2;
}
function createMultiStyleConfigHelpers(parts) {
  return {
    definePartsStyle(config2) {
      return config2;
    },
    defineMultiStyleConfig(config2) {
      return { parts, ...config2 };
    }
  };
}
function normalize2(value, toArray2) {
  if (Array.isArray(value))
    return value;
  if (isObject$2(value))
    return toArray2(value);
  if (value != null)
    return [value];
}
function getNextIndex$1(values2, i) {
  for (let j = i + 1; j < values2.length; j++) {
    if (values2[j] != null)
      return j;
  }
  return -1;
}
function createResolver(theme2) {
  const breakpointUtil = theme2.__breakpoints;
  return function resolver(config2, prop, value, props) {
    var _a4, _b3;
    if (!breakpointUtil)
      return;
    const result = {};
    const normalized = normalize2(value, breakpointUtil.toArrayValue);
    if (!normalized)
      return result;
    const len = normalized.length;
    const isSingle = len === 1;
    const isMultipart = !!config2.parts;
    for (let i = 0; i < len; i++) {
      const key2 = breakpointUtil.details[i];
      const nextKey = breakpointUtil.details[getNextIndex$1(normalized, i)];
      const query = toMediaQueryString(key2.minW, nextKey == null ? void 0 : nextKey._minW);
      const styles2 = runIfFn$2((_a4 = config2[prop]) == null ? void 0 : _a4[normalized[i]], props);
      if (!styles2)
        continue;
      if (isMultipart) {
        (_b3 = config2.parts) == null ? void 0 : _b3.forEach((part) => {
          mergeWith(result, {
            [part]: isSingle ? styles2[part] : { [query]: styles2[part] }
          });
        });
        continue;
      }
      if (!isMultipart) {
        if (isSingle)
          mergeWith(result, styles2);
        else
          result[query] = styles2;
        continue;
      }
      result[query] = styles2;
    }
    return result;
  };
}
function resolveStyleConfig(config2) {
  return (props) => {
    var _a4;
    const { variant, size: size2, theme: theme2 } = props;
    const recipe = createResolver(theme2);
    return mergeWith(
      {},
      runIfFn$2((_a4 = config2.baseStyle) != null ? _a4 : {}, props),
      recipe(config2, "sizes", size2, props),
      recipe(config2, "variants", variant, props)
    );
  };
}
function getCSSVar(theme2, scale2, value) {
  var _a4, _b3, _c2;
  return (_c2 = (_b3 = (_a4 = theme2.__cssMap) == null ? void 0 : _a4[`${scale2}.${value}`]) == null ? void 0 : _b3.varRef) != null ? _c2 : value;
}
function omitThemingProps(props) {
  return omit$4(props, ["styleConfig", "size", "variant", "colorScheme"]);
}
var requiredChakraThemeKeys = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function isChakraTheme(unit) {
  if (!isObject$2(unit)) {
    return false;
  }
  return requiredChakraThemeKeys.every(
    (propertyName) => Object.prototype.hasOwnProperty.call(unit, propertyName)
  );
}
var transitionProperty = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
};
var transitionTimingFunction = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionDuration = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
};
var transition = {
  property: transitionProperty,
  easing: transitionTimingFunction,
  duration: transitionDuration
};
var transition_default = transition;
var zIndices = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
var z_index_default = zIndices;
var borders$1 = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
};
var borders_default = borders$1;
var breakpoints = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
};
var breakpoints_default = breakpoints;
var colors$1 = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
};
var colors_default = colors$1;
var radii = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
var radius_default = radii;
var shadows = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
};
var shadows_default = shadows;
var blur = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var blur_default = blur;
var typography = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    "3": ".75rem",
    "4": "1rem",
    "5": "1.25rem",
    "6": "1.5rem",
    "7": "1.75rem",
    "8": "2rem",
    "9": "2.25rem",
    "10": "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
};
var typography_default = typography;
var spacing$1 = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
};
var largeSizes = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
};
var container$1 = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
};
var sizes$m = {
  ...spacing$1,
  ...largeSizes,
  container: container$1
};
var sizes_default = sizes$m;
var foundations = {
  breakpoints: breakpoints_default,
  zIndices: z_index_default,
  radii: radius_default,
  blur: blur_default,
  colors: colors_default,
  ...typography_default,
  sizes: sizes_default,
  shadows: shadows_default,
  space: spacing$1,
  borders: borders_default,
  transition: transition_default
};
var { defineMultiStyleConfig: defineMultiStyleConfig$p, definePartsStyle: definePartsStyle$p } = createMultiStyleConfigHelpers([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]);
var $size$4 = cssVar$2("stepper-indicator-size");
var $iconSize = cssVar$2("stepper-icon-size");
var $titleFontSize = cssVar$2("stepper-title-font-size");
var $descFontSize = cssVar$2("stepper-description-font-size");
var $accentColor = cssVar$2("stepper-accent-color");
var baseStyle$F = definePartsStyle$p(({ colorScheme: c2 }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [$accentColor.variable]: `colors.${c2}.500`,
    _dark: {
      [$accentColor.variable]: `colors.${c2}.200`
    }
  },
  title: {
    fontSize: $titleFontSize.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: $descFontSize.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: $titleFontSize.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: $iconSize.reference,
    height: $iconSize.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: $size$4.reference,
    height: $size$4.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: $accentColor.reference
    },
    "&[data-status=complete]": {
      bg: $accentColor.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: $accentColor.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${$size$4.reference} - 8px)`,
      top: `calc(${$size$4.reference} + 4px)`,
      insetStart: `calc(${$size$4.reference} / 2 - 1px)`
    }
  }
}));
var stepperTheme = defineMultiStyleConfig$p({
  baseStyle: baseStyle$F,
  sizes: {
    xs: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.4",
        [$iconSize.variable]: "sizes.3",
        [$titleFontSize.variable]: "fontSizes.xs",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    sm: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.6",
        [$iconSize.variable]: "sizes.4",
        [$titleFontSize.variable]: "fontSizes.sm",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    md: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.8",
        [$iconSize.variable]: "sizes.5",
        [$titleFontSize.variable]: "fontSizes.md",
        [$descFontSize.variable]: "fontSizes.sm"
      }
    }),
    lg: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.10",
        [$iconSize.variable]: "sizes.6",
        [$titleFontSize.variable]: "fontSizes.lg",
        [$descFontSize.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
function anatomy(name2, map3 = {}) {
  let called = false;
  function assert() {
    if (!called) {
      called = true;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function parts(...values2) {
    assert();
    for (const part of values2) {
      map3[part] = toPart(part);
    }
    return anatomy(name2, map3);
  }
  function extend(...parts2) {
    for (const part of parts2) {
      if (part in map3)
        continue;
      map3[part] = toPart(part);
    }
    return anatomy(name2, map3);
  }
  function selectors() {
    const value = Object.fromEntries(
      Object.entries(map3).map(([key2, part]) => [key2, part.selector])
    );
    return value;
  }
  function classnames2() {
    const value = Object.fromEntries(
      Object.entries(map3).map(([key2, part]) => [key2, part.className])
    );
    return value;
  }
  function toPart(part) {
    const el2 = ["container", "root"].includes(part != null ? part : "") ? [name2] : [name2, part];
    const attr = el2.filter(Boolean).join("__");
    const className = `chakra-${attr}`;
    const partObj = {
      className,
      selector: `.${className}`,
      toString: () => part
    };
    return partObj;
  }
  const __type = {};
  return {
    parts,
    toPart,
    extend,
    selectors,
    classnames: classnames2,
    get keys() {
      return Object.keys(map3);
    },
    __type
  };
}
var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel").extend("icon");
var alertAnatomy = anatomy("alert").parts("title", "description", "container").extend("icon", "spinner");
var avatarAnatomy = anatomy("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
var breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container").extend("separator");
anatomy("button").parts();
var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container").extend("label");
anatomy("progress").parts("track", "filledTrack").extend("label");
var drawerAnatomy = anatomy("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var editableAnatomy = anatomy("editable").parts(
  "preview",
  "input",
  "textarea"
);
var formAnatomy = anatomy("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
);
var formErrorAnatomy = anatomy("formError").parts("text", "icon");
var inputAnatomy = anatomy("input").parts(
  "addon",
  "field",
  "element",
  "group"
);
var listAnatomy = anatomy("list").parts("container", "item", "icon");
var menuAnatomy = anatomy("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider");
var modalAnatomy = anatomy("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var numberInputAnatomy = anatomy("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
anatomy("pininput").parts("field");
var popoverAnatomy = anatomy("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
var progressAnatomy = anatomy("progress").parts(
  "label",
  "filledTrack",
  "track"
);
var radioAnatomy = anatomy("radio").parts(
  "container",
  "control",
  "label"
);
var selectAnatomy = anatomy("select").parts("field", "icon");
var sliderAnatomy = anatomy("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
);
var statAnatomy = anatomy("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
);
var switchAnatomy = anatomy("switch").parts(
  "container",
  "track",
  "thumb"
);
var tableAnatomy = anatomy("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
);
var tabsAnatomy = anatomy("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
);
var tagAnatomy = anatomy("tag").parts(
  "container",
  "label",
  "closeButton"
);
var cardAnatomy = anatomy("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
function guard$1(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color2) {
    super(`Failed to parse color: "${color2}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color2) {
  if (typeof color2 !== "string")
    throw new ColorError$1(color2);
  if (color2.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color2.trim();
  normalizedColor = namedColorRegex.test(color2) ? nameToHex$1(color2) : color2;
  const reducedHexMatch = reducedHexRegex$1.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(r$1(x2, 2), 16)), parseInt(r$1(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex$1.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex$1.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex$1.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s, l2, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard$1(0, 100, s) !== s)
      throw new ColorError$1(color2);
    if (guard$1(0, 100, l2) !== l2)
      throw new ColorError$1(color2);
    return [...hslToRgb$1(h2, s, l2), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color2);
}
function hash$3(str2) {
  let hash2 = 5381;
  let i = str2.length;
  while (i) {
    hash2 = hash2 * 33 ^ str2.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt$1 = (x2) => parseInt(x2.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next2) => {
  const key2 = colorToInt$1(next2.substring(0, 3));
  const hex2 = colorToInt$1(next2.substring(3)).toString(16);
  let prefix2 = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix2 += "0";
  }
  acc[key2] = `${prefix2}${hex2}`;
  return acc;
}, {});
function nameToHex$1(color2) {
  const normalizedColorName = color2.toLowerCase().trim();
  const result = compressedColorMap[hash$3(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color2);
  return `#${result}`;
}
const r$1 = (str2, amount) => Array.from(Array(amount)).map(() => str2).join("");
const reducedHexRegex$1 = new RegExp(`^#${r$1("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex$1 = new RegExp(`^#${r$1("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex$1 = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r$1(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex$1 = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color2) => {
  return Math.round(color2 * 255);
};
const hslToRgb$1 = (hue, saturation, lightness) => {
  let l2 = lightness / 100;
  if (saturation === 0) {
    return [l2, l2, l2].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l2 - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l2 - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba$2(red, green, blue, alpha2) {
  return `rgba(${guard$1(0, 255, red).toFixed()}, ${guard$1(0, 255, green).toFixed()}, ${guard$1(0, 255, blue).toFixed()}, ${parseFloat(guard$1(0, 1, alpha2).toFixed(3))})`;
}
function transparentize$2(color2, amount) {
  const [r2, g2, b2, a] = parseToRgba(color2);
  return rgba$2(r2, g2, b2, a - amount);
}
function toHex(color2) {
  const [r2, g2, b2, a] = parseToRgba(color2);
  let hex2 = (x2) => {
    const h2 = guard$1(0, 255, x2).toString(16);
    return h2.length === 1 ? `0${h2}` : h2;
  };
  return `#${hex2(r2)}${hex2(g2)}${hex2(b2)}${a < 1 ? hex2(Math.round(a * 255)) : ""}`;
}
function dlv_es_default(t2, e2, l2, n2, r2) {
  for (e2 = e2.split ? e2.split(".") : e2, n2 = 0; n2 < e2.length; n2++)
    t2 = t2 ? t2[e2[n2]] : r2;
  return t2 === r2 ? l2 : t2;
}
var isEmptyObject = (obj) => Object.keys(obj).length === 0;
var getColor = (theme2, color2, fallback) => {
  const hex2 = dlv_es_default(theme2, `colors.${color2}`, color2);
  try {
    toHex(hex2);
    return hex2;
  } catch {
    return fallback != null ? fallback : "#000000";
  }
};
var getBrightness = (color2) => {
  const [r2, g2, b2] = parseToRgba(color2);
  return (r2 * 299 + g2 * 587 + b2 * 114) / 1e3;
};
var tone = (color2) => (theme2) => {
  const hex2 = getColor(theme2, color2);
  const brightness = getBrightness(hex2);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
var isDark = (color2) => (theme2) => tone(color2)(theme2) === "dark";
var transparentize$1 = (color2, opacity) => (theme2) => {
  const raw = getColor(theme2, color2);
  return transparentize$2(raw, 1 - opacity);
};
function generateStripe(size2 = "1rem", color2 = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${color2} 25%,
    transparent 25%,
    transparent 50%,
    ${color2} 50%,
    ${color2} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${size2} ${size2}`
  };
}
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function randomColor(opts) {
  const fallback = randomHex();
  if (!opts || isEmptyObject(opts)) {
    return fallback;
  }
  if (opts.string && opts.colors) {
    return randomColorFromList(opts.string, opts.colors);
  }
  if (opts.string && !opts.colors) {
    return randomColorFromString(opts.string);
  }
  if (opts.colors && !opts.string) {
    return randomFromList(opts.colors);
  }
  return fallback;
}
function randomColorFromString(str2) {
  let hash2 = 0;
  if (str2.length === 0)
    return hash2.toString();
  for (let i = 0; i < str2.length; i += 1) {
    hash2 = str2.charCodeAt(i) + ((hash2 << 5) - hash2);
    hash2 = hash2 & hash2;
  }
  let color2 = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash2 >> j * 8 & 255;
    color2 += `00${value.toString(16)}`.substr(-2);
  }
  return color2;
}
function randomColorFromList(str2, list2) {
  let index2 = 0;
  if (str2.length === 0)
    return list2[0];
  for (let i = 0; i < str2.length; i += 1) {
    index2 = str2.charCodeAt(i) + ((index2 << 5) - index2);
    index2 = index2 & index2;
  }
  index2 = (index2 % list2.length + list2.length) % list2.length;
  return list2[index2];
}
function randomFromList(list2) {
  return list2[Math.floor(Math.random() * list2.length)];
}
function mode(light, dark) {
  return (props) => props.colorMode === "dark" ? dark : light;
}
function orient(options2) {
  const { orientation, vertical, horizontal } = options2;
  if (!orientation)
    return {};
  return orientation === "vertical" ? vertical : horizontal;
}
function toRef(operand) {
  if (isObject$2(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpr("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpr("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpr("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpr("/", ...operands)})`;
var negate = (x2) => {
  const value = toRef(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
function isDecimal$1(value) {
  return !Number.isInteger(parseFloat(value.toString()));
}
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  if (valueStr.includes("\\."))
    return value;
  return isDecimal$1(value) ? valueStr.replace(".", `\\.`) : value;
}
function addPrefix(value, prefix2 = "") {
  return [prefix2, escape(value)].filter(Boolean).join("-");
}
function toVarRef(name2, fallback) {
  return `var(${escape(name2)}${fallback ? `, ${fallback}` : ""})`;
}
function toVar$1(value, prefix2 = "") {
  return `--${addPrefix(value, prefix2)}`;
}
function cssVar$1(name2, options2) {
  const cssVariable = toVar$1(name2, options2 == null ? void 0 : options2.prefix);
  return {
    variable: cssVariable,
    reference: toVarRef(cssVariable, getFallback(options2 == null ? void 0 : options2.fallback))
  };
}
function getFallback(fallback) {
  if (typeof fallback === "string")
    return fallback;
  return fallback == null ? void 0 : fallback.reference;
}
var { defineMultiStyleConfig: defineMultiStyleConfig$o, definePartsStyle: definePartsStyle$o } = createMultiStyleConfigHelpers(switchAnatomy.keys);
var $width = cssVar$1("switch-track-width");
var $height$1 = cssVar$1("switch-track-height");
var $diff = cssVar$1("switch-track-diff");
var diffValue = calc.subtract($width, $height$1);
var $translateX = cssVar$1("switch-thumb-x");
var $bg$f = cssVar$1("switch-bg");
var baseStyleTrack$2 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [$width.reference],
    height: [$height$1.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [$bg$f.variable]: "colors.gray.300",
    _dark: {
      [$bg$f.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [$bg$f.variable]: `colors.${c2}.500`,
      _dark: {
        [$bg$f.variable]: `colors.${c2}.200`
      }
    },
    bg: $bg$f.reference
  };
});
var baseStyleThumb$1 = defineStyle({
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [$height$1.reference],
  height: [$height$1.reference],
  _checked: {
    transform: `translateX(${$translateX.reference})`
  }
});
var baseStyle$E = definePartsStyle$o((props) => ({
  container: {
    [$diff.variable]: diffValue,
    [$translateX.variable]: $diff.reference,
    _rtl: {
      [$translateX.variable]: calc($diff).negate().toString()
    }
  },
  track: baseStyleTrack$2(props),
  thumb: baseStyleThumb$1
}));
var sizes$l = {
  sm: definePartsStyle$o({
    container: {
      [$width.variable]: "1.375rem",
      [$height$1.variable]: "sizes.3"
    }
  }),
  md: definePartsStyle$o({
    container: {
      [$width.variable]: "1.875rem",
      [$height$1.variable]: "sizes.4"
    }
  }),
  lg: definePartsStyle$o({
    container: {
      [$width.variable]: "2.875rem",
      [$height$1.variable]: "sizes.6"
    }
  })
};
var switchTheme = defineMultiStyleConfig$o({
  baseStyle: baseStyle$E,
  sizes: sizes$l,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$n, definePartsStyle: definePartsStyle$n } = createMultiStyleConfigHelpers(tableAnatomy.keys);
var baseStyle$D = definePartsStyle$n({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
});
var numericStyles = defineStyle({
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
});
var variantSimple = definePartsStyle$n((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variantStripe = definePartsStyle$n((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: mode(`${c2}.100`, `${c2}.700`)(props)
          },
          td: {
            background: mode(`${c2}.100`, `${c2}.700`)(props)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variants$f = {
  simple: variantSimple,
  striped: variantStripe,
  unstyled: defineStyle({})
};
var sizes$k = {
  sm: definePartsStyle$n({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: definePartsStyle$n({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: definePartsStyle$n({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
};
var tableTheme = defineMultiStyleConfig$n({
  baseStyle: baseStyle$D,
  variants: variants$f,
  sizes: sizes$k,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
});
var $fg$5 = cssVar$2("tabs-color");
var $bg$e = cssVar$2("tabs-bg");
var $border$3 = cssVar$2("tabs-border-color");
var { defineMultiStyleConfig: defineMultiStyleConfig$m, definePartsStyle: definePartsStyle$m } = createMultiStyleConfigHelpers(tabsAnatomy.keys);
var baseStyleRoot$1 = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: orientation === "vertical" ? "flex" : "block"
  };
});
var baseStyleTab = defineStyle((props) => {
  const { isFitted } = props;
  return {
    flex: isFitted ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
});
var baseStyleTablist = defineStyle((props) => {
  const { align = "start", orientation } = props;
  const alignments = {
    end: "flex-end",
    center: "center",
    start: "flex-start"
  };
  return {
    justifyContent: alignments[align],
    flexDirection: orientation === "vertical" ? "column" : "row"
  };
});
var baseStyleTabpanel = defineStyle({
  p: 4
});
var baseStyle$C = definePartsStyle$m((props) => ({
  root: baseStyleRoot$1(props),
  tab: baseStyleTab(props),
  tablist: baseStyleTablist(props),
  tabpanel: baseStyleTabpanel
}));
var sizes$j = {
  sm: definePartsStyle$m({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: definePartsStyle$m({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: definePartsStyle$m({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
};
var variantLine = definePartsStyle$m((props) => {
  const { colorScheme: c2, orientation } = props;
  const isVertical = orientation === "vertical";
  const borderProp = isVertical ? "borderStart" : "borderBottom";
  const marginProp = isVertical ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [borderProp]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [borderProp]: "2px solid",
      borderColor: "transparent",
      [marginProp]: "-2px",
      _selected: {
        [$fg$5.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg$5.variable]: `colors.${c2}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [$bg$e.variable]: "colors.gray.200",
        _dark: {
          [$bg$e.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    }
  };
});
var variantEnclosed = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [$border$3.variable]: "transparent",
      _selected: {
        [$fg$5.variable]: `colors.${c2}.600`,
        [$border$3.variable]: `colors.white`,
        _dark: {
          [$fg$5.variable]: `colors.${c2}.300`,
          [$border$3.variable]: `colors.gray.800`
        },
        borderColor: "inherit",
        borderBottomColor: $border$3.reference
      },
      color: $fg$5.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantEnclosedColored = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [$bg$e.variable]: "colors.gray.50",
      _dark: {
        [$bg$e.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [$bg$e.variable]: "colors.white",
        [$fg$5.variable]: `colors.${c2}.600`,
        _dark: {
          [$bg$e.variable]: "colors.gray.800",
          [$fg$5.variable]: `colors.${c2}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantSoftRounded = definePartsStyle$m((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: getColor(theme2, `${c2}.700`),
        bg: getColor(theme2, `${c2}.100`)
      }
    }
  };
});
var variantSolidRounded = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [$fg$5.variable]: "colors.gray.600",
      _dark: {
        [$fg$5.variable]: "inherit"
      },
      _selected: {
        [$fg$5.variable]: "colors.white",
        [$bg$e.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg$5.variable]: "colors.gray.800",
          [$bg$e.variable]: `colors.${c2}.300`
        }
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    }
  };
});
var variantUnstyled$2 = definePartsStyle$m({});
var variants$e = {
  line: variantLine,
  enclosed: variantEnclosed,
  "enclosed-colored": variantEnclosedColored,
  "soft-rounded": variantSoftRounded,
  "solid-rounded": variantSolidRounded,
  unstyled: variantUnstyled$2
};
var tabsTheme = defineMultiStyleConfig$m({
  baseStyle: baseStyle$C,
  sizes: sizes$j,
  variants: variants$e,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
});
var vars = defineCssVars("badge", ["bg", "color", "shadow"]);
var baseStyle$B = defineStyle({
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var variantSolid$3 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const dark = transparentize$1(`${c2}.500`, 0.6)(theme2);
  return {
    [vars.bg.variable]: `colors.${c2}.500`,
    [vars.color.variable]: `colors.white`,
    _dark: {
      [vars.bg.variable]: dark,
      [vars.color.variable]: `colors.whiteAlpha.800`
    }
  };
});
var variantSubtle$1 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const darkBg = transparentize$1(`${c2}.200`, 0.16)(theme2);
  return {
    [vars.bg.variable]: `colors.${c2}.100`,
    [vars.color.variable]: `colors.${c2}.800`,
    _dark: {
      [vars.bg.variable]: darkBg,
      [vars.color.variable]: `colors.${c2}.200`
    }
  };
});
var variantOutline$2 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const darkColor = transparentize$1(`${c2}.200`, 0.8)(theme2);
  return {
    [vars.color.variable]: `colors.${c2}.500`,
    _dark: {
      [vars.color.variable]: darkColor
    },
    [vars.shadow.variable]: `inset 0 0 0px 1px ${vars.color.reference}`
  };
});
var variants$d = {
  solid: variantSolid$3,
  subtle: variantSubtle$1,
  outline: variantOutline$2
};
var badgeTheme = defineStyleConfig({
  baseStyle: baseStyle$B,
  variants: variants$d,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$l, definePartsStyle: definePartsStyle$l } = createMultiStyleConfigHelpers(tagAnatomy.keys);
var $bg$d = cssVar$2("tag-bg");
var $color = cssVar$2("tag-color");
var $shadow$3 = cssVar$2("tag-shadow");
var $minH = cssVar$2("tag-min-height");
var $minW = cssVar$2("tag-min-width");
var $fontSize$1 = cssVar$2("tag-font-size");
var $paddingX = cssVar$2("tag-padding-inline");
var baseStyleContainer$4 = defineStyle({
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [$color.variable]: vars.color.reference,
  [$bg$d.variable]: vars.bg.reference,
  [$shadow$3.variable]: vars.shadow.reference,
  color: $color.reference,
  bg: $bg$d.reference,
  boxShadow: $shadow$3.reference,
  borderRadius: "md",
  minH: $minH.reference,
  minW: $minW.reference,
  fontSize: $fontSize$1.reference,
  px: $paddingX.reference,
  _focusVisible: {
    [$shadow$3.variable]: "shadows.outline"
  }
});
var baseStyleLabel$4 = defineStyle({
  lineHeight: 1.2,
  overflow: "visible"
});
var baseStyleCloseButton$3 = defineStyle({
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
});
var baseStyle$A = definePartsStyle$l({
  container: baseStyleContainer$4,
  label: baseStyleLabel$4,
  closeButton: baseStyleCloseButton$3
});
var sizes$i = {
  sm: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.5",
      [$minW.variable]: "sizes.5",
      [$fontSize$1.variable]: "fontSizes.xs",
      [$paddingX.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.6",
      [$minW.variable]: "sizes.6",
      [$fontSize$1.variable]: "fontSizes.sm",
      [$paddingX.variable]: "space.2"
    }
  }),
  lg: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.8",
      [$minW.variable]: "sizes.8",
      [$fontSize$1.variable]: "fontSizes.md",
      [$paddingX.variable]: "space.3"
    }
  })
};
var variants$c = {
  subtle: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.subtle(props)
    };
  }),
  solid: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.solid(props)
    };
  }),
  outline: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.outline(props)
    };
  })
};
var tagTheme = defineMultiStyleConfig$l({
  variants: variants$c,
  baseStyle: baseStyle$A,
  sizes: sizes$i,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
});
var { definePartsStyle: definePartsStyle$k, defineMultiStyleConfig: defineMultiStyleConfig$k } = createMultiStyleConfigHelpers(inputAnatomy.keys);
var $height = cssVar$2("input-height");
var $fontSize = cssVar$2("input-font-size");
var $padding$1 = cssVar$2("input-padding");
var $borderRadius = cssVar$2("input-border-radius");
var baseStyle$z = definePartsStyle$k({
  addon: {
    height: $height.reference,
    fontSize: $fontSize.reference,
    px: $padding$1.reference,
    borderRadius: $borderRadius.reference
  },
  field: {
    width: "100%",
    height: $height.reference,
    fontSize: $fontSize.reference,
    px: $padding$1.reference,
    borderRadius: $borderRadius.reference,
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
});
var size$2 = {
  lg: defineStyle({
    [$fontSize.variable]: "fontSizes.lg",
    [$padding$1.variable]: "space.4",
    [$borderRadius.variable]: "radii.md",
    [$height.variable]: "sizes.12"
  }),
  md: defineStyle({
    [$fontSize.variable]: "fontSizes.md",
    [$padding$1.variable]: "space.4",
    [$borderRadius.variable]: "radii.md",
    [$height.variable]: "sizes.10"
  }),
  sm: defineStyle({
    [$fontSize.variable]: "fontSizes.sm",
    [$padding$1.variable]: "space.3",
    [$borderRadius.variable]: "radii.sm",
    [$height.variable]: "sizes.8"
  }),
  xs: defineStyle({
    [$fontSize.variable]: "fontSizes.xs",
    [$padding$1.variable]: "space.2",
    [$borderRadius.variable]: "radii.sm",
    [$height.variable]: "sizes.6"
  })
};
var sizes$h = {
  lg: definePartsStyle$k({
    field: size$2.lg,
    group: size$2.lg
  }),
  md: definePartsStyle$k({
    field: size$2.md,
    group: size$2.md
  }),
  sm: definePartsStyle$k({
    field: size$2.sm,
    group: size$2.sm
  }),
  xs: definePartsStyle$k({
    field: size$2.xs,
    group: size$2.xs
  })
};
function getDefaults(props) {
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = props;
  return {
    focusBorderColor: fc2 || mode("blue.500", "blue.300")(props),
    errorBorderColor: ec2 || mode("red.500", "red.300")(props)
  };
}
var variantOutline$1 = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: mode("gray.300", "whiteAlpha.400")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme2, ec2),
        boxShadow: `0 0 0 1px ${getColor(theme2, ec2)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: getColor(theme2, fc2),
        boxShadow: `0 0 0 1px ${getColor(theme2, fc2)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: mode("inherit", "whiteAlpha.50")(props),
      bg: mode("gray.100", "whiteAlpha.300")(props)
    }
  };
});
var variantFilled = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props),
      _hover: {
        bg: mode("gray.200", "whiteAlpha.100")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme2, ec2)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: getColor(theme2, fc2)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props)
    }
  };
});
var variantFlushed = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColor(theme2, ec2),
        boxShadow: `0px 1px 0px 0px ${getColor(theme2, ec2)}`
      },
      _focusVisible: {
        borderColor: getColor(theme2, fc2),
        boxShadow: `0px 1px 0px 0px ${getColor(theme2, fc2)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
});
var variantUnstyled$1 = definePartsStyle$k({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
});
var variants$b = {
  outline: variantOutline$1,
  filled: variantFilled,
  flushed: variantFlushed,
  unstyled: variantUnstyled$1
};
var inputTheme = defineMultiStyleConfig$k({
  baseStyle: baseStyle$z,
  sizes: sizes$h,
  variants: variants$b,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
var _a$5;
var baseStyle$y = defineStyle({
  ...(_a$5 = inputTheme.baseStyle) == null ? void 0 : _a$5.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
});
var _a2$2, _b$2;
var variants$a = {
  outline: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.outline(props).field) != null ? _b3 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.flushed(props).field) != null ? _b3 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.filled(props).field) != null ? _b3 : {};
    }
  ),
  unstyled: (_b$2 = (_a2$2 = inputTheme.variants) == null ? void 0 : _a2$2.unstyled.field) != null ? _b$2 : {}
};
var _a3, _b2, _c$1, _d$1, _e$2, _f$1, _g$1, _h$1;
var sizes$g = {
  xs: (_b2 = (_a3 = inputTheme.sizes) == null ? void 0 : _a3.xs.field) != null ? _b2 : {},
  sm: (_d$1 = (_c$1 = inputTheme.sizes) == null ? void 0 : _c$1.sm.field) != null ? _d$1 : {},
  md: (_f$1 = (_e$2 = inputTheme.sizes) == null ? void 0 : _e$2.md.field) != null ? _f$1 : {},
  lg: (_h$1 = (_g$1 = inputTheme.sizes) == null ? void 0 : _g$1.lg.field) != null ? _h$1 : {}
};
var textareaTheme = defineStyleConfig({
  baseStyle: baseStyle$y,
  sizes: sizes$g,
  variants: variants$a,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
var $bg$c = cssVar$1("tooltip-bg");
var $fg$4 = cssVar$1("tooltip-fg");
var $arrowBg$1 = cssVar$1("popper-arrow-bg");
var baseStyle$x = defineStyle({
  bg: $bg$c.reference,
  color: $fg$4.reference,
  [$bg$c.variable]: "colors.gray.700",
  [$fg$4.variable]: "colors.whiteAlpha.900",
  _dark: {
    [$bg$c.variable]: "colors.gray.300",
    [$fg$4.variable]: "colors.gray.900"
  },
  [$arrowBg$1.variable]: $bg$c.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
});
var tooltipTheme = defineStyleConfig({
  baseStyle: baseStyle$x
});
var { defineMultiStyleConfig: defineMultiStyleConfig$j, definePartsStyle: definePartsStyle$j } = createMultiStyleConfigHelpers(progressAnatomy.keys);
var filledStyle = defineStyle((props) => {
  const { colorScheme: c2, theme: t2, isIndeterminate, hasStripe } = props;
  const stripeStyle = mode(
    generateStripe(),
    generateStripe("1rem", "rgba(0,0,0,0.1)")
  )(props);
  const bgColor = mode(`${c2}.500`, `${c2}.200`)(props);
  const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${getColor(t2, bgColor)} 50%,
    transparent 100%
  )`;
  const addStripe = !isIndeterminate && hasStripe;
  return {
    ...addStripe && stripeStyle,
    ...isIndeterminate ? { bgImage: gradient } : { bgColor }
  };
});
var baseStyleLabel$3 = defineStyle({
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
});
var baseStyleTrack$1 = defineStyle((props) => {
  return {
    bg: mode("gray.100", "whiteAlpha.300")(props)
  };
});
var baseStyleFilledTrack$1 = defineStyle((props) => {
  return {
    transitionProperty: "common",
    transitionDuration: "slow",
    ...filledStyle(props)
  };
});
var baseStyle$w = definePartsStyle$j((props) => ({
  label: baseStyleLabel$3,
  filledTrack: baseStyleFilledTrack$1(props),
  track: baseStyleTrack$1(props)
}));
var sizes$f = {
  xs: definePartsStyle$j({
    track: { h: "1" }
  }),
  sm: definePartsStyle$j({
    track: { h: "2" }
  }),
  md: definePartsStyle$j({
    track: { h: "3" }
  }),
  lg: definePartsStyle$j({
    track: { h: "4" }
  })
};
var progressTheme = defineMultiStyleConfig$j({
  sizes: sizes$f,
  baseStyle: baseStyle$w,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var isFunction$3 = (value) => typeof value === "function";
function runIfFn$1(valueOrFn, ...args) {
  return isFunction$3(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var { definePartsStyle: definePartsStyle$i, defineMultiStyleConfig: defineMultiStyleConfig$i } = createMultiStyleConfigHelpers(checkboxAnatomy.keys);
var $size$3 = cssVar$2("checkbox-size");
var baseStyleControl$1 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    w: $size$3.reference,
    h: $size$3.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props),
      _hover: {
        bg: mode(`${c2}.600`, `${c2}.300`)(props),
        borderColor: mode(`${c2}.600`, `${c2}.300`)(props)
      },
      _disabled: {
        borderColor: mode("gray.200", "transparent")(props),
        bg: mode("gray.200", "whiteAlpha.300")(props),
        color: mode("gray.500", "whiteAlpha.500")(props)
      }
    },
    _indeterminate: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props)
    },
    _disabled: {
      bg: mode("gray.100", "whiteAlpha.100")(props),
      borderColor: mode("gray.100", "transparent")(props)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: mode("red.500", "red.300")(props)
    }
  };
});
var baseStyleContainer$3 = defineStyle({
  _disabled: { cursor: "not-allowed" }
});
var baseStyleLabel$2 = defineStyle({
  userSelect: "none",
  _disabled: { opacity: 0.4 }
});
var baseStyleIcon$6 = defineStyle({
  transitionProperty: "transform",
  transitionDuration: "normal"
});
var baseStyle$v = definePartsStyle$i((props) => ({
  icon: baseStyleIcon$6,
  container: baseStyleContainer$3,
  control: runIfFn$1(baseStyleControl$1, props),
  label: baseStyleLabel$2
}));
var sizes$e = {
  sm: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
};
var checkboxTheme = defineMultiStyleConfig$i({
  baseStyle: baseStyle$v,
  sizes: sizes$e,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$h, definePartsStyle: definePartsStyle$h } = createMultiStyleConfigHelpers(radioAnatomy.keys);
var baseStyleControl = defineStyle((props) => {
  var _a4;
  const controlStyle = (_a4 = runIfFn$1(checkboxTheme.baseStyle, props)) == null ? void 0 : _a4.control;
  return {
    ...controlStyle,
    borderRadius: "full",
    _checked: {
      ...controlStyle == null ? void 0 : controlStyle["_checked"],
      _before: {
        content: `""`,
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
});
var baseStyle$u = definePartsStyle$h((props) => {
  var _a4, _b3, _c2, _d2;
  return {
    label: (_b3 = (_a4 = checkboxTheme).baseStyle) == null ? void 0 : _b3.call(_a4, props).label,
    container: (_d2 = (_c2 = checkboxTheme).baseStyle) == null ? void 0 : _d2.call(_c2, props).container,
    control: baseStyleControl(props)
  };
});
var sizes$d = {
  md: definePartsStyle$h({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: definePartsStyle$h({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: definePartsStyle$h({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
};
var radioTheme = defineMultiStyleConfig$h({
  baseStyle: baseStyle$u,
  sizes: sizes$d,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$g, definePartsStyle: definePartsStyle$g } = createMultiStyleConfigHelpers(selectAnatomy.keys);
var $bg$b = cssVar$2("select-bg");
var _a$4;
var baseStyleField$1 = defineStyle({
  ...(_a$4 = inputTheme.baseStyle) == null ? void 0 : _a$4.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: $bg$b.reference,
  [$bg$b.variable]: "colors.white",
  _dark: {
    [$bg$b.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: $bg$b.reference
  }
});
var baseStyleIcon$5 = defineStyle({
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
});
var baseStyle$t = definePartsStyle$g({
  field: baseStyleField$1,
  icon: baseStyleIcon$5
});
var iconSpacing = defineStyle({
  paddingInlineEnd: "8"
});
var _a2$1, _b$1, _c, _d, _e$1, _f, _g, _h;
var sizes$c = {
  lg: {
    ...(_a2$1 = inputTheme.sizes) == null ? void 0 : _a2$1.lg,
    field: {
      ...(_b$1 = inputTheme.sizes) == null ? void 0 : _b$1.lg.field,
      ...iconSpacing
    }
  },
  md: {
    ...(_c = inputTheme.sizes) == null ? void 0 : _c.md,
    field: {
      ...(_d = inputTheme.sizes) == null ? void 0 : _d.md.field,
      ...iconSpacing
    }
  },
  sm: {
    ...(_e$1 = inputTheme.sizes) == null ? void 0 : _e$1.sm,
    field: {
      ...(_f = inputTheme.sizes) == null ? void 0 : _f.sm.field,
      ...iconSpacing
    }
  },
  xs: {
    ...(_g = inputTheme.sizes) == null ? void 0 : _g.xs,
    field: {
      ...(_h = inputTheme.sizes) == null ? void 0 : _h.xs.field,
      ...iconSpacing
    },
    icon: {
      insetEnd: "1"
    }
  }
};
var selectTheme = defineMultiStyleConfig$g({
  baseStyle: baseStyle$t,
  sizes: sizes$c,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});
var $startColor = cssVar$2("skeleton-start-color");
var $endColor = cssVar$2("skeleton-end-color");
var baseStyle$s = defineStyle({
  [$startColor.variable]: "colors.gray.100",
  [$endColor.variable]: "colors.gray.400",
  _dark: {
    [$startColor.variable]: "colors.gray.800",
    [$endColor.variable]: "colors.gray.600"
  },
  background: $startColor.reference,
  borderColor: $endColor.reference,
  opacity: 0.7,
  borderRadius: "sm"
});
var skeletonTheme = defineStyleConfig({
  baseStyle: baseStyle$s
});
var $bg$a = cssVar$2("skip-link-bg");
var baseStyle$r = defineStyle({
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [$bg$a.variable]: "colors.white",
    _dark: {
      [$bg$a.variable]: "colors.gray.700"
    },
    bg: $bg$a.reference
  }
});
var skipLinkTheme = defineStyleConfig({
  baseStyle: baseStyle$r
});
var { defineMultiStyleConfig: defineMultiStyleConfig$f, definePartsStyle: definePartsStyle$f } = createMultiStyleConfigHelpers(sliderAnatomy.keys);
var $thumbSize = cssVar$2("slider-thumb-size");
var $trackSize = cssVar$2("slider-track-size");
var $bg$9 = cssVar$2("slider-bg");
var baseStyleContainer$2 = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...orient({
      orientation,
      vertical: { h: "100%" },
      horizontal: { w: "100%" }
    })
  };
});
var baseStyleTrack = defineStyle((props) => {
  const orientationStyles = orient({
    orientation: props.orientation,
    horizontal: { h: $trackSize.reference },
    vertical: { w: $trackSize.reference }
  });
  return {
    ...orientationStyles,
    overflow: "hidden",
    borderRadius: "sm",
    [$bg$9.variable]: "colors.gray.200",
    _dark: {
      [$bg$9.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [$bg$9.variable]: "colors.gray.300",
      _dark: {
        [$bg$9.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: $bg$9.reference
  };
});
var baseStyleThumb = defineStyle((props) => {
  const { orientation } = props;
  const orientationStyle = orient({
    orientation,
    vertical: {
      left: "50%",
      transform: `translateX(-50%)`,
      _active: {
        transform: `translateX(-50%) scale(1.15)`
      }
    },
    horizontal: {
      top: "50%",
      transform: `translateY(-50%)`,
      _active: {
        transform: `translateY(-50%) scale(1.15)`
      }
    }
  });
  return {
    ...orientationStyle,
    w: $thumbSize.reference,
    h: $thumbSize.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
});
var baseStyleFilledTrack = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    width: "inherit",
    height: "inherit",
    [$bg$9.variable]: `colors.${c2}.500`,
    _dark: {
      [$bg$9.variable]: `colors.${c2}.200`
    },
    bg: $bg$9.reference
  };
});
var baseStyle$q = definePartsStyle$f((props) => ({
  container: baseStyleContainer$2(props),
  track: baseStyleTrack(props),
  thumb: baseStyleThumb(props),
  filledTrack: baseStyleFilledTrack(props)
}));
var sizeLg = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.4`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeMd = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.3.5`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeSm = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.2.5`,
    [$trackSize.variable]: `sizes.0.5`
  }
});
var sizes$b = {
  lg: sizeLg,
  md: sizeMd,
  sm: sizeSm
};
var sliderTheme = defineMultiStyleConfig$f({
  baseStyle: baseStyle$q,
  sizes: sizes$b,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var $size$2 = cssVar$1("spinner-size");
var baseStyle$p = defineStyle({
  width: [$size$2.reference],
  height: [$size$2.reference]
});
var sizes$a = {
  xs: defineStyle({
    [$size$2.variable]: "sizes.3"
  }),
  sm: defineStyle({
    [$size$2.variable]: "sizes.4"
  }),
  md: defineStyle({
    [$size$2.variable]: "sizes.6"
  }),
  lg: defineStyle({
    [$size$2.variable]: "sizes.8"
  }),
  xl: defineStyle({
    [$size$2.variable]: "sizes.12"
  })
};
var spinnerTheme = defineStyleConfig({
  baseStyle: baseStyle$p,
  sizes: sizes$a,
  defaultProps: {
    size: "md"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$e, definePartsStyle: definePartsStyle$e } = createMultiStyleConfigHelpers(statAnatomy.keys);
var baseStyleLabel$1 = defineStyle({
  fontWeight: "medium"
});
var baseStyleHelpText = defineStyle({
  opacity: 0.8,
  marginBottom: "2"
});
var baseStyleNumber = defineStyle({
  verticalAlign: "baseline",
  fontWeight: "semibold"
});
var baseStyleIcon$4 = defineStyle({
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
});
var baseStyle$o = definePartsStyle$e({
  container: {},
  label: baseStyleLabel$1,
  helpText: baseStyleHelpText,
  number: baseStyleNumber,
  icon: baseStyleIcon$4
});
var sizes$9 = {
  md: definePartsStyle$e({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
};
var statTheme = defineMultiStyleConfig$e({
  baseStyle: baseStyle$o,
  sizes: sizes$9,
  defaultProps: {
    size: "md"
  }
});
var $bg$8 = cssVar$2("kbd-bg");
var baseStyle$n = defineStyle({
  [$bg$8.variable]: "colors.gray.100",
  _dark: {
    [$bg$8.variable]: "colors.whiteAlpha.100"
  },
  bg: $bg$8.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
});
var kbdTheme = defineStyleConfig({
  baseStyle: baseStyle$n
});
var baseStyle$m = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
});
var linkTheme = defineStyleConfig({
  baseStyle: baseStyle$m
});
var { defineMultiStyleConfig: defineMultiStyleConfig$d, definePartsStyle: definePartsStyle$d } = createMultiStyleConfigHelpers(listAnatomy.keys);
var baseStyleIcon$3 = defineStyle({
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
});
var baseStyle$l = definePartsStyle$d({
  icon: baseStyleIcon$3
});
var listTheme = defineMultiStyleConfig$d({
  baseStyle: baseStyle$l
});
var { defineMultiStyleConfig: defineMultiStyleConfig$c, definePartsStyle: definePartsStyle$c } = createMultiStyleConfigHelpers(menuAnatomy.keys);
var $bg$7 = cssVar$2("menu-bg");
var $shadow$2 = cssVar$2("menu-shadow");
var baseStyleList = defineStyle({
  [$bg$7.variable]: "#fff",
  [$shadow$2.variable]: "shadows.sm",
  _dark: {
    [$bg$7.variable]: "colors.gray.700",
    [$shadow$2.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: $bg$7.reference,
  boxShadow: $shadow$2.reference
});
var baseStyleItem = defineStyle({
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [$bg$7.variable]: "colors.gray.100",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg$7.variable]: "colors.gray.200",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [$bg$7.variable]: "colors.gray.100",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: $bg$7.reference
});
var baseStyleGroupTitle = defineStyle({
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
});
var baseStyleIcon$2 = defineStyle({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
});
var baseStyleCommand = defineStyle({
  opacity: 0.6
});
var baseStyleDivider = defineStyle({
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
});
var baseStyleButton$1 = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyle$k = definePartsStyle$c({
  button: baseStyleButton$1,
  list: baseStyleList,
  item: baseStyleItem,
  groupTitle: baseStyleGroupTitle,
  icon: baseStyleIcon$2,
  command: baseStyleCommand,
  divider: baseStyleDivider
});
var menuTheme = defineMultiStyleConfig$c({
  baseStyle: baseStyle$k
});
var { defineMultiStyleConfig: defineMultiStyleConfig$b, definePartsStyle: definePartsStyle$b } = createMultiStyleConfigHelpers(modalAnatomy.keys);
var $bg$6 = cssVar$2("modal-bg");
var $shadow$1 = cssVar$2("modal-shadow");
var baseStyleOverlay$1 = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer$1 = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: isCentered ? "center" : "flex-start",
    overflow: scrollBehavior === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
});
var baseStyleDialog$1 = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    borderRadius: "md",
    color: "inherit",
    my: isCentered ? "auto" : "16",
    mx: isCentered ? "auto" : void 0,
    zIndex: "modal",
    maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [$bg$6.variable]: "colors.white",
    [$shadow$1.variable]: "shadows.lg",
    _dark: {
      [$bg$6.variable]: "colors.gray.700",
      [$shadow$1.variable]: "shadows.dark-lg"
    },
    bg: $bg$6.reference,
    boxShadow: $shadow$1.reference
  };
});
var baseStyleHeader$2 = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton$2 = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody$2 = defineStyle((props) => {
  const { scrollBehavior } = props;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: scrollBehavior === "inside" ? "auto" : void 0
  };
});
var baseStyleFooter$2 = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle$j = definePartsStyle$b((props) => ({
  overlay: baseStyleOverlay$1,
  dialogContainer: runIfFn$1(baseStyleDialogContainer$1, props),
  dialog: runIfFn$1(baseStyleDialog$1, props),
  header: baseStyleHeader$2,
  closeButton: baseStyleCloseButton$2,
  body: runIfFn$1(baseStyleBody$2, props),
  footer: baseStyleFooter$2
}));
function getSize$3(value) {
  if (value === "full") {
    return definePartsStyle$b({
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    });
  }
  return definePartsStyle$b({
    dialog: { maxW: value }
  });
}
var sizes$8 = {
  xs: getSize$3("xs"),
  sm: getSize$3("sm"),
  md: getSize$3("md"),
  lg: getSize$3("lg"),
  xl: getSize$3("xl"),
  "2xl": getSize$3("2xl"),
  "3xl": getSize$3("3xl"),
  "4xl": getSize$3("4xl"),
  "5xl": getSize$3("5xl"),
  "6xl": getSize$3("6xl"),
  full: getSize$3("full")
};
var modalTheme = defineMultiStyleConfig$b({
  baseStyle: baseStyle$j,
  sizes: sizes$8,
  defaultProps: { size: "md" }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$a, definePartsStyle: definePartsStyle$a } = createMultiStyleConfigHelpers(numberInputAnatomy.keys);
var $stepperWidth = cssVar$1("number-input-stepper-width");
var $inputPadding = cssVar$1("number-input-input-padding");
var inputPaddingValue = calc($stepperWidth).add("0.5rem").toString();
var $bg$5 = cssVar$1("number-input-bg");
var $fg$3 = cssVar$1("number-input-color");
var $border$2 = cssVar$1("number-input-border-color");
var baseStyleRoot = defineStyle({
  [$stepperWidth.variable]: "sizes.6",
  [$inputPadding.variable]: inputPaddingValue
});
var baseStyleField = defineStyle(
  (props) => {
    var _a4, _b3;
    return (_b3 = (_a4 = runIfFn$1(inputTheme.baseStyle, props)) == null ? void 0 : _a4.field) != null ? _b3 : {};
  }
);
var baseStyleStepperGroup = defineStyle({
  width: $stepperWidth.reference
});
var baseStyleStepper = defineStyle({
  borderStart: "1px solid",
  borderStartColor: $border$2.reference,
  color: $fg$3.reference,
  bg: $bg$5.reference,
  [$fg$3.variable]: "colors.chakra-body-text",
  [$border$2.variable]: "colors.chakra-border-color",
  _dark: {
    [$fg$3.variable]: "colors.whiteAlpha.800",
    [$border$2.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [$bg$5.variable]: "colors.gray.200",
    _dark: {
      [$bg$5.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var baseStyle$i = definePartsStyle$a((props) => {
  var _a4;
  return {
    root: baseStyleRoot,
    field: (_a4 = runIfFn$1(baseStyleField, props)) != null ? _a4 : {},
    stepperGroup: baseStyleStepperGroup,
    stepper: baseStyleStepper
  };
});
function getSize$2(size2) {
  var _a4, _b3, _c2;
  const sizeStyle = (_a4 = inputTheme.sizes) == null ? void 0 : _a4[size2];
  const radius = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  };
  const _fontSize = (_c2 = (_b3 = sizeStyle.field) == null ? void 0 : _b3.fontSize) != null ? _c2 : "md";
  const fontSize = typography_default.fontSizes[_fontSize];
  return definePartsStyle$a({
    field: {
      ...sizeStyle.field,
      paddingInlineEnd: $inputPadding.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: calc(fontSize).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: radius[size2]
      },
      _last: {
        borderBottomEndRadius: radius[size2],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var sizes$7 = {
  xs: getSize$2("xs"),
  sm: getSize$2("sm"),
  md: getSize$2("md"),
  lg: getSize$2("lg")
};
var numberInputTheme = defineMultiStyleConfig$a({
  baseStyle: baseStyle$i,
  sizes: sizes$7,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});
var _a$3;
var baseStyle$h = defineStyle({
  ...(_a$3 = inputTheme.baseStyle) == null ? void 0 : _a$3.field,
  textAlign: "center"
});
var sizes$6 = {
  lg: defineStyle({
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  }),
  md: defineStyle({
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  }),
  sm: defineStyle({
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  }),
  xs: defineStyle({
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  })
};
var _a2, _b;
var variants$9 = {
  outline: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.outline, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.flushed, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.filled, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  unstyled: (_b = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
};
var pinInputTheme = defineStyleConfig({
  baseStyle: baseStyle$h,
  sizes: sizes$6,
  variants: variants$9,
  defaultProps: inputTheme.defaultProps
});
var { defineMultiStyleConfig: defineMultiStyleConfig$9, definePartsStyle: definePartsStyle$9 } = createMultiStyleConfigHelpers(popoverAnatomy.keys);
var $popperBg = cssVar$1("popper-bg");
var $arrowBg = cssVar$1("popper-arrow-bg");
var $arrowShadowColor = cssVar$1("popper-arrow-shadow-color");
var baseStylePopper = defineStyle({ zIndex: 10 });
var baseStyleContent = defineStyle({
  [$popperBg.variable]: `colors.white`,
  bg: $popperBg.reference,
  [$arrowBg.variable]: $popperBg.reference,
  [$arrowShadowColor.variable]: `colors.gray.200`,
  _dark: {
    [$popperBg.variable]: `colors.gray.700`,
    [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
});
var baseStyleHeader$1 = defineStyle({
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
});
var baseStyleBody$1 = defineStyle({
  px: 3,
  py: 2
});
var baseStyleFooter$1 = defineStyle({
  px: 3,
  py: 2,
  borderTopWidth: "1px"
});
var baseStyleCloseButton$1 = defineStyle({
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
});
var baseStyle$g = definePartsStyle$9({
  popper: baseStylePopper,
  content: baseStyleContent,
  header: baseStyleHeader$1,
  body: baseStyleBody$1,
  footer: baseStyleFooter$1,
  closeButton: baseStyleCloseButton$1
});
var popoverTheme = defineMultiStyleConfig$9({
  baseStyle: baseStyle$g
});
var { definePartsStyle: definePartsStyle$8, defineMultiStyleConfig: defineMultiStyleConfig$8 } = createMultiStyleConfigHelpers(drawerAnatomy.keys);
var $bg$4 = cssVar$2("drawer-bg");
var $bs = cssVar$2("drawer-box-shadow");
function getSize$1(value) {
  if (value === "full") {
    return definePartsStyle$8({
      dialog: { maxW: "100vw", h: "100vh" }
    });
  }
  return definePartsStyle$8({
    dialog: { maxW: value }
  });
}
var baseStyleOverlay = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer = defineStyle({
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
});
var baseStyleDialog = defineStyle((props) => {
  const { isFullHeight } = props;
  return {
    ...isFullHeight && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [$bg$4.variable]: "colors.white",
    [$bs.variable]: "shadows.lg",
    _dark: {
      [$bg$4.variable]: "colors.gray.700",
      [$bs.variable]: "shadows.dark-lg"
    },
    bg: $bg$4.reference,
    boxShadow: $bs.reference
  };
});
var baseStyleHeader = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody = defineStyle({
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
});
var baseStyleFooter = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle$f = definePartsStyle$8((props) => ({
  overlay: baseStyleOverlay,
  dialogContainer: baseStyleDialogContainer,
  dialog: runIfFn$1(baseStyleDialog, props),
  header: baseStyleHeader,
  closeButton: baseStyleCloseButton,
  body: baseStyleBody,
  footer: baseStyleFooter
}));
var sizes$5 = {
  xs: getSize$1("xs"),
  sm: getSize$1("md"),
  md: getSize$1("lg"),
  lg: getSize$1("2xl"),
  xl: getSize$1("4xl"),
  full: getSize$1("full")
};
var drawerTheme = defineMultiStyleConfig$8({
  baseStyle: baseStyle$f,
  sizes: sizes$5,
  defaultProps: {
    size: "xs"
  }
});
var { definePartsStyle: definePartsStyle$7, defineMultiStyleConfig: defineMultiStyleConfig$7 } = createMultiStyleConfigHelpers(editableAnatomy.keys);
var baseStylePreview = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyleInput = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyleTextarea = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyle$e = definePartsStyle$7({
  preview: baseStylePreview,
  input: baseStyleInput,
  textarea: baseStyleTextarea
});
var editableTheme = defineMultiStyleConfig$7({
  baseStyle: baseStyle$e
});
var { definePartsStyle: definePartsStyle$6, defineMultiStyleConfig: defineMultiStyleConfig$6 } = createMultiStyleConfigHelpers(formAnatomy.keys);
var $fg$2 = cssVar$2("form-control-color");
var baseStyleRequiredIndicator = defineStyle({
  marginStart: "1",
  [$fg$2.variable]: "colors.red.500",
  _dark: {
    [$fg$2.variable]: "colors.red.300"
  },
  color: $fg$2.reference
});
var baseStyleHelperText = defineStyle({
  mt: "2",
  [$fg$2.variable]: "colors.gray.600",
  _dark: {
    [$fg$2.variable]: "colors.whiteAlpha.600"
  },
  color: $fg$2.reference,
  lineHeight: "normal",
  fontSize: "sm"
});
var baseStyle$d = definePartsStyle$6({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: baseStyleRequiredIndicator,
  helperText: baseStyleHelperText
});
var formTheme = defineMultiStyleConfig$6({
  baseStyle: baseStyle$d
});
var { definePartsStyle: definePartsStyle$5, defineMultiStyleConfig: defineMultiStyleConfig$5 } = createMultiStyleConfigHelpers(formErrorAnatomy.keys);
var $fg$1 = cssVar$2("form-error-color");
var baseStyleText = defineStyle({
  [$fg$1.variable]: `colors.red.500`,
  _dark: {
    [$fg$1.variable]: `colors.red.300`
  },
  color: $fg$1.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
});
var baseStyleIcon$1 = defineStyle({
  marginEnd: "0.5em",
  [$fg$1.variable]: `colors.red.500`,
  _dark: {
    [$fg$1.variable]: `colors.red.300`
  },
  color: $fg$1.reference
});
var baseStyle$c = definePartsStyle$5({
  text: baseStyleText,
  icon: baseStyleIcon$1
});
var formErrorTheme = defineMultiStyleConfig$5({
  baseStyle: baseStyle$c
});
var baseStyle$b = defineStyle({
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
});
var formLabelTheme = defineStyleConfig({
  baseStyle: baseStyle$b
});
var baseStyle$a = defineStyle({
  fontFamily: "heading",
  fontWeight: "bold"
});
var sizes$4 = {
  "4xl": defineStyle({
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  }),
  "3xl": defineStyle({
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  }),
  "2xl": defineStyle({
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  }),
  xl: defineStyle({
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  lg: defineStyle({
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  md: defineStyle({
    fontSize: "xl",
    lineHeight: 1.2
  }),
  sm: defineStyle({
    fontSize: "md",
    lineHeight: 1.2
  }),
  xs: defineStyle({
    fontSize: "sm",
    lineHeight: 1.2
  })
};
var headingTheme = defineStyleConfig({
  baseStyle: baseStyle$a,
  sizes: sizes$4,
  defaultProps: {
    size: "xl"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$4, definePartsStyle: definePartsStyle$4 } = createMultiStyleConfigHelpers(breadcrumbAnatomy.keys);
var $decor = cssVar$2("breadcrumb-link-decor");
var baseStyleLink = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: $decor.reference,
  [$decor.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [$decor.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
});
var baseStyle$9 = definePartsStyle$4({
  link: baseStyleLink
});
var breadcrumbTheme = defineMultiStyleConfig$4({
  baseStyle: baseStyle$9
});
var baseStyle$8 = defineStyle({
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
});
var variantGhost = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  if (c2 === "gray") {
    return {
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.100`, `whiteAlpha.200`)(props)
      },
      _active: { bg: mode(`gray.200`, `whiteAlpha.300`)(props) }
    };
  }
  const darkHoverBg = transparentize$1(`${c2}.200`, 0.12)(theme2);
  const darkActiveBg = transparentize$1(`${c2}.200`, 0.24)(theme2);
  return {
    color: mode(`${c2}.600`, `${c2}.200`)(props),
    bg: "transparent",
    _hover: {
      bg: mode(`${c2}.50`, darkHoverBg)(props)
    },
    _active: {
      bg: mode(`${c2}.100`, darkActiveBg)(props)
    }
  };
});
var variantOutline = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  const borderColor2 = mode(`gray.200`, `whiteAlpha.300`)(props);
  return {
    border: "1px solid",
    borderColor: c2 === "gray" ? borderColor2 : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...runIfFn$1(variantGhost, props)
  };
});
var accessibleColorMap = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
};
var variantSolid$2 = defineStyle((props) => {
  var _a4;
  const { colorScheme: c2 } = props;
  if (c2 === "gray") {
    const bg22 = mode(`gray.100`, `whiteAlpha.200`)(props);
    return {
      bg: bg22,
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.200`, `whiteAlpha.300`)(props),
        _disabled: {
          bg: bg22
        }
      },
      _active: { bg: mode(`gray.300`, `whiteAlpha.400`)(props) }
    };
  }
  const {
    bg: bg2 = `${c2}.500`,
    color: color2 = "white",
    hoverBg = `${c2}.600`,
    activeBg = `${c2}.700`
  } = (_a4 = accessibleColorMap[c2]) != null ? _a4 : {};
  const background2 = mode(bg2, `${c2}.200`)(props);
  return {
    bg: background2,
    color: mode(color2, `gray.800`)(props),
    _hover: {
      bg: mode(hoverBg, `${c2}.300`)(props),
      _disabled: {
        bg: background2
      }
    },
    _active: { bg: mode(activeBg, `${c2}.400`)(props) }
  };
});
var variantLink = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: mode(`${c2}.500`, `${c2}.200`)(props),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: mode(`${c2}.700`, `${c2}.500`)(props)
    }
  };
});
var variantUnstyled = defineStyle({
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
});
var variants$8 = {
  ghost: variantGhost,
  outline: variantOutline,
  solid: variantSolid$2,
  link: variantLink,
  unstyled: variantUnstyled
};
var sizes$3 = {
  lg: defineStyle({
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  }),
  md: defineStyle({
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  }),
  sm: defineStyle({
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  }),
  xs: defineStyle({
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  })
};
var buttonTheme = defineStyleConfig({
  baseStyle: baseStyle$8,
  variants: variants$8,
  sizes: sizes$3,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
});
var { definePartsStyle: definePartsStyle$3, defineMultiStyleConfig: defineMultiStyleConfig$3 } = createMultiStyleConfigHelpers(cardAnatomy.keys);
var $bg$3 = cssVar$2("card-bg");
var $padding = cssVar$2("card-padding");
var $shadow = cssVar$2("card-shadow");
var $radius = cssVar$2("card-radius");
var $border$1 = cssVar$2("card-border-width", "0");
var $borderColor = cssVar$2("card-border-color");
var baseStyle$7 = definePartsStyle$3({
  container: {
    [$bg$3.variable]: "colors.chakra-body-bg",
    backgroundColor: $bg$3.reference,
    boxShadow: $shadow.reference,
    borderRadius: $radius.reference,
    color: "chakra-body-text",
    borderWidth: $border$1.reference,
    borderColor: $borderColor.reference
  },
  body: {
    padding: $padding.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: $padding.reference
  },
  footer: {
    padding: $padding.reference
  }
});
var sizes$2 = {
  sm: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.base",
      [$padding.variable]: "space.3"
    }
  }),
  md: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.md",
      [$padding.variable]: "space.5"
    }
  }),
  lg: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.xl",
      [$padding.variable]: "space.7"
    }
  })
};
var variants$7 = {
  elevated: definePartsStyle$3({
    container: {
      [$shadow.variable]: "shadows.base",
      _dark: {
        [$bg$3.variable]: "colors.gray.700"
      }
    }
  }),
  outline: definePartsStyle$3({
    container: {
      [$border$1.variable]: "1px",
      [$borderColor.variable]: "colors.chakra-border-color"
    }
  }),
  filled: definePartsStyle$3({
    container: {
      [$bg$3.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [$padding.variable]: 0
    },
    header: {
      [$padding.variable]: 0
    },
    footer: {
      [$padding.variable]: 0
    }
  }
};
var cardTheme = defineMultiStyleConfig$3({
  baseStyle: baseStyle$7,
  variants: variants$7,
  sizes: sizes$2,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
});
var $size$1 = cssVar$1("close-button-size");
var $bg$2 = cssVar$1("close-button-bg");
var baseStyle$6 = defineStyle({
  w: [$size$1.reference],
  h: [$size$1.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [$bg$2.variable]: "colors.blackAlpha.100",
    _dark: {
      [$bg$2.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg$2.variable]: "colors.blackAlpha.200",
    _dark: {
      [$bg$2.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: $bg$2.reference
});
var sizes$1 = {
  lg: defineStyle({
    [$size$1.variable]: "sizes.10",
    fontSize: "md"
  }),
  md: defineStyle({
    [$size$1.variable]: "sizes.8",
    fontSize: "xs"
  }),
  sm: defineStyle({
    [$size$1.variable]: "sizes.6",
    fontSize: "2xs"
  })
};
var closeButtonTheme$1 = defineStyleConfig({
  baseStyle: baseStyle$6,
  sizes: sizes$1,
  defaultProps: {
    size: "md"
  }
});
var { variants: variants$6, defaultProps: defaultProps$6 } = badgeTheme;
var baseStyle$5 = defineStyle({
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var codeTheme = defineStyleConfig({
  baseStyle: baseStyle$5,
  variants: variants$6,
  defaultProps: defaultProps$6
});
var baseStyle$4 = defineStyle({
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
});
var containerTheme = defineStyleConfig({
  baseStyle: baseStyle$4
});
var baseStyle$3 = defineStyle({
  opacity: 0.6,
  borderColor: "inherit"
});
var variantSolid$1 = defineStyle({
  borderStyle: "solid"
});
var variantDashed = defineStyle({
  borderStyle: "dashed"
});
var variants$5 = {
  solid: variantSolid$1,
  dashed: variantDashed
};
var dividerTheme = defineStyleConfig({
  baseStyle: baseStyle$3,
  variants: variants$5,
  defaultProps: {
    variant: "solid"
  }
});
var { definePartsStyle: definePartsStyle$2, defineMultiStyleConfig: defineMultiStyleConfig$2 } = createMultiStyleConfigHelpers(accordionAnatomy.keys);
var baseStyleContainer$1 = defineStyle({
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
});
var baseStyleButton = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
});
var baseStylePanel = defineStyle({
  pt: "2",
  px: "4",
  pb: "5"
});
var baseStyleIcon = defineStyle({
  fontSize: "1.25em"
});
var baseStyle$2 = definePartsStyle$2({
  container: baseStyleContainer$1,
  button: baseStyleButton,
  panel: baseStylePanel,
  icon: baseStyleIcon
});
var accordionTheme = defineMultiStyleConfig$2({ baseStyle: baseStyle$2 });
var { definePartsStyle: definePartsStyle$1, defineMultiStyleConfig: defineMultiStyleConfig$1 } = createMultiStyleConfigHelpers(alertAnatomy.keys);
var $fg = cssVar$2("alert-fg");
var $bg$1 = cssVar$2("alert-bg");
var baseStyle$1 = definePartsStyle$1({
  container: {
    bg: $bg$1.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function getBg(props) {
  const { theme: theme2, colorScheme: c2 } = props;
  const darkBg = transparentize$1(`${c2}.200`, 0.16)(theme2);
  return {
    light: `colors.${c2}.100`,
    dark: darkBg
  };
}
var variantSubtle = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      }
    }
  };
});
var variantLeftAccent = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: $fg.reference
    }
  };
});
var variantTopAccent = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: $fg.reference
    }
  };
});
var variantSolid = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  return {
    container: {
      [$fg.variable]: `colors.white`,
      [$bg$1.variable]: `colors.${c2}.500`,
      _dark: {
        [$fg.variable]: `colors.gray.900`,
        [$bg$1.variable]: `colors.${c2}.200`
      },
      color: $fg.reference
    }
  };
});
var variants$4 = {
  subtle: variantSubtle,
  "left-accent": variantLeftAccent,
  "top-accent": variantTopAccent,
  solid: variantSolid
};
var alertTheme = defineMultiStyleConfig$1({
  baseStyle: baseStyle$1,
  variants: variants$4,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
});
var { definePartsStyle, defineMultiStyleConfig } = createMultiStyleConfigHelpers(avatarAnatomy.keys);
var $border = cssVar$2("avatar-border-color");
var $bg = cssVar$2("avatar-bg");
var $fs = cssVar$2("avatar-font-size");
var $size = cssVar$2("avatar-size");
var baseStyleBadge = defineStyle({
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: $border.reference,
  [$border.variable]: "white",
  _dark: {
    [$border.variable]: "colors.gray.800"
  }
});
var baseStyleExcessLabel = defineStyle({
  bg: $bg.reference,
  fontSize: $fs.reference,
  width: $size.reference,
  height: $size.reference,
  lineHeight: "1",
  [$bg.variable]: "colors.gray.200",
  _dark: {
    [$bg.variable]: "colors.whiteAlpha.400"
  }
});
var baseStyleContainer = defineStyle((props) => {
  const { name: name2, theme: theme2 } = props;
  const bg2 = name2 ? randomColor({ string: name2 }) : "colors.gray.400";
  const isBgDark = isDark(bg2)(theme2);
  let color2 = "white";
  if (!isBgDark)
    color2 = "gray.800";
  return {
    bg: $bg.reference,
    fontSize: $fs.reference,
    color: color2,
    borderColor: $border.reference,
    verticalAlign: "top",
    width: $size.reference,
    height: $size.reference,
    "&:not([data-loaded])": {
      [$bg.variable]: bg2
    },
    [$border.variable]: "colors.white",
    _dark: {
      [$border.variable]: "colors.gray.800"
    }
  };
});
var baseStyleLabel = defineStyle({
  fontSize: $fs.reference,
  lineHeight: "1"
});
var baseStyle = definePartsStyle((props) => ({
  badge: runIfFn$1(baseStyleBadge, props),
  excessLabel: runIfFn$1(baseStyleExcessLabel, props),
  container: runIfFn$1(baseStyleContainer, props),
  label: baseStyleLabel
}));
function getSize(size2) {
  const themeSize = size2 !== "100%" ? sizes_default[size2] : void 0;
  return definePartsStyle({
    container: {
      [$size.variable]: themeSize != null ? themeSize : size2,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
    },
    excessLabel: {
      [$size.variable]: themeSize != null ? themeSize : size2,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
    }
  });
}
var sizes = {
  "2xs": getSize(4),
  xs: getSize(6),
  sm: getSize(8),
  md: getSize(12),
  lg: getSize(16),
  xl: getSize(24),
  "2xl": getSize(32),
  full: getSize("100%")
};
var avatarTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
var components$1 = {
  Accordion: accordionTheme,
  Alert: alertTheme,
  Avatar: avatarTheme,
  Badge: badgeTheme,
  Breadcrumb: breadcrumbTheme,
  Button: buttonTheme,
  Checkbox: checkboxTheme,
  CloseButton: closeButtonTheme$1,
  Code: codeTheme,
  Container: containerTheme,
  Divider: dividerTheme,
  Drawer: drawerTheme,
  Editable: editableTheme,
  Form: formTheme,
  FormError: formErrorTheme,
  FormLabel: formLabelTheme,
  Heading: headingTheme,
  Input: inputTheme,
  Kbd: kbdTheme,
  Link: linkTheme,
  List: listTheme,
  Menu: menuTheme,
  Modal: modalTheme,
  NumberInput: numberInputTheme,
  PinInput: pinInputTheme,
  Popover: popoverTheme,
  Progress: progressTheme,
  Radio: radioTheme,
  Select: selectTheme,
  Skeleton: skeletonTheme,
  SkipLink: skipLinkTheme,
  Slider: sliderTheme,
  Spinner: spinnerTheme,
  Stat: statTheme,
  Switch: switchTheme,
  Table: tableTheme,
  Tabs: tabsTheme,
  Tag: tagTheme,
  Textarea: textareaTheme,
  Tooltip: tooltipTheme,
  Card: cardTheme,
  Stepper: stepperTheme
};
var semanticTokens = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
};
var styles$2 = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
};
var direction = "ltr";
var config$2 = {
  useSystemColorMode: false,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
};
var theme$1 = {
  semanticTokens,
  direction,
  ...foundations,
  components: components$1,
  styles: styles$2,
  config: config$2
};
function isFunction$2(value) {
  return typeof value === "function";
}
function pipe$1(...fns) {
  return (v2) => fns.reduce((a, b2) => b2(a), v2);
}
var createExtendTheme = (theme2) => {
  return function extendTheme2(...extensions) {
    let overrides = [...extensions];
    let activeTheme = extensions[extensions.length - 1];
    if (isChakraTheme(activeTheme) && // this ensures backward compatibility
    // previously only `extendTheme(override, activeTheme?)` was allowed
    overrides.length > 1) {
      overrides = overrides.slice(0, overrides.length - 1);
    } else {
      activeTheme = theme2;
    }
    return pipe$1(
      ...overrides.map(
        (extension) => (prevTheme) => isFunction$2(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
      )
    )(activeTheme);
  };
};
var extendTheme = createExtendTheme(theme$1);
function mergeThemeOverride(...overrides) {
  return mergeWith({}, ...overrides, mergeThemeCustomizer);
}
function mergeThemeCustomizer(source, override2, key2, object2) {
  if ((isFunction$2(source) || isFunction$2(override2)) && Object.prototype.hasOwnProperty.call(object2, key2)) {
    return (...args) => {
      const sourceValue = isFunction$2(source) ? source(...args) : source;
      const overrideValue = isFunction$2(override2) ? override2(...args) : override2;
      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer);
    };
  }
  return void 0;
}
function canUseDOM$1() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var isBrowser$1 = /* @__PURE__ */ canUseDOM$1();
function omit$3(object2, keys2) {
  const result = {};
  Object.keys(object2).forEach((key2) => {
    if (keys2.includes(key2))
      return;
    result[key2] = object2[key2];
  });
  return result;
}
function get$4(obj, path2, fallback, index2) {
  const key2 = typeof path2 === "string" ? path2.split(".") : [path2];
  for (index2 = 0; index2 < key2.length; index2 += 1) {
    if (!obj)
      break;
    obj = obj[key2[index2]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize = (fn2) => {
  const cache2 = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path2, fallback, index2) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path2, fallback);
    }
    if (!cache2.has(obj)) {
      cache2.set(obj, /* @__PURE__ */ new Map());
    }
    const map3 = cache2.get(obj);
    if (map3.has(path2)) {
      return map3.get(path2);
    }
    const value = fn2(obj, path2, fallback, index2);
    map3.set(path2, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet = memoize(get$4);
function objectFilter(object2, fn2) {
  const result = {};
  Object.keys(object2).forEach((key2) => {
    const value = object2[key2];
    const shouldPass = fn2(value, key2, object2);
    if (shouldPass) {
      result[key2] = value;
    }
  });
  return result;
}
var filterUndefined = (object2) => objectFilter(object2, (val) => val !== null && val !== void 0);
function isFunction$1(value) {
  return typeof value === "function";
}
function runIfFn(valueOrFn, ...args) {
  return isFunction$1(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some((fn2) => {
      fn2 == null ? void 0 : fn2(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a, b2) {
  if (a === b2)
    return true;
  if (a && b2 && typeof a == "object" && typeof b2 == "object") {
    if (a.constructor !== b2.constructor)
      return false;
    var length2, i, keys2;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 != b2.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!equal(a[i], b2[i]))
          return false;
      return true;
    }
    var it2;
    if (hasMap && a instanceof Map && b2 instanceof Map) {
      if (a.size !== b2.size)
        return false;
      it2 = a.entries();
      while (!(i = it2.next()).done)
        if (!b2.has(i.value[0]))
          return false;
      it2 = a.entries();
      while (!(i = it2.next()).done)
        if (!equal(i.value[1], b2.get(i.value[0])))
          return false;
      return true;
    }
    if (hasSet && a instanceof Set && b2 instanceof Set) {
      if (a.size !== b2.size)
        return false;
      it2 = a.entries();
      while (!(i = it2.next()).done)
        if (!b2.has(i.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b2)) {
      length2 = a.length;
      if (length2 != b2.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (a[i] !== b2[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b2.source && a.flags === b2.flags;
    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b2.valueOf === "function")
      return a.valueOf() === b2.valueOf();
    if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b2.toString === "function")
      return a.toString() === b2.toString();
    keys2 = Object.keys(a);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i]))
        return false;
    if (hasElementType && a instanceof Element)
      return false;
    for (i = length2; i-- !== 0; ) {
      if ((keys2[i] === "_owner" || keys2[i] === "__v" || keys2[i] === "__o") && a.$$typeof) {
        continue;
      }
      if (!equal(a[keys2[i]], b2[keys2[i]]))
        return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
var reactFastCompare = function isEqual(a, b2) {
  try {
    return equal(a, b2);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
const isEqual$2 = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
function useStyleConfigImpl(themeKey, props = {}) {
  var _a4;
  const { styleConfig: styleConfigProp, ...rest } = props;
  const { theme: theme2, colorMode } = useChakra();
  const themeStyleConfig = themeKey ? memoizedGet(theme2, `components.${themeKey}`) : void 0;
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = mergeWith(
    { theme: theme2, colorMode },
    (_a4 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a4 : {},
    filterUndefined(omit$3(rest, ["children"]))
  );
  const stylesRef = reactExports.useRef({});
  if (styleConfig) {
    const getStyles2 = resolveStyleConfig(styleConfig);
    const styles2 = getStyles2(mergedProps);
    const isStyleEqual = isEqual$2(stylesRef.current, styles2);
    if (!isStyleEqual) {
      stylesRef.current = styles2;
    }
  }
  return stylesRef.current;
}
function useStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useMultiStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
var allPropNames = /* @__PURE__ */ new Set([
  ...propNames,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]);
var validHTMLProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function shouldForwardProp(prop) {
  return validHTMLProps.has(prop) || !allPropNames.has(prop);
}
function assignAfter(target, ...sources) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null)
      continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
        continue;
      if (nextKey in result)
        delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$2(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options2, isReal) {
  var shouldForwardProp2;
  if (options2) {
    var optionsShouldForwardProp = options2.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref3) {
  var cache2 = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options2) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options2 !== void 0) {
    identifierName = options2.label;
    targetClassName = options2.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options2, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$8({}, options2, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags$1 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags$1.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
var _a$2;
var emotion_styled = (_a$2 = newStyled.default) != null ? _a$2 : newStyled;
var toCSSObject = ({ baseStyle: baseStyle2 }) => (props) => {
  const { theme: theme2, css: cssProp, __css, sx, ...rest } = props;
  const styleProps2 = objectFilter(rest, (_2, prop) => isStyleProp(prop));
  const finalBaseStyle = runIfFn(baseStyle2, props);
  const finalStyles = assignAfter(
    {},
    __css,
    finalBaseStyle,
    filterUndefined(styleProps2),
    sx
  );
  const computedCSS = css$2(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options2) {
  const { baseStyle: baseStyle2, ...styledOptions } = options2 != null ? options2 : {};
  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }
  const styleObject = toCSSObject({ baseStyle: baseStyle2 });
  const Component = emotion_styled(
    component,
    styledOptions
  )(styleObject);
  const chakraComponent = React.forwardRef(function ChakraComponent(props, ref) {
    const { colorMode, forced } = useColorMode();
    return React.createElement(Component, {
      ref,
      "data-theme": forced ? colorMode : void 0,
      ...props
    });
  });
  return chakraComponent;
}
function factory() {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(target, thisArg, argArray) {
      return styled(...argArray);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(_2, element) {
      if (!cache2.has(element)) {
        cache2.set(element, styled(element));
      }
      return cache2.get(element);
    }
  });
}
var chakra = factory();
function forwardRef(component) {
  return reactExports.forwardRef(component);
}
function createContext(options2 = {}) {
  const {
    strict = true,
    errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name: name2
  } = options2;
  const Context2 = reactExports.createContext(void 0);
  Context2.displayName = name2;
  function useContext() {
    var _a4;
    const context = reactExports.useContext(Context2);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a4 = Error.captureStackTrace) == null ? void 0 : _a4.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [
    Context2.Provider,
    useContext,
    Context2
  ];
}
function ThemeProvider2(props) {
  const { cssVarsRoot, theme: theme2, children } = props;
  const computedTheme = reactExports.useMemo(() => toCSSVar(theme2), [theme2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider$1, { theme: computedTheme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CSSVars, { root: cssVarsRoot }),
    children
  ] });
}
function CSSVars({ root = ":host, :root" }) {
  const selector = [root, `[data-theme]`].join(",");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: (theme2) => ({ [selector]: theme2.__cssVars }) });
}
createContext({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function GlobalStyle() {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Global,
    {
      styles: (theme2) => {
        const styleObjectOrFn = memoizedGet(theme2, "styles.global");
        const globalStyles = runIfFn(styleObjectOrFn, { theme: theme2, colorMode });
        if (!globalStyles)
          return void 0;
        const styles2 = css$2(globalStyles)(theme2);
        return styles2;
      }
    }
  );
}
var EnvironmentContext = reactExports.createContext({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
EnvironmentContext.displayName = "EnvironmentContext";
function EnvironmentProvider(props) {
  const { children, environment: environmentProp, disabled } = props;
  const ref = reactExports.useRef(null);
  const context = reactExports.useMemo(() => {
    if (environmentProp)
      return environmentProp;
    return {
      getDocument: () => {
        var _a4, _b3;
        return (_b3 = (_a4 = ref.current) == null ? void 0 : _a4.ownerDocument) != null ? _b3 : document;
      },
      getWindow: () => {
        var _a4, _b3;
        return (_b3 = (_a4 = ref.current) == null ? void 0 : _a4.ownerDocument.defaultView) != null ? _b3 : window;
      }
    };
  }, [environmentProp]);
  const showSpan = !disabled || !environmentProp;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(EnvironmentContext.Provider, { value: context, children: [
    children,
    showSpan && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { id: "__chakra_env", hidden: true, ref })
  ] });
}
EnvironmentProvider.displayName = "EnvironmentProvider";
var ChakraProvider$1 = (props) => {
  const {
    children,
    colorModeManager,
    portalZIndex,
    resetScope,
    resetCSS = true,
    theme: theme2 = {},
    environment,
    cssVarsRoot,
    disableEnvironment,
    disableGlobalStyle
  } = props;
  const _children = /* @__PURE__ */ jsxRuntimeExports.jsx(
    EnvironmentProvider,
    {
      environment,
      disabled: disableEnvironment,
      children
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider2, { theme: theme2, cssVarsRoot, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ColorModeProvider,
    {
      colorModeManager,
      options: theme2.config,
      children: [
        resetCSS ? /* @__PURE__ */ jsxRuntimeExports.jsx(CSSReset, { scope: resetScope }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CSSPolyfill, {}),
        !disableGlobalStyle && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyle, {}),
        portalZIndex ? /* @__PURE__ */ jsxRuntimeExports.jsx(PortalManager, { zIndex: portalZIndex, children: _children }) : _children
      ]
    }
  ) });
};
var findById = (arr, id2) => arr.find((toast) => toast.id === id2);
function findToast(toasts, id2) {
  const position2 = getToastPosition(toasts, id2);
  const index2 = position2 ? toasts[position2].findIndex((toast) => toast.id === id2) : -1;
  return {
    position: position2,
    index: index2
  };
}
function getToastPosition(toasts, id2) {
  for (const [position2, values2] of Object.entries(toasts)) {
    if (findById(values2, id2)) {
      return position2;
    }
  }
}
function getToastStyle(position2) {
  const isRighty = position2.includes("right");
  const isLefty = position2.includes("left");
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}
function getToastListStyle(position2) {
  const isTopOrBottom = position2 === "top" || position2 === "bottom";
  const margin2 = isTopOrBottom ? "0 auto" : void 0;
  const top2 = position2.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
  const bottom2 = position2.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
  const right2 = !position2.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
  const left2 = !position2.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: margin2,
    top: top2,
    bottom: bottom2,
    right: right2,
    left: left2
  };
}
function useCallbackRef$2(callback, deps = []) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useCallback((...args) => {
    var _a4;
    return (_a4 = callbackRef.current) == null ? void 0 : _a4.call(callbackRef, ...args);
  }, deps);
}
function useTimeout(callback, delay2) {
  const fn2 = useCallbackRef$2(callback);
  reactExports.useEffect(() => {
    if (delay2 == null)
      return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(() => {
      fn2();
    }, delay2);
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay2, fn2]);
}
function useUpdateEffect(callback, deps) {
  const renderCycleRef = reactExports.useRef(false);
  const effectCycleRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run3 = mounted && effectCycleRef.current;
    if (run3) {
      return callback();
    }
    effectCycleRef.current = true;
  }, deps);
  reactExports.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
const PresenceContext = reactExports.createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component, visualState, props, createVisualElement) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  reactExports.useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  const canHandoff = reactExports.useRef(Boolean(window.HandoffAppearAnimations));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    visualElement.render();
    if (canHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    visualElement.updateFeatures();
    if (!canHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    window.HandoffAppearAnimations = void 0;
    canHandoff.current = false;
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key2 in featureProps) {
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name2) => !!props[name2])
  };
}
function loadFeatures(features) {
  for (const key2 in features) {
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
  }
}
const LayoutGroupContext = reactExports.createContext({});
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      const isStrict = reactExports.useContext(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? reactExports.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (!componentCache.has(key2)) {
        componentCache.set(key2, custom(key2));
      }
      return componentCache.get(key2);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate2) {
  let transformString = "";
  for (let i = 0; i < numTransforms; i++) {
    const key2 = transformPropOrder[i];
    if (transform2[key2] !== void 0) {
      const transformName = translateAlias[key2] || key2;
      transformString += `${transformName}(${transform2[key2]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform2.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate2) {
    transformString = transformTemplate2(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
const checkStringStartsWith = (token2) => (key2) => typeof key2 === "string" && key2.startsWith(token2);
const isCSSVariableName = checkStringStartsWith("--");
const isCSSVariableToken = checkStringStartsWith("var(--");
const cssVariableRegex$1 = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
const getValueAsType = (value, type2) => {
  return type2 && typeof value === "number" ? type2.transform(value) : value;
};
const clamp = (min2, max2, v2) => Math.min(Math.max(v2, min2), max2);
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha$2 = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale$1 = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v2) {
  return typeof v2 === "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString$1(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int$3 = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale: scale$1,
  scaleX: scale$1,
  scaleY: scale$1,
  scaleZ: scale$1,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha$2,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int$3,
  // SVG
  fillOpacity: alpha$2,
  strokeOpacity: alpha$2,
  numOctaves: int$3
};
function buildHTMLStyles(state2, latestValues, options2, transformTemplate2) {
  const { style, vars: vars2, transform: transform2, transformOrigin: transformOrigin2 } = state2;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (isCSSVariableName(key2)) {
      vars2[key2] = value;
      continue;
    }
    const valueType = numberValueTypes[key2];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      transform2[key2] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key2.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key2] = valueAsType;
    } else {
      style[key2] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate2) {
      style.transform = buildTransform(state2.transform, options2, transformIsNone, transformTemplate2);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate: transformTemplate2 }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state2 = createHtmlRenderState();
    buildHTMLStyles(state2, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
    return Object.assign({}, state2.vars, state2.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a4) {
}
function filterProps(props, isDom2, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props) {
    if (key2 === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom2 && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props[key2];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset2, size2) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing2 = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing2);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state2, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options2, isSVGTag2, transformTemplate2) {
  buildHTMLStyles(state2, latest, options2, transformTemplate2);
  if (isSVGTag2) {
    if (state2.style.viewBox) {
      state2.attrs.viewBox = state2.style.viewBox;
    }
    return;
  }
  state2.attrs = state2.style;
  state2.style = {};
  const { attrs, style, dimensions } = state2;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state2 = createSvgRenderState();
    buildSVGAttrs(state2, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
    return {
      ...state2.attrs,
      style: { ...state2.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str2) => str2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars2) {
    element.style.setProperty(key2, vars2[key2]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key2 in style) {
    if (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props)) {
      newValues[key2] = style[key2];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key2 in props) {
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state2 = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state2.mount = (instance) => onMount(props, instance, state2);
  }
  return state2;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values2 = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues) {
    values2[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition: transition2, ...target } = resolved;
      for (const key2 in target) {
        let valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values2[key2] = valueTarget;
        }
      }
      for (const key2 in transitionEnd)
        values2[key2] = transitionEnd[key2];
    });
  }
  return values2;
}
const noop$3 = (any) => any;
class Queue {
  constructor() {
    this.order = [];
    this.scheduled = /* @__PURE__ */ new Set();
  }
  add(process2) {
    if (!this.scheduled.has(process2)) {
      this.scheduled.add(process2);
      this.order.push(process2);
      return true;
    }
  }
  remove(process2) {
    const index2 = this.order.indexOf(process2);
    if (index2 !== -1) {
      this.order.splice(index2, 1);
      this.scheduled.delete(process2);
    }
  }
  clear() {
    this.order.length = 0;
    this.scheduled.clear();
  }
}
function createRenderStep(runNextFrame) {
  let thisFrame = new Queue();
  let nextFrame = new Queue();
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (queue.add(callback) && addToCurrentFrame && isProcessing) {
        numToRun = thisFrame.order.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.remove(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      nextFrame.clear();
      numToRun = thisFrame.order.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = thisFrame.order[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const stepsOrder = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state2 = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const steps2 = stepsOrder.reduce((acc, key2) => {
    acc[key2] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {});
  const processStep = (stepId) => steps2[stepId].process(state2);
  const processBatch = () => {
    const timestamp2 = performance.now();
    runNextFrame = false;
    state2.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp2 - state2.timestamp, maxElapsed), 1);
    state2.timestamp = timestamp2;
    state2.isProcessing = true;
    stepsOrder.forEach(processStep);
    state2.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state2.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key2) => {
    const step = steps2[key2];
    acc[key2] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => stepsOrder.forEach((key2) => steps2[key2].cancel(process2));
  return { schedule, cancel, state: state2, steps: steps2 };
}
const { schedule: frame, cancel: cancelFrame$1, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$3, true);
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e2) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component
  };
}
function addDomEvent(target, eventName, handler, options2 = { passive: true }) {
  target.addEventListener(eventName, handler, options2);
  return () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options2) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options2);
}
const combineFunctions = (a, b2) => (v2) => b2(a(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
class Feature {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
}
function addHoverEvent(node2, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave");
  const callbackName = "onHover" + (isActive ? "Start" : "End");
  const handleEvent = (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    const props = node2.getProps();
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", isActive);
    }
    if (props[callbackName]) {
      frame.update(() => props[callbackName](event, info));
    }
  };
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible2 = false;
    try {
      isFocusVisible2 = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible2 = true;
    }
    if (!isFocusVisible2 || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
function fireSyntheticPointerEvent(name2, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name2);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop$3;
    this.removeEndListeners = noop$3;
    this.removeAccessibleListeners = noop$3;
    this.startPointerPress = (startEvent, startInfo) => {
      this.removeEndListeners();
      if (this.isPressing)
        return;
      const props = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel } = this.node.getProps();
        frame.update(() => {
          !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      };
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries2) => {
  entries2.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options2 }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options2);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options2 });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options2, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options2);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport: viewport2 = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once: once3 } = viewport2;
    const options2 = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once3 && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options2, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
  return (name2) => viewport2[name2] !== prevViewport[name2];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev2[i] !== next2[i])
      return false;
  }
  return true;
}
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key2) => current[key2] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key2) => velocity[key2] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
let warning = noop$3;
let invariant = noop$3;
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
const instantAnimationState = {
  current: false
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a, b2, c2, d2]) => `cubic-bezier(${a}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes3, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes3 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
function getFinalKeyframe(keyframes3, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes3.length - 1;
  return keyframes3[index2];
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$3;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const easeIn$1 = cubicBezier(0.42, 0, 1, 1);
const easeOut$1 = cubicBezier(0, 0, 0.58, 1);
const easeInOut$1 = cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$3,
  easeIn: easeIn$1,
  easeInOut: easeInOut$1,
  easeOut: easeOut$1,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
const isColorString = (type2, testProp) => (v2) => {
  return Boolean(isString$1(v2) && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString$1(v2))
    return v2;
  const [a, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba$1 = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha$2.transform(alpha$12)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba$1.transform
};
const hsla$1 = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha$2.transform(alpha$12)) + ")";
  }
};
const color = {
  test: (v2) => rgba$1.test(v2) || hex.test(v2) || hsla$1.test(v2),
  parse: (v2) => {
    if (rgba$1.test(v2)) {
      return rgba$1.parse(v2);
    } else if (hsla$1.test(v2)) {
      return hsla$1.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$1(v2) ? v2 : v2.hasOwnProperty("red") ? rgba$1.transform(v2) : hsla$1.transform(v2);
  }
};
const mix$2 = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba$1, hsla$1];
const getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
function asRGBA(color2) {
  const type2 = getColorType(color2);
  let model = type2.parse(color2);
  if (type2 === hsla$1) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mix$2(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba$1.transform(blended);
  };
};
function test(v2) {
  var _a4, _b3;
  return isNaN(v2) && isString$1(v2) && (((_a4 = v2.match(floatRegex)) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) + (((_b3 = v2.match(colorRegex)) === null || _b3 === void 0 ? void 0 : _b3.length) || 0) > 0;
}
const cssVarTokeniser = {
  regex: cssVariableRegex$1,
  countKey: "Vars",
  token: "${v}",
  parse: noop$3
};
const colorTokeniser = {
  regex: colorRegex,
  countKey: "Colors",
  token: "${c}",
  parse: color.parse
};
const numberTokeniser = {
  regex: floatRegex,
  countKey: "Numbers",
  token: "${n}",
  parse: number.parse
};
function tokenise(info, { regex, countKey, token: token2, parse: parse2 }) {
  const matches2 = info.tokenised.match(regex);
  if (!matches2)
    return;
  info["num" + countKey] = matches2.length;
  info.tokenised = info.tokenised.replace(regex, token2);
  info.values.push(...matches2.map(parse2));
}
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const info = {
    value: originalValue,
    tokenised: originalValue,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  if (info.value.includes("var(--"))
    tokenise(info, cssVarTokeniser);
  tokenise(info, colorTokeniser);
  tokenise(info, numberTokeniser);
  return info;
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { values: values2, numColors, numVars, tokenised } = analyseComplexValue(source);
  const numValues = values2.length;
  return (v2) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      if (i < numVars) {
        output = output.replace(cssVarTokeniser.token, v2[i]);
      } else if (i < numVars + numColors) {
        output = output.replace(colorTokeniser.token, color.transform(v2[i]));
      } else {
        output = output.replace(numberTokeniser.token, sanitize(v2[i]));
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const mixImmediate = (origin, target) => (p2) => `${p2 > 0 ? target : origin}`;
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v2) => mix$2(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
  }
}
const mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v2) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v2);
    }
    return output;
  };
};
const mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key2 in output) {
    if (origin[key2] !== void 0 && target[key2] !== void 0) {
      blendValue[key2] = getMixer(origin[key2], target[key2]);
    }
  }
  return (v2) => {
    for (const key2 in blendValue) {
      output[key2] = blendValue[key2](v2);
    }
    return output;
  };
};
const mixComplex = (origin, target) => {
  const template2 = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template2);
  } else {
    return mixImmediate(origin, target);
  }
};
const progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
const mixNumber = (from2, to) => (p2) => mix$2(from2, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    return color.test(v2) ? mixColor : mixComplex;
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop$3 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v2 < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v2);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset2.push(mix$2(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut$1).splice(0, values2.length - 1);
}
function keyframes2({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state2 = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state2.value = mapTimeToKeyframe(t2);
      state2.done = t2 >= duration;
      return state2;
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration$1 = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration$1));
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b2;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options2, keys2) {
  return keys2.some((key2) => options2[key2] !== void 0);
}
function getSpringOptions(options2) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options2
  };
  if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
    const derived = findSpring(options2);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes3, restDelta, restSpeed, ...options2 }) {
  const origin = keyframes3[0];
  const target = keyframes3[keyframes3.length - 1];
  const state2 = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options2);
  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state2.done = t2 >= duration;
      }
      state2.value = state2.done ? target : current;
      return state2;
    }
  };
}
function inertia({ keyframes: keyframes3, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes3[0];
  const state2 = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state2.done = Math.abs(delta) <= restDelta;
    state2.value = state2.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state2.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state2.value, nearestBoundary(state2.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state2.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 > timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state2;
      }
    }
  };
}
const frameloopDriver = (update2) => {
  const passTimestamp = ({ timestamp: timestamp2 }) => update2(timestamp2);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame$1(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state2 = generator.next(duration);
  while (!state2.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state2 = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
const types$2 = {
  decay: inertia,
  inertia,
  tween: keyframes2,
  keyframes: keyframes2,
  spring
};
function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$12, type: type2 = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options2 }) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve28) => {
      resolveFinishedPromise = resolve28;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types$2[type2] || keyframes2;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes2 && typeof keyframes$12[0] !== "number") {
    mapNumbersToKeyframes = interpolate([0, 100], keyframes$12, {
      clamp: false
    });
    keyframes$12 = [0, 100];
  }
  const generator = generatorFactory({ ...options2, keyframes: keyframes$12 });
  let mirroredGenerator;
  if (repeatType === "mirror") {
    mirroredGenerator = generatorFactory({
      ...options2,
      keyframes: [...keyframes$12].reverse(),
      velocity: -(options2.velocity || 0)
    });
  }
  let playState = "idle";
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator);
  }
  const { calculatedDuration } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp2) => {
    if (startTime === null)
      return;
    if (speed > 0)
      startTime = Math.min(startTime, timestamp2);
    if (speed < 0)
      startTime = Math.min(timestamp2 - totalDuration / speed, startTime);
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = Math.round(timestamp2 - startTime) * speed;
    }
    const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0);
    if (playState === "finished" && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = currentTime / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const iterationIsOdd = Boolean(currentIteration % 2);
      if (iterationIsOdd) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      let p2 = clamp(0, 1, iterationProgress);
      if (currentTime > totalDuration) {
        p2 = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
      }
      elapsed = p2 * resolvedDuration;
    }
    const state2 = isInDelayPhase ? { done: false, value: keyframes$12[0] } : frameGenerator.next(elapsed);
    if (mapNumbersToKeyframes) {
      state2.value = mapNumbersToKeyframes(state2.value);
    }
    let { done } = state2;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
    }
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
    if (onUpdate) {
      onUpdate(state2.value);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state2;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = "idle";
    stopAnimationDriver();
    resolveFinishedPromise();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = "finished";
    onComplete && onComplete();
    stopAnimationDriver();
    resolveFinishedPromise();
  };
  const play = () => {
    if (hasStopped)
      return;
    if (!animationDriver)
      animationDriver = driver(tick);
    const now2 = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now2 - holdTime;
    } else if (!startTime || playState === "finished") {
      startTime = now2;
    }
    if (playState === "finished") {
      updateFinishedPromise();
    }
    cancelTime = startTime;
    holdTime = null;
    playState = "running";
    animationDriver.start();
  };
  if (autoplay) {
    play();
  }
  const controls = {
    then(resolve28, reject) {
      return currentFinishedPromise.then(resolve28, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      if (newSpeed === speed || !animationDriver)
        return;
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime);
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused";
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === "idle")
        return;
      playState = "idle";
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null)
        tick(cancelTime);
      cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => {
      startTime = 0;
      return tick(elapsed);
    }
  };
  return controls;
}
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]);
const sampleDelta = 10;
const maxDuration = 2e4;
const requiresPregeneratedKeyframes = (valueName, options2) => options2.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options2.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options2 }) {
  const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options2.repeatDelay && options2.repeatType !== "mirror" && options2.damping !== 0 && options2.type !== "inertia";
  if (!canAccelerateAnimation)
    return false;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve28) => {
      resolveFinishedPromise = resolve28;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes3, duration = 300, ease: ease2, times } = options2;
  if (requiresPregeneratedKeyframes(valueName, options2)) {
    const sampleAnimation = animateValue({
      ...options2,
      repeat: 0,
      delay: 0
    });
    let state2 = { done: false, value: keyframes3[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state2.done && t2 < maxDuration) {
      state2 = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state2.value);
      t2 += sampleDelta;
    }
    times = void 0;
    keyframes3 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease2 = "linear";
  }
  const animation2 = animateStyle(value.owner.current, valueName, keyframes3, {
    ...options2,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times
  });
  if (options2.syncStart) {
    animation2.startTime = frameData.isProcessing ? frameData.timestamp : document.timeline ? document.timeline.currentTime : performance.now();
  }
  const cancelAnimation = () => animation2.cancel();
  const safeCancel = () => {
    frame.update(cancelAnimation);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation2.onfinish = () => {
    value.set(getFinalKeyframe(keyframes3, options2));
    onComplete && onComplete();
    safeCancel();
  };
  const controls = {
    then(resolve28, reject) {
      return currentFinishedPromise.then(resolve28, reject);
    },
    attachTimeline(timeline) {
      animation2.timeline = timeline;
      animation2.onfinish = null;
      return noop$3;
    },
    get time() {
      return millisecondsToSeconds(animation2.currentTime || 0);
    },
    set time(newTime) {
      animation2.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation2.playbackRate;
    },
    set speed(newSpeed) {
      animation2.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      if (hasStopped)
        return;
      animation2.play();
      cancelFrame$1(cancelAnimation);
    },
    pause: () => animation2.pause(),
    stop: () => {
      hasStopped = true;
      if (animation2.playState === "idle")
        return;
      const { currentTime } = animation2;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options2,
          autoplay: false
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation2.finish(),
    cancel: safeCancel
  };
  return controls;
}
function createInstantAnimation({ keyframes: keyframes3, delay: delay2, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes3[keyframes3.length - 1]);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop$3,
      pause: noop$3,
      stop: noop$3,
      then: (resolve28) => {
        resolve28();
        return Promise.resolve();
      },
      cancel: noop$3,
      complete: noop$3
    };
  };
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes3 }) => {
  if (keyframes3.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes3[1]) : underDampedSpring;
  }
  return ease;
};
const isAnimatable = (key2, value) => {
  if (key2 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name2, value] = v2.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter$1 = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter$1,
  WebkitFilter: filter$1
};
const getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter$1)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  }
}
function getKeyframes(value, valueName, target, transition2) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let keyframes3;
  if (Array.isArray(target)) {
    keyframes3 = [...target];
  } else {
    keyframes3 = [null, target];
  }
  const defaultOrigin = transition2.from !== void 0 ? transition2.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i = 0; i < keyframes3.length; i++) {
    if (keyframes3[i] === null) {
      keyframes3[i] = i === 0 ? defaultOrigin : keyframes3[i - 1];
    }
    if (isNone(keyframes3[i])) {
      noneKeyframeIndexes.push(i);
    }
    if (typeof keyframes3[i] === "string" && keyframes3[i] !== "none" && keyframes3[i] !== "0") {
      animatableTemplateValue = keyframes3[i];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i = 0; i < noneKeyframeIndexes.length; i++) {
      const index2 = noneKeyframeIndexes[i];
      keyframes3[index2] = getAnimatableNone(valueName, animatableTemplateValue);
    }
  }
  return keyframes3;
}
function isTransitionDefined({ when: when2, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition2 }) {
  return !!Object.keys(transition2).length;
}
function getValueTransition(transition2, key2) {
  return transition2[key2] || transition2["default"] || transition2;
}
const animateMotionValue = (valueName, value, target, transition2 = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition2, valueName) || {};
    const delay2 = valueTransition.delay || transition2.delay || 0;
    let { elapsed = 0 } = transition2;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes3 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes3[0];
    const targetKeyframe = keyframes3[keyframes3.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options2 = {
      keyframes: keyframes3,
      velocity: value.getVelocity(),
      ease: "easeOut",
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isTransitionDefined(valueTransition)) {
      options2 = {
        ...options2,
        ...getDefaultTransition(valueName, options2)
      };
    }
    if (options2.duration) {
      options2.duration = secondsToMilliseconds(options2.duration);
    }
    if (options2.repeatDelay) {
      options2.repeatDelay = secondsToMilliseconds(options2.repeatDelay);
    }
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options2);
    }
    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options2);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animateValue(options2);
  };
};
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b2, c2);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const isFloat$2 = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options2 = {}) {
    this.version = "10.16.4";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp: timestamp2 } = frameData;
      if (this.lastUpdated !== timestamp2) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp2;
        frame.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp: timestamp2 }) => {
      if (timestamp2 !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat$2(this.current);
    this.owner = options2.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = prev2;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve28) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve28);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options2) {
  return new MotionValue(init, options2);
}
const testValueType = (v2) => (type2) => type2.test(v2);
const auto$1 = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto$1];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition: transition2 = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a4, _b3;
  const newValueKeys = Object.keys(target).filter((key2) => !visualElement.hasValue(key2));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i = 0; i < numNewValues; i++) {
    const key2 = newValueKeys[i];
    const targetValue = target[key2];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b3 = (_a4 = origin[key2]) !== null && _a4 !== void 0 ? _a4 : visualElement.readValue(key2)) !== null && _b3 !== void 0 ? _b3 : target[key2];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key2, targetValue);
    }
    visualElement.addValue(key2, motionValue(value, { owner: visualElement }));
    if (origin[key2] === void 0) {
      origin[key2] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key2, value);
  }
}
function getOriginFromTransition(key2, transition2) {
  if (!transition2)
    return;
  const valueTransition = transition2[key2] || transition2["default"] || transition2;
  return valueTransition.from;
}
function getOrigin(target, transition2, visualElement) {
  const origin = {};
  for (const key2 in target) {
    const transitionOrigin = getOriginFromTransition(key2, transition2);
    if (transitionOrigin !== void 0) {
      origin[key2] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key2);
      if (value) {
        origin[key2] = value.get();
      }
    }
  }
  return origin;
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type: type2 } = {}) {
  let { transition: transition2 = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition2 = transitionOverride;
  const animations2 = [];
  const animationTypeState = type2 && visualElement.animationState && visualElement.animationState.getState()[type2];
  for (const key2 in target) {
    const value = visualElement.getValue(key2);
    const valueTarget = target[key2];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      elapsed: 0,
      ...transition2
    };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key2, value, frame);
        valueTransition.syncStart = true;
      }
    }
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: false } : valueTransition));
    const animation2 = value.animation;
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key2);
      animation2.then(() => willChange.remove(key2));
    }
    animations2.push(animation2);
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options2 = {}) {
  const resolved = resolveVariant(visualElement, variant, options2.custom);
  let { transition: transition2 = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options2.transitionOverride) {
    transition2 = options2.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options2)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition2;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options2);
  } : () => Promise.resolve();
  const { when: when2 } = transition2;
  if (when2) {
    const [first, last2] = when2 === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last2());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options2.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options2) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options2,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b2) {
  return a.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options2 = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation2;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options2));
    animation2 = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation2 = animateVariant(visualElement, definition, options2);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options2.custom) : definition;
    animation2 = Promise.all(animateTarget(visualElement, resolvedDefinition, options2));
  }
  return animation2.then(() => visualElement.notify("AnimationComplete", definition));
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation: animation2, options: options2 }) => animateVisualElement(visualElement, animation2, options2)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state2 = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition: transition2, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options2, changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type2 = reversePriorityOrder[i];
      const typeState = state2[type2];
      const prop = props[type2] !== void 0 ? props[type2] : context[type2];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type2 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type2] && prop !== props[type2] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type2 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (const key2 in allKeys) {
        const next2 = resolvedValues[key2];
        const prev2 = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        if (next2 !== prev2) {
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            if (!shallowCompare(next2, prev2) || variantDidChange) {
              markToAnimate(key2);
            } else {
              typeState.protectedKeys[key2] = true;
            }
          } else if (next2 !== void 0) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next2 !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation2) => ({
          animation: animation2,
          options: { type: type2, ...options2 }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key2] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type2, isActive, options2) {
    var _a4;
    if (state2[type2].isActive === isActive)
      return Promise.resolve();
    (_a4 = visualElement.variantChildren) === null || _a4 === void 0 ? void 0 : _a4.forEach((child) => {
      var _a5;
      return (_a5 = child.animationState) === null || _a5 === void 0 ? void 0 : _a5.setActive(type2, isActive);
    });
    state2[type2].isActive = isActive;
    const animations2 = animateChanges(options2, type2);
    for (const key2 in state2) {
      state2[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state2
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate)) {
      this.unmount = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: isPresent2, onExitComplete, custom } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent2 === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent2, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
    if (onExitComplete && !isPresent2) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register: register2 } = this.node.presenceContext || {};
    if (register2) {
      this.unmount = register2(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const distance = (a, b2) => Math.abs(a - b2);
function distance2D(a, b2) {
  const xDelta = distance(a.x, b2.x);
  const yDelta = distance(a.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers2, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp3 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp3 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers2;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp: timestamp2 } = frameData;
    this.history = [{ ...point, timestamp: timestamp2 }];
    const { onSessionStart } = handlers2;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers2) {
    this.handlers = handlers2;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame$1(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b2) {
  return { x: a.x - b2.x, y: a.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix$2(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix$2(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mix$2(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mix$2(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label2) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label2] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
  return {
    x: { min: left2, max: right2 },
    y: { min: top2, max: bottom2 }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box2, { x: x2, y: y2 }) {
  applyAxisDelta(box2.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box2.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box2, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node2 = treePath[i];
    delta = node2.projectionDelta;
    const instance = node2.instance;
    if (instance && instance.style && instance.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box2, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box2, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box2, node2.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms2, [key2, scaleKey, originKey]) {
  const axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  const originPoint = mix$2(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key2], transforms2[scaleKey], originPoint, transforms2.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box2, transform2) {
  transformAxis(box2.x, transform2, xKeys$1);
  transformAxis(box2.y, transform2, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.update(() => onDragStart(event, info), false, true);
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout: layout2 } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition2 = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition2 = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition2
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition2) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition2));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase();
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix$2(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate: transformTemplate2 } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix$2(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction2, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction2) && (currentDirection === null || currentDirection === direction2);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction2 = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction2 = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction2 = "x";
  }
  return direction2;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop$3;
    this.removeListeners = noop$3;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$3;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.update(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$3;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
function usePresence() {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent: isPresent2, onExitComplete, register: register2 } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register2(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent(reactExports.useContext(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template2 = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix$2(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template2(shadow);
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      queueMicrotask(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent2, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix$2(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix$2(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix$2(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix$2(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix$2(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$3);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box2, originBox) {
  copyAxisInto(box2.x, originBox.x);
  copyAxisInto(box2.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix$2(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix$2(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms2[key2], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box2, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box2.x, transforms2, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box2.y, transforms2, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a, b2) {
  return a.x.min === b2.x.min && a.x.max === b2.x.max && a.y.min === b2.y.min && a.y.max === b2.y.max;
}
function boxEqualsRounded(a, b2) {
  return Math.round(a.x.min) === Math.round(b2.x.min) && Math.round(a.x.max) === Math.round(b2.x.max) && Math.round(a.y.min) === Math.round(b2.y.min) && Math.round(a.y.max) === Math.round(b2.y.max);
}
function aspectRatio(box2) {
  return calcLength(box2.x) / calcLength(box2.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options: options2, resumingFrom } = node2;
      options2.onExitComplete && options2.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform2 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
const compareByDepth = (a, b2) => a.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start2 = performance.now();
  const checkElapsed = ({ timestamp: timestamp2 }) => {
    const elapsed = timestamp2 - start2;
    if (elapsed >= timeout) {
      cancelFrame$1(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame$1(checkElapsed);
}
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes3, options2) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes3, options2));
  return motionValue$1.animation;
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame$1(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate2 = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = performance.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        queueMicrotask(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      frame.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate2 = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box2 = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box2.x, scroll2.offset.x);
        translateAxis(box2.y, scroll2.offset.y);
      }
      return box2;
    }
    removeElementScroll(box2) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box2);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        const { scroll: scroll2, options: options2 } = node2;
        if (node2 !== this.root && scroll2 && options2.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box2);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box2, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box2);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box2) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box2);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options2) {
      this.options = {
        ...this.options,
        ...options2,
        crossfade: options2.crossfade !== void 0 ? options2.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a4;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a4;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options2) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame$1(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options2,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options2.onUpdate && options2.onUpdate(latest);
          },
          onComplete: () => {
            options2.onComplete && options2.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config2 = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? ((_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.lead) || this : this;
    }
    getPrevLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? (_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition: transition2, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition2)
        this.setOptions({ transition: transition2 });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key2 = "rotate" + transformAxes[i];
        if (latestValues[key2]) {
          resetValues[key2] = latestValues[key2];
          visualElement.setStaticValue(key2, 0);
        }
      }
      visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a4, _b3;
      const styles2 = {};
      if (!this.instance || this.isSVG)
        return styles2;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles2.visibility = "";
      }
      const transformTemplate2 = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate2 ? transformTemplate2(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate2) {
        styles2.transform = transformTemplate2(valuesToRender, styles2.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles2.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_b3 = (_a4 = valuesToRender.opacity) !== null && _a4 !== void 0 ? _a4 : this.latestValues.opacity) !== null && _b3 !== void 0 ? _b3 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key2];
        const corrected = styles2.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles2[applyTo[i]] = corrected;
          }
        } else {
          styles2[key2] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a4;
        return (_a4 = node2.currentAnimation) === null || _a4 === void 0 ? void 0 : _a4.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a4;
  const snapshot = ((_a4 = node2.resumeFrom) === null || _a4 === void 0 ? void 0 : _a4.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  projectionFrameData.totalNodes++;
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetRotation(node2) {
  node2.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mix$2(delta.translate, 0, p2);
  output.scale = mix$2(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p2) {
  output.min = mix$2(from2.min, to.min, p2);
  output.max = mix$2(from2.max, to.max, p2);
}
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().includes(string2);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$3;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box2) {
  roundAxis(box2.x);
  roundAxis(box2.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token2, fallback] = match2;
  return [token2, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  } else if (isCSSVariableToken(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key2 in target) {
    const current = target[key2];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key2] = resolved;
    if (!transitionEnd)
      transitionEnd = {};
    if (transitionEnd[key2] === void 0) {
      transitionEnd[key2] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
const isPositionalKey = (key2) => positionalKeys.has(key2);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top2 }) => parseFloat(top2),
  left: (_bbox, { left: left2 }) => parseFloat(left2),
  bottom: ({ y: y2 }, { top: top2 }) => parseFloat(top2) + (y2.max - y2.min),
  right: ({ x: x2 }, { left: left2 }) => parseFloat(left2) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key2) => {
    origin[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value && value.jump(origin[key2]);
    target[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from2 = origin[key2];
    let fromType = findDimensionValueType(from2);
    const to = target[key2];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (to[i] === null)
          break;
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        } else {
          invariant(findDimensionValueType(to[i]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key2] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key2] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key2] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key2);
        transitionEnd[key2] = transitionEnd[key2] !== void 0 ? transitionEnd[key2] : target[key2];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key2, value]) => {
        visualElement.getValue(key2).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next2, prev2) {
  const { willChange } = next2;
  for (const key2 in next2) {
    const nextValue = next2[key2];
    const prevValue = prev2[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key2);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key2);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev2) {
    if (next2[key2] === void 0)
      element.removeValue(key2);
  }
  return next2;
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
const numVariantProps = variantProps.length;
class VisualElement {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options2 = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options2;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key2);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame$1(this.notifyUpdate);
    cancelFrame$1(this.render);
    this.valueSubscriptions.forEach((remove3) => remove3());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    for (const key2 in this.features) {
      this.features[key2].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    const valueIsTransform = transformProps.has(key2);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    for (let i = 0; i < numFeatures; i++) {
      const name2 = featureNames[i];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name2];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled(renderedProps)) {
        if (!this.features[name2] && FeatureConstructor) {
          this.features[name2] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key2 in this.features) {
      const feature = this.features[key2];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key2 = propEventHandlers[i];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listener = props["on" + key2];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    return this.props.variants ? this.props.variants[name2] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i];
      const prop = this.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context[name2] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    if (value !== this.values.get(key2)) {
      this.removeValue(key2);
      this.bindToMotionValue(key2, value);
    }
    this.values.set(key2, value);
    this.latestValues[key2] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key2);
    }
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2) {
    var _a4;
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : (_a4 = this.getBaseTargetFromProps(this.props, key2)) !== null && _a4 !== void 0 ? _a4 : this.readValueFromInstance(this.current, key2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a4;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a4 = resolveVariantFromProps(this.props, initial)) === null || _a4 === void 0 ? void 0 : _a4[key2] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a, b2) {
    return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars: vars2, style }) {
    delete vars2[key2];
    delete style[key2];
  }
  makeTargetAnimatableFromInstance({ transition: transition2, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition2 || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition: transition2,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$3(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$3(instance);
      const value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options2, props) {
    buildHTMLStyles(renderState, latestValues, options2, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options2, props) {
    buildSVGAttrs(renderState, latestValues, options2, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options2) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options2, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options2, { enableHardwareAcceleration: true });
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config2) => createDomMotionConfig(Component, config2, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent: isPresent2 }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  reactExports.useInsertionEffect(() => {
    const { width, height, top: top2, left: left2 } = size2.current;
    if (isPresent2 || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top2}px !important;
            left: ${left2}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent2]);
  return reactExports.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size2 }, reactExports.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode: mode2 }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_2, key2) => presenceChildren.set(key2, false));
  }, [isPresent2]);
  reactExports.useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2]);
  if (mode2 === "popLayout") {
    children = reactExports.createElement(PopChild, { isPresent: isPresent2 }, children);
  }
  return reactExports.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function useUnmountEffect(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode: mode2 = "sync" }) => {
  const forceRender = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map((child) => reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode: mode2 }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key2 = presentKeys[i];
    if (targetKeys.indexOf(key2) === -1 && !exitingChildren.has(key2)) {
      exitingChildren.set(key2, void 0);
    }
  }
  if (mode2 === "wait" && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    const child = allChildren.get(key2);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key2);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        allChildren.delete(key2);
        exitingChildren.delete(key2);
        const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key2);
        presentChildren.current.splice(removeIndex, 1);
        if (!exitingChildren.size) {
          presentChildren.current = filteredChildren;
          if (isMounted.current === false)
            return;
          forceRender();
          onExitComplete && onExitComplete();
        }
      };
      exitingComponent = reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode: mode2 }, child);
      exitingChildren.set(key2, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  });
  childrenToRender = childrenToRender.map((child) => {
    const key2 = child.key;
    return exitingChildren.has(key2) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode: mode2 }, child);
  });
  return reactExports.createElement(reactExports.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)));
};
var toastMotionVariants = {
  initial: (props) => {
    const { position: position2 } = props;
    const dir = ["top", "bottom"].includes(position2) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position2) ? 1 : -1;
    if (position2 === "bottom")
      factor = 1;
    return {
      opacity: 0,
      [dir]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = reactExports.memo((props) => {
  const {
    id: id2,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position: position2 = "bottom",
    duration = 5e3,
    containerStyle: containerStyle2,
    motionVariants: motionVariants2 = toastMotionVariants,
    toastSpacing = "0.5rem"
  } = props;
  const [delay2, setDelay] = reactExports.useState(duration);
  const isPresent2 = useIsPresent();
  useUpdateEffect(() => {
    if (!isPresent2) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent2]);
  useUpdateEffect(() => {
    setDelay(duration);
  }, [duration]);
  const onMouseEnter = () => setDelay(null);
  const onMouseLeave = () => setDelay(duration);
  const close = () => {
    if (isPresent2)
      onRequestRemove();
  };
  reactExports.useEffect(() => {
    if (isPresent2 && requestClose) {
      onRequestRemove();
    }
  }, [isPresent2, requestClose, onRequestRemove]);
  useTimeout(close, delay2);
  const containerStyles = reactExports.useMemo(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing,
      ...containerStyle2
    }),
    [containerStyle2, toastSpacing]
  );
  const toastStyle = reactExports.useMemo(() => getToastStyle(position2), [position2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      layout: true,
      className: "chakra-toast",
      variants: motionVariants2,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: onMouseEnter,
      onHoverEnd: onMouseLeave,
      custom: { position: position2 },
      style: toastStyle,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        chakra.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: containerStyles,
          children: runIfFn$2(message, { id: id2, onClose: close })
        }
      )
    }
  );
});
ToastComponent.displayName = "ToastComponent";
function getToastPlacement(position2, dir) {
  var _a4;
  const computedPosition = position2 != null ? position2 : "bottom";
  const logicals2 = {
    "top-start": { ltr: "top-left", rtl: "top-right" },
    "top-end": { ltr: "top-right", rtl: "top-left" },
    "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
    "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
  };
  const logical2 = logicals2[computedPosition];
  return (_a4 = logical2 == null ? void 0 : logical2[dir]) != null ? _a4 : computedPosition;
}
var fallbackIcon = {
  path: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
};
var Icon = forwardRef((props, ref) => {
  const {
    as: element,
    viewBox,
    color: color2 = "currentColor",
    focusable = false,
    children,
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-icon", className);
  const customStyles = useStyleConfig("Icon", props);
  const styles2 = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: color2,
    ...__css,
    ...customStyles
  };
  const shared = {
    ref,
    focusable,
    className: _className,
    __css: styles2
  };
  const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
  if (element && typeof element !== "string") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { as: element, ...shared, ...rest });
  }
  const _path = children != null ? children : fallbackIcon.path;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
});
Icon.displayName = "Icon";
function createIcon(options2) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps: defaultProps2 = {}
  } = options2;
  const path2 = reactExports.Children.toArray(options2.path);
  const Comp = forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ref, viewBox, ...defaultProps2, ...props, children: path2.length ? path2 : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "currentColor", d: pathDefinition }) }));
  Comp.displayName = displayName;
  return Comp;
}
function CheckIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function InfoIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function WarningIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
var spin = keyframes$1({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Spinner", props);
  const {
    label: label2 = "Loading...",
    thickness = "2px",
    speed = "0.45s",
    emptyColor = "transparent",
    className,
    ...rest
  } = omitThemingProps(props);
  const _className = cx("chakra-spinner", className);
  const spinnerStyles = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: thickness,
    borderBottomColor: emptyColor,
    borderLeftColor: emptyColor,
    animation: `${spin} ${speed} linear infinite`,
    ...styles2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ref,
      __css: spinnerStyles,
      className: _className,
      ...rest,
      children: label2 && /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { srOnly: true, children: label2 })
    }
  );
});
Spinner.displayName = "Spinner";
var [AlertProvider, useAlertContext] = createContext$1({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
});
var [AlertStylesProvider, useAlertStyles] = createContext$1({
  name: `AlertStylesContext`,
  hookName: `useAlertStyles`,
  providerName: "<Alert />"
});
var STATUSES = {
  info: { icon: InfoIcon, colorScheme: "blue" },
  warning: { icon: WarningIcon, colorScheme: "orange" },
  success: { icon: CheckIcon, colorScheme: "green" },
  error: { icon: WarningIcon, colorScheme: "red" },
  loading: { icon: Spinner, colorScheme: "blue" }
};
function getStatusColorScheme(status) {
  return STATUSES[status].colorScheme;
}
function getStatusIcon(status) {
  return STATUSES[status].icon;
}
var AlertDescription = forwardRef(
  function AlertDescription2(props, ref) {
    const styles2 = useAlertStyles();
    const { status } = useAlertContext();
    const descriptionStyles = {
      display: "inline",
      ...styles2.description
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__desc", props.className),
        __css: descriptionStyles
      }
    );
  }
);
AlertDescription.displayName = "AlertDescription";
function AlertIcon(props) {
  const { status } = useAlertContext();
  const BaseIcon = getStatusIcon(status);
  const styles2 = useAlertStyles();
  const css4 = status === "loading" ? styles2.spinner : styles2.icon;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      display: "inherit",
      "data-status": status,
      ...props,
      className: cx("chakra-alert__icon", props.className),
      __css: css4,
      children: props.children || /* @__PURE__ */ jsxRuntimeExports.jsx(BaseIcon, { h: "100%", w: "100%" })
    }
  );
}
AlertIcon.displayName = "AlertIcon";
var AlertTitle = forwardRef(
  function AlertTitle2(props, ref) {
    const styles2 = useAlertStyles();
    const { status } = useAlertContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__title", props.className),
        __css: styles2.title
      }
    );
  }
);
AlertTitle.displayName = "AlertTitle";
var Alert = forwardRef(function Alert2(props, ref) {
  var _a4;
  const { status = "info", addRole = true, ...rest } = omitThemingProps(props);
  const colorScheme = (_a4 = props.colorScheme) != null ? _a4 : getStatusColorScheme(status);
  const styles2 = useMultiStyleConfig("Alert", { ...props, colorScheme });
  const alertStyles = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...styles2.container
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AlertProvider, { value: { status }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertStylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      "data-status": status,
      role: addRole ? "alert" : void 0,
      ref,
      ...rest,
      className: cx("chakra-alert", props.className),
      __css: alertStyles
    }
  ) }) });
});
Alert.displayName = "Alert";
function CloseIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { focusable: "false", "aria-hidden": true, ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
var CloseButton = forwardRef(
  function CloseButton2(props, ref) {
    const styles2 = useStyleConfig("CloseButton", props);
    const { children, isDisabled: isDisabled2, __css, ...rest } = omitThemingProps(props);
    const baseStyle2 = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.button,
      {
        type: "button",
        "aria-label": "Close",
        ref,
        disabled: isDisabled2,
        __css: {
          ...baseStyle2,
          ...styles2,
          ...__css
        },
        ...rest,
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { width: "1em", height: "1em" })
      }
    );
  }
);
CloseButton.displayName = "CloseButton";
var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
var toastStore = createStore(initialState);
function createStore(initialState2) {
  let state2 = initialState2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (setStateFn) => {
    state2 = setStateFn(state2);
    listeners.forEach((l2) => l2());
  };
  return {
    getState: () => state2,
    subscribe: (listener) => {
      listeners.add(listener);
      return () => {
        setState(() => initialState2);
        listeners.delete(listener);
      };
    },
    /**
     * Delete a toast record at its position
     */
    removeToast: (id2, position2) => {
      setState((prevState) => ({
        ...prevState,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [position2]: prevState[position2].filter((toast) => toast.id != id2)
      }));
    },
    notify: (message, options2) => {
      const toast = createToast(message, options2);
      const { position: position2, id: id2 } = toast;
      setState((prevToasts) => {
        var _a4, _b3;
        const isTop = position2.includes("top");
        const toasts = isTop ? [toast, ...(_a4 = prevToasts[position2]) != null ? _a4 : []] : [...(_b3 = prevToasts[position2]) != null ? _b3 : [], toast];
        return {
          ...prevToasts,
          [position2]: toasts
        };
      });
      return id2;
    },
    update: (id2, options2) => {
      if (!id2)
        return;
      setState((prevState) => {
        const nextState = { ...prevState };
        const { position: position2, index: index2 } = findToast(nextState, id2);
        if (position2 && index2 !== -1) {
          nextState[position2][index2] = {
            ...nextState[position2][index2],
            ...options2,
            message: createRenderToast(options2)
          };
        }
        return nextState;
      });
    },
    closeAll: ({ positions } = {}) => {
      setState((prev2) => {
        const allPositions = [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ];
        const positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce(
          (acc, position2) => {
            acc[position2] = prev2[position2].map((toast) => ({
              ...toast,
              requestClose: true
            }));
            return acc;
          },
          { ...prev2 }
        );
      });
    },
    close: (id2) => {
      setState((prevState) => {
        const position2 = getToastPosition(prevState, id2);
        if (!position2)
          return prevState;
        return {
          ...prevState,
          [position2]: prevState[position2].map((toast) => {
            if (toast.id == id2) {
              return {
                ...toast,
                requestClose: true
              };
            }
            return toast;
          })
        };
      });
    },
    isActive: (id2) => Boolean(findToast(toastStore.getState(), id2).position)
  };
}
var counter = 0;
function createToast(message, options2 = {}) {
  var _a4, _b3;
  counter += 1;
  const id2 = (_a4 = options2.id) != null ? _a4 : counter;
  const position2 = (_b3 = options2.position) != null ? _b3 : "bottom";
  return {
    id: id2,
    message,
    position: position2,
    duration: options2.duration,
    onCloseComplete: options2.onCloseComplete,
    onRequestRemove: () => toastStore.removeToast(String(id2), position2),
    status: options2.status,
    requestClose: false,
    containerStyle: options2.containerStyle
  };
}
var Toast = (props) => {
  const {
    status,
    variant = "solid",
    id: id2,
    title,
    isClosable,
    onClose,
    description: description2,
    colorScheme,
    icon
  } = props;
  const ids = id2 ? {
    root: `toast-${id2}`,
    title: `toast-${id2}-title`,
    description: `toast-${id2}-description`
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Alert,
    {
      addRole: false,
      status,
      variant,
      id: ids == null ? void 0 : ids.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, { children: icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(chakra.div, { flex: "1", maxWidth: "100%", children: [
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
          description2 && /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description2 })
        ] }),
        isClosable && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CloseButton,
          {
            size: "sm",
            onClick: onClose,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function createRenderToast(options2 = {}) {
  const { render, toastComponent: ToastComponent2 = Toast } = options2;
  const renderToast = (props) => {
    if (typeof render === "function") {
      return render({ ...props, ...options2 });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastComponent2, { ...props, ...options2 });
  };
  return renderToast;
}
function createToastFn(dir, defaultOptions2) {
  const normalizeToastOptions = (options2) => {
    var _a4;
    return {
      ...defaultOptions2,
      ...options2,
      position: getToastPlacement(
        (_a4 = options2 == null ? void 0 : options2.position) != null ? _a4 : defaultOptions2 == null ? void 0 : defaultOptions2.position,
        dir
      )
    };
  };
  const toast = (options2) => {
    const normalizedToastOptions = normalizeToastOptions(options2);
    const Message = createRenderToast(normalizedToastOptions);
    return toastStore.notify(Message, normalizedToastOptions);
  };
  toast.update = (id2, options2) => {
    toastStore.update(id2, normalizeToastOptions(options2));
  };
  toast.promise = (promise, options2) => {
    const id2 = toast({
      ...options2.loading,
      status: "loading",
      duration: null
    });
    promise.then(
      (data) => toast.update(id2, {
        status: "success",
        duration: 5e3,
        ...runIfFn$2(options2.success, data)
      })
    ).catch(
      (error) => toast.update(id2, {
        status: "error",
        duration: 5e3,
        ...runIfFn$2(options2.error, error)
      })
    );
  };
  toast.closeAll = toastStore.closeAll;
  toast.close = toastStore.close;
  toast.isActive = toastStore.isActive;
  return toast;
}
var [ToastOptionProvider, useToastOptionContext] = createContext$1({
  name: `ToastOptionsContext`,
  strict: false
});
var ToastProvider = (props) => {
  const state2 = reactExports.useSyncExternalStore(
    toastStore.subscribe,
    toastStore.getState,
    toastStore.getState
  );
  const {
    motionVariants: motionVariants2,
    component: Component = ToastComponent,
    portalProps
  } = props;
  const stateKeys = Object.keys(state2);
  const toastList = stateKeys.map((position2) => {
    const toasts = state2[position2];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": "Notifications",
        id: `chakra-toast-manager-${position2}`,
        style: getToastListStyle(position2),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { initial: false, children: toasts.map((toast) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Component,
          {
            motionVariants: motionVariants2,
            ...toast
          },
          toast.id
        )) })
      },
      position2
    );
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { ...portalProps, children: toastList });
};
function useToast(options2) {
  const { theme: theme2 } = useChakra();
  const defaultOptions2 = useToastOptionContext();
  return reactExports.useMemo(
    () => createToastFn(theme2.direction, {
      ...defaultOptions2,
      ...options2
    }),
    [options2, theme2.direction, defaultOptions2]
  );
}
var createChakraProvider = (providerTheme) => {
  return function ChakraProvider2({
    children,
    theme: theme2 = providerTheme,
    toastOptions,
    ...restProps
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChakraProvider$1, { theme: theme2, ...restProps, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { ...toastOptions })
    ] });
  };
};
var ChakraProvider = createChakraProvider(theme$1);
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key2, value) => key2 in obj ? __defProp$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField$1 = (obj, key2, value) => {
  __defNormalProp$1(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
function sortNodes(nodes) {
  return nodes.sort((a, b2) => {
    const compare = a.compareDocumentPosition(b2);
    if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
var isElement$4 = (el2) => typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
function getNextIndex(current, max2, loop) {
  let next2 = current + 1;
  if (loop && next2 >= max2)
    next2 = 0;
  return next2;
}
function getPrevIndex(current, max2, loop) {
  let next2 = current - 1;
  if (loop && next2 < 0)
    next2 = max2;
  return next2;
}
var useSafeLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var cast = (value) => value;
var DescendantsManager = class {
  constructor() {
    __publicField$1(this, "descendants", /* @__PURE__ */ new Map());
    __publicField$1(this, "register", (nodeOrOptions) => {
      if (nodeOrOptions == null)
        return;
      if (isElement$4(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }
      return (node2) => {
        this.registerNode(node2, nodeOrOptions);
      };
    });
    __publicField$1(this, "unregister", (node2) => {
      this.descendants.delete(node2);
      const sorted = sortNodes(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    });
    __publicField$1(this, "destroy", () => {
      this.descendants.clear();
    });
    __publicField$1(this, "assignIndex", (descendants) => {
      this.descendants.forEach((descendant) => {
        const index2 = descendants.indexOf(descendant.node);
        descendant.index = index2;
        descendant.node.dataset["index"] = descendant.index.toString();
      });
    });
    __publicField$1(this, "count", () => this.descendants.size);
    __publicField$1(this, "enabledCount", () => this.enabledValues().length);
    __publicField$1(this, "values", () => {
      const values2 = Array.from(this.descendants.values());
      return values2.sort((a, b2) => a.index - b2.index);
    });
    __publicField$1(this, "enabledValues", () => {
      return this.values().filter((descendant) => !descendant.disabled);
    });
    __publicField$1(this, "item", (index2) => {
      if (this.count() === 0)
        return void 0;
      return this.values()[index2];
    });
    __publicField$1(this, "enabledItem", (index2) => {
      if (this.enabledCount() === 0)
        return void 0;
      return this.enabledValues()[index2];
    });
    __publicField$1(this, "first", () => this.item(0));
    __publicField$1(this, "firstEnabled", () => this.enabledItem(0));
    __publicField$1(this, "last", () => this.item(this.descendants.size - 1));
    __publicField$1(this, "lastEnabled", () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    });
    __publicField$1(this, "indexOf", (node2) => {
      var _a4, _b3;
      if (!node2)
        return -1;
      return (_b3 = (_a4 = this.descendants.get(node2)) == null ? void 0 : _a4.index) != null ? _b3 : -1;
    });
    __publicField$1(this, "enabledIndexOf", (node2) => {
      if (node2 == null)
        return -1;
      return this.enabledValues().findIndex((i) => i.node.isSameNode(node2));
    });
    __publicField$1(this, "next", (index2, loop = true) => {
      const next2 = getNextIndex(index2, this.count(), loop);
      return this.item(next2);
    });
    __publicField$1(this, "nextEnabled", (index2, loop = true) => {
      const item = this.item(index2);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = getNextIndex(
        enabledIndex,
        this.enabledCount(),
        loop
      );
      return this.enabledItem(nextEnabledIndex);
    });
    __publicField$1(this, "prev", (index2, loop = true) => {
      const prev2 = getPrevIndex(index2, this.count() - 1, loop);
      return this.item(prev2);
    });
    __publicField$1(this, "prevEnabled", (index2, loop = true) => {
      const item = this.item(index2);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = getPrevIndex(
        enabledIndex,
        this.enabledCount() - 1,
        loop
      );
      return this.enabledItem(prevEnabledIndex);
    });
    __publicField$1(this, "registerNode", (node2, options2) => {
      if (!node2 || this.descendants.has(node2))
        return;
      const keys2 = Array.from(this.descendants.keys()).concat(node2);
      const sorted = sortNodes(keys2);
      if (options2 == null ? void 0 : options2.disabled) {
        options2.disabled = !!options2.disabled;
      }
      const descendant = { node: node2, index: -1, ...options2 };
      this.descendants.set(node2, descendant);
      this.assignIndex(sorted);
    });
  }
};
function assignRef$1(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref) => {
      assignRef$1(ref, node2);
    });
  };
}
function useMergeRefs$1(...refs) {
  return reactExports.useMemo(() => mergeRefs(...refs), refs);
}
function useDescendants() {
  const descendants = reactExports.useRef(new DescendantsManager());
  useSafeLayoutEffect$1(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
}
var [DescendantsContextProvider, useDescendantsContext] = createContext$1({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
function useDescendant(options2) {
  const descendants = useDescendantsContext();
  const [index2, setIndex] = reactExports.useState(-1);
  const ref = reactExports.useRef(null);
  useSafeLayoutEffect$1(() => {
    return () => {
      if (!ref.current)
        return;
      descendants.unregister(ref.current);
    };
  }, []);
  useSafeLayoutEffect$1(() => {
    if (!ref.current)
      return;
    const dataIndex = Number(ref.current.dataset["index"]);
    if (index2 != dataIndex && !Number.isNaN(dataIndex)) {
      setIndex(dataIndex);
    }
  });
  const refCallback = options2 ? cast(descendants.register(options2)) : cast(descendants.register);
  return {
    descendants,
    index: index2,
    enabledIndex: descendants.enabledIndexOf(ref.current),
    register: mergeRefs(refCallback, ref)
  };
}
function createDescendantContext() {
  const ContextProvider = cast(DescendantsContextProvider);
  const _useDescendantsContext = () => cast(useDescendantsContext());
  const _useDescendant = (options2) => useDescendant(options2);
  const _useDescendants = () => useDescendants();
  return [
    // context provider
    ContextProvider,
    // call this when you need to read from context
    _useDescendantsContext,
    // descendants state information, to be called and passed to `ContextProvider`
    _useDescendants,
    // descendant index information
    _useDescendant
  ];
}
var TRANSITION_EASINGS = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
};
var TRANSITION_VARIANTS = {
  scale: {
    enter: { scale: 1 },
    exit: { scale: 0.95 }
  },
  fade: {
    enter: { opacity: 1 },
    exit: { opacity: 0 }
  },
  pushLeft: {
    enter: { x: "100%" },
    exit: { x: "-30%" }
  },
  pushRight: {
    enter: { x: "-100%" },
    exit: { x: "30%" }
  },
  pushUp: {
    enter: { y: "100%" },
    exit: { y: "-30%" }
  },
  pushDown: {
    enter: { y: "-100%" },
    exit: { y: "30%" }
  },
  slideLeft: {
    position: { left: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "-100%", y: 0 }
  },
  slideRight: {
    position: { right: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "100%", y: 0 }
  },
  slideUp: {
    position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "-100%" }
  },
  slideDown: {
    position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "100%" }
  }
};
function getSlideTransition(options2) {
  var _a4;
  const side = (_a4 = options2 == null ? void 0 : options2.direction) != null ? _a4 : "right";
  switch (side) {
    case "right":
      return TRANSITION_VARIANTS.slideRight;
    case "left":
      return TRANSITION_VARIANTS.slideLeft;
    case "bottom":
      return TRANSITION_VARIANTS.slideDown;
    case "top":
      return TRANSITION_VARIANTS.slideUp;
    default:
      return TRANSITION_VARIANTS.slideRight;
  }
}
var TRANSITION_DEFAULTS = {
  enter: {
    duration: 0.2,
    ease: TRANSITION_EASINGS.easeOut
  },
  exit: {
    duration: 0.1,
    ease: TRANSITION_EASINGS.easeIn
  }
};
var withDelay = {
  enter: (transition2, delay2) => ({
    ...transition2,
    delay: typeof delay2 === "number" ? delay2 : delay2 == null ? void 0 : delay2["enter"]
  }),
  exit: (transition2, delay2) => ({
    ...transition2,
    delay: typeof delay2 === "number" ? delay2 : delay2 == null ? void 0 : delay2["exit"]
  })
};
var variants$3 = {
  enter: ({ transition: transition2, transitionEnd, delay: delay2 } = {}) => {
    var _a4;
    return {
      opacity: 1,
      transition: (_a4 = transition2 == null ? void 0 : transition2.enter) != null ? _a4 : withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  },
  exit: ({ transition: transition2, transitionEnd, delay: delay2 } = {}) => {
    var _a4;
    return {
      opacity: 0,
      transition: (_a4 = transition2 == null ? void 0 : transition2.exit) != null ? _a4 : withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  }
};
var fadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants$3
};
var Fade$1 = reactExports.forwardRef(function Fade2(props, ref) {
  const {
    unmountOnExit,
    in: isOpen,
    className,
    transition: transition2,
    transitionEnd,
    delay: delay2,
    ...rest
  } = props;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const custom = { transition: transition2, transitionEnd, delay: delay2 };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { custom, children: show && /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      ref,
      className: cx("chakra-fade", className),
      custom,
      ...fadeConfig,
      animate,
      ...rest
    }
  ) });
});
Fade$1.displayName = "Fade";
var variants$2 = {
  exit: ({ reverse: reverse2, initialScale, transition: transition2, transitionEnd, delay: delay2 }) => {
    var _a4;
    return {
      opacity: 0,
      ...reverse2 ? { scale: initialScale, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { scale: initialScale, ...transitionEnd == null ? void 0 : transitionEnd.exit } },
      transition: (_a4 = transition2 == null ? void 0 : transition2.exit) != null ? _a4 : withDelay.exit(TRANSITION_DEFAULTS.exit, delay2)
    };
  },
  enter: ({ transitionEnd, transition: transition2, delay: delay2 }) => {
    var _a4;
    return {
      opacity: 1,
      scale: 1,
      transition: (_a4 = transition2 == null ? void 0 : transition2.enter) != null ? _a4 : withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  }
};
var scaleFadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants$2
};
var ScaleFade = reactExports.forwardRef(
  function ScaleFade2(props, ref) {
    const {
      unmountOnExit,
      in: isOpen,
      reverse: reverse2 = true,
      initialScale = 0.95,
      className,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      ...rest
    } = props;
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const animate = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = { initialScale, reverse: reverse2, transition: transition2, transitionEnd, delay: delay2 };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { custom, children: show && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        ref,
        className: cx("chakra-offset-slide", className),
        ...scaleFadeConfig,
        animate,
        custom,
        ...rest
      }
    ) });
  }
);
ScaleFade.displayName = "ScaleFade";
var variants$1 = {
  initial: ({ offsetX, offsetY, transition: transition2, transitionEnd, delay: delay2 }) => {
    var _a4;
    return {
      opacity: 0,
      x: offsetX,
      y: offsetY,
      transition: (_a4 = transition2 == null ? void 0 : transition2.exit) != null ? _a4 : withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  },
  enter: ({ transition: transition2, transitionEnd, delay: delay2 }) => {
    var _a4;
    return {
      opacity: 1,
      x: 0,
      y: 0,
      transition: (_a4 = transition2 == null ? void 0 : transition2.enter) != null ? _a4 : withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  },
  exit: ({ offsetY, offsetX, transition: transition2, transitionEnd, reverse: reverse2, delay: delay2 }) => {
    var _a4;
    const offset2 = { x: offsetX, y: offsetY };
    return {
      opacity: 0,
      transition: (_a4 = transition2 == null ? void 0 : transition2.exit) != null ? _a4 : withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
      ...reverse2 ? { ...offset2, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { ...offset2, ...transitionEnd == null ? void 0 : transitionEnd.exit } }
    };
  }
};
var slideFadeConfig = {
  initial: "initial",
  animate: "enter",
  exit: "exit",
  variants: variants$1
};
var SlideFade = reactExports.forwardRef(
  function SlideFade2(props, ref) {
    const {
      unmountOnExit,
      in: isOpen,
      reverse: reverse2 = true,
      className,
      offsetX = 0,
      offsetY = 8,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      ...rest
    } = props;
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const animate = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = {
      offsetX,
      offsetY,
      reverse: reverse2,
      transition: transition2,
      transitionEnd,
      delay: delay2
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { custom, children: show && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        ref,
        className: cx("chakra-offset-slide", className),
        custom,
        ...slideFadeConfig,
        animate,
        ...rest
      }
    ) });
  }
);
SlideFade.displayName = "SlideFade";
var defaultTransition = {
  exit: {
    duration: 0.15,
    ease: TRANSITION_EASINGS.easeInOut
  },
  enter: {
    type: "spring",
    damping: 25,
    stiffness: 180
  }
};
var variants = {
  exit: ({ direction: direction2, transition: transition2, transitionEnd, delay: delay2 }) => {
    var _a4;
    const { exit: exitStyles } = getSlideTransition({ direction: direction2 });
    return {
      ...exitStyles,
      transition: (_a4 = transition2 == null ? void 0 : transition2.exit) != null ? _a4 : withDelay.exit(defaultTransition.exit, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  },
  enter: ({ direction: direction2, transitionEnd, transition: transition2, delay: delay2 }) => {
    var _a4;
    const { enter: enterStyles } = getSlideTransition({ direction: direction2 });
    return {
      ...enterStyles,
      transition: (_a4 = transition2 == null ? void 0 : transition2.enter) != null ? _a4 : withDelay.enter(defaultTransition.enter, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  }
};
var Slide = reactExports.forwardRef(function Slide2(props, ref) {
  const {
    direction: direction2 = "right",
    style,
    unmountOnExit,
    in: isOpen,
    className,
    transition: transition2,
    transitionEnd,
    delay: delay2,
    motionProps,
    ...rest
  } = props;
  const transitionStyles = getSlideTransition({ direction: direction2 });
  const computedStyle = Object.assign(
    { position: "fixed" },
    transitionStyles.position,
    style
  );
  const show = unmountOnExit ? isOpen && unmountOnExit : true;
  const animate = isOpen || unmountOnExit ? "enter" : "exit";
  const custom = { transitionEnd, transition: transition2, direction: direction2, delay: delay2 };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { custom, children: show && /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      ...rest,
      ref,
      initial: "exit",
      className: cx("chakra-slide", className),
      animate,
      exit: "exit",
      custom,
      variants,
      style: computedStyle,
      ...motionProps
    }
  ) });
});
Slide.displayName = "Slide";
function getValidChildren(children) {
  return reactExports.Children.toArray(children).filter(
    (child) => reactExports.isValidElement(child)
  );
}
var [ButtonGroupProvider, useButtonGroup] = createContext$1({
  strict: false,
  name: "ButtonGroupContext"
});
function useButtonType(value) {
  const [isButton, setIsButton] = reactExports.useState(!value);
  const refCallback = reactExports.useCallback((node2) => {
    if (!node2)
      return;
    setIsButton(node2.tagName === "BUTTON");
  }, []);
  const type2 = isButton ? "button" : void 0;
  return { ref: refCallback, type: type2 };
}
function ButtonIcon(props) {
  const { children, className, ...rest } = props;
  const _children = reactExports.isValidElement(children) ? reactExports.cloneElement(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;
  const _className = cx("chakra-button__icon", className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...rest,
      className: _className,
      children: _children
    }
  );
}
ButtonIcon.displayName = "ButtonIcon";
function ButtonSpinner(props) {
  const {
    label: label2,
    placement,
    spacing: spacing2 = "0.5rem",
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-button__spinner", className);
  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = reactExports.useMemo(
    () => ({
      display: "flex",
      alignItems: "center",
      position: label2 ? "relative" : "absolute",
      [marginProp]: label2 ? spacing2 : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...__css
    }),
    [__css, label2, marginProp, spacing2]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
}
ButtonSpinner.displayName = "ButtonSpinner";
var Button = forwardRef((props, ref) => {
  const group = useButtonGroup();
  const styles2 = useStyleConfig("Button", { ...group, ...props });
  const {
    isDisabled: isDisabled2 = group == null ? void 0 : group.isDisabled,
    isLoading,
    isActive,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing: iconSpacing2 = "0.5rem",
    type: type2,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = omitThemingProps(props);
  const buttonStyles = reactExports.useMemo(() => {
    const _focus = { ...styles2 == null ? void 0 : styles2["_focus"], zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...styles2,
      ...!!group && { _focus }
    };
  }, [styles2, group]);
  const { ref: _ref3, type: defaultType } = useButtonType(as);
  const contentProps = { rightIcon, leftIcon, iconSpacing: iconSpacing2, children };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    chakra.button,
    {
      ref: useMergeRefs$1(ref, _ref3),
      as,
      type: type2 != null ? type2 : defaultType,
      "data-active": dataAttr(isActive),
      "data-loading": dataAttr(isLoading),
      __css: buttonStyles,
      className: cx("chakra-button", className),
      ...rest,
      disabled: isDisabled2 || isLoading,
      children: [
        isLoading && spinnerPlacement === "start" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--start",
            label: loadingText,
            placement: "start",
            spacing: iconSpacing2,
            children: spinner
          }
        ),
        isLoading ? loadingText || /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { opacity: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonContent, { ...contentProps }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonContent, { ...contentProps }),
        isLoading && spinnerPlacement === "end" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--end",
            label: loadingText,
            placement: "end",
            spacing: iconSpacing2,
            children: spinner
          }
        )
      ]
    }
  );
});
Button.displayName = "Button";
function ButtonContent(props) {
  const { leftIcon, rightIcon, children, iconSpacing: iconSpacing2 } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonIcon, { marginEnd: iconSpacing2, children: leftIcon }),
    children,
    rightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonIcon, { marginStart: iconSpacing2, children: rightIcon })
  ] });
}
var IconButton = forwardRef(
  (props, ref) => {
    const { icon, children, isRound, "aria-label": ariaLabel, ...rest } = props;
    const element = icon || children;
    const _children = reactExports.isValidElement(element) ? reactExports.cloneElement(element, {
      "aria-hidden": true,
      focusable: false
    }) : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        padding: "0",
        borderRadius: isRound ? "full" : void 0,
        ref,
        "aria-label": ariaLabel,
        ...rest,
        children: _children
      }
    );
  }
);
IconButton.displayName = "IconButton";
var [FormControlStylesProvider, useFormControlStyles] = createContext$1({
  name: `FormControlStylesContext`,
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
});
var [FormControlProvider, useFormControlContext] = createContext$1({
  strict: false,
  name: "FormControlContext"
});
function useFormControlProvider(props) {
  const {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled: isDisabled2,
    isReadOnly,
    ...htmlProps
  } = props;
  const uuid2 = reactExports.useId();
  const id2 = idProp || `field-${uuid2}`;
  const labelId = `${id2}-label`;
  const feedbackId = `${id2}-feedback`;
  const helpTextId = `${id2}-helptext`;
  const [hasFeedbackText, setHasFeedbackText] = reactExports.useState(false);
  const [hasHelpText, setHasHelpText] = reactExports.useState(false);
  const [isFocused, setFocus] = reactExports.useState(false);
  const getHelpTextProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      id: helpTextId,
      ...props2,
      /**
       * Notify the field context when the help text is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node2) => {
        if (!node2)
          return;
        setHasHelpText(true);
      })
    }),
    [helpTextId]
  );
  const getLabelProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled2),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      id: props2.id !== void 0 ? props2.id : labelId,
      htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id2
    }),
    [id2, isDisabled2, isFocused, isInvalid, isReadOnly, labelId]
  );
  const getErrorMessageProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      id: feedbackId,
      ...props2,
      /**
       * Notify the field context when the error message is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node2) => {
        if (!node2)
          return;
        setHasFeedbackText(true);
      }),
      "aria-live": "polite"
    }),
    [feedbackId]
  );
  const getRootProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ...htmlProps,
      ref: forwardedRef,
      role: "group"
    }),
    [htmlProps]
  );
  const getRequiredIndicatorProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      role: "presentation",
      "aria-hidden": true,
      children: props2.children || "*"
    }),
    []
  );
  return {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled2,
    isFocused: !!isFocused,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    hasFeedbackText,
    setHasFeedbackText,
    hasHelpText,
    setHasHelpText,
    id: id2,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps,
    getHelpTextProps,
    getErrorMessageProps,
    getRootProps,
    getLabelProps,
    getRequiredIndicatorProps
  };
}
var FormControl = forwardRef(
  function FormControl2(props, ref) {
    const styles2 = useMultiStyleConfig("Form", props);
    const ownProps = omitThemingProps(props);
    const {
      getRootProps,
      htmlProps: _2,
      ...context
    } = useFormControlProvider(ownProps);
    const className = cx("chakra-form-control", props.className);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlProvider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlStylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ...getRootProps({}, ref),
        className,
        __css: styles2["container"]
      }
    ) }) });
  }
);
FormControl.displayName = "FormControl";
var FormHelperText = forwardRef(
  function FormHelperText2(props, ref) {
    const field = useFormControlContext();
    const styles2 = useFormControlStyles();
    const className = cx("chakra-form__helper-text", props.className);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ...field == null ? void 0 : field.getHelpTextProps(props, ref),
        __css: styles2.helperText,
        className
      }
    );
  }
);
FormHelperText.displayName = "FormHelperText";
var FormLabel = forwardRef(function FormLabel2(passedProps, ref) {
  var _a4;
  const styles2 = useStyleConfig("FormLabel", passedProps);
  const props = omitThemingProps(passedProps);
  const {
    className,
    children,
    requiredIndicator = /* @__PURE__ */ jsxRuntimeExports.jsx(RequiredIndicator, {}),
    optionalIndicator = null,
    ...rest
  } = props;
  const field = useFormControlContext();
  const ownProps = (_a4 = field == null ? void 0 : field.getLabelProps(rest, ref)) != null ? _a4 : { ref, ...rest };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    chakra.label,
    {
      ...ownProps,
      className: cx("chakra-form__label", props.className),
      __css: {
        display: "block",
        textAlign: "start",
        ...styles2
      },
      children: [
        children,
        (field == null ? void 0 : field.isRequired) ? requiredIndicator : optionalIndicator
      ]
    }
  );
});
FormLabel.displayName = "FormLabel";
var RequiredIndicator = forwardRef(
  function RequiredIndicator2(props, ref) {
    const field = useFormControlContext();
    const styles2 = useFormControlStyles();
    if (!(field == null ? void 0 : field.isRequired))
      return null;
    const className = cx("chakra-form__required-indicator", props.className);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.span,
      {
        ...field == null ? void 0 : field.getRequiredIndicatorProps(props, ref),
        __css: styles2.requiredIndicator,
        className
      }
    );
  }
);
RequiredIndicator.displayName = "RequiredIndicator";
function useFormControl(props) {
  const { isDisabled: isDisabled2, isInvalid, isReadOnly, isRequired, ...rest } = useFormControlProps(props);
  return {
    ...rest,
    disabled: isDisabled2,
    readOnly: isReadOnly,
    required: isRequired,
    "aria-invalid": ariaAttr(isInvalid),
    "aria-required": ariaAttr(isRequired),
    "aria-readonly": ariaAttr(isReadOnly)
  };
}
function useFormControlProps(props) {
  var _a4, _b3, _c2;
  const field = useFormControlContext();
  const {
    id: id2,
    disabled,
    readOnly,
    required,
    isRequired,
    isInvalid,
    isReadOnly,
    isDisabled: isDisabled2,
    onFocus: onFocus4,
    onBlur: onBlur3,
    ...rest
  } = props;
  const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
  if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
    labelIds.push(field.feedbackId);
  }
  if (field == null ? void 0 : field.hasHelpText) {
    labelIds.push(field.helpTextId);
  }
  return {
    ...rest,
    "aria-describedby": labelIds.join(" ") || void 0,
    id: id2 != null ? id2 : field == null ? void 0 : field.id,
    isDisabled: (_a4 = disabled != null ? disabled : isDisabled2) != null ? _a4 : field == null ? void 0 : field.isDisabled,
    isReadOnly: (_b3 = readOnly != null ? readOnly : isReadOnly) != null ? _b3 : field == null ? void 0 : field.isReadOnly,
    isRequired: (_c2 = required != null ? required : isRequired) != null ? _c2 : field == null ? void 0 : field.isRequired,
    isInvalid: isInvalid != null ? isInvalid : field == null ? void 0 : field.isInvalid,
    onFocus: callAllHandlers$1(field == null ? void 0 : field.onFocus, onFocus4),
    onBlur: callAllHandlers$1(field == null ? void 0 : field.onBlur, onBlur3)
  };
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var isDom = () => typeof document !== "undefined";
var hasSetup = false;
var modality = null;
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var handlers$1 = /* @__PURE__ */ new Set();
function trigger(modality2, event) {
  handlers$1.forEach((handler) => handler(modality2, event));
}
var isMac = typeof window !== "undefined" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;
function isValidKey(e2) {
  return !(e2.metaKey || !isMac && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function onKeyboardEvent(event) {
  hasEventBeforeFocus = true;
  if (isValidKey(event)) {
    modality = "keyboard";
    trigger("keyboard", event);
  }
}
function onPointerEvent(event) {
  modality = "pointer";
  if (event.type === "mousedown" || event.type === "pointerdown") {
    hasEventBeforeFocus = true;
    const target = event.composedPath ? event.composedPath()[0] : event.target;
    let matches2 = false;
    try {
      matches2 = target.matches(":focus-visible");
    } catch {
    }
    if (matches2)
      return;
    trigger("pointer", event);
  }
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted)
    return true;
  return event.detail === 0 && !event.pointerType;
}
function onClickEvent(e2) {
  if (isVirtualClick(e2)) {
    hasEventBeforeFocus = true;
    modality = "virtual";
  }
}
function onWindowFocus(event) {
  if (event.target === window || event.target === document) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    modality = "virtual";
    trigger("virtual", event);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function onWindowBlur$1() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function isFocusVisible() {
  return modality !== "pointer";
}
function setupGlobalFocusEvents() {
  if (!isDom() || hasSetup) {
    return;
  }
  const { focus } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function focusElement(...args) {
    hasEventBeforeFocus = true;
    focus.apply(this, args);
  };
  document.addEventListener("keydown", onKeyboardEvent, true);
  document.addEventListener("keyup", onKeyboardEvent, true);
  document.addEventListener("click", onClickEvent, true);
  window.addEventListener("focus", onWindowFocus, true);
  window.addEventListener("blur", onWindowBlur$1, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", onPointerEvent, true);
    document.addEventListener("pointermove", onPointerEvent, true);
    document.addEventListener("pointerup", onPointerEvent, true);
  } else {
    document.addEventListener("mousedown", onPointerEvent, true);
    document.addEventListener("mousemove", onPointerEvent, true);
    document.addEventListener("mouseup", onPointerEvent, true);
  }
  hasSetup = true;
}
function trackFocusVisible(fn2) {
  setupGlobalFocusEvents();
  fn2(isFocusVisible());
  const handler = () => fn2(isFocusVisible());
  handlers$1.add(handler);
  return () => {
    handlers$1.delete(handler);
  };
}
function omit$2(object2, keysToOmit = []) {
  const clone = Object.assign({}, object2);
  for (const key2 of keysToOmit) {
    if (key2 in clone) {
      delete clone[key2];
    }
  }
  return clone;
}
function useCheckbox(props = {}) {
  const formControlProps = useFormControlProps(props);
  const {
    isDisabled: isDisabled2,
    isReadOnly,
    isRequired,
    isInvalid,
    id: id2,
    onBlur: onBlur3,
    onFocus: onFocus4,
    "aria-describedby": ariaDescribedBy
  } = formControlProps;
  const {
    defaultChecked,
    isChecked: checkedProp,
    isFocusable: isFocusable2,
    onChange: onChange2,
    isIndeterminate,
    name: name2,
    value,
    tabIndex = void 0,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-invalid": ariaInvalid,
    ...rest
  } = props;
  const htmlProps = omit$2(rest, [
    "isDisabled",
    "isReadOnly",
    "isRequired",
    "isInvalid",
    "id",
    "onBlur",
    "onFocus",
    "aria-describedby"
  ]);
  const onChangeProp = useCallbackRef$2(onChange2);
  const onBlurProp = useCallbackRef$2(onBlur3);
  const onFocusProp = useCallbackRef$2(onFocus4);
  const [isFocusVisible2, setIsFocusVisible] = reactExports.useState(false);
  const [isFocused, setFocused] = reactExports.useState(false);
  const [isHovered, setHovered] = reactExports.useState(false);
  const [isActive, setActive] = reactExports.useState(false);
  reactExports.useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  const inputRef = reactExports.useRef(null);
  const [rootIsLabelElement, setRootIsLabelElement] = reactExports.useState(true);
  const [checkedState, setCheckedState] = reactExports.useState(!!defaultChecked);
  const isControlled = checkedProp !== void 0;
  const isChecked = isControlled ? checkedProp : checkedState;
  const handleChange = reactExports.useCallback(
    (event) => {
      if (isReadOnly || isDisabled2) {
        event.preventDefault();
        return;
      }
      if (!isControlled) {
        if (isChecked) {
          setCheckedState(event.target.checked);
        } else {
          setCheckedState(isIndeterminate ? true : event.target.checked);
        }
      }
      onChangeProp == null ? void 0 : onChangeProp(event);
    },
    [
      isReadOnly,
      isDisabled2,
      isChecked,
      isControlled,
      isIndeterminate,
      onChangeProp
    ]
  );
  useSafeLayoutEffect$2(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(isIndeterminate);
    }
  }, [isIndeterminate]);
  useUpdateEffect(() => {
    if (isDisabled2) {
      setFocused(false);
    }
  }, [isDisabled2, setFocused]);
  useSafeLayoutEffect$2(() => {
    const el2 = inputRef.current;
    if (!(el2 == null ? void 0 : el2.form))
      return;
    const formResetListener = () => {
      setCheckedState(!!defaultChecked);
    };
    el2.form.addEventListener("reset", formResetListener);
    return () => {
      var _a4;
      return (_a4 = el2.form) == null ? void 0 : _a4.removeEventListener("reset", formResetListener);
    };
  }, []);
  const trulyDisabled = isDisabled2 && !isFocusable2;
  const onKeyDown = reactExports.useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(true);
      }
    },
    [setActive]
  );
  const onKeyUp = reactExports.useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(false);
      }
    },
    [setActive]
  );
  useSafeLayoutEffect$2(() => {
    if (!inputRef.current)
      return;
    const notInSync = inputRef.current.checked !== isChecked;
    if (notInSync) {
      setCheckedState(inputRef.current.checked);
    }
  }, [inputRef.current]);
  const getCheckboxProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => {
      const onPressDown = (event) => {
        if (isFocused) {
          event.preventDefault();
        }
        setActive(true);
      };
      return {
        ...props2,
        ref: forwardedRef,
        "data-active": dataAttr(isActive),
        "data-hover": dataAttr(isHovered),
        "data-checked": dataAttr(isChecked),
        "data-focus": dataAttr(isFocused),
        "data-focus-visible": dataAttr(isFocused && isFocusVisible2),
        "data-indeterminate": dataAttr(isIndeterminate),
        "data-disabled": dataAttr(isDisabled2),
        "data-invalid": dataAttr(isInvalid),
        "data-readonly": dataAttr(isReadOnly),
        "aria-hidden": true,
        onMouseDown: callAllHandlers$1(props2.onMouseDown, onPressDown),
        onMouseUp: callAllHandlers$1(props2.onMouseUp, () => setActive(false)),
        onMouseEnter: callAllHandlers$1(
          props2.onMouseEnter,
          () => setHovered(true)
        ),
        onMouseLeave: callAllHandlers$1(
          props2.onMouseLeave,
          () => setHovered(false)
        )
      };
    },
    [
      isActive,
      isChecked,
      isDisabled2,
      isFocused,
      isFocusVisible2,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getIndicatorProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(isChecked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible2),
      "data-indeterminate": dataAttr(isIndeterminate),
      "data-disabled": dataAttr(isDisabled2),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    [
      isActive,
      isChecked,
      isDisabled2,
      isFocused,
      isFocusVisible2,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getRootProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...htmlProps,
      ...props2,
      ref: mergeRefs(forwardedRef, (node2) => {
        if (!node2)
          return;
        setRootIsLabelElement(node2.tagName === "LABEL");
      }),
      onClick: callAllHandlers$1(props2.onClick, () => {
        var _a4;
        if (!rootIsLabelElement) {
          (_a4 = inputRef.current) == null ? void 0 : _a4.click();
          requestAnimationFrame(() => {
            var _a22;
            (_a22 = inputRef.current) == null ? void 0 : _a22.focus({ preventScroll: true });
          });
        }
      }),
      "data-disabled": dataAttr(isDisabled2),
      "data-checked": dataAttr(isChecked),
      "data-invalid": dataAttr(isInvalid)
    }),
    [htmlProps, isDisabled2, isChecked, isInvalid, rootIsLabelElement]
  );
  const getInputProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => {
      return {
        ...props2,
        ref: mergeRefs(inputRef, forwardedRef),
        type: "checkbox",
        name: name2,
        value,
        id: id2,
        tabIndex,
        onChange: callAllHandlers$1(props2.onChange, handleChange),
        onBlur: callAllHandlers$1(
          props2.onBlur,
          onBlurProp,
          () => setFocused(false)
        ),
        onFocus: callAllHandlers$1(
          props2.onFocus,
          onFocusProp,
          () => setFocused(true)
        ),
        onKeyDown: callAllHandlers$1(props2.onKeyDown, onKeyDown),
        onKeyUp: callAllHandlers$1(props2.onKeyUp, onKeyUp),
        required: isRequired,
        checked: isChecked,
        disabled: trulyDisabled,
        readOnly: isReadOnly,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isDisabled2,
        style: visuallyHiddenStyle
      };
    },
    [
      name2,
      value,
      id2,
      handleChange,
      onBlurProp,
      onFocusProp,
      onKeyDown,
      onKeyUp,
      isRequired,
      isChecked,
      trulyDisabled,
      isReadOnly,
      ariaLabel,
      ariaLabelledBy,
      ariaInvalid,
      isInvalid,
      ariaDescribedBy,
      isDisabled2,
      tabIndex
    ]
  );
  const getLabelProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      onMouseDown: callAllHandlers$1(props2.onMouseDown, stopEvent),
      "data-disabled": dataAttr(isDisabled2),
      "data-checked": dataAttr(isChecked),
      "data-invalid": dataAttr(isInvalid)
    }),
    [isChecked, isDisabled2, isInvalid]
  );
  const state2 = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isIndeterminate,
    isDisabled: isDisabled2,
    isReadOnly,
    isRequired
  };
  return {
    state: state2,
    getRootProps,
    getCheckboxProps,
    getIndicatorProps,
    getInputProps,
    getLabelProps,
    htmlProps
  };
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function useEventListener(target, event, handler, options2) {
  const listener = useCallbackRef$2(handler);
  reactExports.useEffect(() => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    if (!handler || !node2)
      return;
    node2.addEventListener(event, listener, options2);
    return () => {
      node2.removeEventListener(event, listener, options2);
    };
  }, [event, target, options2, listener, handler]);
  return () => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    node2 == null ? void 0 : node2.removeEventListener(event, listener, options2);
  };
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes)
    return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
requirePropTypes();
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
var FOCUS_NO_AUTOFOCUS = "data-no-autofocus";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef$1(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  return innerCreateMedium(defaults2, middleware2);
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}
var SideCar$1 = function(_a4) {
  var sideCar = _a4.sideCar, rest = __rest(_a4, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var mediumFocus = createMedium({}, function(_ref3) {
  var target = _ref3.target, currentTarget = _ref3.currentTarget;
  return {
    target,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
  // focus-lock sidecar is not required on the server
  // however, it might be required for JSDOM tests
  // ssr: true,
});
var emptyArray = [];
var FocusLock$2 = /* @__PURE__ */ reactExports.forwardRef(function FocusLockUI(props, parentRef) {
  var _extends2;
  var _React$useState = reactExports.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
  var observed = reactExports.useRef();
  var isActive = reactExports.useRef(false);
  var originalFocusedElement = reactExports.useRef(null);
  var children = props.children, disabled = props.disabled, noFocusGuards = props.noFocusGuards, persistentFocus = props.persistentFocus, crossFrame = props.crossFrame, autoFocus = props.autoFocus;
  props.allowTextSelection;
  var group = props.group, className = props.className, whiteList = props.whiteList, hasPositiveIndices = props.hasPositiveIndices, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container2 = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props.sideCar, shouldReturnFocus = props.returnFocus, focusOptions = props.focusOptions, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
  var _React$useState2 = reactExports.useState({}), id2 = _React$useState2[0];
  var onActivation = reactExports.useCallback(function() {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = reactExports.useCallback(function() {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  reactExports.useEffect(function() {
    if (!disabled) {
      originalFocusedElement.current = null;
    }
  }, []);
  var returnFocus = reactExports.useCallback(function(allowDefer) {
    var returnFocusTo = originalFocusedElement.current;
    if (returnFocusTo && returnFocusTo.focus) {
      var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (howToReturnFocus) {
        var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
        originalFocusedElement.current = null;
        if (allowDefer) {
          Promise.resolve().then(function() {
            return returnFocusTo.focus(returnFocusOptions);
          });
        } else {
          returnFocusTo.focus(returnFocusOptions);
        }
      }
    }
  }, [shouldReturnFocus]);
  var onFocus4 = reactExports.useCallback(function(event) {
    if (isActive.current) {
      mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur3 = mediumBlur.useMedium;
  var setObserveNode = reactExports.useCallback(function(newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  var lockProps = _extends$8((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
  var mergedRef = useMergeRefs([parentRef, setObserveNode]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, hasLeadingGuards && [
    // nearest focus guard
    /* @__PURE__ */ reactExports.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }),
    // first tabbed element guard
    hasPositiveIndices ? /* @__PURE__ */ reactExports.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 1,
      style: hiddenGuard
    }) : null
  ], !disabled && /* @__PURE__ */ reactExports.createElement(SideCar2, {
    id: id2,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled,
    persistentFocus,
    crossFrame,
    autoFocus,
    whiteList,
    shards,
    onActivation,
    onDeactivation,
    returnFocus,
    focusOptions
  }), /* @__PURE__ */ reactExports.createElement(Container2, _extends$8({
    ref: mergedRef
  }, lockProps, {
    className,
    onBlur: onBlur3,
    onFocus: onFocus4
  }), children), hasTailingGuards && /* @__PURE__ */ reactExports.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
});
FocusLock$2.propTypes = {};
FocusLock$2.defaultProps = {
  children: void 0,
  disabled: false,
  returnFocus: false,
  focusOptions: void 0,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  hasPositiveIndices: void 0,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
const FocusLockUI2 = FocusLock$2;
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$2(subClass, superClass);
}
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$1(arg) {
  var key2 = _toPrimitive$1(arg, "string");
  return _typeof$2(key2) === "symbol" ? key2 : String(key2);
}
function _defineProperty$1(obj, key2, value) {
  key2 = _toPropertyKey$1(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  function getDisplayName2(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap2(WrappedComponent) {
    var mountedInstances = [];
    var state2;
    function emitChange() {
      state2 = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state2);
    }
    var SideEffect = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose$1(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek2() {
        return state2;
      };
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index2 = mountedInstances.indexOf(this);
        mountedInstances.splice(index2, 1);
        emitChange();
      };
      _proto.render = function render() {
        return /* @__PURE__ */ React.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(reactExports.PureComponent);
    _defineProperty$1(SideEffect, "displayName", "SideEffect(" + getDisplayName2(WrappedComponent) + ")");
    return SideEffect;
  };
}
var toArray = function(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};
var asArray = function(a) {
  return Array.isArray(a) ? a : [a];
};
var getFirst = function(a) {
  return Array.isArray(a) ? a[0] : a;
};
var isElementHidden = function(node2) {
  if (node2.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node2, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
};
var getParentNode$2 = function(node2) {
  return node2.parentNode && node2.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    node2.parentNode.host
  ) : node2.parentNode;
};
var isTopNode = function(node2) {
  return node2 === document || node2 && node2.nodeType === Node.DOCUMENT_NODE;
};
var isVisibleUncached = function(node2, checkParent) {
  return !node2 || isTopNode(node2) || !isElementHidden(node2) && checkParent(getParentNode$2(node2));
};
var isVisibleCached = function(visibilityCache, node2) {
  var cached = visibilityCache.get(node2);
  if (cached !== void 0) {
    return cached;
  }
  var result = isVisibleUncached(node2, isVisibleCached.bind(void 0, visibilityCache));
  visibilityCache.set(node2, result);
  return result;
};
var isAutoFocusAllowedUncached = function(node2, checkParent) {
  return node2 && !isTopNode(node2) ? isAutoFocusAllowed(node2) ? checkParent(getParentNode$2(node2)) : false : true;
};
var isAutoFocusAllowedCached = function(cache2, node2) {
  var cached = cache2.get(node2);
  if (cached !== void 0) {
    return cached;
  }
  var result = isAutoFocusAllowedUncached(node2, isAutoFocusAllowedCached.bind(void 0, cache2));
  cache2.set(node2, result);
  return result;
};
var getDataset = function(node2) {
  return node2.dataset;
};
var isHTMLButtonElement = function(node2) {
  return node2.tagName === "BUTTON";
};
var isHTMLInputElement = function(node2) {
  return node2.tagName === "INPUT";
};
var isRadioElement = function(node2) {
  return isHTMLInputElement(node2) && node2.type === "radio";
};
var notHiddenInput = function(node2) {
  return !((isHTMLInputElement(node2) || isHTMLButtonElement(node2)) && (node2.type === "hidden" || node2.disabled));
};
var isAutoFocusAllowed = function(node2) {
  var attribute = node2.getAttribute(FOCUS_NO_AUTOFOCUS);
  return ![true, "true", ""].includes(attribute);
};
var isGuard = function(node2) {
  var _a4;
  return Boolean(node2 && ((_a4 = getDataset(node2)) === null || _a4 === void 0 ? void 0 : _a4.focusGuard));
};
var isNotAGuard = function(node2) {
  return !isGuard(node2);
};
var isDefined$1 = function(x2) {
  return Boolean(x2);
};
var tabSort = function(a, b2) {
  var tabDiff = a.tabIndex - b2.tabIndex;
  var indexDiff = a.index - b2.index;
  if (tabDiff) {
    if (!a.tabIndex) {
      return 1;
    }
    if (!b2.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node2, index2) {
    return {
      node: node2,
      index: index2,
      tabIndex: keepGuards && node2.tabIndex === -1 ? (node2.dataset || {}).focusGuard ? 0 : -1 : node2.tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function(parent, withGuards) {
  return toArray((parent.shadowRoot || parent).children).reduce(function(acc, child) {
    return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
  }, []);
};
var getFocusablesWithIFrame = function(parent, withGuards) {
  var _a4;
  if (parent instanceof HTMLIFrameElement && ((_a4 = parent.contentDocument) === null || _a4 === void 0 ? void 0 : _a4.body)) {
    return getFocusables([parent.contentDocument.body], withGuards);
  }
  return [parent];
};
var getFocusables = function(parents, withGuards) {
  return parents.reduce(function(acc, parent) {
    var _a4;
    var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
    var focusableWithIframes = (_a4 = []).concat.apply(_a4, focusableWithShadowDom.map(function(node2) {
      return getFocusablesWithIFrame(node2, withGuards);
    }));
    return acc.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      focusableWithIframes,
      // add if node is tabbable itself
      parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function(node2) {
        return node2 === parent;
      }) : []
    );
  }, []);
};
var getParentAutofocusables = function(parent) {
  var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
  return toArray(parentFocus).map(function(node2) {
    return getFocusables([node2]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
};
var filterFocusable = function(nodes, visibilityCache) {
  return toArray(nodes).filter(function(node2) {
    return isVisibleCached(visibilityCache, node2);
  }).filter(function(node2) {
    return notHiddenInput(node2);
  });
};
var filterAutoFocusable = function(nodes, cache2) {
  if (cache2 === void 0) {
    cache2 = /* @__PURE__ */ new Map();
  }
  return toArray(nodes).filter(function(node2) {
    return isAutoFocusAllowedCached(cache2, node2);
  });
};
var getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
};
var getFocusableNodes = function(topNodes, visibilityCache) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
};
var parentAutofocusables = function(topNode, visibilityCache) {
  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
};
var contains$2 = function(scope, element) {
  if (scope.shadowRoot) {
    return contains$2(scope.shadowRoot, element);
  } else {
    if (Object.getPrototypeOf(scope).contains !== void 0 && Object.getPrototypeOf(scope).contains.call(scope, element)) {
      return true;
    }
    return toArray(scope.children).some(function(child) {
      var _a4;
      if (child instanceof HTMLIFrameElement) {
        var iframeBody = (_a4 = child.contentDocument) === null || _a4 === void 0 ? void 0 : _a4.body;
        if (iframeBody) {
          return contains$2(iframeBody, element);
        }
        return false;
      }
      return contains$2(child, element);
    });
  }
};
var filterNested = function(nodes) {
  var contained = /* @__PURE__ */ new Set();
  var l2 = nodes.length;
  for (var i = 0; i < l2; i += 1) {
    for (var j = i + 1; j < l2; j += 1) {
      var position2 = nodes[i].compareDocumentPosition(nodes[j]);
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i);
      }
    }
  }
  return nodes.filter(function(_2, index2) {
    return !contained.has(index2);
  });
};
var getTopParent = function(node2) {
  return node2.parentNode ? getTopParent(node2.parentNode) : node2;
};
var getAllAffectedNodes = function(node2) {
  var nodes = asArray(node2);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
    return acc;
  }, []);
};
var safeProbe = function(cb2) {
  try {
    return cb2();
  } catch (e2) {
    return void 0;
  }
};
var getActiveElement$1 = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  if (!inDocument || !inDocument.activeElement) {
    return void 0;
  }
  var activeElement = inDocument.activeElement;
  return activeElement.shadowRoot ? getActiveElement$1(activeElement.shadowRoot) : activeElement instanceof HTMLIFrameElement && safeProbe(function() {
    return activeElement.contentWindow.document;
  }) ? getActiveElement$1(activeElement.contentWindow.document) : activeElement;
};
var focusInFrame = function(frame2, activeElement) {
  return frame2 === activeElement;
};
var focusInsideIframe = function(topNode, activeElement) {
  return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node2) {
    return focusInFrame(node2, activeElement);
  }));
};
var focusInside = function(topNode, activeElement) {
  if (activeElement === void 0) {
    activeElement = getActiveElement$1(getFirst(topNode).ownerDocument);
  }
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).some(function(node2) {
    return contains$2(node2, activeElement) || focusInsideIframe(node2, activeElement);
  });
};
var focusIsHidden = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  var activeElement = getActiveElement$1(inDocument);
  if (!activeElement) {
    return false;
  }
  return toArray(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node2) {
    return contains$2(node2, activeElement);
  });
};
var findSelectedRadio = function(node2, nodes) {
  return nodes.filter(isRadioElement).filter(function(el2) {
    return el2.name === node2.name;
  }).filter(function(el2) {
    return el2.checked;
  })[0] || node2;
};
var correctNode = function(node2, nodes) {
  if (isRadioElement(node2) && node2.name) {
    return findSelectedRadio(node2, nodes);
  }
  return node2;
};
var correctNodes = function(nodes) {
  var resultSet = /* @__PURE__ */ new Set();
  nodes.forEach(function(node2) {
    return resultSet.add(correctNode(node2, nodes));
  });
  return nodes.filter(function(node2) {
    return resultSet.has(node2);
  });
};
var pickFirstFocus = function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
};
var pickFocusable = function(nodes, index2) {
  if (nodes.length > 1) {
    return nodes.indexOf(correctNode(nodes[index2], nodes));
  }
  return index2;
};
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = function(innerNodes, outerNodes, activeElement, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);
  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
    return void 0;
  }
  var activeIndex = activeElement !== void 0 ? outerNodes.indexOf(activeElement) : -1;
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = correctNodes(outerNodes);
  var correctedIndex = activeElement !== void 0 ? correctedNodes.indexOf(activeElement) : -1;
  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
};
var findAutoFocused = function(autoFocusables) {
  return function(node2) {
    var _a4;
    var autofocus = (_a4 = getDataset(node2)) === null || _a4 === void 0 ? void 0 : _a4.autofocus;
    return (
      // @ts-expect-error
      node2.autofocus || //
      autofocus !== void 0 && autofocus !== "false" || //
      autoFocusables.indexOf(node2) >= 0
    );
  };
};
var pickAutofocus = function(nodesIndexes, orderedNodes, groups) {
  var nodes = nodesIndexes.map(function(_a4) {
    var node2 = _a4.node;
    return node2;
  });
  var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
  if (autoFocusable && autoFocusable.length) {
    return pickFirstFocus(autoFocusable);
  }
  return pickFirstFocus(filterAutoFocusable(orderedNodes));
};
var getParents = function(node2, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node2);
  if (node2.parentNode) {
    getParents(node2.parentNode.host || node2.parentNode, parents);
  }
  return parents;
};
var getCommonParent = function(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      var common2 = getCommonParent(activeElement, subEntry);
      if (common2) {
        if (!topCommon || contains$2(common2, topCommon)) {
          topCommon = common2;
        } else {
          topCommon = getCommonParent(common2, topCommon);
        }
      }
    });
  });
  return topCommon;
};
var allParentAutofocusables = function(entries2, visibilityCache) {
  return entries2.reduce(function(acc, node2) {
    return acc.concat(parentAutofocusables(node2, visibilityCache));
  }, []);
};
var reorderNodes = function(srcNodes, dstNodes) {
  var remap = /* @__PURE__ */ new Map();
  dstNodes.forEach(function(entity) {
    return remap.set(entity.node, entity);
  });
  return srcNodes.map(function(node2) {
    return remap.get(node2);
  }).filter(isDefined$1);
};
var focusSolver = function(topNode, lastNode) {
  var activeElement = getActiveElement$1(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
  var entries2 = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries2);
  var visibilityCache = /* @__PURE__ */ new Map();
  var anyFocusable = getFocusableNodes(entries2, visibilityCache);
  var innerElements = getTabbableNodes(entries2, visibilityCache).filter(function(_a4) {
    var node2 = _a4.node;
    return isNotAGuard(node2);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return void 0;
    }
  }
  var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function(_a4) {
    var node2 = _a4.node;
    return node2;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function(_a4) {
    var node2 = _a4.node;
    return node2;
  });
  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
  if (newId === NEW_FOCUS) {
    var focusNode = pickAutofocus(anyFocusable, innerNodes, allParentAutofocusables(entries2, visibilityCache));
    if (focusNode) {
      return { node: focusNode };
    } else {
      console.warn("focus-lock: cannot find any node to move focus into");
      return void 0;
    }
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
};
var expandFocusableNodes = function(topNode) {
  var entries2 = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries2);
  var visibilityCache = /* @__PURE__ */ new Map();
  var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
  var innerElements = getTabbableNodes(entries2, visibilityCache).filter(function(_a4) {
    var node2 = _a4.node;
    return isNotAGuard(node2);
  }).map(function(_a4) {
    var node2 = _a4.node;
    return node2;
  });
  return outerNodes.map(function(_a4) {
    var node2 = _a4.node, index2 = _a4.index;
    return {
      node: node2,
      index: index2,
      lockItem: innerElements.indexOf(node2) >= 0,
      guard: isGuard(node2)
    };
  });
};
var focusOn = function(target, focusOptions) {
  if ("focus" in target) {
    target.focus(focusOptions);
  }
  if ("contentWindow" in target && target.contentWindow) {
    target.contentWindow.focus();
  }
};
var guardCount = 0;
var lockDisabled = false;
var moveFocusInside = function(topNode, lastNode, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var focusable = focusSolver(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node, options2.focusOptions);
    guardCount--;
  }
};
function deferAction(action2) {
  setTimeout(action2, 1);
}
var focusOnBody = function focusOnBody2() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = function defaultWhitelist2() {
  return true;
};
var focusWhitelisted = function focusWhitelisted2(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};
var recordPortal = function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end2, step, allNodes) {
  var lastGuard = null;
  var i = startIndex;
  do {
    var item = allNodes[i];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end2);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var extractRef$1 = function extractRef(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var focusWasOutside = function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
};
var checkInHost = function checkInHost2(check, el2, boundary) {
  return el2 && // find host equal to active element and check nested active element
  (el2.host === check && (!el2.activeElement || boundary.contains(el2.activeElement)) || el2.parentNode && checkInHost2(check, el2.parentNode, boundary));
};
var withinHost = function withinHost2(activeElement, workingArea) {
  return workingArea.some(function(area) {
    return checkInHost(activeElement, area, area);
  });
};
var activateTrap = function activateTrap2() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef$1).filter(Boolean));
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !// active element is "inside" working area
          (focusInside(workingArea) || // check for shadow-dom contained elements
          activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = moveFocusInside(workingArea, lastActiveFocus, {
                focusOptions
              });
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = expandFocusableNodes(workingArea);
        var focusedIndex = allNodes.map(function(_ref3) {
          var node2 = _ref3.node;
          return node2;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref22) {
            var guard2 = _ref22.guard, node2 = _ref22.node;
            return guard2 && node2.dataset.focusAutoGuard;
          }).forEach(function(_ref3) {
            var node2 = _ref3.node;
            return node2.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap2(event) {
  if (activateTrap() && event) {
    event.stopPropagation();
    event.preventDefault();
  }
};
var onBlur = function onBlur2() {
  return deferAction(activateTrap);
};
var onFocus = function onFocus2(event) {
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher2() {
  return null;
};
var onWindowBlur = function onWindowBlur2() {
  focusWasOutsideWindow = "just";
  deferAction(function() {
    focusWasOutsideWindow = "meanwhile";
  });
};
var attachHandler = function attachHandler2() {
  document.addEventListener("focusin", onTrap);
  document.addEventListener("focusout", onBlur);
  window.addEventListener("blur", onWindowBlur);
};
var detachHandler = function detachHandler2() {
  document.removeEventListener("focusin", onTrap);
  document.removeEventListener("focusout", onBlur);
  window.removeEventListener("blur", onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      var id2 = _ref6.id;
      return id2 === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap();
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function(cb2) {
  return cb2({
    moveFocusInside,
    focusInside
  });
});
const FocusTrap$1 = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
var FocusLockCombination = /* @__PURE__ */ reactExports.forwardRef(function FocusLockUICombination(props, ref) {
  return /* @__PURE__ */ reactExports.createElement(FocusLockUI2, _extends$8({
    sideCar: FocusTrap$1,
    ref
  }, props));
});
var _ref$1 = FocusLockUI2.propTypes || {};
_ref$1.sideCar;
_objectWithoutPropertiesLoose$5(_ref$1, ["sideCar"]);
FocusLockCombination.propTypes = {};
const FocusLock$1 = FocusLockCombination;
function isElement$3(el2) {
  return el2 != null && typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement$3(el2) {
  var _a4;
  if (!isElement$3(el2))
    return false;
  const win = (_a4 = el2.ownerDocument.defaultView) != null ? _a4 : window;
  return el2 instanceof win.HTMLElement;
}
function getOwnerWindow(node2) {
  var _a4, _b3;
  return (_b3 = (_a4 = getOwnerDocument$2(node2)) == null ? void 0 : _a4.defaultView) != null ? _b3 : window;
}
function getOwnerDocument$2(node2) {
  return isElement$3(node2) ? node2.ownerDocument : document;
}
function getActiveElement(node2) {
  return getOwnerDocument$2(node2).activeElement;
}
function isScrollParent$1(el2) {
  const win = el2.ownerDocument.defaultView || window;
  const { overflow, overflowX, overflowY } = win.getComputedStyle(el2);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getParent(el2) {
  if (el2.localName === "html")
    return el2;
  return el2.assignedSlot || el2.parentElement || el2.ownerDocument.documentElement;
}
function getScrollParent$2(el2) {
  if (["html", "body", "#document"].includes(el2.localName)) {
    return el2.ownerDocument.body;
  }
  if (isHTMLElement$3(el2) && isScrollParent$1(el2)) {
    return el2;
  }
  return getScrollParent$2(getParent(el2));
}
var hasTabIndex = (element) => element.hasAttribute("tabindex");
var hasNegativeTabIndex = (element) => hasTabIndex(element) && element.tabIndex === -1;
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement))
    return true;
  return element.hidden;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable$1(element) {
  if (!isHTMLElement$3(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }
  const { localName } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0)
    return true;
  const others2 = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others2) {
    return others2[localName]();
  }
  if (isContentEditable(element))
    return true;
  return hasTabIndex(element);
}
function isTabbable(element) {
  if (!element)
    return false;
  return isHTMLElement$3(element) && isFocusable$1(element) && !hasNegativeTabIndex(element);
}
var focusableElList = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
];
var focusableElSelector = focusableElList.join();
var isVisible = (el2) => el2.offsetWidth > 0 && el2.offsetHeight > 0;
function getAllFocusable(container2) {
  const focusableEls = Array.from(
    container2.querySelectorAll(focusableElSelector)
  );
  focusableEls.unshift(container2);
  return focusableEls.filter((el2) => isFocusable$1(el2) && isVisible(el2));
}
var _a$1;
var FocusTrap = (_a$1 = FocusLock$1.default) != null ? _a$1 : FocusLock$1;
var FocusLock = (props) => {
  const {
    initialFocusRef,
    finalFocusRef,
    contentRef,
    restoreFocus,
    children,
    isDisabled: isDisabled2,
    autoFocus,
    persistentFocus,
    lockFocusAcrossFrames
  } = props;
  const onActivation = reactExports.useCallback(() => {
    if (initialFocusRef == null ? void 0 : initialFocusRef.current) {
      initialFocusRef.current.focus();
    } else if (contentRef == null ? void 0 : contentRef.current) {
      const focusables = getAllFocusable(contentRef.current);
      if (focusables.length === 0) {
        requestAnimationFrame(() => {
          var _a22;
          (_a22 = contentRef.current) == null ? void 0 : _a22.focus();
        });
      }
    }
  }, [initialFocusRef, contentRef]);
  const onDeactivation = reactExports.useCallback(() => {
    var _a22;
    (_a22 = finalFocusRef == null ? void 0 : finalFocusRef.current) == null ? void 0 : _a22.focus();
  }, [finalFocusRef]);
  const returnFocus = restoreFocus && !finalFocusRef;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FocusTrap,
    {
      crossFrame: lockFocusAcrossFrames,
      persistentFocus,
      autoFocus,
      disabled: isDisabled2,
      onActivation,
      onDeactivation,
      returnFocus,
      children
    }
  );
};
FocusLock.displayName = "FocusLock";
var useSafeLayoutEffect = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
function useCallbackRef(fn2, deps = []) {
  const ref = reactExports.useRef(fn2);
  useSafeLayoutEffect(() => {
    ref.current = fn2;
  });
  return reactExports.useCallback((...args) => {
    var _a4;
    return (_a4 = ref.current) == null ? void 0 : _a4.call(ref, ...args);
  }, deps);
}
function useId(idProp, prefix2) {
  const id2 = reactExports.useId();
  return reactExports.useMemo(
    () => idProp || [prefix2, id2].filter(Boolean).join("-"),
    [idProp, prefix2, id2]
  );
}
function useControllableProp(prop, state2) {
  const isControlled = prop !== void 0;
  const value = isControlled && typeof prop !== "undefined" ? prop : state2;
  return [isControlled, value];
}
function useDisclosure$1(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const onOpenPropCallbackRef = useCallbackRef(onOpenProp);
  const onClosePropCallbackRef = useCallbackRef(onCloseProp);
  const [isOpenState, setIsOpen] = reactExports.useState(props.defaultIsOpen || false);
  const [isControlled, isOpen] = useControllableProp(isOpenProp, isOpenState);
  const id2 = useId(idProp, "disclosure");
  const onClose = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
  }, [isControlled, onClosePropCallbackRef]);
  const onOpen = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
  }, [isControlled, onOpenPropCallbackRef]);
  const onToggle = reactExports.useCallback(() => {
    const action2 = isOpen ? onClose : onOpen;
    action2();
  }, [isOpen, onOpen, onClose]);
  return {
    isOpen: !!isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps: (props2 = {}) => ({
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick: callAllHandlers(props2.onClick, onToggle)
    }),
    getDisclosureProps: (props2 = {}) => ({
      ...props2,
      hidden: !isOpen,
      id: id2
    })
  };
}
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$1(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text, options2) {
  var debug, message, reselectPrevious, range, selection, mark2, success = false;
  if (!options2) {
    options2 = {};
  }
  debug = options2.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range = document.createRange();
    selection = document.getSelection();
    mark2 = document.createElement("span");
    mark2.textContent = text;
    mark2.ariaHidden = "true";
    mark2.style.all = "unset";
    mark2.style.position = "fixed";
    mark2.style.top = 0;
    mark2.style.clip = "rect(0, 0, 0, 0)";
    mark2.style.whiteSpace = "pre";
    mark2.style.webkitUserSelect = "text";
    mark2.style.MozUserSelect = "text";
    mark2.style.msUserSelect = "text";
    mark2.style.userSelect = "text";
    mark2.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options2.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options2.format, text);
        }
      }
      if (options2.onCopy) {
        e2.preventDefault();
        options2.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark2);
    range.selectNodeContents(mark2);
    selection.addRange(range);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options2.format || "text", text);
      options2.onCopy && options2.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format$1("message" in options2 ? options2.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark2) {
      document.body.removeChild(mark2);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy$1;
const copy$2 = /* @__PURE__ */ getDefaultExportFromCjs(copyToClipboard);
var Input$2 = forwardRef(function Input2(props, ref) {
  const { htmlSize, ...rest } = props;
  const styles2 = useMultiStyleConfig("Input", rest);
  const ownProps = omitThemingProps(rest);
  const input = useFormControl(ownProps);
  const _className = cx("chakra-input", props.className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.input,
    {
      size: htmlSize,
      ...input,
      __css: styles2.field,
      ref,
      className: _className
    }
  );
});
Input$2.displayName = "Input";
Input$2.id = "Input";
function mapResponsive(prop, mapper) {
  if (Array.isArray(prop)) {
    return prop.map((item) => item === null ? null : mapper(item));
  }
  if (isObject$2(prop)) {
    return Object.keys(prop).reduce((result, key2) => {
      result[key2] = mapper(prop[key2]);
      return result;
    }, {});
  }
  if (prop != null) {
    return mapper(prop);
  }
  return null;
}
var Wrap = forwardRef(function Wrap2(props, ref) {
  const {
    spacing: spacing2 = "0.5rem",
    spacingX,
    spacingY,
    children,
    justify,
    direction: direction2,
    align,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const _children = reactExports.useMemo(
    () => shouldWrapChildren ? reactExports.Children.map(children, (child, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(WrapItem, { children: child }, index2)) : children,
    [children, shouldWrapChildren]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.div, { ref, className: cx("chakra-wrap", className), ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.ul,
    {
      className: "chakra-wrap__list",
      __css: {
        display: "flex",
        flexWrap: "wrap",
        justifyContent: justify,
        alignItems: align,
        flexDirection: direction2,
        listStyleType: "none",
        gap: spacing2,
        columnGap: spacingX,
        rowGap: spacingY,
        padding: "0"
      },
      children: _children
    }
  ) });
});
Wrap.displayName = "Wrap";
var WrapItem = forwardRef(function WrapItem2(props, ref) {
  const { className, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.li,
    {
      ref,
      __css: { display: "flex", alignItems: "flex-start" },
      className: cx("chakra-wrap__listitem", className),
      ...rest
    }
  );
});
WrapItem.displayName = "WrapItem";
var StackItem = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.div,
  {
    className: "chakra-stack__item",
    ...props,
    __css: {
      display: "inline-block",
      flex: "0 0 auto",
      minWidth: 0,
      ...props["__css"]
    }
  }
);
StackItem.displayName = "StackItem";
function getDividerStyles(options2) {
  const { spacing: spacing2, direction: direction2 } = options2;
  const dividerStyles = {
    column: {
      my: spacing2,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: spacing2,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: spacing2,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: spacing2,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": mapResponsive(
      direction2,
      (value) => dividerStyles[value]
    )
  };
}
var Stack = forwardRef((props, ref) => {
  const {
    isInline,
    direction: directionProp,
    align,
    justify,
    spacing: spacing2 = "0.5rem",
    wrap: wrap2,
    children,
    divider,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const direction2 = isInline ? "row" : directionProp != null ? directionProp : "column";
  const dividerStyle = reactExports.useMemo(
    () => getDividerStyles({ spacing: spacing2, direction: direction2 }),
    [spacing2, direction2]
  );
  const hasDivider = !!divider;
  const shouldUseChildren = !shouldWrapChildren && !hasDivider;
  const clones = reactExports.useMemo(() => {
    const validChildren = getValidChildren(children);
    return shouldUseChildren ? validChildren : validChildren.map((child, index2) => {
      const key2 = typeof child.key !== "undefined" ? child.key : index2;
      const isLast = index2 + 1 === validChildren.length;
      const wrappedChild = /* @__PURE__ */ jsxRuntimeExports.jsx(StackItem, { children: child }, key2);
      const _child = shouldWrapChildren ? wrappedChild : child;
      if (!hasDivider)
        return _child;
      const clonedDivider = reactExports.cloneElement(
        divider,
        {
          __css: dividerStyle
        }
      );
      const _divider = isLast ? null : clonedDivider;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
        _child,
        _divider
      ] }, key2);
    });
  }, [
    divider,
    dividerStyle,
    hasDivider,
    shouldUseChildren,
    shouldWrapChildren,
    children
  ]);
  const _className = cx("chakra-stack", className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ref,
      display: "flex",
      alignItems: align,
      justifyContent: justify,
      flexDirection: direction2,
      flexWrap: wrap2,
      gap: hasDivider ? void 0 : spacing2,
      className: _className,
      ...rest,
      children: clones
    }
  );
});
Stack.displayName = "Stack";
var HStack = forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "row", ref }));
HStack.displayName = "HStack";
var Heading = forwardRef(function Heading2(props, ref) {
  const styles2 = useStyleConfig("Heading", props);
  const { className, ...rest } = omitThemingProps(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.h2,
    {
      ref,
      className: cx("chakra-heading", props.className),
      ...rest,
      __css: styles2
    }
  );
});
Heading.displayName = "Heading";
function isPrintableCharacter(event) {
  const { key: key2 } = event;
  return key2.length === 1 || key2.length > 1 && /[^a-zA-Z0-9]/.test(key2);
}
function useShortcut(props = {}) {
  const { timeout = 300, preventDefault = () => true } = props;
  const [keys2, setKeys] = reactExports.useState([]);
  const timeoutRef = reactExports.useRef();
  const flush = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  const clearKeysAfterDelay = () => {
    flush();
    timeoutRef.current = setTimeout(() => {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  reactExports.useEffect(() => flush, []);
  function onKeyDown(fn2) {
    return (event) => {
      if (event.key === "Backspace") {
        const keysCopy = [...keys2];
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        const keysCopy = keys2.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(keysCopy);
        fn2(keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(
      (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
    );
    return foundItem;
  }
  const matchingItems = items.filter(
    (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
  );
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}
function useEventListeners() {
  const listeners = reactExports.useRef(/* @__PURE__ */ new Map());
  const currentListeners = listeners.current;
  const add2 = reactExports.useCallback((el2, type2, listener, options2) => {
    listeners.current.set(listener, { type: type2, el: el2, options: options2 });
    el2.addEventListener(type2, listener, options2);
  }, []);
  const remove3 = reactExports.useCallback(
    (el2, type2, listener, options2) => {
      el2.removeEventListener(type2, listener, options2);
      listeners.current.delete(listener);
    },
    []
  );
  reactExports.useEffect(
    () => () => {
      currentListeners.forEach((value, key2) => {
        remove3(value.el, value.type, key2, value.options);
      });
    },
    [remove3, currentListeners]
  );
  return { add: add2, remove: remove3 };
}
function isValidElement(event) {
  const element = event.target;
  const { tagName, isContentEditable: isContentEditable2 } = element;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable2 !== true;
}
function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  const [isButton, setIsButton] = reactExports.useState(true);
  const [isPressed, setIsPressed] = reactExports.useState(false);
  const listeners = useEventListeners();
  const refCallback = (node2) => {
    if (!node2)
      return;
    if (node2.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };
  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  const handleClick = reactExports.useCallback(
    (event) => {
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      const self2 = event.currentTarget;
      self2.focus();
      onClick == null ? void 0 : onClick(event);
    },
    [isDisabled2, onClick]
  );
  const onDocumentKeyUp = reactExports.useCallback(
    (e2) => {
      if (isPressed && isValidElement(e2)) {
        e2.preventDefault();
        e2.stopPropagation();
        setIsPressed(false);
        listeners.remove(document, "keyup", onDocumentKeyUp, false);
      }
    },
    [isPressed, listeners]
  );
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey) {
        return;
      }
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(true);
      }
      if (shouldClickOnEnter) {
        event.preventDefault();
        const self2 = event.currentTarget;
        self2.click();
      }
      listeners.add(document, "keyup", onDocumentKeyUp, false);
    },
    [
      isDisabled2,
      isButton,
      onKeyDown,
      clickOnEnter,
      clickOnSpace,
      listeners,
      onDocumentKeyUp
    ]
  );
  const handleKeyUp = reactExports.useCallback(
    (event) => {
      onKeyUp == null ? void 0 : onKeyUp(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey)
        return;
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(false);
        const self2 = event.currentTarget;
        self2.click();
      }
    },
    [clickOnSpace, isButton, isDisabled2, onKeyUp]
  );
  const onDocumentMouseUp = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      setIsPressed(false);
      listeners.remove(document, "mouseup", onDocumentMouseUp, false);
    },
    [listeners]
  );
  const handleMouseDown = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      if (!isButton) {
        setIsPressed(true);
      }
      const target = event.currentTarget;
      target.focus({ preventScroll: true });
      listeners.add(document, "mouseup", onDocumentMouseUp, false);
      onMouseDown == null ? void 0 : onMouseDown(event);
    },
    [isDisabled2, isButton, onMouseDown, listeners, onDocumentMouseUp]
  );
  const handleMouseUp = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (!isButton) {
        setIsPressed(false);
      }
      onMouseUp == null ? void 0 : onMouseUp(event);
    },
    [onMouseUp, isButton]
  );
  const handleMouseOver = reactExports.useCallback(
    (event) => {
      if (isDisabled2) {
        event.preventDefault();
        return;
      }
      onMouseOver == null ? void 0 : onMouseOver(event);
    },
    [isDisabled2, onMouseOver]
  );
  const handleMouseLeave = reactExports.useCallback(
    (event) => {
      if (isPressed) {
        event.preventDefault();
        setIsPressed(false);
      }
      onMouseLeave == null ? void 0 : onMouseLeave(event);
    },
    [isPressed, onMouseLeave]
  );
  const ref = mergeRefs(htmlRef, refCallback);
  if (isButton) {
    return {
      ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled2,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }
  return {
    ...htmlProps,
    ref,
    role: "button",
    "data-active": dataAttr(isPressed),
    "aria-disabled": isDisabled2 ? "true" : void 0,
    tabIndex: trulyDisabled ? void 0 : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}
function preventReturnFocus(containerRef) {
  const el2 = containerRef.current;
  if (!el2)
    return false;
  const activeElement = getActiveElement(el2);
  if (!activeElement)
    return false;
  if (el2.contains(activeElement))
    return false;
  if (isTabbable(activeElement))
    return true;
  return false;
}
function useFocusOnHide(containerRef, options2) {
  const { shouldFocus: shouldFocusProp, visible, focusRef } = options2;
  const shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(() => {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el2 = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    let rafId;
    if (el2) {
      rafId = requestAnimationFrame(() => {
        el2.focus({ preventScroll: true });
      });
      return () => {
        cancelAnimationFrame(rafId);
      };
    }
  }, [shouldFocus, containerRef, focusRef]);
}
var toVar = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});
var cssVars = {
  arrowShadowColor: toVar("--popper-arrow-shadow-color"),
  arrowSize: toVar("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar("--popper-arrow-size-half"),
  arrowBg: toVar("--popper-arrow-bg"),
  transformOrigin: toVar("--popper-transform-origin"),
  arrowOffset: toVar("--popper-arrow-offset")
};
function getBoxShadow(placement) {
  if (placement.includes("top"))
    return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom"))
    return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right"))
    return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left"))
    return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
}
var transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var toTransformOrigin = (placement) => transforms[placement];
var defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners2;
  if (typeof value === "object") {
    eventListeners2 = {
      enabled: true,
      options: { ...defaultEventListeners, ...value }
    };
  } else {
    eventListeners2 = {
      enabled: value,
      options: defaultEventListeners
    };
  }
  return eventListeners2;
}
var matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: state2 }) => {
    state2.styles.popper.width = `${state2.rects.reference.width}px`;
  },
  effect: ({ state: state2 }) => () => {
    const reference2 = state2.elements.reference;
    state2.elements.popper.style.width = `${reference2.offsetWidth}px`;
  }
};
var transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({ state: state2 }) => {
    setTransformOrigin(state2);
  },
  effect: ({ state: state2 }) => () => {
    setTransformOrigin(state2);
  }
};
var setTransformOrigin = (state2) => {
  state2.elements.popper.style.setProperty(
    cssVars.transformOrigin.var,
    toTransformOrigin(state2.placement)
  );
};
var positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({ state: state2 }) => {
    setArrowStyles(state2);
  }
};
var setArrowStyles = (state2) => {
  var _a4;
  if (!state2.placement)
    return;
  const overrides = getArrowStyle$1(state2.placement);
  if (((_a4 = state2.elements) == null ? void 0 : _a4.arrow) && overrides) {
    Object.assign(state2.elements.arrow.style, {
      [overrides.property]: overrides.value,
      width: cssVars.arrowSize.varRef,
      height: cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars2 = {
      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
    };
    for (const property in vars2) {
      state2.elements.arrow.style.setProperty(property, vars2[property]);
    }
  }
};
var getArrowStyle$1 = (placement) => {
  if (placement.startsWith("top")) {
    return { property: "bottom", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("bottom")) {
    return { property: "top", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("left")) {
    return { property: "right", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("right")) {
    return { property: "left", value: cssVars.arrowOffset.varRef };
  }
};
var innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: state2 }) => {
    setInnerArrowStyles(state2);
  },
  effect: ({ state: state2 }) => () => {
    setInnerArrowStyles(state2);
  }
};
var setInnerArrowStyles = (state2) => {
  if (!state2.elements.arrow)
    return;
  const inner = state2.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!inner)
    return;
  const boxShadow = getBoxShadow(state2.placement);
  if (boxShadow) {
    inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
  }
  Object.assign(inner.style, {
    transform: "rotate(45deg)",
    background: cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
  });
};
var logicals = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
var opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir = "ltr") {
  var _a4, _b3;
  const value = ((_a4 = logicals[placement]) == null ? void 0 : _a4[dir]) || placement;
  if (dir === "ltr")
    return value;
  return (_b3 = opposites[placement]) != null ? _b3 : value;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main$1 = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow$1(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}
function isElement$2(node2) {
  var OwnElement = getWindow$1(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$2(node2) {
  var OwnElement = getWindow$1(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot$1(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref3) {
  var state2 = _ref3.state;
  Object.keys(state2.elements).forEach(function(name2) {
    var style = state2.styles[name2] || {};
    var attributes = state2.attributes[name2] || {};
    var element = state2.elements[name2];
    if (!isHTMLElement$2(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref22) {
  var state2 = _ref22.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name2) {
      var element = state2.elements[name2];
      var attributes = state2.attributes[name2] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement$2(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$2 = Math.max;
var min$2 = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$2(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref3 = isElement$2(element) ? getWindow$1(element) : window, visualViewport = _ref3.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect$1(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$2(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$2(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$2(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css4 = getComputedStyle$2(currentNode);
    if (css4.transform !== "none" || css4.perspective !== "none" || css4.contain === "paint" || ["transform", "perspective"].indexOf(css4.willChange) !== -1 || isFirefox && css4.willChange === "filter" || isFirefox && css4.filter && css4.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max$2(min2, min$2(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state2) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref3) {
  var _state$modifiersData$;
  var state2 = _ref3.state, name2 = _ref3.name, options2 = _ref3.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref22) {
  var state2 = _ref22.state, options2 = _ref22.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref3, win) {
  var x2 = _ref3.x, y2 = _ref3.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref22) {
  var _Object$assign2;
  var popper2 = _ref22.popper, popperRect = _ref22.popperRect, placement = _ref22.placement, variation = _ref22.variation, offsets = _ref22.offsets, position2 = _ref22.position, gpuAcceleration = _ref22.gpuAcceleration, adaptive = _ref22.adaptive, roundOffsets = _ref22.roundOffsets, isFixed = _ref22.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow$1(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref3) {
  var state2 = _ref3.state, instance = _ref3.instance, options2 = _ref3.options;
  var _options$scroll = options2.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$2[matched];
  });
}
var hash$1 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash$1[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow$1(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow$1(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x2 += max$2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent$1(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$2(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent$1(getParentNode$1(node2));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent$1(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode$1(target)))
  );
}
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect(getDocumentElement$1(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$2(element) ? getOffsetParent(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$2(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$2(rect.right, accRect.right);
    accRect.bottom = min$2(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref3) {
  var reference2 = _ref3.reference, element = _ref3.element, placement = _ref3.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$2(element) ? element : element.contextElement || getDocumentElement$1(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply2 = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply2;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b2) {
    return overflows[a] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref3) {
  var state2 = _ref3.state, options2 = _ref3.options, name2 = _ref3.name;
  if (state2.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding2 = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name2]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref3) {
  var state2 = _ref3.state, name2 = _ref3.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref3 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref3[0], distance2 = _ref3[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref22) {
  var state2 = _ref22.state, options2 = _ref22.options, name2 = _ref22.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x2;
    state2.modifiersData.popperOffsets.y += y2;
  }
  state2.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref3) {
  var state2 = _ref3.state, name2 = _ref3.name;
  state2.modifiersData[name2] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref3) {
  var state2 = _ref3.state, options2 = _ref3.options, name2 = _ref3.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding2 = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$2(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow$1(node2) || !isHTMLElement$2(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  var offsetParentIsScaled = isHTMLElement$2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$2(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map3 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map3.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map3.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve28) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve28(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options3);
        state2.scrollParents = {
          reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name: name2,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve28) {
          instance.forceUpdate();
          resolve28(state2);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state3) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref$options = _ref3.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name: name2,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners: eventListeners2 = true,
    offset: offset2,
    gutter = 8,
    flip: flip2 = true,
    boundary = "clippingParents",
    preventOverflow: preventOverflow2 = true,
    matchWidth: matchWidth2,
    direction: direction2 = "ltr"
  } = props;
  const reference2 = reactExports.useRef(null);
  const popper2 = reactExports.useRef(null);
  const instance = reactExports.useRef(null);
  const placement = getPopperPlacement(placementProp, direction2);
  const cleanup = reactExports.useRef(() => {
  });
  const setupPopper = reactExports.useCallback(() => {
    var _a4;
    if (!enabled || !reference2.current || !popper2.current)
      return;
    (_a4 = cleanup.current) == null ? void 0 : _a4.call(cleanup);
    instance.current = createPopper(reference2.current, popper2.current, {
      placement,
      modifiers: [
        innerArrow,
        positionArrow,
        transformOrigin,
        {
          ...matchWidth,
          enabled: !!matchWidth2
        },
        {
          name: "eventListeners",
          ...getEventListenerOptions(eventListeners2)
        },
        {
          name: "arrow",
          options: { padding: arrowPadding }
        },
        {
          name: "offset",
          options: {
            offset: offset2 != null ? offset2 : [0, gutter]
          }
        },
        {
          name: "flip",
          enabled: !!flip2,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!preventOverflow2,
          options: { boundary }
        },
        // allow users override internal modifiers
        ...modifiers != null ? modifiers : []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled,
    modifiers,
    matchWidth2,
    eventListeners2,
    arrowPadding,
    offset2,
    gutter,
    flip2,
    preventOverflow2,
    boundary,
    strategy
  ]);
  reactExports.useEffect(() => {
    return () => {
      var _a4;
      if (!reference2.current && !popper2.current) {
        (_a4 = instance.current) == null ? void 0 : _a4.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = reactExports.useCallback(
    (node2) => {
      reference2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = reactExports.useCallback(
    (node2) => {
      popper2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props2.style,
        position: strategy,
        minWidth: matchWidth2 ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth2]
  );
  const getArrowProps = reactExports.useCallback((props2 = {}, ref = null) => {
    const { size: size2, shadowColor, bg: bg2, style, ...rest } = props2;
    return {
      ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle(props2)
    };
  }, []);
  const getArrowInnerProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      var _a4;
      (_a4 = instance.current) == null ? void 0 : _a4.update();
    },
    forceUpdate() {
      var _a4;
      (_a4 = instance.current) == null ? void 0 : _a4.forceUpdate();
    },
    transformOrigin: cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}
function getArrowStyle(props) {
  const { size: size2, shadowColor, bg: bg2, style } = props;
  const computedStyle = { ...style, position: "absolute" };
  if (size2) {
    computedStyle["--popper-arrow-size"] = size2;
  }
  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }
  if (bg2) {
    computedStyle["--popper-arrow-bg"] = bg2;
  }
  return computedStyle;
}
function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const handleOpen = useCallbackRef$2(onOpenProp);
  const handleClose = useCallbackRef$2(onCloseProp);
  const [isOpenState, setIsOpen] = reactExports.useState(props.defaultIsOpen || false);
  const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
  const isControlled = isOpenProp !== void 0;
  const uid = reactExports.useId();
  const id2 = idProp != null ? idProp : `disclosure-${uid}`;
  const onClose = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = reactExports.useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      onOpen();
    }
  }, [isOpen, onOpen, onClose]);
  function getButtonProps(props2 = {}) {
    return {
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick(event) {
        var _a4;
        (_a4 = props2.onClick) == null ? void 0 : _a4.call(props2, event);
        onToggle();
      }
    };
  }
  function getDisclosureProps(props2 = {}) {
    return {
      ...props2,
      hidden: !isOpen,
      id: id2
    };
  }
  return {
    isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps,
    getDisclosureProps
  };
}
function useOutsideClick(props) {
  const { ref, handler, enabled = true } = props;
  const savedHandler = useCallbackRef$2(handler);
  const stateRef = reactExports.useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state2 = stateRef.current;
  reactExports.useEffect(() => {
    if (!enabled)
      return;
    const onPointerDown = (e2) => {
      if (isValidEvent(e2, ref)) {
        state2.isPointerDown = true;
      }
    };
    const onMouseUp = (event) => {
      if (state2.ignoreEmulatedMouseEvents) {
        state2.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state2.isPointerDown && handler && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = (event) => {
      state2.ignoreEmulatedMouseEvents = true;
      if (handler && state2.isPointerDown && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = getOwnerDocument$1(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state2, enabled]);
}
function isValidEvent(event, ref) {
  var _a4;
  const target = event.target;
  if (target) {
    const doc = getOwnerDocument$1(target);
    if (!doc.contains(target))
      return false;
  }
  return !((_a4 = ref.current) == null ? void 0 : _a4.contains(target));
}
function getOwnerDocument$1(node2) {
  var _a4;
  return (_a4 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a4 : document;
}
function useAnimationState(props) {
  const { isOpen, ref } = props;
  const [mounted, setMounted] = reactExports.useState(isOpen);
  const [once3, setOnce] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!once3) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once3, mounted]);
  useEventListener(
    () => ref.current,
    "animationend",
    () => {
      setMounted(isOpen);
    }
  );
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete() {
      var _a4;
      const win = getOwnerWindow(ref.current);
      const evt = new win.CustomEvent("animationend", { bubbles: true });
      (_a4 = ref.current) == null ? void 0 : _a4.dispatchEvent(evt);
    }
  };
}
function lazyDisclosure(options2) {
  const { wasSelected, enabled, isSelected, mode: mode2 = "unmount" } = options2;
  if (!enabled)
    return true;
  if (isSelected)
    return true;
  if (mode2 === "keepMounted" && wasSelected)
    return true;
  return false;
}
var [
  MenuDescendantsProvider,
  useMenuDescendantsContext,
  useMenuDescendants,
  useMenuDescendant
] = createDescendantContext();
var [MenuProvider, useMenuContext] = createContext$1({
  strict: false,
  name: "MenuContext"
});
function useIds$1(idProp, ...prefixes) {
  const reactId = reactExports.useId();
  const id2 = idProp || reactId;
  return reactExports.useMemo(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
function getOwnerDocument(node2) {
  var _a4;
  return (_a4 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a4 : document;
}
function isActiveElement(element) {
  const doc = getOwnerDocument(element);
  return doc.activeElement === element;
}
function useMenu(props = {}) {
  const {
    id: id2,
    closeOnSelect = true,
    closeOnBlur = true,
    initialFocusRef,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction: direction2,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  const menuRef = reactExports.useRef(null);
  const buttonRef = reactExports.useRef(null);
  const descendants = useMenuDescendants();
  const focusMenu = reactExports.useCallback(() => {
    requestAnimationFrame(() => {
      var _a4;
      (_a4 = menuRef.current) == null ? void 0 : _a4.focus({ preventScroll: false });
    });
  }, []);
  const focusFirstItem = reactExports.useCallback(() => {
    const id22 = setTimeout(() => {
      var _a4;
      if (initialFocusRef) {
        (_a4 = initialFocusRef.current) == null ? void 0 : _a4.focus();
      } else {
        const first = descendants.firstEnabled();
        if (first)
          setFocusedIndex(first.index);
      }
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const focusLastItem = reactExports.useCallback(() => {
    const id22 = setTimeout(() => {
      const last2 = descendants.lastEnabled();
      if (last2)
        setFocusedIndex(last2.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants]);
  const onOpenInternal = reactExports.useCallback(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  useOutsideClick({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: (event) => {
      var _a4;
      if (!((_a4 = buttonRef.current) == null ? void 0 : _a4.contains(event.target))) {
        onClose();
      }
    }
  });
  const popper2 = usePopper({
    ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction: direction2
  });
  const [focusedIndex, setFocusedIndex] = reactExports.useState(-1);
  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  const animationState = useAnimationState({ isOpen, ref: menuRef });
  const [buttonId, menuId] = useIds$1(id2, `menu-button`, `menu-list`);
  const openAndFocusMenu = reactExports.useCallback(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = reactExports.useRef(/* @__PURE__ */ new Set([]));
  reactExports.useEffect(() => {
    const ids = timeoutIds.current;
    return () => {
      ids.forEach((id22) => clearTimeout(id22));
      ids.clear();
    };
  }, []);
  const openAndFocusFirstItem = reactExports.useCallback(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = reactExports.useCallback(() => {
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = reactExports.useCallback(() => {
    var _a4, _b3;
    const doc = getOwnerDocument(menuRef.current);
    const hasFocusWithin = (_a4 = menuRef.current) == null ? void 0 : _a4.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus)
      return;
    const node2 = (_b3 = descendants.item(focusedIndex)) == null ? void 0 : _b3.node;
    node2 == null ? void 0 : node2.focus({ preventScroll: true });
  }, [isOpen, focusedIndex, descendants]);
  const rafId = reactExports.useRef(null);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    unstable__animationState: animationState,
    descendants,
    popper: popper2,
    buttonId,
    menuId,
    forceUpdate: popper2.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior,
    initialFocusRef,
    rafId
  };
}
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const { onToggle, popper: popper2, openAndFocusFirstItem, openAndFocusLastItem } = menu;
  const onKeyDown = reactExports.useCallback(
    (event) => {
      const eventKey = event.key;
      const keyMap = {
        Enter: openAndFocusFirstItem,
        ArrowDown: openAndFocusFirstItem,
        ArrowUp: openAndFocusLastItem
      };
      const action2 = keyMap[eventKey];
      if (action2) {
        event.preventDefault();
        event.stopPropagation();
        action2(event);
      }
    },
    [openAndFocusFirstItem, openAndFocusLastItem]
  );
  return {
    ...props,
    ref: mergeRefs(menu.buttonRef, externalRef, popper2.referenceRef),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers$1(props.onClick, onToggle),
    onKeyDown: callAllHandlers$1(props.onKeyDown, onKeyDown)
  };
}
function isTargetMenuItem(target) {
  var _a4;
  return isHTMLElement$1(target) && !!((_a4 = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a4.startsWith("menuitem"));
}
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();
  if (!menu) {
    throw new Error(
      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`
    );
  }
  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior,
    unstable__animationState: animated
  } = menu;
  const descendants = useMenuDescendantsContext();
  const createTypeaheadHandler = useShortcut({
    preventDefault: (event) => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = reactExports.useCallback(
    (event) => {
      if (!event.currentTarget.contains(event.target))
        return;
      const eventKey = event.key;
      const keyMap = {
        Tab: (event2) => event2.preventDefault(),
        Escape: onClose,
        ArrowDown: () => {
          const next2 = descendants.nextEnabled(focusedIndex);
          if (next2)
            setFocusedIndex(next2.index);
        },
        ArrowUp: () => {
          const prev2 = descendants.prevEnabled(focusedIndex);
          if (prev2)
            setFocusedIndex(prev2.index);
        }
      };
      const fn2 = keyMap[eventKey];
      if (fn2) {
        event.preventDefault();
        fn2(event);
        return;
      }
      const onTypeahead = createTypeaheadHandler((character2) => {
        const nextItem = getNextItemFromSearch(
          descendants.values(),
          character2,
          (item) => {
            var _a4, _b3;
            return (_b3 = (_a4 = item == null ? void 0 : item.node) == null ? void 0 : _a4.textContent) != null ? _b3 : "";
          },
          descendants.item(focusedIndex)
        );
        if (nextItem) {
          const index2 = descendants.indexOf(nextItem.node);
          setFocusedIndex(index2);
        }
      });
      if (isTargetMenuItem(event.target)) {
        onTypeahead(event);
      }
    },
    [
      descendants,
      focusedIndex,
      createTypeaheadHandler,
      onClose,
      setFocusedIndex
    ]
  );
  const hasBeenOpened = reactExports.useRef(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const shouldRenderChildren = lazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  return {
    ...props,
    ref: mergeRefs(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: {
      ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers$1(props.onKeyDown, onKeyDown)
  };
}
function useMenuPositioner(props = {}) {
  const { popper: popper2, isOpen } = useMenuContext();
  return popper2.getPopperProps({
    ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    onFocus: onFocusProp,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect,
    type: typeProp,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuRef,
    isOpen,
    menuId,
    rafId
  } = menu;
  const ref = reactExports.useRef(null);
  const id2 = `${menuId}-menuitem-${reactExports.useId()}`;
  const { index: index2, register: register2 } = useMenuDescendant({
    disabled: isDisabled2 && !isFocusable2
  });
  const onMouseEnter = reactExports.useCallback(
    (event) => {
      onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(index2);
    },
    [setFocusedIndex, index2, isDisabled2, onMouseEnterProp]
  );
  const onMouseMove = reactExports.useCallback(
    (event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (ref.current && !isActiveElement(ref.current)) {
        onMouseEnter(event);
      }
    },
    [onMouseEnter, onMouseMoveProp]
  );
  const onMouseLeave = reactExports.useCallback(
    (event) => {
      onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(-1);
    },
    [setFocusedIndex, isDisabled2, onMouseLeaveProp]
  );
  const onClick = reactExports.useCallback(
    (event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (!isTargetMenuItem(event.currentTarget))
        return;
      if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {
        onClose();
      }
    },
    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]
  );
  const onFocus4 = reactExports.useCallback(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      setFocusedIndex(index2);
    },
    [setFocusedIndex, onFocusProp, index2]
  );
  const isFocused = index2 === focusedIndex;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  useUpdateEffect(() => {
    if (!isOpen)
      return;
    if (isFocused && !trulyDisabled && ref.current) {
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
      rafId.current = requestAnimationFrame(() => {
        var _a4;
        (_a4 = ref.current) == null ? void 0 : _a4.focus({ preventScroll: true });
        rafId.current = null;
      });
    } else if (menuRef.current && !isActiveElement(menuRef.current)) {
      menuRef.current.focus({ preventScroll: true });
    }
    return () => {
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  const clickableProps = useClickable({
    onClick,
    onFocus: onFocus4,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(register2, ref, externalRef),
    isDisabled: isDisabled2,
    isFocusable: isFocusable2
  });
  return {
    ...htmlProps,
    ...clickableProps,
    type: typeProp != null ? typeProp : clickableProps.type,
    id: id2,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
function isHTMLElement$1(el2) {
  var _a4;
  if (!isElement$1(el2))
    return false;
  const win = (_a4 = el2.ownerDocument.defaultView) != null ? _a4 : window;
  return el2 instanceof win.HTMLElement;
}
function isElement$1(el2) {
  return el2 != null && typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
}
var [MenuStylesProvider, useMenuStyles] = createContext$1({
  name: `MenuStylesContext`,
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
});
var Menu$2 = (props) => {
  const { children } = props;
  const styles2 = useMultiStyleConfig("Menu", props);
  const ownProps = omitThemingProps(props);
  const { direction: direction2 } = useTheme();
  const { descendants, ...ctx } = useMenu({ ...ownProps, direction: direction2 });
  const context = reactExports.useMemo(() => ctx, [ctx]);
  const { isOpen, onClose, forceUpdate } = context;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDescendantsProvider, { value: descendants, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuStylesProvider, { value: styles2, children: runIfFn$2(children, { isOpen, onClose, forceUpdate }) }) }) });
};
Menu$2.displayName = "Menu";
var MenuCommand = forwardRef(
  (props, ref) => {
    const styles2 = useMenuStyles();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.span,
      {
        ref,
        ...props,
        __css: styles2.command,
        className: "chakra-menu__command"
      }
    );
  }
);
MenuCommand.displayName = "MenuCommand";
var StyledMenuItem = forwardRef(
  (props, ref) => {
    const { type: type2, ...rest } = props;
    const styles2 = useMenuStyles();
    const btnType = rest.as || type2 ? type2 != null ? type2 : void 0 : "button";
    const buttonStyles = reactExports.useMemo(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...styles2.item
      }),
      [styles2.item]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.button, { ref, type: btnType, ...rest, __css: buttonStyles });
  }
);
var MenuIcon = (props) => {
  const { className, children, ...rest } = props;
  const styles2 = useMenuStyles();
  const child = reactExports.Children.only(children);
  const clone = reactExports.isValidElement(child) ? reactExports.cloneElement(child, {
    focusable: "false",
    "aria-hidden": true,
    className: cx("chakra-menu__icon", child.props.className)
  }) : null;
  const _className = cx("chakra-menu__icon-wrapper", className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { className: _className, ...rest, __css: styles2.icon, children: clone });
};
MenuIcon.displayName = "MenuIcon";
var MenuItem = forwardRef((props, ref) => {
  const {
    icon,
    iconSpacing: iconSpacing2 = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = useMenuItem(rest, ref);
  const shouldWrap = icon || command;
  const _children = shouldWrap ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { pointerEvents: "none", flex: 1 }, children }) : children;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    StyledMenuItem,
    {
      ...menuitemProps,
      className: cx("chakra-menu__menuitem", menuitemProps.className),
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuIcon, { fontSize: "0.8em", marginEnd: iconSpacing2, children: icon }),
        _children,
        command && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuCommand, { marginStart: commandSpacing, children: command })
      ]
    }
  );
});
MenuItem.displayName = "MenuItem";
var motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
};
var MenuTransition = chakra(motion.div);
var MenuList$1 = forwardRef(function MenuList2(props, ref) {
  var _a4, _b3;
  const { rootProps, motionProps, ...rest } = props;
  const {
    isOpen,
    onTransitionEnd,
    unstable__animationState: animated
  } = useMenuContext();
  const listProps = useMenuList(rest, ref);
  const positionerProps = useMenuPositioner(rootProps);
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ...positionerProps,
      __css: { zIndex: (_b3 = props.zIndex) != null ? _b3 : (_a4 = styles2.list) == null ? void 0 : _a4.zIndex },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuTransition,
        {
          variants: motionVariants,
          initial: false,
          animate: isOpen ? "enter" : "exit",
          __css: { outline: 0, ...styles2.list },
          ...motionProps,
          className: cx("chakra-menu__menu-list", listProps.className),
          ...listProps,
          onUpdate: onTransitionEnd,
          onAnimationComplete: callAll(
            animated.onComplete,
            listProps.onAnimationComplete
          )
        }
      )
    }
  );
});
MenuList$1.displayName = "MenuList";
var StyledMenuButton = forwardRef((props, ref) => {
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.button,
    {
      ref,
      ...props,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...styles2.button
      }
    }
  );
});
var MenuButton = forwardRef(
  (props, ref) => {
    const { children, as: As, ...rest } = props;
    const buttonProps = useMenuButton(rest, ref);
    const Element2 = As || StyledMenuButton;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Element2,
      {
        ...buttonProps,
        className: cx("chakra-menu__menu-button", props.className),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          chakra.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: props.children
          }
        )
      }
    );
  }
);
MenuButton.displayName = "MenuButton";
var transitions$1 = {
  slideInBottom: {
    ...slideFadeConfig,
    custom: { offsetY: 16, reverse: true }
  },
  slideInRight: {
    ...slideFadeConfig,
    custom: { offsetX: 16, reverse: true }
  },
  slideInTop: {
    ...slideFadeConfig,
    custom: { offsetY: -16, reverse: true }
  },
  slideInLeft: {
    ...slideFadeConfig,
    custom: { offsetX: -16, reverse: true }
  },
  scale: {
    ...scaleFadeConfig,
    custom: { initialScale: 0.95, reverse: true }
  },
  none: {}
};
var MotionSection = chakra(motion.section);
var getMotionProps = (preset) => {
  return transitions$1[preset || "none"];
};
var ModalTransition = reactExports.forwardRef(
  (props, ref) => {
    const { preset, motionProps = getMotionProps(preset), ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MotionSection, { ref, ...motionProps, ...rest });
  }
);
ModalTransition.displayName = "ModalTransition";
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField2 = (obj, key2, value) => {
  __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var ModalManager = class {
  constructor() {
    __publicField2(this, "modals");
    this.modals = /* @__PURE__ */ new Map();
  }
  add(modal) {
    this.modals.set(modal, this.modals.size + 1);
    return this.modals.size;
  }
  remove(modal) {
    this.modals.delete(modal);
  }
  isTopModal(modal) {
    if (!modal)
      return false;
    return this.modals.get(modal) === this.modals.size;
  }
};
var modalManager = new ModalManager();
function useModalManager(ref, isOpen) {
  const [index2, setIndex] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node2 = ref.current;
    if (!node2)
      return;
    if (isOpen) {
      const index22 = modalManager.add(node2);
      setIndex(index22);
    }
    return () => {
      modalManager.remove(node2);
      setIndex(0);
    };
  }, [isOpen, ref]);
  return index2;
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        var attr = node2.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node2) || 0) + 1;
        var markerValue = (markerCounter.get(node2) || 0) + 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        hiddenNodes.push(node2);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node2, true);
        }
        if (markerValue === 1) {
          node2.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node2.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
function useModal(props) {
  const {
    isOpen,
    onClose,
    id: id2,
    closeOnOverlayClick = true,
    closeOnEsc = true,
    useInert = true,
    onOverlayClick: onOverlayClickProp,
    onEsc
  } = props;
  const dialogRef = reactExports.useRef(null);
  const overlayRef = reactExports.useRef(null);
  const [dialogId, headerId, bodyId] = useIds(
    id2,
    `chakra-modal`,
    `chakra-modal--header`,
    `chakra-modal--body`
  );
  useAriaHidden(dialogRef, isOpen && useInert);
  const index2 = useModalManager(dialogRef, isOpen);
  const mouseDownTarget = reactExports.useRef(null);
  const onMouseDown = reactExports.useCallback((event) => {
    mouseDownTarget.current = event.target;
  }, []);
  const onKeyDown = reactExports.useCallback(
    (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        if (closeOnEsc) {
          onClose == null ? void 0 : onClose();
        }
        onEsc == null ? void 0 : onEsc();
      }
    },
    [closeOnEsc, onClose, onEsc]
  );
  const [headerMounted, setHeaderMounted] = reactExports.useState(false);
  const [bodyMounted, setBodyMounted] = reactExports.useState(false);
  const getDialogProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      role: "dialog",
      ...props2,
      ref: mergeRefs(ref, dialogRef),
      id: dialogId,
      tabIndex: -1,
      "aria-modal": true,
      "aria-labelledby": headerMounted ? headerId : void 0,
      "aria-describedby": bodyMounted ? bodyId : void 0,
      onClick: callAllHandlers$1(
        props2.onClick,
        (event) => event.stopPropagation()
      )
    }),
    [bodyId, bodyMounted, dialogId, headerId, headerMounted]
  );
  const onOverlayClick = reactExports.useCallback(
    (event) => {
      event.stopPropagation();
      if (mouseDownTarget.current !== event.target)
        return;
      if (!modalManager.isTopModal(dialogRef.current))
        return;
      if (closeOnOverlayClick) {
        onClose == null ? void 0 : onClose();
      }
      onOverlayClickProp == null ? void 0 : onOverlayClickProp();
    },
    [onClose, closeOnOverlayClick, onOverlayClickProp]
  );
  const getDialogContainerProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(ref, overlayRef),
      onClick: callAllHandlers$1(props2.onClick, onOverlayClick),
      onKeyDown: callAllHandlers$1(props2.onKeyDown, onKeyDown),
      onMouseDown: callAllHandlers$1(props2.onMouseDown, onMouseDown)
    }),
    [onKeyDown, onMouseDown, onOverlayClick]
  );
  return {
    isOpen,
    onClose,
    headerId,
    bodyId,
    setBodyMounted,
    setHeaderMounted,
    dialogRef,
    overlayRef,
    getDialogProps,
    getDialogContainerProps,
    index: index2
  };
}
function useAriaHidden(ref, shouldHide) {
  const currentElement = ref.current;
  reactExports.useEffect(() => {
    if (!ref.current || !shouldHide)
      return void 0;
    return hideOthers(ref.current);
  }, [shouldHide, ref, currentElement]);
}
function useIds(idProp, ...prefixes) {
  const reactId = reactExports.useId();
  const id2 = idProp || reactId;
  return reactExports.useMemo(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
var [ModalStylesProvider, useModalStyles] = createContext$1({
  name: `ModalStylesContext`,
  errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
});
var [ModalContextProvider, useModalContext] = createContext$1({
  strict: true,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
});
var Modal = (props) => {
  const modalProps = {
    scrollBehavior: "outside",
    autoFocus: true,
    trapFocus: true,
    returnFocusOnClose: true,
    blockScrollOnMount: true,
    allowPinchZoom: false,
    motionPreset: "scale",
    lockFocusAcrossFrames: true,
    ...props
  };
  const {
    portalProps,
    children,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames,
    onCloseComplete
  } = modalProps;
  const styles2 = useMultiStyleConfig("Modal", modalProps);
  const modal = useModal(modalProps);
  const context = {
    ...modal,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ModalContextProvider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalStylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { onExitComplete: onCloseComplete, children: context.isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { ...portalProps, children }) }) }) });
};
Modal.displayName = "Modal";
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll$1 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a4 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a4[0], setCallbacks = _a4[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container2 = _b3 === void 0 ? "div" : _b3, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css4) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css4;
  } else {
    tag.appendChild(document.createTextNode(css4));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a4) {
    var styles2 = _a4.styles, dynamic = _a4.dynamic;
    useStyle2(styles2, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$8 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$8(left2), parse$8(top2), parse$8(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var getStyles = function(_a4, allowRelative, gapMode, important2) {
  var left2 = _a4.left, top2 = _a4.top, right2 = _a4.right, gap = _a4.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important2, ";\n   padding-right: ").concat(gap, "px ").concat(important2, ";\n  }\n  body {\n    overflow: hidden ").concat(important2, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important2, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important2, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important2, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important2, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important2, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important2, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important2, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a4 = props.gapMode, gapMode = _a4 === void 0 ? "margin" : _a4;
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument;
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables(axis, current), s = _a4[1], d2 = _a4[2];
      if (s > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction2) {
  return axis === "h" && direction2 === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables(axis, target), position2 = _a4[0], scroll_1 = _a4[1], capacity = _a4[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef2 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef2), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch2 = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch2[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch2[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef2).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  var shadowParent = null;
  while (node2 !== null) {
    if (node2 instanceof ShadowRoot) {
      shadowParent = node2.host;
      node2 = node2.host;
    }
    node2 = node2.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$1, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function ModalFocusScope(props) {
  const {
    autoFocus,
    trapFocus,
    dialogRef,
    initialFocusRef,
    blockScrollOnMount,
    allowPinchZoom,
    finalFocusRef,
    returnFocusOnClose,
    preserveScrollBarGap,
    lockFocusAcrossFrames,
    isOpen
  } = useModalContext();
  const [isPresent2, safeToRemove] = usePresence();
  reactExports.useEffect(() => {
    if (!isPresent2 && safeToRemove) {
      setTimeout(safeToRemove);
    }
  }, [isPresent2, safeToRemove]);
  const index2 = useModalManager(dialogRef, isOpen);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FocusLock,
    {
      autoFocus,
      isDisabled: !trapFocus,
      initialFocusRef,
      finalFocusRef,
      restoreFocus: returnFocusOnClose,
      contentRef: dialogRef,
      lockFocusAcrossFrames,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RemoveScroll,
        {
          removeScrollBar: !preserveScrollBarGap,
          allowPinchZoom,
          enabled: index2 === 1 && blockScrollOnMount,
          forwardProps: true,
          children: props.children
        }
      )
    }
  );
}
var ModalContent = forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      containerProps: rootProps,
      motionProps,
      ...rest
    } = props;
    const { getDialogProps, getDialogContainerProps } = useModalContext();
    const dialogProps = getDialogProps(rest, ref);
    const containerProps = getDialogContainerProps(rootProps);
    const _className = cx("chakra-modal__content", className);
    const styles2 = useModalStyles();
    const dialogStyles = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...styles2.dialog
    };
    const dialogContainerStyles = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...styles2.dialogContainer
    };
    const { motionPreset } = useModalContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFocusScope, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ...containerProps,
        className: "chakra-modal__content-container",
        tabIndex: -1,
        __css: dialogContainerStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ModalTransition,
          {
            preset: motionPreset,
            motionProps,
            className: _className,
            ...dialogProps,
            __css: dialogStyles,
            children
          }
        )
      }
    ) });
  }
);
ModalContent.displayName = "ModalContent";
var [DrawerContextProvider, useDrawerContext] = createContext$1();
var placementMap = {
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
function getDrawerPlacement(placement, dir) {
  var _a4, _b3;
  if (!placement)
    return;
  return (_b3 = (_a4 = placementMap[placement]) == null ? void 0 : _a4[dir]) != null ? _b3 : placement;
}
function Drawer(props) {
  var _a4;
  const {
    isOpen,
    onClose,
    placement: placementProp = "right",
    children,
    ...rest
  } = props;
  const theme2 = useTheme();
  const drawerStyleConfig = (_a4 = theme2.components) == null ? void 0 : _a4.Drawer;
  const placement = getDrawerPlacement(placementProp, theme2.direction);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerContextProvider, { value: { placement }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      isOpen,
      onClose,
      styleConfig: drawerStyleConfig,
      ...rest,
      children
    }
  ) });
}
var MotionDiv$2 = chakra(Slide);
var DrawerContent = forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      motionProps,
      containerProps: rootProps,
      ...rest
    } = props;
    const { getDialogProps, getDialogContainerProps, isOpen } = useModalContext();
    const dialogProps = getDialogProps(rest, ref);
    const containerProps = getDialogContainerProps(rootProps);
    const _className = cx("chakra-modal__content", className);
    const styles2 = useModalStyles();
    const dialogStyles = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...styles2.dialog
    };
    const dialogContainerStyles = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...styles2.dialogContainer
    };
    const { placement } = useDrawerContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFocusScope, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ...containerProps,
        className: "chakra-modal__content-container",
        __css: dialogContainerStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MotionDiv$2,
          {
            motionProps,
            direction: placement,
            in: isOpen,
            className: _className,
            ...dialogProps,
            __css: dialogStyles,
            children
          }
        )
      }
    ) });
  }
);
DrawerContent.displayName = "DrawerContent";
var ModalFooter = forwardRef(
  (props, ref) => {
    const { className, ...rest } = props;
    const _className = cx("chakra-modal__footer", className);
    const styles2 = useModalStyles();
    const footerStyles = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      ...styles2.footer
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.footer,
      {
        ref,
        ...rest,
        __css: footerStyles,
        className: _className
      }
    );
  }
);
ModalFooter.displayName = "ModalFooter";
var ModalHeader = forwardRef(
  (props, ref) => {
    const { className, ...rest } = props;
    const { headerId, setHeaderMounted } = useModalContext();
    reactExports.useEffect(() => {
      setHeaderMounted(true);
      return () => setHeaderMounted(false);
    }, [setHeaderMounted]);
    const _className = cx("chakra-modal__header", className);
    const styles2 = useModalStyles();
    const headerStyles = {
      flex: 0,
      ...styles2.header
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.header,
      {
        ref,
        className: _className,
        id: headerId,
        ...rest,
        __css: headerStyles
      }
    );
  }
);
ModalHeader.displayName = "ModalHeader";
var MotionDiv$1 = chakra(motion.div);
var ModalOverlay = forwardRef(
  (props, ref) => {
    const { className, transition: transition2, motionProps: _motionProps, ...rest } = props;
    const _className = cx("chakra-modal__overlay", className);
    const styles2 = useModalStyles();
    const overlayStyle = {
      pos: "fixed",
      left: "0",
      top: "0",
      w: "100vw",
      h: "100vh",
      ...styles2.overlay
    };
    const { motionPreset } = useModalContext();
    const defaultMotionProps = motionPreset === "none" ? {} : fadeConfig;
    const motionProps = _motionProps || defaultMotionProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MotionDiv$1,
      {
        ...motionProps,
        __css: overlayStyle,
        ref,
        className: _className,
        ...rest
      }
    );
  }
);
ModalOverlay.displayName = "ModalOverlay";
var ModalBody = forwardRef((props, ref) => {
  const { className, ...rest } = props;
  const { bodyId, setBodyMounted } = useModalContext();
  reactExports.useEffect(() => {
    setBodyMounted(true);
    return () => setBodyMounted(false);
  }, [setBodyMounted]);
  const _className = cx("chakra-modal__body", className);
  const styles2 = useModalStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ref,
      className: _className,
      id: bodyId,
      ...rest,
      __css: styles2.body
    }
  );
});
ModalBody.displayName = "ModalBody";
var ModalCloseButton = forwardRef(
  (props, ref) => {
    const { onClick, className, ...rest } = props;
    const { onClose } = useModalContext();
    const _className = cx("chakra-modal__close-btn", className);
    const styles2 = useModalStyles();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CloseButton,
      {
        ref,
        __css: styles2.closeButton,
        className: _className,
        onClick: callAllHandlers$1(onClick, (event) => {
          event.stopPropagation();
          onClose();
        }),
        ...rest
      }
    );
  }
);
ModalCloseButton.displayName = "ModalCloseButton";
var Switch = forwardRef(function Switch2(props, ref) {
  const styles2 = useMultiStyleConfig("Switch", props);
  const { spacing: spacing2 = "0.5rem", children, ...ownProps } = omitThemingProps(props);
  const {
    getIndicatorProps,
    getInputProps,
    getCheckboxProps,
    getRootProps,
    getLabelProps
  } = useCheckbox(ownProps);
  const containerStyles = reactExports.useMemo(
    () => ({
      display: "inline-block",
      position: "relative",
      verticalAlign: "middle",
      lineHeight: 0,
      ...styles2.container
    }),
    [styles2.container]
  );
  const trackStyles = reactExports.useMemo(
    () => ({
      display: "inline-flex",
      flexShrink: 0,
      justifyContent: "flex-start",
      boxSizing: "content-box",
      cursor: "pointer",
      ...styles2.track
    }),
    [styles2.track]
  );
  const labelStyles = reactExports.useMemo(
    () => ({
      userSelect: "none",
      marginStart: spacing2,
      ...styles2.label
    }),
    [spacing2, styles2.label]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    chakra.label,
    {
      ...getRootProps(),
      className: cx("chakra-switch", props.className),
      __css: containerStyles,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: "chakra-switch__input", ...getInputProps({}, ref) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          chakra.span,
          {
            ...getCheckboxProps(),
            className: "chakra-switch__track",
            __css: trackStyles,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              chakra.span,
              {
                __css: styles2.thumb,
                className: "chakra-switch__thumb",
                ...getIndicatorProps()
              }
            )
          }
        ),
        children && /* @__PURE__ */ jsxRuntimeExports.jsx(
          chakra.span,
          {
            className: "chakra-switch__label",
            ...getLabelProps(),
            __css: labelStyles,
            children
          }
        )
      ]
    }
  );
});
Switch.displayName = "Switch";
function omit$1(object2, keysToOmit = []) {
  const clone = Object.assign({}, object2);
  for (const key2 of keysToOmit) {
    if (key2 in clone) {
      delete clone[key2];
    }
  }
  return clone;
}
var omitted = ["h", "minH", "height", "minHeight"];
var Textarea = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Textarea", props);
  const { className, rows, ...rest } = omitThemingProps(props);
  const textareaProps = useFormControl(rest);
  const textareaStyles = rows ? omit$1(styles2, omitted) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.textarea,
    {
      ref,
      rows,
      ...textareaProps,
      className: cx("chakra-textarea", className),
      __css: textareaStyles
    }
  );
});
Textarea.displayName = "Textarea";
var scale = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: { duration: 0.15, easings: "easeInOut" },
      scale: { duration: 0.2, easings: "easeInOut" }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: { easings: "easeOut", duration: 0.2 },
      scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
    }
  }
};
var getDoc = (ref) => {
  var _a4;
  return ((_a4 = ref.current) == null ? void 0 : _a4.ownerDocument) || document;
};
var getWin = (ref) => {
  var _a4, _b3;
  return ((_b3 = (_a4 = ref.current) == null ? void 0 : _a4.ownerDocument) == null ? void 0 : _b3.defaultView) || window;
};
function useTooltip(props = {}) {
  const {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    closeOnScroll,
    closeOnPointerDown = closeOnMouseDown,
    closeOnEsc = true,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id: id2,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled: isDisabled2,
    gutter,
    offset: offset2,
    direction: direction2,
    ...htmlProps
  } = props;
  const { isOpen, onOpen, onClose } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const { referenceRef, getPopperProps, getArrowInnerProps, getArrowProps } = usePopper({
    enabled: isOpen,
    placement,
    arrowPadding,
    modifiers,
    gutter,
    offset: offset2,
    direction: direction2
  });
  const uuid2 = reactExports.useId();
  const uid = id2 != null ? id2 : uuid2;
  const tooltipId = `tooltip-${uid}`;
  const ref = reactExports.useRef(null);
  const enterTimeout = reactExports.useRef();
  const clearEnterTimeout = reactExports.useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
      enterTimeout.current = void 0;
    }
  }, []);
  const exitTimeout = reactExports.useRef();
  const clearExitTimeout = reactExports.useCallback(() => {
    if (exitTimeout.current) {
      clearTimeout(exitTimeout.current);
      exitTimeout.current = void 0;
    }
  }, []);
  const closeNow = reactExports.useCallback(() => {
    clearExitTimeout();
    onClose();
  }, [onClose, clearExitTimeout]);
  const dispatchCloseEvent = useCloseEvent(ref, closeNow);
  const openWithDelay = reactExports.useCallback(() => {
    if (!isDisabled2 && !enterTimeout.current) {
      if (isOpen)
        dispatchCloseEvent();
      const win = getWin(ref);
      enterTimeout.current = win.setTimeout(onOpen, openDelay);
    }
  }, [dispatchCloseEvent, isDisabled2, isOpen, onOpen, openDelay]);
  const closeWithDelay = reactExports.useCallback(() => {
    clearEnterTimeout();
    const win = getWin(ref);
    exitTimeout.current = win.setTimeout(closeNow, closeDelay);
  }, [closeDelay, closeNow, clearEnterTimeout]);
  const onClick = reactExports.useCallback(() => {
    if (isOpen && closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay, isOpen]);
  const onPointerDown = reactExports.useCallback(() => {
    if (isOpen && closeOnPointerDown) {
      closeWithDelay();
    }
  }, [closeOnPointerDown, closeWithDelay, isOpen]);
  const onKeyDown = reactExports.useCallback(
    (event) => {
      if (isOpen && event.key === "Escape") {
        closeWithDelay();
      }
    },
    [isOpen, closeWithDelay]
  );
  useEventListener(
    () => getDoc(ref),
    "keydown",
    closeOnEsc ? onKeyDown : void 0
  );
  useEventListener(
    () => {
      const node2 = ref.current;
      if (!node2)
        return null;
      const scrollParent = getScrollParent$2(node2);
      return scrollParent.localName === "body" ? getWin(ref) : scrollParent;
    },
    "scroll",
    () => {
      if (isOpen && closeOnScroll) {
        closeNow();
      }
    },
    { passive: true, capture: true }
  );
  reactExports.useEffect(() => {
    if (!isDisabled2)
      return;
    clearEnterTimeout();
    if (isOpen)
      onClose();
  }, [isDisabled2, isOpen, onClose, clearEnterTimeout]);
  reactExports.useEffect(() => {
    return () => {
      clearEnterTimeout();
      clearExitTimeout();
    };
  }, [clearEnterTimeout, clearExitTimeout]);
  useEventListener(() => ref.current, "pointerleave", closeWithDelay);
  const getTriggerProps = reactExports.useCallback(
    (props2 = {}, _ref3 = null) => {
      const triggerProps = {
        ...props2,
        ref: mergeRefs(ref, _ref3, referenceRef),
        onPointerEnter: callAllHandlers$1(props2.onPointerEnter, (e2) => {
          if (e2.pointerType === "touch")
            return;
          openWithDelay();
        }),
        onClick: callAllHandlers$1(props2.onClick, onClick),
        onPointerDown: callAllHandlers$1(props2.onPointerDown, onPointerDown),
        onFocus: callAllHandlers$1(props2.onFocus, openWithDelay),
        onBlur: callAllHandlers$1(props2.onBlur, closeWithDelay),
        "aria-describedby": isOpen ? tooltipId : void 0
      };
      return triggerProps;
    },
    [
      openWithDelay,
      closeWithDelay,
      onPointerDown,
      isOpen,
      tooltipId,
      onClick,
      referenceRef
    ]
  );
  const getTooltipPositionerProps = reactExports.useCallback(
    (props2 = {}, forwardedRef = null) => getPopperProps(
      {
        ...props2,
        style: {
          ...props2.style,
          [cssVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
          [cssVars.arrowShadowColor.var]: arrowShadowColor
        }
      },
      forwardedRef
    ),
    [getPopperProps, arrowSize, arrowShadowColor]
  );
  const getTooltipProps = reactExports.useCallback(
    (props2 = {}, ref2 = null) => {
      const styles2 = {
        ...props2.style,
        position: "relative",
        transformOrigin: cssVars.transformOrigin.varRef
      };
      return {
        ref: ref2,
        ...htmlProps,
        ...props2,
        id: tooltipId,
        role: "tooltip",
        style: styles2
      };
    },
    [htmlProps, tooltipId]
  );
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipPositionerProps,
    getArrowProps,
    getArrowInnerProps
  };
}
var closeEventName = "chakra-ui:close-tooltip";
function useCloseEvent(ref, close) {
  reactExports.useEffect(() => {
    const doc = getDoc(ref);
    doc.addEventListener(closeEventName, close);
    return () => doc.removeEventListener(closeEventName, close);
  }, [close, ref]);
  return () => {
    const doc = getDoc(ref);
    const win = getWin(ref);
    doc.dispatchEvent(new win.CustomEvent(closeEventName));
  };
}
function omit(object2, keysToOmit = []) {
  const clone = Object.assign({}, object2);
  for (const key2 of keysToOmit) {
    if (key2 in clone) {
      delete clone[key2];
    }
  }
  return clone;
}
function pick(object2, keysToPick) {
  const result = {};
  for (const key2 of keysToPick) {
    if (key2 in object2) {
      result[key2] = object2[key2];
    }
  }
  return result;
}
var MotionDiv = chakra(motion.div);
var Tooltip = forwardRef((props, ref) => {
  var _a4, _b3;
  const styles2 = useStyleConfig("Tooltip", props);
  const ownProps = omitThemingProps(props);
  const theme2 = useTheme();
  const {
    children,
    label: label2,
    shouldWrapChildren,
    "aria-label": ariaLabel,
    hasArrow,
    bg: bg2,
    portalProps,
    background: background2,
    backgroundColor,
    bgColor,
    motionProps,
    ...rest
  } = ownProps;
  const userDefinedBg = (_b3 = (_a4 = background2 != null ? background2 : backgroundColor) != null ? _a4 : bg2) != null ? _b3 : bgColor;
  if (userDefinedBg) {
    styles2.bg = userDefinedBg;
    const bgVar = getCSSVar(theme2, "colors", userDefinedBg);
    styles2[cssVars.arrowBg.var] = bgVar;
  }
  const tooltip = useTooltip({ ...rest, direction: theme2.direction });
  const shouldWrap = typeof children === "string" || shouldWrapChildren;
  let trigger2;
  if (shouldWrap) {
    trigger2 = /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.span,
      {
        display: "inline-block",
        tabIndex: 0,
        ...tooltip.getTriggerProps(),
        children
      }
    );
  } else {
    const child = reactExports.Children.only(children);
    trigger2 = reactExports.cloneElement(
      child,
      tooltip.getTriggerProps(child.props, child.ref)
    );
  }
  const hasAriaLabel = !!ariaLabel;
  const _tooltipProps = tooltip.getTooltipProps({}, ref);
  const tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
  const srOnlyProps = pick(_tooltipProps, ["role", "id"]);
  if (!label2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    trigger2,
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: tooltip.isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { ...portalProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ...tooltip.getTooltipPositionerProps(),
        __css: {
          zIndex: styles2.zIndex,
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          MotionDiv,
          {
            variants: scale,
            initial: "exit",
            animate: "enter",
            exit: "exit",
            ...motionProps,
            ...tooltipProps,
            __css: styles2,
            children: [
              label2,
              hasAriaLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { srOnly: true, ...srOnlyProps, children: ariaLabel }),
              hasArrow && /* @__PURE__ */ jsxRuntimeExports.jsx(
                chakra.div,
                {
                  "data-popper-arrow": true,
                  className: "chakra-tooltip__arrow-wrapper",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    chakra.div,
                    {
                      "data-popper-arrow-inner": true,
                      className: "chakra-tooltip__arrow",
                      __css: { bg: styles2.bg }
                    }
                  )
                }
              )
            ]
          }
        )
      }
    ) }) })
  ] });
});
Tooltip.displayName = "Tooltip";
var redoc_browser_lib = { exports: {} };
var lunr = { exports: {} };
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
var hasRequiredLunr;
function requireLunr() {
  if (hasRequiredLunr)
    return lunr.exports;
  hasRequiredLunr = 1;
  (function(module, exports) {
    (function() {
      var lunr2 = function(config2) {
        var builder = new lunr2.Builder();
        builder.pipeline.add(
          lunr2.trimmer,
          lunr2.stopWordFilter,
          lunr2.stemmer
        );
        builder.searchPipeline.add(
          lunr2.stemmer
        );
        config2.call(builder, builder);
        return builder.build();
      };
      lunr2.version = "2.3.9";
      /*!
       * lunr.utils
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.utils = {};
      lunr2.utils.warn = function(global2) {
        return function(message) {
          if (global2.console && console.warn) {
            console.warn(message);
          }
        };
      }(this);
      lunr2.utils.asString = function(obj) {
        if (obj === void 0 || obj === null) {
          return "";
        } else {
          return obj.toString();
        }
      };
      lunr2.utils.clone = function(obj) {
        if (obj === null || obj === void 0) {
          return obj;
        }
        var clone = /* @__PURE__ */ Object.create(null), keys2 = Object.keys(obj);
        for (var i = 0; i < keys2.length; i++) {
          var key2 = keys2[i], val = obj[key2];
          if (Array.isArray(val)) {
            clone[key2] = val.slice();
            continue;
          }
          if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
            clone[key2] = val;
            continue;
          }
          throw new TypeError("clone is not deep and does not support nested objects");
        }
        return clone;
      };
      lunr2.FieldRef = function(docRef, fieldName, stringValue) {
        this.docRef = docRef;
        this.fieldName = fieldName;
        this._stringValue = stringValue;
      };
      lunr2.FieldRef.joiner = "/";
      lunr2.FieldRef.fromString = function(s) {
        var n2 = s.indexOf(lunr2.FieldRef.joiner);
        if (n2 === -1) {
          throw "malformed field ref string";
        }
        var fieldRef = s.slice(0, n2), docRef = s.slice(n2 + 1);
        return new lunr2.FieldRef(docRef, fieldRef, s);
      };
      lunr2.FieldRef.prototype.toString = function() {
        if (this._stringValue == void 0) {
          this._stringValue = this.fieldName + lunr2.FieldRef.joiner + this.docRef;
        }
        return this._stringValue;
      };
      /*!
       * lunr.Set
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.Set = function(elements) {
        this.elements = /* @__PURE__ */ Object.create(null);
        if (elements) {
          this.length = elements.length;
          for (var i = 0; i < this.length; i++) {
            this.elements[elements[i]] = true;
          }
        } else {
          this.length = 0;
        }
      };
      lunr2.Set.complete = {
        intersect: function(other) {
          return other;
        },
        union: function() {
          return this;
        },
        contains: function() {
          return true;
        }
      };
      lunr2.Set.empty = {
        intersect: function() {
          return this;
        },
        union: function(other) {
          return other;
        },
        contains: function() {
          return false;
        }
      };
      lunr2.Set.prototype.contains = function(object2) {
        return !!this.elements[object2];
      };
      lunr2.Set.prototype.intersect = function(other) {
        var a, b2, elements, intersection2 = [];
        if (other === lunr2.Set.complete) {
          return this;
        }
        if (other === lunr2.Set.empty) {
          return other;
        }
        if (this.length < other.length) {
          a = this;
          b2 = other;
        } else {
          a = other;
          b2 = this;
        }
        elements = Object.keys(a.elements);
        for (var i = 0; i < elements.length; i++) {
          var element = elements[i];
          if (element in b2.elements) {
            intersection2.push(element);
          }
        }
        return new lunr2.Set(intersection2);
      };
      lunr2.Set.prototype.union = function(other) {
        if (other === lunr2.Set.complete) {
          return lunr2.Set.complete;
        }
        if (other === lunr2.Set.empty) {
          return this;
        }
        return new lunr2.Set(Object.keys(this.elements).concat(Object.keys(other.elements)));
      };
      lunr2.idf = function(posting, documentCount) {
        var documentsWithTerm = 0;
        for (var fieldName in posting) {
          if (fieldName == "_index")
            continue;
          documentsWithTerm += Object.keys(posting[fieldName]).length;
        }
        var x2 = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5);
        return Math.log(1 + Math.abs(x2));
      };
      lunr2.Token = function(str2, metadata) {
        this.str = str2 || "";
        this.metadata = metadata || {};
      };
      lunr2.Token.prototype.toString = function() {
        return this.str;
      };
      lunr2.Token.prototype.update = function(fn2) {
        this.str = fn2(this.str, this.metadata);
        return this;
      };
      lunr2.Token.prototype.clone = function(fn2) {
        fn2 = fn2 || function(s) {
          return s;
        };
        return new lunr2.Token(fn2(this.str, this.metadata), this.metadata);
      };
      /*!
       * lunr.tokenizer
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.tokenizer = function(obj, metadata) {
        if (obj == null || obj == void 0) {
          return [];
        }
        if (Array.isArray(obj)) {
          return obj.map(function(t2) {
            return new lunr2.Token(
              lunr2.utils.asString(t2).toLowerCase(),
              lunr2.utils.clone(metadata)
            );
          });
        }
        var str2 = obj.toString().toLowerCase(), len = str2.length, tokens2 = [];
        for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
          var char2 = str2.charAt(sliceEnd), sliceLength = sliceEnd - sliceStart;
          if (char2.match(lunr2.tokenizer.separator) || sliceEnd == len) {
            if (sliceLength > 0) {
              var tokenMetadata = lunr2.utils.clone(metadata) || {};
              tokenMetadata["position"] = [sliceStart, sliceLength];
              tokenMetadata["index"] = tokens2.length;
              tokens2.push(
                new lunr2.Token(
                  str2.slice(sliceStart, sliceEnd),
                  tokenMetadata
                )
              );
            }
            sliceStart = sliceEnd + 1;
          }
        }
        return tokens2;
      };
      lunr2.tokenizer.separator = /[\s\-]+/;
      /*!
       * lunr.Pipeline
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.Pipeline = function() {
        this._stack = [];
      };
      lunr2.Pipeline.registeredFunctions = /* @__PURE__ */ Object.create(null);
      lunr2.Pipeline.registerFunction = function(fn2, label2) {
        if (label2 in this.registeredFunctions) {
          lunr2.utils.warn("Overwriting existing registered function: " + label2);
        }
        fn2.label = label2;
        lunr2.Pipeline.registeredFunctions[fn2.label] = fn2;
      };
      lunr2.Pipeline.warnIfFunctionNotRegistered = function(fn2) {
        var isRegistered = fn2.label && fn2.label in this.registeredFunctions;
        if (!isRegistered) {
          lunr2.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n", fn2);
        }
      };
      lunr2.Pipeline.load = function(serialised) {
        var pipeline = new lunr2.Pipeline();
        serialised.forEach(function(fnName) {
          var fn2 = lunr2.Pipeline.registeredFunctions[fnName];
          if (fn2) {
            pipeline.add(fn2);
          } else {
            throw new Error("Cannot load unregistered function: " + fnName);
          }
        });
        return pipeline;
      };
      lunr2.Pipeline.prototype.add = function() {
        var fns = Array.prototype.slice.call(arguments);
        fns.forEach(function(fn2) {
          lunr2.Pipeline.warnIfFunctionNotRegistered(fn2);
          this._stack.push(fn2);
        }, this);
      };
      lunr2.Pipeline.prototype.after = function(existingFn, newFn) {
        lunr2.Pipeline.warnIfFunctionNotRegistered(newFn);
        var pos = this._stack.indexOf(existingFn);
        if (pos == -1) {
          throw new Error("Cannot find existingFn");
        }
        pos = pos + 1;
        this._stack.splice(pos, 0, newFn);
      };
      lunr2.Pipeline.prototype.before = function(existingFn, newFn) {
        lunr2.Pipeline.warnIfFunctionNotRegistered(newFn);
        var pos = this._stack.indexOf(existingFn);
        if (pos == -1) {
          throw new Error("Cannot find existingFn");
        }
        this._stack.splice(pos, 0, newFn);
      };
      lunr2.Pipeline.prototype.remove = function(fn2) {
        var pos = this._stack.indexOf(fn2);
        if (pos == -1) {
          return;
        }
        this._stack.splice(pos, 1);
      };
      lunr2.Pipeline.prototype.run = function(tokens2) {
        var stackLength = this._stack.length;
        for (var i = 0; i < stackLength; i++) {
          var fn2 = this._stack[i];
          var memo2 = [];
          for (var j = 0; j < tokens2.length; j++) {
            var result = fn2(tokens2[j], j, tokens2);
            if (result === null || result === void 0 || result === "")
              continue;
            if (Array.isArray(result)) {
              for (var k2 = 0; k2 < result.length; k2++) {
                memo2.push(result[k2]);
              }
            } else {
              memo2.push(result);
            }
          }
          tokens2 = memo2;
        }
        return tokens2;
      };
      lunr2.Pipeline.prototype.runString = function(str2, metadata) {
        var token2 = new lunr2.Token(str2, metadata);
        return this.run([token2]).map(function(t2) {
          return t2.toString();
        });
      };
      lunr2.Pipeline.prototype.reset = function() {
        this._stack = [];
      };
      lunr2.Pipeline.prototype.toJSON = function() {
        return this._stack.map(function(fn2) {
          lunr2.Pipeline.warnIfFunctionNotRegistered(fn2);
          return fn2.label;
        });
      };
      /*!
       * lunr.Vector
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.Vector = function(elements) {
        this._magnitude = 0;
        this.elements = elements || [];
      };
      lunr2.Vector.prototype.positionForIndex = function(index2) {
        if (this.elements.length == 0) {
          return 0;
        }
        var start2 = 0, end2 = this.elements.length / 2, sliceLength = end2 - start2, pivotPoint = Math.floor(sliceLength / 2), pivotIndex = this.elements[pivotPoint * 2];
        while (sliceLength > 1) {
          if (pivotIndex < index2) {
            start2 = pivotPoint;
          }
          if (pivotIndex > index2) {
            end2 = pivotPoint;
          }
          if (pivotIndex == index2) {
            break;
          }
          sliceLength = end2 - start2;
          pivotPoint = start2 + Math.floor(sliceLength / 2);
          pivotIndex = this.elements[pivotPoint * 2];
        }
        if (pivotIndex == index2) {
          return pivotPoint * 2;
        }
        if (pivotIndex > index2) {
          return pivotPoint * 2;
        }
        if (pivotIndex < index2) {
          return (pivotPoint + 1) * 2;
        }
      };
      lunr2.Vector.prototype.insert = function(insertIdx, val) {
        this.upsert(insertIdx, val, function() {
          throw "duplicate index";
        });
      };
      lunr2.Vector.prototype.upsert = function(insertIdx, val, fn2) {
        this._magnitude = 0;
        var position2 = this.positionForIndex(insertIdx);
        if (this.elements[position2] == insertIdx) {
          this.elements[position2 + 1] = fn2(this.elements[position2 + 1], val);
        } else {
          this.elements.splice(position2, 0, insertIdx, val);
        }
      };
      lunr2.Vector.prototype.magnitude = function() {
        if (this._magnitude)
          return this._magnitude;
        var sumOfSquares = 0, elementsLength = this.elements.length;
        for (var i = 1; i < elementsLength; i += 2) {
          var val = this.elements[i];
          sumOfSquares += val * val;
        }
        return this._magnitude = Math.sqrt(sumOfSquares);
      };
      lunr2.Vector.prototype.dot = function(otherVector) {
        var dotProduct = 0, a = this.elements, b2 = otherVector.elements, aLen = a.length, bLen = b2.length, aVal = 0, bVal = 0, i = 0, j = 0;
        while (i < aLen && j < bLen) {
          aVal = a[i], bVal = b2[j];
          if (aVal < bVal) {
            i += 2;
          } else if (aVal > bVal) {
            j += 2;
          } else if (aVal == bVal) {
            dotProduct += a[i + 1] * b2[j + 1];
            i += 2;
            j += 2;
          }
        }
        return dotProduct;
      };
      lunr2.Vector.prototype.similarity = function(otherVector) {
        return this.dot(otherVector) / this.magnitude() || 0;
      };
      lunr2.Vector.prototype.toArray = function() {
        var output = new Array(this.elements.length / 2);
        for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
          output[j] = this.elements[i];
        }
        return output;
      };
      lunr2.Vector.prototype.toJSON = function() {
        return this.elements;
      };
      /*!
       * lunr.stemmer
       * Copyright (C) 2020 Oliver Nightingale
       * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
       */
      lunr2.stemmer = function() {
        var step2list = {
          "ational": "ate",
          "tional": "tion",
          "enci": "ence",
          "anci": "ance",
          "izer": "ize",
          "bli": "ble",
          "alli": "al",
          "entli": "ent",
          "eli": "e",
          "ousli": "ous",
          "ization": "ize",
          "ation": "ate",
          "ator": "ate",
          "alism": "al",
          "iveness": "ive",
          "fulness": "ful",
          "ousness": "ous",
          "aliti": "al",
          "iviti": "ive",
          "biliti": "ble",
          "logi": "log"
        }, step3list = {
          "icate": "ic",
          "ative": "",
          "alize": "al",
          "iciti": "ic",
          "ical": "ic",
          "ful": "",
          "ness": ""
        }, c2 = "[^aeiou]", v2 = "[aeiouy]", C2 = c2 + "[^aeiouy]*", V2 = v2 + "[aeiou]*", mgr0 = "^(" + C2 + ")?" + V2 + C2, meq1 = "^(" + C2 + ")?" + V2 + C2 + "(" + V2 + ")?$", mgr1 = "^(" + C2 + ")?" + V2 + C2 + V2 + C2, s_v = "^(" + C2 + ")?" + v2;
        var re_mgr0 = new RegExp(mgr0);
        var re_mgr1 = new RegExp(mgr1);
        var re_meq1 = new RegExp(meq1);
        var re_s_v = new RegExp(s_v);
        var re_1a = /^(.+?)(ss|i)es$/;
        var re2_1a = /^(.+?)([^s])s$/;
        var re_1b = /^(.+?)eed$/;
        var re2_1b = /^(.+?)(ed|ing)$/;
        var re_1b_2 = /.$/;
        var re2_1b_2 = /(at|bl|iz)$/;
        var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
        var re4_1b_2 = new RegExp("^" + C2 + v2 + "[^aeiouwxy]$");
        var re_1c = /^(.+?[^aeiou])y$/;
        var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
        var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
        var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
        var re2_4 = /^(.+?)(s|t)(ion)$/;
        var re_5 = /^(.+?)e$/;
        var re_5_1 = /ll$/;
        var re3_5 = new RegExp("^" + C2 + v2 + "[^aeiouwxy]$");
        var porterStemmer = function porterStemmer2(w2) {
          var stem, suffix, firstch, re2, re22, re3, re4;
          if (w2.length < 3) {
            return w2;
          }
          firstch = w2.substr(0, 1);
          if (firstch == "y") {
            w2 = firstch.toUpperCase() + w2.substr(1);
          }
          re2 = re_1a;
          re22 = re2_1a;
          if (re2.test(w2)) {
            w2 = w2.replace(re2, "$1$2");
          } else if (re22.test(w2)) {
            w2 = w2.replace(re22, "$1$2");
          }
          re2 = re_1b;
          re22 = re2_1b;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            re2 = re_mgr0;
            if (re2.test(fp[1])) {
              re2 = re_1b_2;
              w2 = w2.replace(re2, "");
            }
          } else if (re22.test(w2)) {
            var fp = re22.exec(w2);
            stem = fp[1];
            re22 = re_s_v;
            if (re22.test(stem)) {
              w2 = stem;
              re22 = re2_1b_2;
              re3 = re3_1b_2;
              re4 = re4_1b_2;
              if (re22.test(w2)) {
                w2 = w2 + "e";
              } else if (re3.test(w2)) {
                re2 = re_1b_2;
                w2 = w2.replace(re2, "");
              } else if (re4.test(w2)) {
                w2 = w2 + "e";
              }
            }
          }
          re2 = re_1c;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            stem = fp[1];
            w2 = stem + "i";
          }
          re2 = re_2;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            stem = fp[1];
            suffix = fp[2];
            re2 = re_mgr0;
            if (re2.test(stem)) {
              w2 = stem + step2list[suffix];
            }
          }
          re2 = re_3;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            stem = fp[1];
            suffix = fp[2];
            re2 = re_mgr0;
            if (re2.test(stem)) {
              w2 = stem + step3list[suffix];
            }
          }
          re2 = re_4;
          re22 = re2_4;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            stem = fp[1];
            re2 = re_mgr1;
            if (re2.test(stem)) {
              w2 = stem;
            }
          } else if (re22.test(w2)) {
            var fp = re22.exec(w2);
            stem = fp[1] + fp[2];
            re22 = re_mgr1;
            if (re22.test(stem)) {
              w2 = stem;
            }
          }
          re2 = re_5;
          if (re2.test(w2)) {
            var fp = re2.exec(w2);
            stem = fp[1];
            re2 = re_mgr1;
            re22 = re_meq1;
            re3 = re3_5;
            if (re2.test(stem) || re22.test(stem) && !re3.test(stem)) {
              w2 = stem;
            }
          }
          re2 = re_5_1;
          re22 = re_mgr1;
          if (re2.test(w2) && re22.test(w2)) {
            re2 = re_1b_2;
            w2 = w2.replace(re2, "");
          }
          if (firstch == "y") {
            w2 = firstch.toLowerCase() + w2.substr(1);
          }
          return w2;
        };
        return function(token2) {
          return token2.update(porterStemmer);
        };
      }();
      lunr2.Pipeline.registerFunction(lunr2.stemmer, "stemmer");
      /*!
       * lunr.stopWordFilter
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.generateStopWordFilter = function(stopWords) {
        var words = stopWords.reduce(function(memo2, stopWord) {
          memo2[stopWord] = stopWord;
          return memo2;
        }, {});
        return function(token2) {
          if (token2 && words[token2.toString()] !== token2.toString())
            return token2;
        };
      };
      lunr2.stopWordFilter = lunr2.generateStopWordFilter([
        "a",
        "able",
        "about",
        "across",
        "after",
        "all",
        "almost",
        "also",
        "am",
        "among",
        "an",
        "and",
        "any",
        "are",
        "as",
        "at",
        "be",
        "because",
        "been",
        "but",
        "by",
        "can",
        "cannot",
        "could",
        "dear",
        "did",
        "do",
        "does",
        "either",
        "else",
        "ever",
        "every",
        "for",
        "from",
        "get",
        "got",
        "had",
        "has",
        "have",
        "he",
        "her",
        "hers",
        "him",
        "his",
        "how",
        "however",
        "i",
        "if",
        "in",
        "into",
        "is",
        "it",
        "its",
        "just",
        "least",
        "let",
        "like",
        "likely",
        "may",
        "me",
        "might",
        "most",
        "must",
        "my",
        "neither",
        "no",
        "nor",
        "not",
        "of",
        "off",
        "often",
        "on",
        "only",
        "or",
        "other",
        "our",
        "own",
        "rather",
        "said",
        "say",
        "says",
        "she",
        "should",
        "since",
        "so",
        "some",
        "than",
        "that",
        "the",
        "their",
        "them",
        "then",
        "there",
        "these",
        "they",
        "this",
        "tis",
        "to",
        "too",
        "twas",
        "us",
        "wants",
        "was",
        "we",
        "were",
        "what",
        "when",
        "where",
        "which",
        "while",
        "who",
        "whom",
        "why",
        "will",
        "with",
        "would",
        "yet",
        "you",
        "your"
      ]);
      lunr2.Pipeline.registerFunction(lunr2.stopWordFilter, "stopWordFilter");
      /*!
       * lunr.trimmer
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.trimmer = function(token2) {
        return token2.update(function(s) {
          return s.replace(/^\W+/, "").replace(/\W+$/, "");
        });
      };
      lunr2.Pipeline.registerFunction(lunr2.trimmer, "trimmer");
      /*!
       * lunr.TokenSet
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.TokenSet = function() {
        this.final = false;
        this.edges = {};
        this.id = lunr2.TokenSet._nextId;
        lunr2.TokenSet._nextId += 1;
      };
      lunr2.TokenSet._nextId = 1;
      lunr2.TokenSet.fromArray = function(arr) {
        var builder = new lunr2.TokenSet.Builder();
        for (var i = 0, len = arr.length; i < len; i++) {
          builder.insert(arr[i]);
        }
        builder.finish();
        return builder.root;
      };
      lunr2.TokenSet.fromClause = function(clause) {
        if ("editDistance" in clause) {
          return lunr2.TokenSet.fromFuzzyString(clause.term, clause.editDistance);
        } else {
          return lunr2.TokenSet.fromString(clause.term);
        }
      };
      lunr2.TokenSet.fromFuzzyString = function(str2, editDistance) {
        var root = new lunr2.TokenSet();
        var stack = [{
          node: root,
          editsRemaining: editDistance,
          str: str2
        }];
        while (stack.length) {
          var frame2 = stack.pop();
          if (frame2.str.length > 0) {
            var char2 = frame2.str.charAt(0), noEditNode;
            if (char2 in frame2.node.edges) {
              noEditNode = frame2.node.edges[char2];
            } else {
              noEditNode = new lunr2.TokenSet();
              frame2.node.edges[char2] = noEditNode;
            }
            if (frame2.str.length == 1) {
              noEditNode.final = true;
            }
            stack.push({
              node: noEditNode,
              editsRemaining: frame2.editsRemaining,
              str: frame2.str.slice(1)
            });
          }
          if (frame2.editsRemaining == 0) {
            continue;
          }
          if ("*" in frame2.node.edges) {
            var insertionNode = frame2.node.edges["*"];
          } else {
            var insertionNode = new lunr2.TokenSet();
            frame2.node.edges["*"] = insertionNode;
          }
          if (frame2.str.length == 0) {
            insertionNode.final = true;
          }
          stack.push({
            node: insertionNode,
            editsRemaining: frame2.editsRemaining - 1,
            str: frame2.str
          });
          if (frame2.str.length > 1) {
            stack.push({
              node: frame2.node,
              editsRemaining: frame2.editsRemaining - 1,
              str: frame2.str.slice(1)
            });
          }
          if (frame2.str.length == 1) {
            frame2.node.final = true;
          }
          if (frame2.str.length >= 1) {
            if ("*" in frame2.node.edges) {
              var substitutionNode = frame2.node.edges["*"];
            } else {
              var substitutionNode = new lunr2.TokenSet();
              frame2.node.edges["*"] = substitutionNode;
            }
            if (frame2.str.length == 1) {
              substitutionNode.final = true;
            }
            stack.push({
              node: substitutionNode,
              editsRemaining: frame2.editsRemaining - 1,
              str: frame2.str.slice(1)
            });
          }
          if (frame2.str.length > 1) {
            var charA = frame2.str.charAt(0), charB = frame2.str.charAt(1), transposeNode;
            if (charB in frame2.node.edges) {
              transposeNode = frame2.node.edges[charB];
            } else {
              transposeNode = new lunr2.TokenSet();
              frame2.node.edges[charB] = transposeNode;
            }
            if (frame2.str.length == 1) {
              transposeNode.final = true;
            }
            stack.push({
              node: transposeNode,
              editsRemaining: frame2.editsRemaining - 1,
              str: charA + frame2.str.slice(2)
            });
          }
        }
        return root;
      };
      lunr2.TokenSet.fromString = function(str2) {
        var node2 = new lunr2.TokenSet(), root = node2;
        for (var i = 0, len = str2.length; i < len; i++) {
          var char2 = str2[i], final = i == len - 1;
          if (char2 == "*") {
            node2.edges[char2] = node2;
            node2.final = final;
          } else {
            var next2 = new lunr2.TokenSet();
            next2.final = final;
            node2.edges[char2] = next2;
            node2 = next2;
          }
        }
        return root;
      };
      lunr2.TokenSet.prototype.toArray = function() {
        var words = [];
        var stack = [{
          prefix: "",
          node: this
        }];
        while (stack.length) {
          var frame2 = stack.pop(), edges = Object.keys(frame2.node.edges), len = edges.length;
          if (frame2.node.final) {
            frame2.prefix.charAt(0);
            words.push(frame2.prefix);
          }
          for (var i = 0; i < len; i++) {
            var edge = edges[i];
            stack.push({
              prefix: frame2.prefix.concat(edge),
              node: frame2.node.edges[edge]
            });
          }
        }
        return words;
      };
      lunr2.TokenSet.prototype.toString = function() {
        if (this._str) {
          return this._str;
        }
        var str2 = this.final ? "1" : "0", labels = Object.keys(this.edges).sort(), len = labels.length;
        for (var i = 0; i < len; i++) {
          var label2 = labels[i], node2 = this.edges[label2];
          str2 = str2 + label2 + node2.id;
        }
        return str2;
      };
      lunr2.TokenSet.prototype.intersect = function(b2) {
        var output = new lunr2.TokenSet(), frame2 = void 0;
        var stack = [{
          qNode: b2,
          output,
          node: this
        }];
        while (stack.length) {
          frame2 = stack.pop();
          var qEdges = Object.keys(frame2.qNode.edges), qLen = qEdges.length, nEdges = Object.keys(frame2.node.edges), nLen = nEdges.length;
          for (var q2 = 0; q2 < qLen; q2++) {
            var qEdge = qEdges[q2];
            for (var n2 = 0; n2 < nLen; n2++) {
              var nEdge = nEdges[n2];
              if (nEdge == qEdge || qEdge == "*") {
                var node2 = frame2.node.edges[nEdge], qNode = frame2.qNode.edges[qEdge], final = node2.final && qNode.final, next2 = void 0;
                if (nEdge in frame2.output.edges) {
                  next2 = frame2.output.edges[nEdge];
                  next2.final = next2.final || final;
                } else {
                  next2 = new lunr2.TokenSet();
                  next2.final = final;
                  frame2.output.edges[nEdge] = next2;
                }
                stack.push({
                  qNode,
                  output: next2,
                  node: node2
                });
              }
            }
          }
        }
        return output;
      };
      lunr2.TokenSet.Builder = function() {
        this.previousWord = "";
        this.root = new lunr2.TokenSet();
        this.uncheckedNodes = [];
        this.minimizedNodes = {};
      };
      lunr2.TokenSet.Builder.prototype.insert = function(word) {
        var node2, commonPrefix = 0;
        if (word < this.previousWord) {
          throw new Error("Out of order word insertion");
        }
        for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
          if (word[i] != this.previousWord[i])
            break;
          commonPrefix++;
        }
        this.minimize(commonPrefix);
        if (this.uncheckedNodes.length == 0) {
          node2 = this.root;
        } else {
          node2 = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;
        }
        for (var i = commonPrefix; i < word.length; i++) {
          var nextNode = new lunr2.TokenSet(), char2 = word[i];
          node2.edges[char2] = nextNode;
          this.uncheckedNodes.push({
            parent: node2,
            char: char2,
            child: nextNode
          });
          node2 = nextNode;
        }
        node2.final = true;
        this.previousWord = word;
      };
      lunr2.TokenSet.Builder.prototype.finish = function() {
        this.minimize(0);
      };
      lunr2.TokenSet.Builder.prototype.minimize = function(downTo) {
        for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
          var node2 = this.uncheckedNodes[i], childKey = node2.child.toString();
          if (childKey in this.minimizedNodes) {
            node2.parent.edges[node2.char] = this.minimizedNodes[childKey];
          } else {
            node2.child._str = childKey;
            this.minimizedNodes[childKey] = node2.child;
          }
          this.uncheckedNodes.pop();
        }
      };
      /*!
       * lunr.Index
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.Index = function(attrs) {
        this.invertedIndex = attrs.invertedIndex;
        this.fieldVectors = attrs.fieldVectors;
        this.tokenSet = attrs.tokenSet;
        this.fields = attrs.fields;
        this.pipeline = attrs.pipeline;
      };
      lunr2.Index.prototype.search = function(queryString) {
        return this.query(function(query) {
          var parser = new lunr2.QueryParser(queryString, query);
          parser.parse();
        });
      };
      lunr2.Index.prototype.query = function(fn2) {
        var query = new lunr2.Query(this.fields), matchingFields = /* @__PURE__ */ Object.create(null), queryVectors = /* @__PURE__ */ Object.create(null), termFieldCache = /* @__PURE__ */ Object.create(null), requiredMatches = /* @__PURE__ */ Object.create(null), prohibitedMatches = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < this.fields.length; i++) {
          queryVectors[this.fields[i]] = new lunr2.Vector();
        }
        fn2.call(query, query);
        for (var i = 0; i < query.clauses.length; i++) {
          var clause = query.clauses[i], terms = null, clauseMatches = lunr2.Set.empty;
          if (clause.usePipeline) {
            terms = this.pipeline.runString(clause.term, {
              fields: clause.fields
            });
          } else {
            terms = [clause.term];
          }
          for (var m2 = 0; m2 < terms.length; m2++) {
            var term = terms[m2];
            clause.term = term;
            var termTokenSet = lunr2.TokenSet.fromClause(clause), expandedTerms = this.tokenSet.intersect(termTokenSet).toArray();
            if (expandedTerms.length === 0 && clause.presence === lunr2.Query.presence.REQUIRED) {
              for (var k2 = 0; k2 < clause.fields.length; k2++) {
                var field = clause.fields[k2];
                requiredMatches[field] = lunr2.Set.empty;
              }
              break;
            }
            for (var j = 0; j < expandedTerms.length; j++) {
              var expandedTerm = expandedTerms[j], posting = this.invertedIndex[expandedTerm], termIndex = posting._index;
              for (var k2 = 0; k2 < clause.fields.length; k2++) {
                var field = clause.fields[k2], fieldPosting = posting[field], matchingDocumentRefs = Object.keys(fieldPosting), termField = expandedTerm + "/" + field, matchingDocumentsSet = new lunr2.Set(matchingDocumentRefs);
                if (clause.presence == lunr2.Query.presence.REQUIRED) {
                  clauseMatches = clauseMatches.union(matchingDocumentsSet);
                  if (requiredMatches[field] === void 0) {
                    requiredMatches[field] = lunr2.Set.complete;
                  }
                }
                if (clause.presence == lunr2.Query.presence.PROHIBITED) {
                  if (prohibitedMatches[field] === void 0) {
                    prohibitedMatches[field] = lunr2.Set.empty;
                  }
                  prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet);
                  continue;
                }
                queryVectors[field].upsert(termIndex, clause.boost, function(a, b2) {
                  return a + b2;
                });
                if (termFieldCache[termField]) {
                  continue;
                }
                for (var l2 = 0; l2 < matchingDocumentRefs.length; l2++) {
                  var matchingDocumentRef = matchingDocumentRefs[l2], matchingFieldRef = new lunr2.FieldRef(matchingDocumentRef, field), metadata = fieldPosting[matchingDocumentRef], fieldMatch;
                  if ((fieldMatch = matchingFields[matchingFieldRef]) === void 0) {
                    matchingFields[matchingFieldRef] = new lunr2.MatchData(expandedTerm, field, metadata);
                  } else {
                    fieldMatch.add(expandedTerm, field, metadata);
                  }
                }
                termFieldCache[termField] = true;
              }
            }
          }
          if (clause.presence === lunr2.Query.presence.REQUIRED) {
            for (var k2 = 0; k2 < clause.fields.length; k2++) {
              var field = clause.fields[k2];
              requiredMatches[field] = requiredMatches[field].intersect(clauseMatches);
            }
          }
        }
        var allRequiredMatches = lunr2.Set.complete, allProhibitedMatches = lunr2.Set.empty;
        for (var i = 0; i < this.fields.length; i++) {
          var field = this.fields[i];
          if (requiredMatches[field]) {
            allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field]);
          }
          if (prohibitedMatches[field]) {
            allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field]);
          }
        }
        var matchingFieldRefs = Object.keys(matchingFields), results = [], matches2 = /* @__PURE__ */ Object.create(null);
        if (query.isNegated()) {
          matchingFieldRefs = Object.keys(this.fieldVectors);
          for (var i = 0; i < matchingFieldRefs.length; i++) {
            var matchingFieldRef = matchingFieldRefs[i];
            var fieldRef = lunr2.FieldRef.fromString(matchingFieldRef);
            matchingFields[matchingFieldRef] = new lunr2.MatchData();
          }
        }
        for (var i = 0; i < matchingFieldRefs.length; i++) {
          var fieldRef = lunr2.FieldRef.fromString(matchingFieldRefs[i]), docRef = fieldRef.docRef;
          if (!allRequiredMatches.contains(docRef)) {
            continue;
          }
          if (allProhibitedMatches.contains(docRef)) {
            continue;
          }
          var fieldVector = this.fieldVectors[fieldRef], score = queryVectors[fieldRef.fieldName].similarity(fieldVector), docMatch;
          if ((docMatch = matches2[docRef]) !== void 0) {
            docMatch.score += score;
            docMatch.matchData.combine(matchingFields[fieldRef]);
          } else {
            var match2 = {
              ref: docRef,
              score,
              matchData: matchingFields[fieldRef]
            };
            matches2[docRef] = match2;
            results.push(match2);
          }
        }
        return results.sort(function(a, b2) {
          return b2.score - a.score;
        });
      };
      lunr2.Index.prototype.toJSON = function() {
        var invertedIndex = Object.keys(this.invertedIndex).sort().map(function(term) {
          return [term, this.invertedIndex[term]];
        }, this);
        var fieldVectors = Object.keys(this.fieldVectors).map(function(ref) {
          return [ref, this.fieldVectors[ref].toJSON()];
        }, this);
        return {
          version: lunr2.version,
          fields: this.fields,
          fieldVectors,
          invertedIndex,
          pipeline: this.pipeline.toJSON()
        };
      };
      lunr2.Index.load = function(serializedIndex) {
        var attrs = {}, fieldVectors = {}, serializedVectors = serializedIndex.fieldVectors, invertedIndex = /* @__PURE__ */ Object.create(null), serializedInvertedIndex = serializedIndex.invertedIndex, tokenSetBuilder = new lunr2.TokenSet.Builder(), pipeline = lunr2.Pipeline.load(serializedIndex.pipeline);
        if (serializedIndex.version != lunr2.version) {
          lunr2.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + lunr2.version + "' does not match serialized index '" + serializedIndex.version + "'");
        }
        for (var i = 0; i < serializedVectors.length; i++) {
          var tuple = serializedVectors[i], ref = tuple[0], elements = tuple[1];
          fieldVectors[ref] = new lunr2.Vector(elements);
        }
        for (var i = 0; i < serializedInvertedIndex.length; i++) {
          var tuple = serializedInvertedIndex[i], term = tuple[0], posting = tuple[1];
          tokenSetBuilder.insert(term);
          invertedIndex[term] = posting;
        }
        tokenSetBuilder.finish();
        attrs.fields = serializedIndex.fields;
        attrs.fieldVectors = fieldVectors;
        attrs.invertedIndex = invertedIndex;
        attrs.tokenSet = tokenSetBuilder.root;
        attrs.pipeline = pipeline;
        return new lunr2.Index(attrs);
      };
      /*!
       * lunr.Builder
       * Copyright (C) 2020 Oliver Nightingale
       */
      lunr2.Builder = function() {
        this._ref = "id";
        this._fields = /* @__PURE__ */ Object.create(null);
        this._documents = /* @__PURE__ */ Object.create(null);
        this.invertedIndex = /* @__PURE__ */ Object.create(null);
        this.fieldTermFrequencies = {};
        this.fieldLengths = {};
        this.tokenizer = lunr2.tokenizer;
        this.pipeline = new lunr2.Pipeline();
        this.searchPipeline = new lunr2.Pipeline();
        this.documentCount = 0;
        this._b = 0.75;
        this._k1 = 1.2;
        this.termIndex = 0;
        this.metadataWhitelist = [];
      };
      lunr2.Builder.prototype.ref = function(ref) {
        this._ref = ref;
      };
      lunr2.Builder.prototype.field = function(fieldName, attributes) {
        if (/\//.test(fieldName)) {
          throw new RangeError("Field '" + fieldName + "' contains illegal character '/'");
        }
        this._fields[fieldName] = attributes || {};
      };
      lunr2.Builder.prototype.b = function(number2) {
        if (number2 < 0) {
          this._b = 0;
        } else if (number2 > 1) {
          this._b = 1;
        } else {
          this._b = number2;
        }
      };
      lunr2.Builder.prototype.k1 = function(number2) {
        this._k1 = number2;
      };
      lunr2.Builder.prototype.add = function(doc, attributes) {
        var docRef = doc[this._ref], fields = Object.keys(this._fields);
        this._documents[docRef] = attributes || {};
        this.documentCount += 1;
        for (var i = 0; i < fields.length; i++) {
          var fieldName = fields[i], extractor = this._fields[fieldName].extractor, field = extractor ? extractor(doc) : doc[fieldName], tokens2 = this.tokenizer(field, {
            fields: [fieldName]
          }), terms = this.pipeline.run(tokens2), fieldRef = new lunr2.FieldRef(docRef, fieldName), fieldTerms = /* @__PURE__ */ Object.create(null);
          this.fieldTermFrequencies[fieldRef] = fieldTerms;
          this.fieldLengths[fieldRef] = 0;
          this.fieldLengths[fieldRef] += terms.length;
          for (var j = 0; j < terms.length; j++) {
            var term = terms[j];
            if (fieldTerms[term] == void 0) {
              fieldTerms[term] = 0;
            }
            fieldTerms[term] += 1;
            if (this.invertedIndex[term] == void 0) {
              var posting = /* @__PURE__ */ Object.create(null);
              posting["_index"] = this.termIndex;
              this.termIndex += 1;
              for (var k2 = 0; k2 < fields.length; k2++) {
                posting[fields[k2]] = /* @__PURE__ */ Object.create(null);
              }
              this.invertedIndex[term] = posting;
            }
            if (this.invertedIndex[term][fieldName][docRef] == void 0) {
              this.invertedIndex[term][fieldName][docRef] = /* @__PURE__ */ Object.create(null);
            }
            for (var l2 = 0; l2 < this.metadataWhitelist.length; l2++) {
              var metadataKey = this.metadataWhitelist[l2], metadata = term.metadata[metadataKey];
              if (this.invertedIndex[term][fieldName][docRef][metadataKey] == void 0) {
                this.invertedIndex[term][fieldName][docRef][metadataKey] = [];
              }
              this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata);
            }
          }
        }
      };
      lunr2.Builder.prototype.calculateAverageFieldLengths = function() {
        var fieldRefs = Object.keys(this.fieldLengths), numberOfFields = fieldRefs.length, accumulator = {}, documentsWithField = {};
        for (var i = 0; i < numberOfFields; i++) {
          var fieldRef = lunr2.FieldRef.fromString(fieldRefs[i]), field = fieldRef.fieldName;
          documentsWithField[field] || (documentsWithField[field] = 0);
          documentsWithField[field] += 1;
          accumulator[field] || (accumulator[field] = 0);
          accumulator[field] += this.fieldLengths[fieldRef];
        }
        var fields = Object.keys(this._fields);
        for (var i = 0; i < fields.length; i++) {
          var fieldName = fields[i];
          accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName];
        }
        this.averageFieldLength = accumulator;
      };
      lunr2.Builder.prototype.createFieldVectors = function() {
        var fieldVectors = {}, fieldRefs = Object.keys(this.fieldTermFrequencies), fieldRefsLength = fieldRefs.length, termIdfCache = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < fieldRefsLength; i++) {
          var fieldRef = lunr2.FieldRef.fromString(fieldRefs[i]), fieldName = fieldRef.fieldName, fieldLength = this.fieldLengths[fieldRef], fieldVector = new lunr2.Vector(), termFrequencies = this.fieldTermFrequencies[fieldRef], terms = Object.keys(termFrequencies), termsLength = terms.length;
          var fieldBoost = this._fields[fieldName].boost || 1, docBoost = this._documents[fieldRef.docRef].boost || 1;
          for (var j = 0; j < termsLength; j++) {
            var term = terms[j], tf2 = termFrequencies[term], termIndex = this.invertedIndex[term]._index, idf, score, scoreWithPrecision;
            if (termIdfCache[term] === void 0) {
              idf = lunr2.idf(this.invertedIndex[term], this.documentCount);
              termIdfCache[term] = idf;
            } else {
              idf = termIdfCache[term];
            }
            score = idf * ((this._k1 + 1) * tf2) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf2);
            score *= fieldBoost;
            score *= docBoost;
            scoreWithPrecision = Math.round(score * 1e3) / 1e3;
            fieldVector.insert(termIndex, scoreWithPrecision);
          }
          fieldVectors[fieldRef] = fieldVector;
        }
        this.fieldVectors = fieldVectors;
      };
      lunr2.Builder.prototype.createTokenSet = function() {
        this.tokenSet = lunr2.TokenSet.fromArray(
          Object.keys(this.invertedIndex).sort()
        );
      };
      lunr2.Builder.prototype.build = function() {
        this.calculateAverageFieldLengths();
        this.createFieldVectors();
        this.createTokenSet();
        return new lunr2.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline
        });
      };
      lunr2.Builder.prototype.use = function(fn2) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(this);
        fn2.apply(this, args);
      };
      lunr2.MatchData = function(term, field, metadata) {
        var clonedMetadata = /* @__PURE__ */ Object.create(null), metadataKeys = Object.keys(metadata || {});
        for (var i = 0; i < metadataKeys.length; i++) {
          var key2 = metadataKeys[i];
          clonedMetadata[key2] = metadata[key2].slice();
        }
        this.metadata = /* @__PURE__ */ Object.create(null);
        if (term !== void 0) {
          this.metadata[term] = /* @__PURE__ */ Object.create(null);
          this.metadata[term][field] = clonedMetadata;
        }
      };
      lunr2.MatchData.prototype.combine = function(otherMatchData) {
        var terms = Object.keys(otherMatchData.metadata);
        for (var i = 0; i < terms.length; i++) {
          var term = terms[i], fields = Object.keys(otherMatchData.metadata[term]);
          if (this.metadata[term] == void 0) {
            this.metadata[term] = /* @__PURE__ */ Object.create(null);
          }
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j], keys2 = Object.keys(otherMatchData.metadata[term][field]);
            if (this.metadata[term][field] == void 0) {
              this.metadata[term][field] = /* @__PURE__ */ Object.create(null);
            }
            for (var k2 = 0; k2 < keys2.length; k2++) {
              var key2 = keys2[k2];
              if (this.metadata[term][field][key2] == void 0) {
                this.metadata[term][field][key2] = otherMatchData.metadata[term][field][key2];
              } else {
                this.metadata[term][field][key2] = this.metadata[term][field][key2].concat(otherMatchData.metadata[term][field][key2]);
              }
            }
          }
        }
      };
      lunr2.MatchData.prototype.add = function(term, field, metadata) {
        if (!(term in this.metadata)) {
          this.metadata[term] = /* @__PURE__ */ Object.create(null);
          this.metadata[term][field] = metadata;
          return;
        }
        if (!(field in this.metadata[term])) {
          this.metadata[term][field] = metadata;
          return;
        }
        var metadataKeys = Object.keys(metadata);
        for (var i = 0; i < metadataKeys.length; i++) {
          var key2 = metadataKeys[i];
          if (key2 in this.metadata[term][field]) {
            this.metadata[term][field][key2] = this.metadata[term][field][key2].concat(metadata[key2]);
          } else {
            this.metadata[term][field][key2] = metadata[key2];
          }
        }
      };
      lunr2.Query = function(allFields) {
        this.clauses = [];
        this.allFields = allFields;
      };
      lunr2.Query.wildcard = new String("*");
      lunr2.Query.wildcard.NONE = 0;
      lunr2.Query.wildcard.LEADING = 1;
      lunr2.Query.wildcard.TRAILING = 2;
      lunr2.Query.presence = {
        /**
         * Term's presence in a document is optional, this is the default value.
         */
        OPTIONAL: 1,
        /**
         * Term's presence in a document is required, documents that do not contain
         * this term will not be returned.
         */
        REQUIRED: 2,
        /**
         * Term's presence in a document is prohibited, documents that do contain
         * this term will not be returned.
         */
        PROHIBITED: 3
      };
      lunr2.Query.prototype.clause = function(clause) {
        if (!("fields" in clause)) {
          clause.fields = this.allFields;
        }
        if (!("boost" in clause)) {
          clause.boost = 1;
        }
        if (!("usePipeline" in clause)) {
          clause.usePipeline = true;
        }
        if (!("wildcard" in clause)) {
          clause.wildcard = lunr2.Query.wildcard.NONE;
        }
        if (clause.wildcard & lunr2.Query.wildcard.LEADING && clause.term.charAt(0) != lunr2.Query.wildcard) {
          clause.term = "*" + clause.term;
        }
        if (clause.wildcard & lunr2.Query.wildcard.TRAILING && clause.term.slice(-1) != lunr2.Query.wildcard) {
          clause.term = "" + clause.term + "*";
        }
        if (!("presence" in clause)) {
          clause.presence = lunr2.Query.presence.OPTIONAL;
        }
        this.clauses.push(clause);
        return this;
      };
      lunr2.Query.prototype.isNegated = function() {
        for (var i = 0; i < this.clauses.length; i++) {
          if (this.clauses[i].presence != lunr2.Query.presence.PROHIBITED) {
            return false;
          }
        }
        return true;
      };
      lunr2.Query.prototype.term = function(term, options2) {
        if (Array.isArray(term)) {
          term.forEach(function(t2) {
            this.term(t2, lunr2.utils.clone(options2));
          }, this);
          return this;
        }
        var clause = options2 || {};
        clause.term = term.toString();
        this.clause(clause);
        return this;
      };
      lunr2.QueryParseError = function(message, start2, end2) {
        this.name = "QueryParseError";
        this.message = message;
        this.start = start2;
        this.end = end2;
      };
      lunr2.QueryParseError.prototype = new Error();
      lunr2.QueryLexer = function(str2) {
        this.lexemes = [];
        this.str = str2;
        this.length = str2.length;
        this.pos = 0;
        this.start = 0;
        this.escapeCharPositions = [];
      };
      lunr2.QueryLexer.prototype.run = function() {
        var state2 = lunr2.QueryLexer.lexText;
        while (state2) {
          state2 = state2(this);
        }
      };
      lunr2.QueryLexer.prototype.sliceString = function() {
        var subSlices = [], sliceStart = this.start, sliceEnd = this.pos;
        for (var i = 0; i < this.escapeCharPositions.length; i++) {
          sliceEnd = this.escapeCharPositions[i];
          subSlices.push(this.str.slice(sliceStart, sliceEnd));
          sliceStart = sliceEnd + 1;
        }
        subSlices.push(this.str.slice(sliceStart, this.pos));
        this.escapeCharPositions.length = 0;
        return subSlices.join("");
      };
      lunr2.QueryLexer.prototype.emit = function(type2) {
        this.lexemes.push({
          type: type2,
          str: this.sliceString(),
          start: this.start,
          end: this.pos
        });
        this.start = this.pos;
      };
      lunr2.QueryLexer.prototype.escapeCharacter = function() {
        this.escapeCharPositions.push(this.pos - 1);
        this.pos += 1;
      };
      lunr2.QueryLexer.prototype.next = function() {
        if (this.pos >= this.length) {
          return lunr2.QueryLexer.EOS;
        }
        var char2 = this.str.charAt(this.pos);
        this.pos += 1;
        return char2;
      };
      lunr2.QueryLexer.prototype.width = function() {
        return this.pos - this.start;
      };
      lunr2.QueryLexer.prototype.ignore = function() {
        if (this.start == this.pos) {
          this.pos += 1;
        }
        this.start = this.pos;
      };
      lunr2.QueryLexer.prototype.backup = function() {
        this.pos -= 1;
      };
      lunr2.QueryLexer.prototype.acceptDigitRun = function() {
        var char2, charCode;
        do {
          char2 = this.next();
          charCode = char2.charCodeAt(0);
        } while (charCode > 47 && charCode < 58);
        if (char2 != lunr2.QueryLexer.EOS) {
          this.backup();
        }
      };
      lunr2.QueryLexer.prototype.more = function() {
        return this.pos < this.length;
      };
      lunr2.QueryLexer.EOS = "EOS";
      lunr2.QueryLexer.FIELD = "FIELD";
      lunr2.QueryLexer.TERM = "TERM";
      lunr2.QueryLexer.EDIT_DISTANCE = "EDIT_DISTANCE";
      lunr2.QueryLexer.BOOST = "BOOST";
      lunr2.QueryLexer.PRESENCE = "PRESENCE";
      lunr2.QueryLexer.lexField = function(lexer) {
        lexer.backup();
        lexer.emit(lunr2.QueryLexer.FIELD);
        lexer.ignore();
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexTerm = function(lexer) {
        if (lexer.width() > 1) {
          lexer.backup();
          lexer.emit(lunr2.QueryLexer.TERM);
        }
        lexer.ignore();
        if (lexer.more()) {
          return lunr2.QueryLexer.lexText;
        }
      };
      lunr2.QueryLexer.lexEditDistance = function(lexer) {
        lexer.ignore();
        lexer.acceptDigitRun();
        lexer.emit(lunr2.QueryLexer.EDIT_DISTANCE);
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexBoost = function(lexer) {
        lexer.ignore();
        lexer.acceptDigitRun();
        lexer.emit(lunr2.QueryLexer.BOOST);
        return lunr2.QueryLexer.lexText;
      };
      lunr2.QueryLexer.lexEOS = function(lexer) {
        if (lexer.width() > 0) {
          lexer.emit(lunr2.QueryLexer.TERM);
        }
      };
      lunr2.QueryLexer.termSeparator = lunr2.tokenizer.separator;
      lunr2.QueryLexer.lexText = function(lexer) {
        while (true) {
          var char2 = lexer.next();
          if (char2 == lunr2.QueryLexer.EOS) {
            return lunr2.QueryLexer.lexEOS;
          }
          if (char2.charCodeAt(0) == 92) {
            lexer.escapeCharacter();
            continue;
          }
          if (char2 == ":") {
            return lunr2.QueryLexer.lexField;
          }
          if (char2 == "~") {
            lexer.backup();
            if (lexer.width() > 0) {
              lexer.emit(lunr2.QueryLexer.TERM);
            }
            return lunr2.QueryLexer.lexEditDistance;
          }
          if (char2 == "^") {
            lexer.backup();
            if (lexer.width() > 0) {
              lexer.emit(lunr2.QueryLexer.TERM);
            }
            return lunr2.QueryLexer.lexBoost;
          }
          if (char2 == "+" && lexer.width() === 1) {
            lexer.emit(lunr2.QueryLexer.PRESENCE);
            return lunr2.QueryLexer.lexText;
          }
          if (char2 == "-" && lexer.width() === 1) {
            lexer.emit(lunr2.QueryLexer.PRESENCE);
            return lunr2.QueryLexer.lexText;
          }
          if (char2.match(lunr2.QueryLexer.termSeparator)) {
            return lunr2.QueryLexer.lexTerm;
          }
        }
      };
      lunr2.QueryParser = function(str2, query) {
        this.lexer = new lunr2.QueryLexer(str2);
        this.query = query;
        this.currentClause = {};
        this.lexemeIdx = 0;
      };
      lunr2.QueryParser.prototype.parse = function() {
        this.lexer.run();
        this.lexemes = this.lexer.lexemes;
        var state2 = lunr2.QueryParser.parseClause;
        while (state2) {
          state2 = state2(this);
        }
        return this.query;
      };
      lunr2.QueryParser.prototype.peekLexeme = function() {
        return this.lexemes[this.lexemeIdx];
      };
      lunr2.QueryParser.prototype.consumeLexeme = function() {
        var lexeme = this.peekLexeme();
        this.lexemeIdx += 1;
        return lexeme;
      };
      lunr2.QueryParser.prototype.nextClause = function() {
        var completedClause = this.currentClause;
        this.query.clause(completedClause);
        this.currentClause = {};
      };
      lunr2.QueryParser.parseClause = function(parser) {
        var lexeme = parser.peekLexeme();
        if (lexeme == void 0) {
          return;
        }
        switch (lexeme.type) {
          case lunr2.QueryLexer.PRESENCE:
            return lunr2.QueryParser.parsePresence;
          case lunr2.QueryLexer.FIELD:
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expected either a field or a term, found " + lexeme.type;
            if (lexeme.str.length >= 1) {
              errorMessage += " with value '" + lexeme.str + "'";
            }
            throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
      };
      lunr2.QueryParser.parsePresence = function(parser) {
        var lexeme = parser.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        switch (lexeme.str) {
          case "-":
            parser.currentClause.presence = lunr2.Query.presence.PROHIBITED;
            break;
          case "+":
            parser.currentClause.presence = lunr2.Query.presence.REQUIRED;
            break;
          default:
            var errorMessage = "unrecognised presence operator'" + lexeme.str + "'";
            throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        var nextLexeme = parser.peekLexeme();
        if (nextLexeme == void 0) {
          var errorMessage = "expecting term or field, found nothing";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.FIELD:
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseField = function(parser) {
        var lexeme = parser.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        if (parser.query.allFields.indexOf(lexeme.str) == -1) {
          var possibleFields = parser.query.allFields.map(function(f2) {
            return "'" + f2 + "'";
          }).join(", "), errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields;
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser.currentClause.fields = [lexeme.str];
        var nextLexeme = parser.peekLexeme();
        if (nextLexeme == void 0) {
          var errorMessage = "expecting term, found nothing";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            return lunr2.QueryParser.parseTerm;
          default:
            var errorMessage = "expecting term, found '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseTerm = function(parser) {
        var lexeme = parser.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        parser.currentClause.term = lexeme.str.toLowerCase();
        if (lexeme.str.indexOf("*") != -1) {
          parser.currentClause.usePipeline = false;
        }
        var nextLexeme = parser.peekLexeme();
        if (nextLexeme == void 0) {
          parser.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseEditDistance = function(parser) {
        var lexeme = parser.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        var editDistance = parseInt(lexeme.str, 10);
        if (isNaN(editDistance)) {
          var errorMessage = "edit distance must be numeric";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser.currentClause.editDistance = editDistance;
        var nextLexeme = parser.peekLexeme();
        if (nextLexeme == void 0) {
          parser.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      lunr2.QueryParser.parseBoost = function(parser) {
        var lexeme = parser.consumeLexeme();
        if (lexeme == void 0) {
          return;
        }
        var boost = parseInt(lexeme.str, 10);
        if (isNaN(boost)) {
          var errorMessage = "boost must be numeric";
          throw new lunr2.QueryParseError(errorMessage, lexeme.start, lexeme.end);
        }
        parser.currentClause.boost = boost;
        var nextLexeme = parser.peekLexeme();
        if (nextLexeme == void 0) {
          parser.nextClause();
          return;
        }
        switch (nextLexeme.type) {
          case lunr2.QueryLexer.TERM:
            parser.nextClause();
            return lunr2.QueryParser.parseTerm;
          case lunr2.QueryLexer.FIELD:
            parser.nextClause();
            return lunr2.QueryParser.parseField;
          case lunr2.QueryLexer.EDIT_DISTANCE:
            return lunr2.QueryParser.parseEditDistance;
          case lunr2.QueryLexer.BOOST:
            return lunr2.QueryParser.parseBoost;
          case lunr2.QueryLexer.PRESENCE:
            parser.nextClause();
            return lunr2.QueryParser.parsePresence;
          default:
            var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'";
            throw new lunr2.QueryParseError(errorMessage, nextLexeme.start, nextLexeme.end);
        }
      };
      (function(root, factory2) {
        {
          module.exports = factory2();
        }
      })(this, function() {
        return lunr2;
      });
    })();
  })(lunr);
  return lunr.exports;
}
var next$1;
var hasRequiredNext;
function requireNext() {
  if (hasRequiredNext)
    return next$1;
  hasRequiredNext = 1;
  function makeNext() {
    if (typeof process === "object" && typeof process.nextTick === "function") {
      return process.nextTick;
    } else if (typeof setImmediate === "function") {
      return setImmediate;
    } else {
      return function next2(f2) {
        setTimeout(f2, 0);
      };
    }
  }
  next$1 = makeNext();
  return next$1;
}
var maybe;
var hasRequiredMaybe;
function requireMaybe() {
  if (hasRequiredMaybe)
    return maybe;
  hasRequiredMaybe = 1;
  var next2 = requireNext();
  maybe = function maybe2(cb2, promise) {
    if (cb2) {
      promise.then(function(result) {
        next2(function() {
          cb2(null, result);
        });
      }, function(err) {
        next2(function() {
          cb2(err);
        });
      });
      return void 0;
    } else {
      return promise;
    }
  };
  return maybe;
}
var fastSafeStringify;
var hasRequiredFastSafeStringify;
function requireFastSafeStringify() {
  if (hasRequiredFastSafeStringify)
    return fastSafeStringify;
  hasRequiredFastSafeStringify = 1;
  fastSafeStringify = stringify16;
  stringify16.default = stringify16;
  stringify16.stable = deterministicStringify;
  stringify16.stableStringify = deterministicStringify;
  var LIMIT_REPLACE_NODE = "[...]";
  var CIRCULAR_REPLACE_NODE = "[Circular]";
  var arr = [];
  var replacerStack = [];
  function defaultOptions2() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function stringify16(obj, replacer, spacer, options2) {
    if (typeof options2 === "undefined") {
      options2 = defaultOptions2();
    }
    decirc(obj, "", 0, [], void 0, 0, options2);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_2) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function setReplace(replace3, val, k2, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
    if (propertyDescriptor.get !== void 0) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k2, { value: replace3 });
        arr.push([parent, k2, val, propertyDescriptor]);
      } else {
        replacerStack.push([val, k2, replace3]);
      }
    } else {
      parent[k2] = replace3;
      arr.push([parent, k2, val]);
    }
  }
  function decirc(val, k2, edgeIndex, stack, parent, depth, options2) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
          return;
        }
      }
      if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          decirc(val[i], i, i, stack, val, depth, options2);
        }
      } else {
        var keys2 = Object.keys(val);
        for (i = 0; i < keys2.length; i++) {
          var key2 = keys2[i];
          decirc(val[key2], key2, i, stack, val, depth, options2);
        }
      }
      stack.pop();
    }
  }
  function compareFunction(a, b2) {
    if (a < b2) {
      return -1;
    }
    if (a > b2) {
      return 1;
    }
    return 0;
  }
  function deterministicStringify(obj, replacer, spacer, options2) {
    if (typeof options2 === "undefined") {
      options2 = defaultOptions2();
    }
    var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(tmp, replacer, spacer);
      } else {
        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
      }
    } catch (_2) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function deterministicDecirc(val, k2, edgeIndex, stack, parent, depth, options2) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
          return;
        }
      }
      try {
        if (typeof val.toJSON === "function") {
          return;
        }
      } catch (_2) {
        return;
      }
      if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          deterministicDecirc(val[i], i, i, stack, val, depth, options2);
        }
      } else {
        var tmp = {};
        var keys2 = Object.keys(val).sort(compareFunction);
        for (i = 0; i < keys2.length; i++) {
          var key2 = keys2[i];
          deterministicDecirc(val[key2], key2, i, stack, val, depth, options2);
          tmp[key2] = val[key2];
        }
        if (typeof parent !== "undefined") {
          arr.push([parent, k2, val]);
          parent[k2] = tmp;
        } else {
          return tmp;
        }
      }
      stack.pop();
    }
  }
  function replaceGetterValues(replacer) {
    replacer = typeof replacer !== "undefined" ? replacer : function(k2, v2) {
      return v2;
    };
    return function(key2, val) {
      if (replacerStack.length > 0) {
        for (var i = 0; i < replacerStack.length; i++) {
          var part = replacerStack[i];
          if (part[1] === key2 && part[0] === val) {
            val = part[2];
            replacerStack.splice(i, 1);
            break;
          }
        }
      }
      return replacer.call(this, key2, val);
    };
  }
  return fastSafeStringify;
}
/*!
 * Stickyfill -- `position: sticky` polyfill
 * v. 1.1.1 | https://github.com/wilddeer/stickyfill
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 */
var stickyfill;
var hasRequiredStickyfill;
function requireStickyfill() {
  if (hasRequiredStickyfill)
    return stickyfill;
  hasRequiredStickyfill = 1;
  stickyfill = function(doc, win) {
    if (!doc) {
      doc = document;
    }
    if (!win) {
      win = window;
    }
    var watchArray = [], scroll2, initialized = false, html = doc.documentElement, noop4 = function() {
    }, checkTimer, hiddenPropertyName = "hidden", visibilityChangeEventName = "visibilitychange";
    if (doc.webkitHidden !== void 0) {
      hiddenPropertyName = "webkitHidden";
      visibilityChangeEventName = "webkitvisibilitychange";
    }
    if (!win.getComputedStyle) {
      seppuku();
    }
    var prefixes = ["", "-webkit-", "-moz-", "-ms-"], block = document.createElement("div");
    for (var i = prefixes.length - 1; i >= 0; i--) {
      try {
        block.style.position = prefixes[i] + "sticky";
      } catch (e2) {
      }
      if (block.style.position != "") {
        seppuku();
      }
    }
    updateScrollPos();
    function seppuku() {
      init = add2 = rebuild = pause = stop = kill = noop4;
    }
    function mergeObjects(targetObj, sourceObject) {
      for (key in sourceObject) {
        if (sourceObject.hasOwnProperty(key)) {
          targetObj[key] = sourceObject[key];
        }
      }
    }
    function parseNumeric(val) {
      return parseFloat(val) || 0;
    }
    function updateScrollPos() {
      scroll2 = {
        top: win.pageYOffset,
        left: win.pageXOffset
      };
    }
    function onScroll2() {
      if (win.pageXOffset != scroll2.left) {
        updateScrollPos();
        rebuild();
        return;
      }
      if (win.pageYOffset != scroll2.top) {
        updateScrollPos();
        recalcAllPos();
      }
    }
    function onWheel(event) {
      setTimeout(function() {
        if (win.pageYOffset != scroll2.top) {
          scroll2.top = win.pageYOffset;
          recalcAllPos();
        }
      }, 0);
    }
    function recalcAllPos() {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        recalcElementPos(watchArray[i2]);
      }
    }
    function recalcElementPos(el2) {
      if (!el2.inited)
        return;
      var currentMode = scroll2.top <= el2.limit.start ? 0 : scroll2.top >= el2.limit.end ? 2 : 1;
      if (el2.mode != currentMode) {
        switchElementMode(el2, currentMode);
      }
    }
    function fastCheck() {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        if (!watchArray[i2].inited)
          continue;
        var deltaTop = Math.abs(getDocOffsetTop(watchArray[i2].clone) - watchArray[i2].docOffsetTop), deltaHeight = Math.abs(watchArray[i2].parent.node.offsetHeight - watchArray[i2].parent.height);
        if (deltaTop >= 2 || deltaHeight >= 2)
          return false;
      }
      return true;
    }
    function initElement(el2) {
      if (isNaN(parseFloat(el2.computed.top)) || el2.isCell)
        return;
      el2.inited = true;
      if (!el2.clone)
        clone(el2);
      if (el2.parent.computed.position != "absolute" && el2.parent.computed.position != "relative")
        el2.parent.node.style.position = "relative";
      recalcElementPos(el2);
      el2.parent.height = el2.parent.node.offsetHeight;
      el2.docOffsetTop = getDocOffsetTop(el2.clone);
    }
    function deinitElement(el2) {
      var deinitParent = true;
      el2.clone && killClone(el2);
      mergeObjects(el2.node.style, el2.css);
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        if (watchArray[i2].node !== el2.node && watchArray[i2].parent.node === el2.parent.node) {
          deinitParent = false;
          break;
        }
      }
      if (deinitParent)
        el2.parent.node.style.position = el2.parent.css.position;
      el2.mode = -1;
    }
    function initAll() {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        initElement(watchArray[i2]);
      }
    }
    function deinitAll() {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        deinitElement(watchArray[i2]);
      }
    }
    function switchElementMode(el2, mode2) {
      var nodeStyle = el2.node.style;
      switch (mode2) {
        case 0:
          nodeStyle.position = "absolute";
          nodeStyle.left = el2.offset.left + "px";
          nodeStyle.right = el2.offset.right + "px";
          nodeStyle.top = el2.offset.top + "px";
          nodeStyle.bottom = "auto";
          nodeStyle.width = "auto";
          nodeStyle.marginLeft = 0;
          nodeStyle.marginRight = 0;
          nodeStyle.marginTop = 0;
          break;
        case 1:
          nodeStyle.position = "fixed";
          nodeStyle.left = el2.box.left + "px";
          nodeStyle.right = el2.box.right + "px";
          nodeStyle.top = el2.css.top;
          nodeStyle.bottom = "auto";
          nodeStyle.width = "auto";
          nodeStyle.marginLeft = 0;
          nodeStyle.marginRight = 0;
          nodeStyle.marginTop = 0;
          break;
        case 2:
          nodeStyle.position = "absolute";
          nodeStyle.left = el2.offset.left + "px";
          nodeStyle.right = el2.offset.right + "px";
          nodeStyle.top = "auto";
          nodeStyle.bottom = 0;
          nodeStyle.width = "auto";
          nodeStyle.marginLeft = 0;
          nodeStyle.marginRight = 0;
          break;
      }
      el2.mode = mode2;
    }
    function clone(el2) {
      el2.clone = document.createElement("div");
      var refElement = el2.node.nextSibling || el2.node, cloneStyle = el2.clone.style;
      cloneStyle.height = el2.height + "px";
      cloneStyle.width = el2.width + "px";
      cloneStyle.marginTop = el2.computed.marginTop;
      cloneStyle.marginBottom = el2.computed.marginBottom;
      cloneStyle.marginLeft = el2.computed.marginLeft;
      cloneStyle.marginRight = el2.computed.marginRight;
      cloneStyle.padding = cloneStyle.border = cloneStyle.borderSpacing = 0;
      cloneStyle.fontSize = "1em";
      cloneStyle.position = "static";
      cloneStyle.cssFloat = el2.computed.cssFloat;
      el2.node.parentNode.insertBefore(el2.clone, refElement);
    }
    function killClone(el2) {
      el2.clone.parentNode.removeChild(el2.clone);
      el2.clone = void 0;
    }
    function getElementParams(node2) {
      var computedStyle = getComputedStyle(node2), parentNode = node2.parentNode, parentComputedStyle = getComputedStyle(parentNode), cachedPosition = node2.style.position;
      node2.style.position = "relative";
      var computed3 = {
        top: computedStyle.top,
        marginTop: computedStyle.marginTop,
        marginBottom: computedStyle.marginBottom,
        marginLeft: computedStyle.marginLeft,
        marginRight: computedStyle.marginRight,
        cssFloat: computedStyle.cssFloat
      }, numeric = {
        top: parseNumeric(computedStyle.top),
        marginBottom: parseNumeric(computedStyle.marginBottom),
        paddingLeft: parseNumeric(computedStyle.paddingLeft),
        paddingRight: parseNumeric(computedStyle.paddingRight),
        borderLeftWidth: parseNumeric(computedStyle.borderLeftWidth),
        borderRightWidth: parseNumeric(computedStyle.borderRightWidth)
      };
      node2.style.position = cachedPosition;
      var css4 = {
        position: node2.style.position,
        top: node2.style.top,
        bottom: node2.style.bottom,
        left: node2.style.left,
        right: node2.style.right,
        width: node2.style.width,
        marginTop: node2.style.marginTop,
        marginLeft: node2.style.marginLeft,
        marginRight: node2.style.marginRight
      }, nodeOffset = getElementOffset(node2), parentOffset = getElementOffset(parentNode), parent = {
        node: parentNode,
        css: {
          position: parentNode.style.position
        },
        computed: {
          position: parentComputedStyle.position
        },
        numeric: {
          borderLeftWidth: parseNumeric(parentComputedStyle.borderLeftWidth),
          borderRightWidth: parseNumeric(parentComputedStyle.borderRightWidth),
          borderTopWidth: parseNumeric(parentComputedStyle.borderTopWidth),
          borderBottomWidth: parseNumeric(parentComputedStyle.borderBottomWidth)
        }
      }, el2 = {
        node: node2,
        box: {
          left: nodeOffset.win.left,
          right: html.clientWidth - nodeOffset.win.right
        },
        offset: {
          top: nodeOffset.win.top - parentOffset.win.top - parent.numeric.borderTopWidth,
          left: nodeOffset.win.left - parentOffset.win.left - parent.numeric.borderLeftWidth,
          right: -nodeOffset.win.right + parentOffset.win.right - parent.numeric.borderRightWidth
        },
        css: css4,
        isCell: computedStyle.display == "table-cell",
        computed: computed3,
        numeric,
        width: nodeOffset.win.right - nodeOffset.win.left,
        height: nodeOffset.win.bottom - nodeOffset.win.top,
        mode: -1,
        inited: false,
        parent,
        limit: {
          start: nodeOffset.doc.top - numeric.top,
          end: parentOffset.doc.top + parentNode.offsetHeight - parent.numeric.borderBottomWidth - node2.offsetHeight - numeric.top - numeric.marginBottom
        }
      };
      return el2;
    }
    function getDocOffsetTop(node2) {
      var docOffsetTop = 0;
      while (node2) {
        docOffsetTop += node2.offsetTop;
        node2 = node2.offsetParent;
      }
      return docOffsetTop;
    }
    function getElementOffset(node2) {
      var box2 = node2.getBoundingClientRect();
      return {
        doc: {
          top: box2.top + win.pageYOffset,
          left: box2.left + win.pageXOffset
        },
        win: box2
      };
    }
    function startFastCheckTimer() {
      checkTimer = setInterval(function() {
        !fastCheck() && rebuild();
      }, 500);
    }
    function stopFastCheckTimer() {
      clearInterval(checkTimer);
    }
    function handlePageVisibilityChange() {
      if (!initialized)
        return;
      if (document[hiddenPropertyName]) {
        stopFastCheckTimer();
      } else {
        startFastCheckTimer();
      }
    }
    function init() {
      if (initialized)
        return;
      updateScrollPos();
      initAll();
      win.addEventListener("scroll", onScroll2);
      win.addEventListener("wheel", onWheel);
      win.addEventListener("resize", rebuild);
      win.addEventListener("orientationchange", rebuild);
      doc.addEventListener(visibilityChangeEventName, handlePageVisibilityChange);
      startFastCheckTimer();
      initialized = true;
    }
    function rebuild() {
      if (!initialized)
        return;
      deinitAll();
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        watchArray[i2] = getElementParams(watchArray[i2].node);
      }
      initAll();
    }
    function pause() {
      win.removeEventListener("scroll", onScroll2);
      win.removeEventListener("wheel", onWheel);
      win.removeEventListener("resize", rebuild);
      win.removeEventListener("orientationchange", rebuild);
      doc.removeEventListener(visibilityChangeEventName, handlePageVisibilityChange);
      stopFastCheckTimer();
      initialized = false;
    }
    function stop() {
      pause();
      deinitAll();
    }
    function kill() {
      stop();
      while (watchArray.length) {
        watchArray.pop();
      }
    }
    function add2(node2) {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        if (watchArray[i2].node === node2)
          return;
      }
      var el2 = getElementParams(node2);
      watchArray.push(el2);
      if (!initialized) {
        init();
      } else {
        initElement(el2);
      }
    }
    function remove3(node2) {
      for (var i2 = watchArray.length - 1; i2 >= 0; i2--) {
        if (watchArray[i2].node === node2) {
          deinitElement(watchArray[i2]);
          watchArray.splice(i2, 1);
        }
      }
    }
    return {
      stickies: watchArray,
      add: add2,
      remove: remove3,
      init,
      rebuild,
      pause,
      stop,
      kill
    };
  };
  return stickyfill;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct$1(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct$1 = Reflect.construct;
  } else {
    _construct$1 = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$1.apply(null, arguments);
}
function _isNativeFunction$1(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper$1(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper$1 = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction$1(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct$1(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper$1(Class);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _superPropBase(object2, property) {
  while (!Object.prototype.hasOwnProperty.call(object2, property)) {
    object2 = _getPrototypeOf$1(object2);
    if (object2 === null)
      break;
  }
  return object2;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$1();
}
function _toArray(arr) {
  return _arrayWithHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableRest$1();
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit$1(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d2 = false;
  var _e2 = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d2 = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d2)
        throw _e2;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it2 = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2)
        o = it2;
      var i = 0;
      var F2 = function() {
      };
      return {
        s: F2,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e2) {
          throw e2;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it2 = o[Symbol.iterator]();
    },
    n: function() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e2) {
      didErr = true;
      err = e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var Char = {
  ANCHOR: "&",
  COMMENT: "#",
  TAG: "!",
  DIRECTIVES_END: "-",
  DOCUMENT_END: "."
};
var Type = {
  ALIAS: "ALIAS",
  BLANK_LINE: "BLANK_LINE",
  BLOCK_FOLDED: "BLOCK_FOLDED",
  BLOCK_LITERAL: "BLOCK_LITERAL",
  COMMENT: "COMMENT",
  DIRECTIVE: "DIRECTIVE",
  DOCUMENT: "DOCUMENT",
  FLOW_MAP: "FLOW_MAP",
  FLOW_SEQ: "FLOW_SEQ",
  MAP: "MAP",
  MAP_KEY: "MAP_KEY",
  MAP_VALUE: "MAP_VALUE",
  PLAIN: "PLAIN",
  QUOTE_DOUBLE: "QUOTE_DOUBLE",
  QUOTE_SINGLE: "QUOTE_SINGLE",
  SEQ: "SEQ",
  SEQ_ITEM: "SEQ_ITEM"
};
var defaultTagPrefix$1 = "tag:yaml.org,2002:";
var defaultTags = {
  MAP: "tag:yaml.org,2002:map",
  SEQ: "tag:yaml.org,2002:seq",
  STR: "tag:yaml.org,2002:str"
};
function findLineStarts(src) {
  var ls = [0];
  var offset2 = src.indexOf("\n");
  while (offset2 !== -1) {
    offset2 += 1;
    ls.push(offset2);
    offset2 = src.indexOf("\n", offset2);
  }
  return ls;
}
function getSrcInfo(cst) {
  var lineStarts, src;
  if (typeof cst === "string") {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst))
      cst = cst[0];
    if (cst && cst.context) {
      if (!cst.lineStarts)
        cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }
  return {
    lineStarts,
    src
  };
}
function getLinePos(offset2, cst) {
  if (typeof offset2 !== "number" || offset2 < 0)
    return null;
  var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
  if (!lineStarts || !src || offset2 > src.length)
    return null;
  for (var i = 0; i < lineStarts.length; ++i) {
    var start2 = lineStarts[i];
    if (offset2 < start2) {
      return {
        line: i,
        col: offset2 - lineStarts[i - 1] + 1
      };
    }
    if (offset2 === start2)
      return {
        line: i + 1,
        col: 1
      };
  }
  var line2 = lineStarts.length;
  return {
    line: line2,
    col: offset2 - lineStarts[line2 - 1] + 1
  };
}
function getLine(line2, cst) {
  var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
  if (!lineStarts || !(line2 >= 1) || line2 > lineStarts.length)
    return null;
  var start2 = lineStarts[line2 - 1];
  var end2 = lineStarts[line2];
  while (end2 && end2 > start2 && src[end2 - 1] === "\n") {
    --end2;
  }
  return src.slice(start2, end2);
}
function getPrettyContext(_ref3, cst) {
  var start2 = _ref3.start, end2 = _ref3.end;
  var maxWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80;
  var src = getLine(start2.line, cst);
  if (!src)
    return null;
  var col = start2.col;
  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + "";
    } else {
      var halfWidth2 = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth2)
        src = src.substr(0, col + halfWidth2 - 1) + "";
      col -= src.length - maxWidth;
      src = "" + src.substr(1 - maxWidth);
    }
  }
  var errLen = 1;
  var errEnd = "";
  if (end2) {
    if (end2.line === start2.line && col + (end2.col - start2.col) <= maxWidth + 1) {
      errLen = end2.col - start2.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = "";
    }
  }
  var offset2 = col > 1 ? " ".repeat(col - 1) : "";
  var err = "^".repeat(errLen);
  return "".concat(src, "\n").concat(offset2).concat(err).concat(errEnd);
}
var Range = /* @__PURE__ */ function() {
  function Range2(start2, end2) {
    _classCallCheck$1(this, Range2);
    this.start = start2;
    this.end = end2 || start2;
  }
  _createClass$2(Range2, [{
    key: "isEmpty",
    value: function isEmpty2() {
      return typeof this.start !== "number" || !this.end || this.end <= this.start;
    }
    /**
     * Set `origStart` and `origEnd` to point to the original source range for
     * this node, which may differ due to dropped CR characters.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRange",
    value: function setOrigRange(cr, offset2) {
      var start2 = this.start, end2 = this.end;
      if (cr.length === 0 || end2 <= cr[0]) {
        this.origStart = start2;
        this.origEnd = end2;
        return offset2;
      }
      var i = offset2;
      while (i < cr.length) {
        if (cr[i] > start2)
          break;
        else
          ++i;
      }
      this.origStart = start2 + i;
      var nextOffset = i;
      while (i < cr.length) {
        if (cr[i] >= end2)
          break;
        else
          ++i;
      }
      this.origEnd = end2 + i;
      return nextOffset;
    }
  }], [{
    key: "copy",
    value: function copy2(orig) {
      return new Range2(orig.start, orig.end);
    }
  }]);
  return Range2;
}();
var Node$2 = /* @__PURE__ */ function() {
  function Node3(type2, props, context) {
    _classCallCheck$1(this, Node3);
    Object.defineProperty(this, "context", {
      value: context || null,
      writable: true
    });
    this.error = null;
    this.range = null;
    this.valueRange = null;
    this.props = props || [];
    this.type = type2;
    this.value = null;
  }
  _createClass$2(Node3, [{
    key: "getPropValue",
    value: function getPropValue(idx, key2, skipKey) {
      if (!this.context)
        return null;
      var src = this.context.src;
      var prop = this.props[idx];
      return prop && src[prop.start] === key2 ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
    }
  }, {
    key: "anchor",
    get: function get4() {
      for (var i = 0; i < this.props.length; ++i) {
        var anchor = this.getPropValue(i, Char.ANCHOR, true);
        if (anchor != null)
          return anchor;
      }
      return null;
    }
  }, {
    key: "comment",
    get: function get4() {
      var comments = [];
      for (var i = 0; i < this.props.length; ++i) {
        var comment2 = this.getPropValue(i, Char.COMMENT, true);
        if (comment2 != null)
          comments.push(comment2);
      }
      return comments.length > 0 ? comments.join("\n") : null;
    }
  }, {
    key: "commentHasRequiredWhitespace",
    value: function commentHasRequiredWhitespace(start2) {
      var src = this.context.src;
      if (this.header && start2 === this.header.end)
        return false;
      if (!this.valueRange)
        return false;
      var end2 = this.valueRange.end;
      return start2 !== end2 || Node3.atBlank(src, end2 - 1);
    }
  }, {
    key: "hasComment",
    get: function get4() {
      if (this.context) {
        var src = this.context.src;
        for (var i = 0; i < this.props.length; ++i) {
          if (src[this.props[i].start] === Char.COMMENT)
            return true;
        }
      }
      return false;
    }
  }, {
    key: "hasProps",
    get: function get4() {
      if (this.context) {
        var src = this.context.src;
        for (var i = 0; i < this.props.length; ++i) {
          if (src[this.props[i].start] !== Char.COMMENT)
            return true;
        }
      }
      return false;
    }
  }, {
    key: "includesTrailingLines",
    get: function get4() {
      return false;
    }
  }, {
    key: "jsonLike",
    get: function get4() {
      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
      return jsonLikeTypes.indexOf(this.type) !== -1;
    }
  }, {
    key: "rangeAsLinePos",
    get: function get4() {
      if (!this.range || !this.context)
        return void 0;
      var start2 = getLinePos(this.range.start, this.context.root);
      if (!start2)
        return void 0;
      var end2 = getLinePos(this.range.end, this.context.root);
      return {
        start: start2,
        end: end2
      };
    }
  }, {
    key: "rawValue",
    get: function get4() {
      if (!this.valueRange || !this.context)
        return null;
      var _this$valueRange = this.valueRange, start2 = _this$valueRange.start, end2 = _this$valueRange.end;
      return this.context.src.slice(start2, end2);
    }
  }, {
    key: "tag",
    get: function get4() {
      for (var i = 0; i < this.props.length; ++i) {
        var tag = this.getPropValue(i, Char.TAG, false);
        if (tag != null) {
          if (tag[1] === "<") {
            return {
              verbatim: tag.slice(2, -1)
            };
          } else {
            var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = _slicedToArray$1(_tag$match, 3);
            _tag$match2[0];
            var handle = _tag$match2[1], suffix = _tag$match2[2];
            return {
              handle,
              suffix
            };
          }
        }
      }
      return null;
    }
  }, {
    key: "valueRangeContainsNewline",
    get: function get4() {
      if (!this.valueRange || !this.context)
        return false;
      var _this$valueRange2 = this.valueRange, start2 = _this$valueRange2.start, end2 = _this$valueRange2.end;
      var src = this.context.src;
      for (var i = start2; i < end2; ++i) {
        if (src[i] === "\n")
          return true;
      }
      return false;
    }
  }, {
    key: "parseComment",
    value: function parseComment(start2) {
      var src = this.context.src;
      if (src[start2] === Char.COMMENT) {
        var end2 = Node3.endOfLine(src, start2 + 1);
        var commentRange = new Range(start2, end2);
        this.props.push(commentRange);
        return end2;
      }
      return start2;
    }
    /**
     * Populates the `origStart` and `origEnd` values of all ranges for this
     * node. Extended by child classes to handle descendant nodes.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      if (this.range)
        offset2 = this.range.setOrigRange(cr, offset2);
      if (this.valueRange)
        this.valueRange.setOrigRange(cr, offset2);
      this.props.forEach(function(prop) {
        return prop.setOrigRange(cr, offset2);
      });
      return offset2;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var src = this.context.src, range = this.range, value = this.value;
      if (value != null)
        return value;
      var str2 = src.slice(range.start, range.end);
      return Node3.addStringTerminator(src, range.end, str2);
    }
  }], [{
    key: "addStringTerminator",
    value: function addStringTerminator(src, offset2, str2) {
      if (str2[str2.length - 1] === "\n")
        return str2;
      var next2 = Node3.endOfWhiteSpace(src, offset2);
      return next2 >= src.length || src[next2] === "\n" ? str2 + "\n" : str2;
    }
    // ^(---|...)
  }, {
    key: "atDocumentBoundary",
    value: function atDocumentBoundary(src, offset2, sep) {
      var ch0 = src[offset2];
      if (!ch0)
        return true;
      var prev2 = src[offset2 - 1];
      if (prev2 && prev2 !== "\n")
        return false;
      if (sep) {
        if (ch0 !== sep)
          return false;
      } else {
        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
          return false;
      }
      var ch1 = src[offset2 + 1];
      var ch2 = src[offset2 + 2];
      if (ch1 !== ch0 || ch2 !== ch0)
        return false;
      var ch3 = src[offset2 + 3];
      return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
    }
  }, {
    key: "endOfIdentifier",
    value: function endOfIdentifier(src, offset2) {
      var ch2 = src[offset2];
      var isVerbatim = ch2 === "<";
      var notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
      while (ch2 && notOk.indexOf(ch2) === -1) {
        ch2 = src[offset2 += 1];
      }
      if (isVerbatim && ch2 === ">")
        offset2 += 1;
      return offset2;
    }
  }, {
    key: "endOfIndent",
    value: function endOfIndent(src, offset2) {
      var ch2 = src[offset2];
      while (ch2 === " ") {
        ch2 = src[offset2 += 1];
      }
      return offset2;
    }
  }, {
    key: "endOfLine",
    value: function endOfLine(src, offset2) {
      var ch2 = src[offset2];
      while (ch2 && ch2 !== "\n") {
        ch2 = src[offset2 += 1];
      }
      return offset2;
    }
  }, {
    key: "endOfWhiteSpace",
    value: function endOfWhiteSpace(src, offset2) {
      var ch2 = src[offset2];
      while (ch2 === "	" || ch2 === " ") {
        ch2 = src[offset2 += 1];
      }
      return offset2;
    }
  }, {
    key: "startOfLine",
    value: function startOfLine(src, offset2) {
      var ch2 = src[offset2 - 1];
      if (ch2 === "\n")
        return offset2;
      while (ch2 && ch2 !== "\n") {
        ch2 = src[offset2 -= 1];
      }
      return offset2 + 1;
    }
    /**
     * End of indentation, or null if the line's indent level is not more
     * than `indent`
     *
     * @param {string} src
     * @param {number} indent
     * @param {number} lineStart
     * @returns {?number}
     */
  }, {
    key: "endOfBlockIndent",
    value: function endOfBlockIndent(src, indent, lineStart) {
      var inEnd = Node3.endOfIndent(src, lineStart);
      if (inEnd > lineStart + indent) {
        return inEnd;
      } else {
        var wsEnd = Node3.endOfWhiteSpace(src, inEnd);
        var ch2 = src[wsEnd];
        if (!ch2 || ch2 === "\n")
          return wsEnd;
      }
      return null;
    }
  }, {
    key: "atBlank",
    value: function atBlank(src, offset2, endAsBlank) {
      var ch2 = src[offset2];
      return ch2 === "\n" || ch2 === "	" || ch2 === " " || endAsBlank && !ch2;
    }
  }, {
    key: "nextNodeIsIndented",
    value: function nextNodeIsIndented(ch2, indentDiff, indicatorAsIndent) {
      if (!ch2 || indentDiff < 0)
        return false;
      if (indentDiff > 0)
        return true;
      return indicatorAsIndent && ch2 === "-";
    }
    // should be at line or string end, or at next non-whitespace char
  }, {
    key: "normalizeOffset",
    value: function normalizeOffset(src, offset2) {
      var ch2 = src[offset2];
      return !ch2 ? offset2 : ch2 !== "\n" && src[offset2 - 1] === "\n" ? offset2 - 1 : Node3.endOfWhiteSpace(src, offset2);
    }
    // fold single newline into space, multiple newlines to N - 1 newlines
    // presumes src[offset] === '\n'
  }, {
    key: "foldNewline",
    value: function foldNewline(src, offset2, indent) {
      var inCount = 0;
      var error = false;
      var fold = "";
      var ch2 = src[offset2 + 1];
      while (ch2 === " " || ch2 === "	" || ch2 === "\n") {
        switch (ch2) {
          case "\n":
            inCount = 0;
            offset2 += 1;
            fold += "\n";
            break;
          case "	":
            if (inCount <= indent)
              error = true;
            offset2 = Node3.endOfWhiteSpace(src, offset2 + 2) - 1;
            break;
          case " ":
            inCount += 1;
            offset2 += 1;
            break;
        }
        ch2 = src[offset2 + 1];
      }
      if (!fold)
        fold = " ";
      if (ch2 && inCount <= indent)
        error = true;
      return {
        fold,
        offset: offset2,
        error
      };
    }
  }]);
  return Node3;
}();
var YAMLError = /* @__PURE__ */ function(_Error) {
  _inherits$1(YAMLError2, _Error);
  var _super = _createSuper$1(YAMLError2);
  function YAMLError2(name2, source, message) {
    var _this;
    _classCallCheck$1(this, YAMLError2);
    if (!message || !(source instanceof Node$2))
      throw new Error("Invalid arguments for new ".concat(name2));
    _this = _super.call(this);
    _this.name = name2;
    _this.message = message;
    _this.source = source;
    return _this;
  }
  _createClass$2(YAMLError2, [{
    key: "makePretty",
    value: function makePretty() {
      if (!this.source)
        return;
      this.nodeType = this.source.type;
      var cst = this.source.context && this.source.context.root;
      if (typeof this.offset === "number") {
        this.range = new Range(this.offset, this.offset + 1);
        var start2 = cst && getLinePos(this.offset, cst);
        if (start2) {
          var end2 = {
            line: start2.line,
            col: start2.col + 1
          };
          this.linePos = {
            start: start2,
            end: end2
          };
        }
        delete this.offset;
      } else {
        this.range = this.source.range;
        this.linePos = this.source.rangeAsLinePos;
      }
      if (this.linePos) {
        var _this$linePos$start = this.linePos.start, line2 = _this$linePos$start.line, col = _this$linePos$start.col;
        this.message += " at line ".concat(line2, ", column ").concat(col);
        var ctx = cst && getPrettyContext(this.linePos, cst);
        if (ctx)
          this.message += ":\n\n".concat(ctx, "\n");
      }
      delete this.source;
    }
  }]);
  return YAMLError2;
}(/* @__PURE__ */ _wrapNativeSuper$1(Error));
var YAMLReferenceError = /* @__PURE__ */ function(_YAMLError) {
  _inherits$1(YAMLReferenceError2, _YAMLError);
  var _super2 = _createSuper$1(YAMLReferenceError2);
  function YAMLReferenceError2(source, message) {
    _classCallCheck$1(this, YAMLReferenceError2);
    return _super2.call(this, "YAMLReferenceError", source, message);
  }
  return YAMLReferenceError2;
}(YAMLError);
var YAMLSemanticError = /* @__PURE__ */ function(_YAMLError2) {
  _inherits$1(YAMLSemanticError2, _YAMLError2);
  var _super3 = _createSuper$1(YAMLSemanticError2);
  function YAMLSemanticError2(source, message) {
    _classCallCheck$1(this, YAMLSemanticError2);
    return _super3.call(this, "YAMLSemanticError", source, message);
  }
  return YAMLSemanticError2;
}(YAMLError);
var YAMLSyntaxError = /* @__PURE__ */ function(_YAMLError3) {
  _inherits$1(YAMLSyntaxError2, _YAMLError3);
  var _super4 = _createSuper$1(YAMLSyntaxError2);
  function YAMLSyntaxError2(source, message) {
    _classCallCheck$1(this, YAMLSyntaxError2);
    return _super4.call(this, "YAMLSyntaxError", source, message);
  }
  return YAMLSyntaxError2;
}(YAMLError);
var YAMLWarning = /* @__PURE__ */ function(_YAMLError4) {
  _inherits$1(YAMLWarning2, _YAMLError4);
  var _super5 = _createSuper$1(YAMLWarning2);
  function YAMLWarning2(source, message) {
    _classCallCheck$1(this, YAMLWarning2);
    return _super5.call(this, "YAMLWarning", source, message);
  }
  return YAMLWarning2;
}(YAMLError);
var PlainValue = /* @__PURE__ */ function(_Node) {
  _inherits$1(PlainValue2, _Node);
  var _super = _createSuper$1(PlainValue2);
  function PlainValue2() {
    _classCallCheck$1(this, PlainValue2);
    return _super.apply(this, arguments);
  }
  _createClass$2(PlainValue2, [{
    key: "strValue",
    get: function get4() {
      if (!this.valueRange || !this.context)
        return null;
      var _this$valueRange = this.valueRange, start2 = _this$valueRange.start, end2 = _this$valueRange.end;
      var src = this.context.src;
      var ch2 = src[end2 - 1];
      while (start2 < end2 && (ch2 === "\n" || ch2 === "	" || ch2 === " ")) {
        ch2 = src[--end2 - 1];
      }
      var str2 = "";
      for (var i = start2; i < end2; ++i) {
        var _ch = src[i];
        if (_ch === "\n") {
          var _Node$foldNewline = Node$2.foldNewline(src, i, -1), fold = _Node$foldNewline.fold, offset2 = _Node$foldNewline.offset;
          str2 += fold;
          i = offset2;
        } else if (_ch === " " || _ch === "	") {
          var wsStart = i;
          var next2 = src[i + 1];
          while (i < end2 && (next2 === " " || next2 === "	")) {
            i += 1;
            next2 = src[i + 1];
          }
          if (next2 !== "\n")
            str2 += i > wsStart ? src.slice(wsStart, i + 1) : _ch;
        } else {
          str2 += _ch;
        }
      }
      var ch0 = src[start2];
      switch (ch0) {
        case "	": {
          var msg = "Plain value cannot start with a tab character";
          var errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str: str2
          };
        }
        case "@":
        case "`": {
          var _msg = "Plain value cannot start with reserved character ".concat(ch0);
          var _errors = [new YAMLSemanticError(this, _msg)];
          return {
            errors: _errors,
            str: str2
          };
        }
        default:
          return str2;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function parseBlockValue(start2) {
      var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
      var offset2 = start2;
      var valueEnd = start2;
      for (var ch2 = src[offset2]; ch2 === "\n"; ch2 = src[offset2]) {
        if (Node$2.atDocumentBoundary(src, offset2 + 1))
          break;
        var end2 = Node$2.endOfBlockIndent(src, indent, offset2 + 1);
        if (end2 === null || src[end2] === "#")
          break;
        if (src[end2] === "\n") {
          offset2 = end2;
        } else {
          valueEnd = PlainValue2.endOfLine(src, end2, inFlow);
          offset2 = valueEnd;
        }
      }
      if (this.valueRange.isEmpty())
        this.valueRange.start = start2;
      this.valueRange.end = valueEnd;
      return valueEnd;
    }
    /**
     * Parses a plain value from the source
     *
     * Accepted forms are:
     * ```
     * #comment
     *
     * first line
     *
     * first line #comment
     *
     * first line
     * block
     * lines
     *
     * #comment
     * block
     * lines
     * ```
     * where block lines are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar, may be `\n`
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var inFlow = context.inFlow, src = context.src;
      var offset2 = start2;
      var ch2 = src[offset2];
      if (ch2 && ch2 !== "#" && ch2 !== "\n") {
        offset2 = PlainValue2.endOfLine(src, start2, inFlow);
      }
      this.valueRange = new Range(start2, offset2);
      offset2 = Node$2.endOfWhiteSpace(src, offset2);
      offset2 = this.parseComment(offset2);
      if (!this.hasComment || this.valueRange.isEmpty()) {
        offset2 = this.parseBlockValue(offset2);
      }
      return offset2;
    }
  }], [{
    key: "endOfLine",
    value: function endOfLine(src, start2, inFlow) {
      var ch2 = src[start2];
      var offset2 = start2;
      while (ch2 && ch2 !== "\n") {
        if (inFlow && (ch2 === "[" || ch2 === "]" || ch2 === "{" || ch2 === "}" || ch2 === ","))
          break;
        var next2 = src[offset2 + 1];
        if (ch2 === ":" && (!next2 || next2 === "\n" || next2 === "	" || next2 === " " || inFlow && next2 === ","))
          break;
        if ((ch2 === " " || ch2 === "	") && next2 === "#")
          break;
        offset2 += 1;
        ch2 = next2;
      }
      return offset2;
    }
  }]);
  return PlainValue2;
}(Node$2);
var BlankLine = /* @__PURE__ */ function(_Node) {
  _inherits$1(BlankLine2, _Node);
  var _super = _createSuper$1(BlankLine2);
  function BlankLine2() {
    _classCallCheck$1(this, BlankLine2);
    return _super.call(this, Type.BLANK_LINE);
  }
  _createClass$2(BlankLine2, [{
    key: "includesTrailingLines",
    get: function get4() {
      return true;
    }
    /**
     * Parses a blank line from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first \n character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      this.range = new Range(start2, start2 + 1);
      return start2 + 1;
    }
  }]);
  return BlankLine2;
}(Node$2);
var CollectionItem = /* @__PURE__ */ function(_Node) {
  _inherits$1(CollectionItem2, _Node);
  var _super = _createSuper$1(CollectionItem2);
  function CollectionItem2(type2, props) {
    var _this;
    _classCallCheck$1(this, CollectionItem2);
    _this = _super.call(this, type2, props);
    _this.node = null;
    return _this;
  }
  _createClass$2(CollectionItem2, [{
    key: "includesTrailingLines",
    get: function get4() {
      return !!this.node && this.node.includesTrailingLines;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var parseNode = context.parseNode, src = context.src;
      var atLineStart = context.atLineStart, lineStart = context.lineStart;
      if (!atLineStart && this.type === Type.SEQ_ITEM)
        this.error = new YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
      var indent = atLineStart ? start2 - lineStart : context.indent;
      var offset2 = Node$2.endOfWhiteSpace(src, start2 + 1);
      var ch2 = src[offset2];
      var inlineComment = ch2 === "#";
      var comments = [];
      var blankLine = null;
      while (ch2 === "\n" || ch2 === "#") {
        if (ch2 === "#") {
          var _end = Node$2.endOfLine(src, offset2 + 1);
          comments.push(new Range(offset2, _end));
          offset2 = _end;
        } else {
          atLineStart = true;
          lineStart = offset2 + 1;
          var wsEnd = Node$2.endOfWhiteSpace(src, lineStart);
          if (src[wsEnd] === "\n" && comments.length === 0) {
            blankLine = new BlankLine();
            lineStart = blankLine.parse({
              src
            }, lineStart);
          }
          offset2 = Node$2.endOfIndent(src, lineStart);
        }
        ch2 = src[offset2];
      }
      if (Node$2.nextNodeIsIndented(ch2, offset2 - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
        this.node = parseNode({
          atLineStart,
          inCollection: false,
          indent,
          lineStart,
          parent: this
        }, offset2);
      } else if (ch2 && lineStart > start2 + 1) {
        offset2 = lineStart - 1;
      }
      if (this.node) {
        if (blankLine) {
          var items = context.parent.items || context.parent.contents;
          if (items)
            items.push(blankLine);
        }
        if (comments.length)
          Array.prototype.push.apply(this.props, comments);
        offset2 = this.node.range.end;
      } else {
        if (inlineComment) {
          var c2 = comments[0];
          this.props.push(c2);
          offset2 = c2.end;
        } else {
          offset2 = Node$2.endOfLine(src, start2 + 1);
        }
      }
      var end2 = this.node ? this.node.valueRange.end : offset2;
      this.valueRange = new Range(start2, end2);
      return offset2;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      offset2 = _get(_getPrototypeOf$1(CollectionItem2.prototype), "setOrigRanges", this).call(this, cr, offset2);
      return this.node ? this.node.setOrigRanges(cr, offset2) : offset2;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var src = this.context.src, node2 = this.node, range = this.range, value = this.value;
      if (value != null)
        return value;
      var str2 = node2 ? src.slice(range.start, node2.range.start) + String(node2) : src.slice(range.start, range.end);
      return Node$2.addStringTerminator(src, range.end, str2);
    }
  }]);
  return CollectionItem2;
}(Node$2);
var Comment = /* @__PURE__ */ function(_Node) {
  _inherits$1(Comment2, _Node);
  var _super = _createSuper$1(Comment2);
  function Comment2() {
    _classCallCheck$1(this, Comment2);
    return _super.call(this, Type.COMMENT);
  }
  _createClass$2(Comment2, [{
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var offset2 = this.parseComment(start2);
      this.range = new Range(start2, offset2);
      return offset2;
    }
  }]);
  return Comment2;
}(Node$2);
function grabCollectionEndComments(node2) {
  var cnode = node2;
  while (cnode instanceof CollectionItem) {
    cnode = cnode.node;
  }
  if (!(cnode instanceof Collection$2))
    return null;
  var len = cnode.items.length;
  var ci2 = -1;
  for (var i = len - 1; i >= 0; --i) {
    var n2 = cnode.items[i];
    if (n2.type === Type.COMMENT) {
      var _n$context = n2.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
      if (indent > 0 && n2.range.start >= lineStart + indent)
        break;
      ci2 = i;
    } else if (n2.type === Type.BLANK_LINE)
      ci2 = i;
    else
      break;
  }
  if (ci2 === -1)
    return null;
  var ca2 = cnode.items.splice(ci2, len - ci2);
  var prevEnd = ca2[0].range.start;
  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd)
      cnode.valueRange.end = prevEnd;
    if (cnode === node2)
      break;
    cnode = cnode.context.parent;
  }
  return ca2;
}
var Collection$2 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Collection2, _Node);
  var _super = _createSuper$1(Collection2);
  function Collection2(firstItem) {
    var _this;
    _classCallCheck$1(this, Collection2);
    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);
    for (var i = firstItem.props.length - 1; i >= 0; --i) {
      if (firstItem.props[i].start < firstItem.context.lineStart) {
        _this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        var itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
      }
    }
    _this.items = [firstItem];
    var ec2 = grabCollectionEndComments(firstItem);
    if (ec2)
      Array.prototype.push.apply(_this.items, ec2);
    return _this;
  }
  _createClass$2(Collection2, [{
    key: "includesTrailingLines",
    get: function get4() {
      return this.items.length > 0;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var parseNode = context.parseNode, src = context.src;
      var lineStart = Node$2.startOfLine(src, start2);
      var firstItem = this.items[0];
      firstItem.context.parent = this;
      this.valueRange = Range.copy(firstItem.valueRange);
      var indent = firstItem.range.start - firstItem.context.lineStart;
      var offset2 = start2;
      offset2 = Node$2.normalizeOffset(src, offset2);
      var ch2 = src[offset2];
      var atLineStart = Node$2.endOfWhiteSpace(src, lineStart) === offset2;
      var prevIncludesTrailingLines = false;
      while (ch2) {
        while (ch2 === "\n" || ch2 === "#") {
          if (atLineStart && ch2 === "\n" && !prevIncludesTrailingLines) {
            var blankLine = new BlankLine();
            offset2 = blankLine.parse({
              src
            }, offset2);
            this.valueRange.end = offset2;
            if (offset2 >= src.length) {
              ch2 = null;
              break;
            }
            this.items.push(blankLine);
            offset2 -= 1;
          } else if (ch2 === "#") {
            if (offset2 < lineStart + indent && !Collection2.nextContentHasIndent(src, offset2, indent)) {
              return offset2;
            }
            var comment2 = new Comment();
            offset2 = comment2.parse({
              indent,
              lineStart,
              src
            }, offset2);
            this.items.push(comment2);
            this.valueRange.end = offset2;
            if (offset2 >= src.length) {
              ch2 = null;
              break;
            }
          }
          lineStart = offset2 + 1;
          offset2 = Node$2.endOfIndent(src, lineStart);
          if (Node$2.atBlank(src, offset2)) {
            var wsEnd = Node$2.endOfWhiteSpace(src, offset2);
            var next2 = src[wsEnd];
            if (!next2 || next2 === "\n" || next2 === "#") {
              offset2 = wsEnd;
            }
          }
          ch2 = src[offset2];
          atLineStart = true;
        }
        if (!ch2) {
          break;
        }
        if (offset2 !== lineStart + indent && (atLineStart || ch2 !== ":")) {
          if (offset2 < lineStart + indent) {
            if (lineStart > start2)
              offset2 = lineStart;
            break;
          } else if (!this.error) {
            var msg = "All collection items must start at the same column";
            this.error = new YAMLSyntaxError(this, msg);
          }
        }
        if (firstItem.type === Type.SEQ_ITEM) {
          if (ch2 !== "-") {
            if (lineStart > start2)
              offset2 = lineStart;
            break;
          }
        } else if (ch2 === "-" && !this.error) {
          var _next = src[offset2 + 1];
          if (!_next || _next === "\n" || _next === "	" || _next === " ") {
            var _msg = "A collection cannot be both a mapping and a sequence";
            this.error = new YAMLSyntaxError(this, _msg);
          }
        }
        var node2 = parseNode({
          atLineStart,
          inCollection: true,
          indent,
          lineStart,
          parent: this
        }, offset2);
        if (!node2)
          return offset2;
        this.items.push(node2);
        this.valueRange.end = node2.valueRange.end;
        offset2 = Node$2.normalizeOffset(src, node2.range.end);
        ch2 = src[offset2];
        atLineStart = false;
        prevIncludesTrailingLines = node2.includesTrailingLines;
        if (ch2) {
          var ls = offset2 - 1;
          var prev2 = src[ls];
          while (prev2 === " " || prev2 === "	") {
            prev2 = src[--ls];
          }
          if (prev2 === "\n") {
            lineStart = ls + 1;
            atLineStart = true;
          }
        }
        var ec2 = grabCollectionEndComments(node2);
        if (ec2)
          Array.prototype.push.apply(this.items, ec2);
      }
      return offset2;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      offset2 = _get(_getPrototypeOf$1(Collection2.prototype), "setOrigRanges", this).call(this, cr, offset2);
      this.items.forEach(function(node2) {
        offset2 = node2.setOrigRanges(cr, offset2);
      });
      return offset2;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var src = this.context.src, items = this.items, range = this.range, value = this.value;
      if (value != null)
        return value;
      var str2 = src.slice(range.start, items[0].range.start) + String(items[0]);
      for (var i = 1; i < items.length; ++i) {
        var item = items[i];
        var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
        if (atLineStart)
          for (var _i = 0; _i < indent; ++_i) {
            str2 += " ";
          }
        str2 += String(item);
      }
      return Node$2.addStringTerminator(src, range.end, str2);
    }
  }], [{
    key: "nextContentHasIndent",
    value: function nextContentHasIndent(src, offset2, indent) {
      var lineStart = Node$2.endOfLine(src, offset2) + 1;
      offset2 = Node$2.endOfWhiteSpace(src, lineStart);
      var ch2 = src[offset2];
      if (!ch2)
        return false;
      if (offset2 >= lineStart + indent)
        return true;
      if (ch2 !== "#" && ch2 !== "\n")
        return false;
      return Collection2.nextContentHasIndent(src, offset2, indent);
    }
  }]);
  return Collection2;
}(Node$2);
var Directive = /* @__PURE__ */ function(_Node) {
  _inherits$1(Directive2, _Node);
  var _super = _createSuper$1(Directive2);
  function Directive2() {
    var _this;
    _classCallCheck$1(this, Directive2);
    _this = _super.call(this, Type.DIRECTIVE);
    _this.name = null;
    return _this;
  }
  _createClass$2(Directive2, [{
    key: "parameters",
    get: function get4() {
      var raw = this.rawValue;
      return raw ? raw.trim().split(/[ \t]+/) : [];
    }
  }, {
    key: "parseName",
    value: function parseName(start2) {
      var src = this.context.src;
      var offset2 = start2;
      var ch2 = src[offset2];
      while (ch2 && ch2 !== "\n" && ch2 !== "	" && ch2 !== " ") {
        ch2 = src[offset2 += 1];
      }
      this.name = src.slice(start2, offset2);
      return offset2;
    }
  }, {
    key: "parseParameters",
    value: function parseParameters(start2) {
      var src = this.context.src;
      var offset2 = start2;
      var ch2 = src[offset2];
      while (ch2 && ch2 !== "\n" && ch2 !== "#") {
        ch2 = src[offset2 += 1];
      }
      this.valueRange = new Range(start2, offset2);
      return offset2;
    }
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var offset2 = this.parseName(start2 + 1);
      offset2 = this.parseParameters(offset2);
      offset2 = this.parseComment(offset2);
      this.range = new Range(start2, offset2);
      return offset2;
    }
  }]);
  return Directive2;
}(Node$2);
var Document$3 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Document2, _Node);
  var _super = _createSuper$1(Document2);
  function Document2() {
    var _this;
    _classCallCheck$1(this, Document2);
    _this = _super.call(this, Type.DOCUMENT);
    _this.directives = null;
    _this.contents = null;
    _this.directivesEndMarker = null;
    _this.documentEndMarker = null;
    return _this;
  }
  _createClass$2(Document2, [{
    key: "parseDirectives",
    value: function parseDirectives2(start2) {
      var src = this.context.src;
      this.directives = [];
      var atLineStart = true;
      var hasDirectives = false;
      var offset2 = start2;
      while (!Node$2.atDocumentBoundary(src, offset2, Char.DIRECTIVES_END)) {
        offset2 = Document2.startCommentOrEndBlankLine(src, offset2);
        switch (src[offset2]) {
          case "\n":
            if (atLineStart) {
              var blankLine = new BlankLine();
              offset2 = blankLine.parse({
                src
              }, offset2);
              if (offset2 < src.length) {
                this.directives.push(blankLine);
              }
            } else {
              offset2 += 1;
              atLineStart = true;
            }
            break;
          case "#":
            {
              var comment2 = new Comment();
              offset2 = comment2.parse({
                src
              }, offset2);
              this.directives.push(comment2);
              atLineStart = false;
            }
            break;
          case "%":
            {
              var directive = new Directive();
              offset2 = directive.parse({
                parent: this,
                src
              }, offset2);
              this.directives.push(directive);
              hasDirectives = true;
              atLineStart = false;
            }
            break;
          default:
            if (hasDirectives) {
              this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
            } else if (this.directives.length > 0) {
              this.contents = this.directives;
              this.directives = [];
            }
            return offset2;
        }
      }
      if (src[offset2]) {
        this.directivesEndMarker = new Range(offset2, offset2 + 3);
        return offset2 + 3;
      }
      if (hasDirectives) {
        this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
      } else if (this.directives.length > 0) {
        this.contents = this.directives;
        this.directives = [];
      }
      return offset2;
    }
  }, {
    key: "parseContents",
    value: function parseContents2(start2) {
      var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
      if (!this.contents)
        this.contents = [];
      var lineStart = start2;
      while (src[lineStart - 1] === "-") {
        lineStart -= 1;
      }
      var offset2 = Node$2.endOfWhiteSpace(src, start2);
      var atLineStart = lineStart === start2;
      this.valueRange = new Range(offset2);
      while (!Node$2.atDocumentBoundary(src, offset2, Char.DOCUMENT_END)) {
        switch (src[offset2]) {
          case "\n":
            if (atLineStart) {
              var blankLine = new BlankLine();
              offset2 = blankLine.parse({
                src
              }, offset2);
              if (offset2 < src.length) {
                this.contents.push(blankLine);
              }
            } else {
              offset2 += 1;
              atLineStart = true;
            }
            lineStart = offset2;
            break;
          case "#":
            {
              var comment2 = new Comment();
              offset2 = comment2.parse({
                src
              }, offset2);
              this.contents.push(comment2);
              atLineStart = false;
            }
            break;
          default: {
            var iEnd = Node$2.endOfIndent(src, offset2);
            var context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
            };
            var node2 = parseNode(context, iEnd);
            if (!node2)
              return this.valueRange.end = iEnd;
            this.contents.push(node2);
            offset2 = node2.range.end;
            atLineStart = false;
            var ec2 = grabCollectionEndComments(node2);
            if (ec2)
              Array.prototype.push.apply(this.contents, ec2);
          }
        }
        offset2 = Document2.startCommentOrEndBlankLine(src, offset2);
      }
      this.valueRange.end = offset2;
      if (src[offset2]) {
        this.documentEndMarker = new Range(offset2, offset2 + 3);
        offset2 += 3;
        if (src[offset2]) {
          offset2 = Node$2.endOfWhiteSpace(src, offset2);
          if (src[offset2] === "#") {
            var _comment = new Comment();
            offset2 = _comment.parse({
              src
            }, offset2);
            this.contents.push(_comment);
          }
          switch (src[offset2]) {
            case "\n":
              offset2 += 1;
              break;
            case void 0:
              break;
            default:
              this.error = new YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
          }
        }
      }
      return offset2;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      context.root = this;
      this.context = context;
      var src = context.src;
      var offset2 = src.charCodeAt(start2) === 65279 ? start2 + 1 : start2;
      offset2 = this.parseDirectives(offset2);
      offset2 = this.parseContents(offset2);
      return offset2;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      offset2 = _get(_getPrototypeOf$1(Document2.prototype), "setOrigRanges", this).call(this, cr, offset2);
      this.directives.forEach(function(node2) {
        offset2 = node2.setOrigRanges(cr, offset2);
      });
      if (this.directivesEndMarker)
        offset2 = this.directivesEndMarker.setOrigRange(cr, offset2);
      this.contents.forEach(function(node2) {
        offset2 = node2.setOrigRanges(cr, offset2);
      });
      if (this.documentEndMarker)
        offset2 = this.documentEndMarker.setOrigRange(cr, offset2);
      return offset2;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var contents = this.contents, directives = this.directives, value = this.value;
      if (value != null)
        return value;
      var str2 = directives.join("");
      if (contents.length > 0) {
        if (directives.length > 0 || contents[0].type === Type.COMMENT)
          str2 += "---\n";
        str2 += contents.join("");
      }
      if (str2[str2.length - 1] !== "\n")
        str2 += "\n";
      return str2;
    }
  }], [{
    key: "startCommentOrEndBlankLine",
    value: function startCommentOrEndBlankLine(src, start2) {
      var offset2 = Node$2.endOfWhiteSpace(src, start2);
      var ch2 = src[offset2];
      return ch2 === "#" || ch2 === "\n" ? offset2 : start2;
    }
  }]);
  return Document2;
}(Node$2);
var Alias$2 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Alias2, _Node);
  var _super = _createSuper$1(Alias2);
  function Alias2() {
    _classCallCheck$1(this, Alias2);
    return _super.apply(this, arguments);
  }
  _createClass$2(Alias2, [{
    key: "parse",
    value: (
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      function parse2(context, start2) {
        this.context = context;
        var src = context.src;
        var offset2 = Node$2.endOfIdentifier(src, start2 + 1);
        this.valueRange = new Range(start2 + 1, offset2);
        offset2 = Node$2.endOfWhiteSpace(src, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    )
  }]);
  return Alias2;
}(Node$2);
var Chomp = {
  CLIP: "CLIP",
  KEEP: "KEEP",
  STRIP: "STRIP"
};
var BlockValue = /* @__PURE__ */ function(_Node) {
  _inherits$1(BlockValue2, _Node);
  var _super = _createSuper$1(BlockValue2);
  function BlockValue2(type2, props) {
    var _this;
    _classCallCheck$1(this, BlockValue2);
    _this = _super.call(this, type2, props);
    _this.blockIndent = null;
    _this.chomping = Chomp.CLIP;
    _this.header = null;
    return _this;
  }
  _createClass$2(BlockValue2, [{
    key: "includesTrailingLines",
    get: function get4() {
      return this.chomping === Chomp.KEEP;
    }
  }, {
    key: "strValue",
    get: function get4() {
      if (!this.valueRange || !this.context)
        return null;
      var _this$valueRange = this.valueRange, start2 = _this$valueRange.start, end2 = _this$valueRange.end;
      var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
      if (this.valueRange.isEmpty())
        return "";
      var lastNewLine = null;
      var ch2 = src[end2 - 1];
      while (ch2 === "\n" || ch2 === "	" || ch2 === " ") {
        end2 -= 1;
        if (end2 <= start2) {
          if (this.chomping === Chomp.KEEP)
            break;
          else
            return "";
        }
        if (ch2 === "\n")
          lastNewLine = end2;
        ch2 = src[end2 - 1];
      }
      var keepStart = end2 + 1;
      if (lastNewLine) {
        if (this.chomping === Chomp.KEEP) {
          keepStart = lastNewLine;
          end2 = this.valueRange.end;
        } else {
          end2 = lastNewLine;
        }
      }
      var bi2 = indent + this.blockIndent;
      var folded = this.type === Type.BLOCK_FOLDED;
      var atStart = true;
      var str2 = "";
      var sep = "";
      var prevMoreIndented = false;
      for (var i = start2; i < end2; ++i) {
        for (var j = 0; j < bi2; ++j) {
          if (src[i] !== " ")
            break;
          i += 1;
        }
        var _ch = src[i];
        if (_ch === "\n") {
          if (sep === "\n")
            str2 += "\n";
          else
            sep = "\n";
        } else {
          var lineEnd = Node$2.endOfLine(src, i);
          var line2 = src.slice(i, lineEnd);
          i = lineEnd;
          if (folded && (_ch === " " || _ch === "	") && i < keepStart) {
            if (sep === " ")
              sep = "\n";
            else if (!prevMoreIndented && !atStart && sep === "\n")
              sep = "\n\n";
            str2 += sep + line2;
            sep = lineEnd < end2 && src[lineEnd] || "";
            prevMoreIndented = true;
          } else {
            str2 += sep + line2;
            sep = folded && i < keepStart ? " " : "\n";
            prevMoreIndented = false;
          }
          if (atStart && line2 !== "")
            atStart = false;
        }
      }
      return this.chomping === Chomp.STRIP ? str2 : str2 + "\n";
    }
  }, {
    key: "parseBlockHeader",
    value: function parseBlockHeader(start2) {
      var src = this.context.src;
      var offset2 = start2 + 1;
      var bi2 = "";
      while (true) {
        var ch2 = src[offset2];
        switch (ch2) {
          case "-":
            this.chomping = Chomp.STRIP;
            break;
          case "+":
            this.chomping = Chomp.KEEP;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            bi2 += ch2;
            break;
          default:
            this.blockIndent = Number(bi2) || null;
            this.header = new Range(start2, offset2);
            return offset2;
        }
        offset2 += 1;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function parseBlockValue(start2) {
      var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
      var explicit = !!this.blockIndent;
      var offset2 = start2;
      var valueEnd = start2;
      var minBlockIndent = 1;
      for (var ch2 = src[offset2]; ch2 === "\n"; ch2 = src[offset2]) {
        offset2 += 1;
        if (Node$2.atDocumentBoundary(src, offset2))
          break;
        var end2 = Node$2.endOfBlockIndent(src, indent, offset2);
        if (end2 === null)
          break;
        var _ch2 = src[end2];
        var lineIndent = end2 - (offset2 + indent);
        if (!this.blockIndent) {
          if (src[end2] !== "\n") {
            if (lineIndent < minBlockIndent) {
              var msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
              this.error = new YAMLSemanticError(this, msg);
            }
            this.blockIndent = lineIndent;
          } else if (lineIndent > minBlockIndent) {
            minBlockIndent = lineIndent;
          }
        } else if (_ch2 && _ch2 !== "\n" && lineIndent < this.blockIndent) {
          if (src[end2] === "#")
            break;
          if (!this.error) {
            var _src = explicit ? "explicit indentation indicator" : "first line";
            var _msg = "Block scalars must not be less indented than their ".concat(_src);
            this.error = new YAMLSemanticError(this, _msg);
          }
        }
        if (src[end2] === "\n") {
          offset2 = end2;
        } else {
          offset2 = valueEnd = Node$2.endOfLine(src, end2);
        }
      }
      if (this.chomping !== Chomp.KEEP) {
        offset2 = src[valueEnd] ? valueEnd + 1 : valueEnd;
      }
      this.valueRange = new Range(start2 + 1, offset2);
      return offset2;
    }
    /**
     * Parses a block value from the source
     *
     * Accepted forms are:
     * ```
     * BS
     * block
     * lines
     *
     * BS #comment
     * block
     * lines
     * ```
     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
     * are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this block
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var src = context.src;
      var offset2 = this.parseBlockHeader(start2);
      offset2 = Node$2.endOfWhiteSpace(src, offset2);
      offset2 = this.parseComment(offset2);
      offset2 = this.parseBlockValue(offset2);
      return offset2;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      offset2 = _get(_getPrototypeOf$1(BlockValue2.prototype), "setOrigRanges", this).call(this, cr, offset2);
      return this.header ? this.header.setOrigRange(cr, offset2) : offset2;
    }
  }]);
  return BlockValue2;
}(Node$2);
var FlowCollection = /* @__PURE__ */ function(_Node) {
  _inherits$1(FlowCollection2, _Node);
  var _super = _createSuper$1(FlowCollection2);
  function FlowCollection2(type2, props) {
    var _this;
    _classCallCheck$1(this, FlowCollection2);
    _this = _super.call(this, type2, props);
    _this.items = null;
    return _this;
  }
  _createClass$2(FlowCollection2, [{
    key: "prevNodeIsJsonLike",
    value: function prevNodeIsJsonLike() {
      var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
      var node2 = this.items[idx - 1];
      return !!node2 && (node2.jsonLike || node2.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var parseNode = context.parseNode, src = context.src;
      var indent = context.indent, lineStart = context.lineStart;
      var char2 = src[start2];
      this.items = [{
        char: char2,
        offset: start2
      }];
      var offset2 = Node$2.endOfWhiteSpace(src, start2 + 1);
      char2 = src[offset2];
      while (char2 && char2 !== "]" && char2 !== "}") {
        switch (char2) {
          case "\n":
            {
              lineStart = offset2 + 1;
              var wsEnd = Node$2.endOfWhiteSpace(src, lineStart);
              if (src[wsEnd] === "\n") {
                var blankLine = new BlankLine();
                lineStart = blankLine.parse({
                  src
                }, lineStart);
                this.items.push(blankLine);
              }
              offset2 = Node$2.endOfIndent(src, lineStart);
              if (offset2 <= lineStart + indent) {
                char2 = src[offset2];
                if (offset2 < lineStart + indent || char2 !== "]" && char2 !== "}") {
                  var msg = "Insufficient indentation in flow collection";
                  this.error = new YAMLSemanticError(this, msg);
                }
              }
            }
            break;
          case ",":
            {
              this.items.push({
                char: char2,
                offset: offset2
              });
              offset2 += 1;
            }
            break;
          case "#":
            {
              var comment2 = new Comment();
              offset2 = comment2.parse({
                src
              }, offset2);
              this.items.push(comment2);
            }
            break;
          case "?":
          case ":": {
            var next2 = src[offset2 + 1];
            if (next2 === "\n" || next2 === "	" || next2 === " " || next2 === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
            char2 === ":" && this.prevNodeIsJsonLike()) {
              this.items.push({
                char: char2,
                offset: offset2
              });
              offset2 += 1;
              break;
            }
          }
          default: {
            var node2 = parseNode({
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
            }, offset2);
            if (!node2) {
              this.valueRange = new Range(start2, offset2);
              return offset2;
            }
            this.items.push(node2);
            offset2 = Node$2.normalizeOffset(src, node2.range.end);
          }
        }
        offset2 = Node$2.endOfWhiteSpace(src, offset2);
        char2 = src[offset2];
      }
      this.valueRange = new Range(start2, offset2 + 1);
      if (char2) {
        this.items.push({
          char: char2,
          offset: offset2
        });
        offset2 = Node$2.endOfWhiteSpace(src, offset2 + 1);
        offset2 = this.parseComment(offset2);
      }
      return offset2;
    }
  }, {
    key: "setOrigRanges",
    value: function setOrigRanges(cr, offset2) {
      offset2 = _get(_getPrototypeOf$1(FlowCollection2.prototype), "setOrigRanges", this).call(this, cr, offset2);
      this.items.forEach(function(node2) {
        if (node2 instanceof Node$2) {
          offset2 = node2.setOrigRanges(cr, offset2);
        } else if (cr.length === 0) {
          node2.origOffset = node2.offset;
        } else {
          var i = offset2;
          while (i < cr.length) {
            if (cr[i] > node2.offset)
              break;
            else
              ++i;
          }
          node2.origOffset = node2.offset + i;
          offset2 = i;
        }
      });
      return offset2;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var src = this.context.src, items = this.items, range = this.range, value = this.value;
      if (value != null)
        return value;
      var nodes = items.filter(function(item) {
        return item instanceof Node$2;
      });
      var str2 = "";
      var prevEnd = range.start;
      nodes.forEach(function(node2) {
        var prefix2 = src.slice(prevEnd, node2.range.start);
        prevEnd = node2.range.end;
        str2 += prefix2 + String(node2);
        if (str2[str2.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
          prevEnd += 1;
        }
      });
      str2 += src.slice(prevEnd, range.end);
      return Node$2.addStringTerminator(src, range.end, str2);
    }
  }]);
  return FlowCollection2;
}(Node$2);
var QuoteDouble = /* @__PURE__ */ function(_Node) {
  _inherits$1(QuoteDouble2, _Node);
  var _super = _createSuper$1(QuoteDouble2);
  function QuoteDouble2() {
    _classCallCheck$1(this, QuoteDouble2);
    return _super.apply(this, arguments);
  }
  _createClass$2(QuoteDouble2, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function get4() {
        if (!this.valueRange || !this.context)
          return null;
        var errors = [];
        var _this$valueRange = this.valueRange, start2 = _this$valueRange.start, end2 = _this$valueRange.end;
        var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
        if (src[end2 - 1] !== '"')
          errors.push(new YAMLSyntaxError(this, 'Missing closing "quote'));
        var str2 = "";
        for (var i = start2 + 1; i < end2 - 1; ++i) {
          var ch2 = src[i];
          if (ch2 === "\n") {
            if (Node$2.atDocumentBoundary(src, i + 1))
              errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            var _Node$foldNewline = Node$2.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset2 = _Node$foldNewline.offset, error = _Node$foldNewline.error;
            str2 += fold;
            i = offset2;
            if (error)
              errors.push(new YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str2 += "\0";
                break;
              case "a":
                str2 += "\x07";
                break;
              case "b":
                str2 += "\b";
                break;
              case "e":
                str2 += "\x1B";
                break;
              case "f":
                str2 += "\f";
                break;
              case "n":
                str2 += "\n";
                break;
              case "r":
                str2 += "\r";
                break;
              case "t":
                str2 += "	";
                break;
              case "v":
                str2 += "\v";
                break;
              case "N":
                str2 += "";
                break;
              case "_":
                str2 += "";
                break;
              case "L":
                str2 += "\u2028";
                break;
              case "P":
                str2 += "\u2029";
                break;
              case " ":
                str2 += " ";
                break;
              case '"':
                str2 += '"';
                break;
              case "/":
                str2 += "/";
                break;
              case "\\":
                str2 += "\\";
                break;
              case "	":
                str2 += "	";
                break;
              case "x":
                str2 += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str2 += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str2 += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	") {
                  i += 1;
                }
                break;
              default:
                errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i - 1, 2))));
                str2 += "\\" + src[i];
            }
          } else if (ch2 === " " || ch2 === "	") {
            var wsStart = i;
            var next2 = src[i + 1];
            while (next2 === " " || next2 === "	") {
              i += 1;
              next2 = src[i + 1];
            }
            if (next2 !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
    )
  }, {
    key: "parseCharCode",
    value: function parseCharCode(offset2, length2, errors) {
      var src = this.context.src;
      var cc2 = src.substr(offset2, length2);
      var ok2 = cc2.length === length2 && /^[0-9a-fA-F]+$/.test(cc2);
      var code = ok2 ? parseInt(cc2, 16) : NaN;
      if (isNaN(code)) {
        errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset2 - 2, length2 + 2))));
        return src.substr(offset2 - 2, length2 + 2);
      }
      return String.fromCodePoint(code);
    }
    /**
     * Parses a "double quoted" value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var src = context.src;
      var offset2 = QuoteDouble2.endOfQuote(src, start2 + 1);
      this.valueRange = new Range(start2, offset2);
      offset2 = Node$2.endOfWhiteSpace(src, offset2);
      offset2 = this.parseComment(offset2);
      return offset2;
    }
  }], [{
    key: "endOfQuote",
    value: function endOfQuote(src, offset2) {
      var ch2 = src[offset2];
      while (ch2 && ch2 !== '"') {
        offset2 += ch2 === "\\" ? 2 : 1;
        ch2 = src[offset2];
      }
      return offset2 + 1;
    }
  }]);
  return QuoteDouble2;
}(Node$2);
var QuoteSingle = /* @__PURE__ */ function(_Node) {
  _inherits$1(QuoteSingle2, _Node);
  var _super = _createSuper$1(QuoteSingle2);
  function QuoteSingle2() {
    _classCallCheck$1(this, QuoteSingle2);
    return _super.apply(this, arguments);
  }
  _createClass$2(QuoteSingle2, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function get4() {
        if (!this.valueRange || !this.context)
          return null;
        var errors = [];
        var _this$valueRange = this.valueRange, start2 = _this$valueRange.start, end2 = _this$valueRange.end;
        var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
        if (src[end2 - 1] !== "'")
          errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
        var str2 = "";
        for (var i = start2 + 1; i < end2 - 1; ++i) {
          var ch2 = src[i];
          if (ch2 === "\n") {
            if (Node$2.atDocumentBoundary(src, i + 1))
              errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            var _Node$foldNewline = Node$2.foldNewline(src, i, indent), fold = _Node$foldNewline.fold, offset2 = _Node$foldNewline.offset, error = _Node$foldNewline.error;
            str2 += fold;
            i = offset2;
            if (error)
              errors.push(new YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "'") {
            str2 += ch2;
            i += 1;
            if (src[i] !== "'")
              errors.push(new YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch2 === " " || ch2 === "	") {
            var wsStart = i;
            var next2 = src[i + 1];
            while (next2 === " " || next2 === "	") {
              i += 1;
              next2 = src[i + 1];
            }
            if (next2 !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
    )
    /**
     * Parses a 'single quoted' value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function parse2(context, start2) {
      this.context = context;
      var src = context.src;
      var offset2 = QuoteSingle2.endOfQuote(src, start2 + 1);
      this.valueRange = new Range(start2, offset2);
      offset2 = Node$2.endOfWhiteSpace(src, offset2);
      offset2 = this.parseComment(offset2);
      return offset2;
    }
  }], [{
    key: "endOfQuote",
    value: function endOfQuote(src, offset2) {
      var ch2 = src[offset2];
      while (ch2) {
        if (ch2 === "'") {
          if (src[offset2 + 1] !== "'")
            break;
          ch2 = src[offset2 += 2];
        } else {
          ch2 = src[offset2 += 1];
        }
      }
      return offset2 + 1;
    }
  }]);
  return QuoteSingle2;
}(Node$2);
function createNewNode(type2, props) {
  switch (type2) {
    case Type.ALIAS:
      return new Alias$2(type2, props);
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
      return new BlockValue(type2, props);
    case Type.FLOW_MAP:
    case Type.FLOW_SEQ:
      return new FlowCollection(type2, props);
    case Type.MAP_KEY:
    case Type.MAP_VALUE:
    case Type.SEQ_ITEM:
      return new CollectionItem(type2, props);
    case Type.COMMENT:
    case Type.PLAIN:
      return new PlainValue(type2, props);
    case Type.QUOTE_DOUBLE:
      return new QuoteDouble(type2, props);
    case Type.QUOTE_SINGLE:
      return new QuoteSingle(type2, props);
    default:
      return null;
  }
}
var ParseContext = /* @__PURE__ */ function() {
  function ParseContext2() {
    var _this = this;
    var orig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, atLineStart = _ref3.atLineStart, inCollection = _ref3.inCollection, inFlow = _ref3.inFlow, indent = _ref3.indent, lineStart = _ref3.lineStart, parent = _ref3.parent;
    _classCallCheck$1(this, ParseContext2);
    _defineProperty(this, "parseNode", function(overlay, start2) {
      if (Node$2.atDocumentBoundary(_this.src, start2))
        return null;
      var context = new ParseContext2(_this, overlay);
      var _context$parseProps = context.parseProps(start2), props = _context$parseProps.props, type2 = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
      var node2 = createNewNode(type2, props);
      var offset2 = node2.parse(context, valueStart);
      node2.range = new Range(start2, offset2);
      if (offset2 <= start2) {
        node2.error = new Error("Node#parse consumed no characters");
        node2.error.parseEnd = offset2;
        node2.error.source = node2;
        node2.range.end = start2 + 1;
      }
      if (context.nodeStartsCollection(node2)) {
        if (!node2.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
          node2.error = new YAMLSyntaxError(node2, "Block collection must not have preceding content here (e.g. directives-end indicator)");
        }
        var collection = new Collection$2(node2);
        offset2 = collection.parse(new ParseContext2(context), offset2);
        collection.range = new Range(start2, offset2);
        return collection;
      }
      return node2;
    });
    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || {};
    this.root = orig.root;
    this.src = orig.src;
  }
  _createClass$2(ParseContext2, [{
    key: "nodeStartsCollection",
    value: function nodeStartsCollection(node2) {
      var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
      if (inCollection || inFlow)
        return false;
      if (node2 instanceof CollectionItem)
        return true;
      var offset2 = node2.range.end;
      if (src[offset2] === "\n" || src[offset2 - 1] === "\n")
        return false;
      offset2 = Node$2.endOfWhiteSpace(src, offset2);
      return src[offset2] === ":";
    }
    // Anchor and tag are before type, which determines the node implementation
    // class; hence this intermediate step.
  }, {
    key: "parseProps",
    value: function parseProps(offset2) {
      var inFlow = this.inFlow, parent = this.parent, src = this.src;
      var props = [];
      var lineHasProps = false;
      offset2 = this.atLineStart ? Node$2.endOfIndent(src, offset2) : Node$2.endOfWhiteSpace(src, offset2);
      var ch2 = src[offset2];
      while (ch2 === Char.ANCHOR || ch2 === Char.COMMENT || ch2 === Char.TAG || ch2 === "\n") {
        if (ch2 === "\n") {
          var inEnd = offset2;
          var lineStart = void 0;
          do {
            lineStart = inEnd + 1;
            inEnd = Node$2.endOfIndent(src, lineStart);
          } while (src[inEnd] === "\n");
          var indentDiff = inEnd - (lineStart + this.indent);
          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
          if (src[inEnd] !== "#" && !Node$2.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
            break;
          this.atLineStart = true;
          this.lineStart = lineStart;
          lineHasProps = false;
          offset2 = inEnd;
        } else if (ch2 === Char.COMMENT) {
          var end2 = Node$2.endOfLine(src, offset2 + 1);
          props.push(new Range(offset2, end2));
          offset2 = end2;
        } else {
          var _end = Node$2.endOfIdentifier(src, offset2 + 1);
          if (ch2 === Char.TAG && src[_end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset2 + 1, _end + 13))) {
            _end = Node$2.endOfIdentifier(src, _end + 5);
          }
          props.push(new Range(offset2, _end));
          lineHasProps = true;
          offset2 = Node$2.endOfWhiteSpace(src, _end);
        }
        ch2 = src[offset2];
      }
      if (lineHasProps && ch2 === ":" && Node$2.atBlank(src, offset2 + 1, true))
        offset2 -= 1;
      var type2 = ParseContext2.parseType(src, offset2, inFlow);
      return {
        props,
        type: type2,
        valueStart: offset2
      };
    }
    /**
     * Parses a node from the source
     * @param {ParseContext} overlay
     * @param {number} start - Index of first non-whitespace character for the node
     * @returns {?Node} - null if at a document boundary
     */
  }], [{
    key: "parseType",
    value: function parseType(src, offset2, inFlow) {
      switch (src[offset2]) {
        case "*":
          return Type.ALIAS;
        case ">":
          return Type.BLOCK_FOLDED;
        case "|":
          return Type.BLOCK_LITERAL;
        case "{":
          return Type.FLOW_MAP;
        case "[":
          return Type.FLOW_SEQ;
        case "?":
          return !inFlow && Node$2.atBlank(src, offset2 + 1, true) ? Type.MAP_KEY : Type.PLAIN;
        case ":":
          return !inFlow && Node$2.atBlank(src, offset2 + 1, true) ? Type.MAP_VALUE : Type.PLAIN;
        case "-":
          return !inFlow && Node$2.atBlank(src, offset2 + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;
        case '"':
          return Type.QUOTE_DOUBLE;
        case "'":
          return Type.QUOTE_SINGLE;
        default:
          return Type.PLAIN;
      }
    }
  }]);
  return ParseContext2;
}();
function parse$7(src) {
  var cr = [];
  if (src.indexOf("\r") !== -1) {
    src = src.replace(/\r\n?/g, function(match2, offset3) {
      if (match2.length > 1)
        cr.push(offset3);
      return "\n";
    });
  }
  var documents = [];
  var offset2 = 0;
  do {
    var doc = new Document$3();
    var context = new ParseContext({
      src
    });
    offset2 = doc.parse(context, offset2);
    documents.push(doc);
  } while (offset2 < src.length);
  documents.setOrigRanges = function() {
    if (cr.length === 0)
      return false;
    for (var i = 1; i < cr.length; ++i) {
      cr[i] -= i;
    }
    var crOffset = 0;
    for (var _i = 0; _i < documents.length; ++_i) {
      crOffset = documents[_i].setOrigRanges(cr, crOffset);
    }
    cr.splice(0, cr.length);
    return true;
  };
  documents.toString = function() {
    return documents.join("...\n");
  };
  return documents;
}
function addCommentBefore$1(str2, indent, comment2) {
  if (!comment2)
    return str2;
  var cc2 = comment2.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
  return "#".concat(cc2, "\n").concat(indent).concat(str2);
}
function addComment(str2, indent, comment2) {
  return !comment2 ? str2 : comment2.indexOf("\n") === -1 ? "".concat(str2, " #").concat(comment2) : "".concat(str2, "\n") + comment2.replace(/^/gm, "".concat(indent || "", "#"));
}
var Node$1 = function Node2() {
  _classCallCheck$1(this, Node2);
};
function toJSON(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map(function(v2, i) {
      return toJSON(v2, String(i), ctx);
    });
  if (value && typeof value.toJSON === "function") {
    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor)
      ctx.onCreate = function(res2) {
        anchor.res = res2;
        delete ctx.onCreate;
      };
    var res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if ((!ctx || !ctx.keep) && typeof value === "bigint")
    return Number(value);
  return value;
}
var Scalar$1 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Scalar2, _Node);
  var _super = _createSuper$1(Scalar2);
  function Scalar2(value) {
    var _this;
    _classCallCheck$1(this, Scalar2);
    _this = _super.call(this);
    _this.value = value;
    return _this;
  }
  _createClass$2(Scalar2, [{
    key: "toJSON",
    value: function toJSON$1(arg, ctx) {
      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return String(this.value);
    }
  }]);
  return Scalar2;
}(Node$1);
function collectionFromPath$1(schema2, path2, value) {
  var v2 = value;
  for (var i = path2.length - 1; i >= 0; --i) {
    var k2 = path2[i];
    if (Number.isInteger(k2) && k2 >= 0) {
      var a = [];
      a[k2] = v2;
      v2 = a;
    } else {
      var o = {};
      Object.defineProperty(o, k2, {
        value: v2,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v2 = o;
    }
  }
  return schema2.createNode(v2, false);
}
var isEmptyPath$1 = function isEmptyPath(path2) {
  return path2 == null || _typeof$1(path2) === "object" && path2[Symbol.iterator]().next().done;
};
var Collection$1 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Collection2, _Node);
  var _super = _createSuper$1(Collection2);
  function Collection2(schema2) {
    var _this;
    _classCallCheck$1(this, Collection2);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized$2(_this), "items", []);
    _this.schema = schema2;
    return _this;
  }
  _createClass$2(Collection2, [{
    key: "addIn",
    value: function addIn(path2, value) {
      if (isEmptyPath$1(path2))
        this.add(value);
      else {
        var _path = _toArray(path2), key2 = _path[0], rest = _path.slice(1);
        var node2 = this.get(key2, true);
        if (node2 instanceof Collection2)
          node2.addIn(rest, value);
        else if (node2 === void 0 && this.schema)
          this.set(key2, collectionFromPath$1(this.schema, rest, value));
        else
          throw new Error("Expected YAML collection at ".concat(key2, ". Remaining path: ").concat(rest));
      }
    }
  }, {
    key: "deleteIn",
    value: function deleteIn(_ref3) {
      var _ref22 = _toArray(_ref3), key2 = _ref22[0], rest = _ref22.slice(1);
      if (rest.length === 0)
        return this.delete(key2);
      var node2 = this.get(key2, true);
      if (node2 instanceof Collection2)
        return node2.deleteIn(rest);
      else
        throw new Error("Expected YAML collection at ".concat(key2, ". Remaining path: ").concat(rest));
    }
  }, {
    key: "getIn",
    value: function getIn(_ref3, keepScalar) {
      var _ref4 = _toArray(_ref3), key2 = _ref4[0], rest = _ref4.slice(1);
      var node2 = this.get(key2, true);
      if (rest.length === 0)
        return !keepScalar && node2 instanceof Scalar$1 ? node2.value : node2;
      else
        return node2 instanceof Collection2 ? node2.getIn(rest, keepScalar) : void 0;
    }
  }, {
    key: "hasAllNullValues",
    value: function hasAllNullValues() {
      return this.items.every(function(node2) {
        if (!node2 || node2.type !== "PAIR")
          return false;
        var n2 = node2.value;
        return n2 == null || n2 instanceof Scalar$1 && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
      });
    }
  }, {
    key: "hasIn",
    value: function hasIn(_ref5) {
      var _ref6 = _toArray(_ref5), key2 = _ref6[0], rest = _ref6.slice(1);
      if (rest.length === 0)
        return this.has(key2);
      var node2 = this.get(key2, true);
      return node2 instanceof Collection2 ? node2.hasIn(rest) : false;
    }
  }, {
    key: "setIn",
    value: function setIn(_ref7, value) {
      var _ref8 = _toArray(_ref7), key2 = _ref8[0], rest = _ref8.slice(1);
      if (rest.length === 0) {
        this.set(key2, value);
      } else {
        var node2 = this.get(key2, true);
        if (node2 instanceof Collection2)
          node2.setIn(rest, value);
        else if (node2 === void 0 && this.schema)
          this.set(key2, collectionFromPath$1(this.schema, rest, value));
        else
          throw new Error("Expected YAML collection at ".concat(key2, ". Remaining path: ").concat(rest));
      }
    }
    // overridden in implementations
    /* istanbul ignore next */
  }, {
    key: "toJSON",
    value: function toJSON3() {
      return null;
    }
  }, {
    key: "toString",
    value: function toString2(ctx, _ref9, onComment, onChompKeep) {
      var _this2 = this;
      var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap2 = _ref9.isMap, itemIndent = _ref9.itemIndent;
      var _ctx = ctx, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
      var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
      if (inFlow)
        itemIndent += indentStep;
      var allNullValues = isMap2 && this.hasAllNullValues();
      ctx = Object.assign({}, ctx, {
        allNullValues,
        indent: itemIndent,
        inFlow,
        type: null
      });
      var chompKeep = false;
      var hasItemWithNewLine = false;
      var nodes = this.items.reduce(function(nodes2, item, i) {
        var comment2;
        if (item) {
          if (!chompKeep && item.spaceBefore)
            nodes2.push({
              type: "comment",
              str: ""
            });
          if (item.commentBefore)
            item.commentBefore.match(/^.*$/gm).forEach(function(line2) {
              nodes2.push({
                type: "comment",
                str: "#".concat(line2)
              });
            });
          if (item.comment)
            comment2 = item.comment;
          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
            hasItemWithNewLine = true;
        }
        chompKeep = false;
        var str3 = stringify16(item, ctx, function() {
          return comment2 = null;
        }, function() {
          return chompKeep = true;
        });
        if (inFlow && !hasItemWithNewLine && str3.includes("\n"))
          hasItemWithNewLine = true;
        if (inFlow && i < _this2.items.length - 1)
          str3 += ",";
        str3 = addComment(str3, itemIndent, comment2);
        if (chompKeep && (comment2 || inFlow))
          chompKeep = false;
        nodes2.push({
          type: "item",
          str: str3
        });
        return nodes2;
      }, []);
      var str2;
      if (nodes.length === 0) {
        str2 = flowChars.start + flowChars.end;
      } else if (inFlow) {
        var start2 = flowChars.start, end2 = flowChars.end;
        var strings = nodes.map(function(n2) {
          return n2.str;
        });
        if (hasItemWithNewLine || strings.reduce(function(sum, str3) {
          return sum + str3.length + 2;
        }, 2) > Collection2.maxFlowStringSingleLineLength) {
          str2 = start2;
          var _iterator = _createForOfIteratorHelper(strings), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var s = _step.value;
              str2 += s ? "\n".concat(indentStep).concat(indent).concat(s) : "\n";
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          str2 += "\n".concat(indent).concat(end2);
        } else {
          str2 = "".concat(start2, " ").concat(strings.join(" "), " ").concat(end2);
        }
      } else {
        var _strings = nodes.map(blockItem);
        str2 = _strings.shift();
        var _iterator2 = _createForOfIteratorHelper(_strings), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _s = _step2.value;
            str2 += _s ? "\n".concat(indent).concat(_s) : "\n";
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      if (this.comment) {
        str2 += "\n" + this.comment.replace(/^/gm, "".concat(indent, "#"));
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str2;
    }
  }]);
  return Collection2;
}(Node$1);
_defineProperty(Collection$1, "maxFlowStringSingleLineLength", 60);
function asItemIndex$1(key2) {
  var idx = key2 instanceof Scalar$1 ? key2.value : key2;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq$1 = /* @__PURE__ */ function(_Collection) {
  _inherits$1(YAMLSeq2, _Collection);
  var _super = _createSuper$1(YAMLSeq2);
  function YAMLSeq2() {
    _classCallCheck$1(this, YAMLSeq2);
    return _super.apply(this, arguments);
  }
  _createClass$2(YAMLSeq2, [{
    key: "add",
    value: function add2(value) {
      this.items.push(value);
    }
  }, {
    key: "delete",
    value: function _delete(key2) {
      var idx = asItemIndex$1(key2);
      if (typeof idx !== "number")
        return false;
      var del = this.items.splice(idx, 1);
      return del.length > 0;
    }
  }, {
    key: "get",
    value: function get4(key2, keepScalar) {
      var idx = asItemIndex$1(key2);
      if (typeof idx !== "number")
        return void 0;
      var it2 = this.items[idx];
      return !keepScalar && it2 instanceof Scalar$1 ? it2.value : it2;
    }
  }, {
    key: "has",
    value: function has3(key2) {
      var idx = asItemIndex$1(key2);
      return typeof idx === "number" && idx < this.items.length;
    }
  }, {
    key: "set",
    value: function set5(key2, value) {
      var idx = asItemIndex$1(key2);
      if (typeof idx !== "number")
        throw new Error("Expected a valid index, not ".concat(key2, "."));
      this.items[idx] = value;
    }
  }, {
    key: "toJSON",
    value: function toJSON$1(_2, ctx) {
      var seq2 = [];
      if (ctx && ctx.onCreate)
        ctx.onCreate(seq2);
      var i = 0;
      var _iterator = _createForOfIteratorHelper(this.items), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var item = _step.value;
          seq2.push(toJSON(item, String(i++), ctx));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return seq2;
    }
  }, {
    key: "toString",
    value: function toString2(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return _get(_getPrototypeOf$1(YAMLSeq2.prototype), "toString", this).call(this, ctx, {
        blockItem: function blockItem(n2) {
          return n2.type === "comment" ? n2.str : "- ".concat(n2.str);
        },
        flowChars: {
          start: "[",
          end: "]"
        },
        isMap: false,
        itemIndent: (ctx.indent || "") + "  "
      }, onComment, onChompKeep);
    }
  }]);
  return YAMLSeq2;
}(Collection$1);
var stringifyKey$1 = function stringifyKey(key2, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (_typeof$1(jsKey) !== "object")
    return String(jsKey);
  if (key2 instanceof Node$1 && ctx && ctx.doc)
    return key2.toString({
      anchors: /* @__PURE__ */ Object.create(null),
      doc: ctx.doc,
      indent: "",
      indentStep: ctx.indentStep,
      inFlow: true,
      inStringifyKey: true,
      stringify: ctx.stringify
    });
  return JSON.stringify(jsKey);
};
var Pair$1 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Pair2, _Node);
  var _super = _createSuper$1(Pair2);
  function Pair2(key2) {
    var _this;
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _classCallCheck$1(this, Pair2);
    _this = _super.call(this);
    _this.key = key2;
    _this.value = value;
    _this.type = Pair2.Type.PAIR;
    return _this;
  }
  _createClass$2(Pair2, [{
    key: "commentBefore",
    get: function get4() {
      return this.key instanceof Node$1 ? this.key.commentBefore : void 0;
    },
    set: function set5(cb2) {
      if (this.key == null)
        this.key = new Scalar$1(null);
      if (this.key instanceof Node$1)
        this.key.commentBefore = cb2;
      else {
        var msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
        throw new Error(msg);
      }
    }
  }, {
    key: "addToJSMap",
    value: function addToJSMap(ctx, map3) {
      var key2 = toJSON(this.key, "", ctx);
      if (map3 instanceof Map) {
        var value = toJSON(this.value, key2, ctx);
        map3.set(key2, value);
      } else if (map3 instanceof Set) {
        map3.add(key2);
      } else {
        var stringKey = stringifyKey$1(this.key, key2, ctx);
        var _value = toJSON(this.value, stringKey, ctx);
        if (stringKey in map3)
          Object.defineProperty(map3, stringKey, {
            value: _value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map3[stringKey] = _value;
      }
      return map3;
    }
  }, {
    key: "toJSON",
    value: function toJSON3(_2, ctx) {
      var pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return this.addToJSMap(ctx, pair);
    }
  }, {
    key: "toString",
    value: function toString2(ctx, onComment, onChompKeep) {
      if (!ctx || !ctx.doc)
        return JSON.stringify(this);
      var _ctx$doc$options = ctx.doc.options, indentSize = _ctx$doc$options.indent, indentSeq = _ctx$doc$options.indentSeq, simpleKeys = _ctx$doc$options.simpleKeys;
      var key2 = this.key, value = this.value;
      var keyComment = key2 instanceof Node$1 && key2.comment;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (key2 instanceof Collection$1) {
          var msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      var explicitKey = !simpleKeys && (!key2 || keyComment || (key2 instanceof Node$1 ? key2 instanceof Collection$1 || key2.type === Type.BLOCK_FOLDED || key2.type === Type.BLOCK_LITERAL : _typeof$1(key2) === "object"));
      var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify16 = _ctx.stringify;
      ctx = Object.assign({}, ctx, {
        implicitKey: !explicitKey,
        indent: indent + indentStep
      });
      var chompKeep = false;
      var str2 = stringify16(key2, ctx, function() {
        return keyComment = null;
      }, function() {
        return chompKeep = true;
      });
      str2 = addComment(str2, ctx.indent, keyComment);
      if (!explicitKey && str2.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.allNullValues && !simpleKeys) {
        if (this.comment) {
          str2 = addComment(str2, ctx.indent, this.comment);
          if (onComment)
            onComment();
        } else if (chompKeep && !keyComment && onChompKeep)
          onChompKeep();
        return ctx.inFlow && !explicitKey ? str2 : "? ".concat(str2);
      }
      str2 = explicitKey ? "? ".concat(str2, "\n").concat(indent, ":") : "".concat(str2, ":");
      if (this.comment) {
        str2 = addComment(str2, ctx.indent, this.comment);
        if (onComment)
          onComment();
      }
      var vcb = "";
      var valueComment = null;
      if (value instanceof Node$1) {
        if (value.spaceBefore)
          vcb = "\n";
        if (value.commentBefore) {
          var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
          vcb += "\n".concat(cs);
        }
        valueComment = value.comment;
      } else if (value && _typeof$1(value) === "object") {
        value = doc.schema.createNode(value, true);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !this.comment && value instanceof Scalar$1)
        ctx.indentAtStart = str2.length + 1;
      chompKeep = false;
      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq$1 && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
        ctx.indent = ctx.indent.substr(2);
      }
      var valueStr = stringify16(value, ctx, function() {
        return valueComment = null;
      }, function() {
        return chompKeep = true;
      });
      var ws = " ";
      if (vcb || this.comment) {
        ws = "".concat(vcb, "\n").concat(ctx.indent);
      } else if (!explicitKey && value instanceof Collection$1) {
        var flow3 = valueStr[0] === "[" || valueStr[0] === "{";
        if (!flow3 || valueStr.includes("\n"))
          ws = "\n".concat(ctx.indent);
      } else if (valueStr[0] === "\n")
        ws = "";
      if (chompKeep && !valueComment && onChompKeep)
        onChompKeep();
      return addComment(str2 + ws + valueStr, ctx.indent, valueComment);
    }
  }]);
  return Pair2;
}(Node$1);
_defineProperty(Pair$1, "Type", {
  PAIR: "PAIR",
  MERGE_PAIR: "MERGE_PAIR"
});
var getAliasCount$1 = function getAliasCount(node2, anchors) {
  if (node2 instanceof Alias$1) {
    var anchor = anchors.get(node2.source);
    return anchor.count * anchor.aliasCount;
  } else if (node2 instanceof Collection$1) {
    var count2 = 0;
    var _iterator = _createForOfIteratorHelper(node2.items), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        var c2 = getAliasCount(item, anchors);
        if (c2 > count2)
          count2 = c2;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return count2;
  } else if (node2 instanceof Pair$1) {
    var kc2 = getAliasCount(node2.key, anchors);
    var vc2 = getAliasCount(node2.value, anchors);
    return Math.max(kc2, vc2);
  }
  return 1;
};
var Alias$1 = /* @__PURE__ */ function(_Node) {
  _inherits$1(Alias2, _Node);
  var _super = _createSuper$1(Alias2);
  function Alias2(source) {
    var _this;
    _classCallCheck$1(this, Alias2);
    _this = _super.call(this);
    _this.source = source;
    _this.type = Type.ALIAS;
    return _this;
  }
  _createClass$2(Alias2, [{
    key: "tag",
    set: function set5(t2) {
      throw new Error("Alias nodes cannot have tags");
    }
  }, {
    key: "toJSON",
    value: function toJSON$1(arg, ctx) {
      if (!ctx)
        return toJSON(this.source, arg, ctx);
      var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
      var anchor = anchors.get(this.source);
      if (!anchor || anchor.res === void 0) {
        var msg = "This should not happen: Alias anchor was not resolved?";
        if (this.cstNode)
          throw new YAMLReferenceError(this.cstNode, msg);
        else
          throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        anchor.count += 1;
        if (anchor.aliasCount === 0)
          anchor.aliasCount = getAliasCount$1(this.source, anchors);
        if (anchor.count * anchor.aliasCount > maxAliasCount) {
          var _msg = "Excessive alias count indicates a resource exhaustion attack";
          if (this.cstNode)
            throw new YAMLReferenceError(this.cstNode, _msg);
          else
            throw new ReferenceError(_msg);
        }
      }
      return anchor.res;
    }
    // Only called when stringifying an alias mapping key while constructing
    // Object output.
  }, {
    key: "toString",
    value: function toString2(ctx) {
      return Alias2.stringify(this, ctx);
    }
  }], [{
    key: "stringify",
    value: function stringify16(_ref3, _ref22) {
      var range = _ref3.range, source = _ref3.source;
      var anchors = _ref22.anchors, doc = _ref22.doc, implicitKey = _ref22.implicitKey, inStringifyKey = _ref22.inStringifyKey;
      var anchor = Object.keys(anchors).find(function(a) {
        return anchors[a] === source;
      });
      if (!anchor && inStringifyKey)
        anchor = doc.anchors.getName(source) || doc.anchors.newName();
      if (anchor)
        return "*".concat(anchor).concat(implicitKey ? " " : "");
      var msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
      throw new Error("".concat(msg, " [").concat(range, "]"));
    }
  }]);
  return Alias2;
}(Node$1);
_defineProperty(Alias$1, "default", true);
function findPair$1(items, key2) {
  var k2 = key2 instanceof Scalar$1 ? key2.value : key2;
  var _iterator = _createForOfIteratorHelper(items), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it2 = _step.value;
      if (it2 instanceof Pair$1) {
        if (it2.key === key2 || it2.key === k2)
          return it2;
        if (it2.key && it2.key.value === k2)
          return it2;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return void 0;
}
var YAMLMap$1 = /* @__PURE__ */ function(_Collection) {
  _inherits$1(YAMLMap2, _Collection);
  var _super = _createSuper$1(YAMLMap2);
  function YAMLMap2() {
    _classCallCheck$1(this, YAMLMap2);
    return _super.apply(this, arguments);
  }
  _createClass$2(YAMLMap2, [{
    key: "add",
    value: function add2(pair, overwrite) {
      if (!pair)
        pair = new Pair$1(pair);
      else if (!(pair instanceof Pair$1))
        pair = new Pair$1(pair.key || pair, pair.value);
      var prev2 = findPair$1(this.items, pair.key);
      var sortEntries = this.schema && this.schema.sortMapEntries;
      if (prev2) {
        if (overwrite)
          prev2.value = pair.value;
        else
          throw new Error("Key ".concat(pair.key, " already set"));
      } else if (sortEntries) {
        var i = this.items.findIndex(function(item) {
          return sortEntries(pair, item) < 0;
        });
        if (i === -1)
          this.items.push(pair);
        else
          this.items.splice(i, 0, pair);
      } else {
        this.items.push(pair);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key2) {
      var it2 = findPair$1(this.items, key2);
      if (!it2)
        return false;
      var del = this.items.splice(this.items.indexOf(it2), 1);
      return del.length > 0;
    }
  }, {
    key: "get",
    value: function get4(key2, keepScalar) {
      var it2 = findPair$1(this.items, key2);
      var node2 = it2 && it2.value;
      return !keepScalar && node2 instanceof Scalar$1 ? node2.value : node2;
    }
  }, {
    key: "has",
    value: function has3(key2) {
      return !!findPair$1(this.items, key2);
    }
  }, {
    key: "set",
    value: function set5(key2, value) {
      this.add(new Pair$1(key2, value), true);
    }
    /**
     * @param {*} arg ignored
     * @param {*} ctx Conversion context, originally set in Document#toJSON()
     * @param {Class} Type If set, forces the returned collection type
     * @returns {*} Instance of Type, Map, or Object
     */
  }, {
    key: "toJSON",
    value: function toJSON3(_2, ctx, Type2) {
      var map3 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
      if (ctx && ctx.onCreate)
        ctx.onCreate(map3);
      var _iterator2 = _createForOfIteratorHelper(this.items), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var item = _step2.value;
          item.addToJSMap(ctx, map3);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return map3;
    }
  }, {
    key: "toString",
    value: function toString2(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      var _iterator3 = _createForOfIteratorHelper(this.items), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var item = _step3.value;
          if (!(item instanceof Pair$1))
            throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return _get(_getPrototypeOf$1(YAMLMap2.prototype), "toString", this).call(this, ctx, {
        blockItem: function blockItem(n2) {
          return n2.str;
        },
        flowChars: {
          start: "{",
          end: "}"
        },
        isMap: true,
        itemIndent: ctx.indent || ""
      }, onComment, onChompKeep);
    }
  }]);
  return YAMLMap2;
}(Collection$1);
var MERGE_KEY$1 = "<<";
var Merge = /* @__PURE__ */ function(_Pair) {
  _inherits$1(Merge2, _Pair);
  var _super = _createSuper$1(Merge2);
  function Merge2(pair) {
    var _this;
    _classCallCheck$1(this, Merge2);
    if (pair instanceof Pair$1) {
      var seq2 = pair.value;
      if (!(seq2 instanceof YAMLSeq$1)) {
        seq2 = new YAMLSeq$1();
        seq2.items.push(pair.value);
        seq2.range = pair.value.range;
      }
      _this = _super.call(this, pair.key, seq2);
      _this.range = pair.range;
    } else {
      _this = _super.call(this, new Scalar$1(MERGE_KEY$1), new YAMLSeq$1());
    }
    _this.type = Pair$1.Type.MERGE_PAIR;
    return _possibleConstructorReturn$1(_this);
  }
  _createClass$2(Merge2, [{
    key: "addToJSMap",
    value: function addToJSMap(ctx, map3) {
      var _iterator = _createForOfIteratorHelper(this.value.items), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var source = _step.value.source;
          if (!(source instanceof YAMLMap$1))
            throw new Error("Merge sources must be maps");
          var srcMap = source.toJSON(null, ctx, Map);
          var _iterator2 = _createForOfIteratorHelper(srcMap), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _step2$value = _slicedToArray$1(_step2.value, 2), key2 = _step2$value[0], value = _step2$value[1];
              if (map3 instanceof Map) {
                if (!map3.has(key2))
                  map3.set(key2, value);
              } else if (map3 instanceof Set) {
                map3.add(key2);
              } else if (!Object.prototype.hasOwnProperty.call(map3, key2)) {
                Object.defineProperty(map3, key2, {
                  value,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return map3;
    }
  }, {
    key: "toString",
    value: function toString2(ctx, onComment) {
      var seq2 = this.value;
      if (seq2.items.length > 1)
        return _get(_getPrototypeOf$1(Merge2.prototype), "toString", this).call(this, ctx, onComment);
      this.value = seq2.items[0];
      var str2 = _get(_getPrototypeOf$1(Merge2.prototype), "toString", this).call(this, ctx, onComment);
      this.value = seq2;
      return str2;
    }
  }]);
  return Merge2;
}(Pair$1);
var binaryOptions = {
  defaultType: Type.BLOCK_LITERAL,
  lineWidth: 76
};
var boolOptions = {
  trueStr: "true",
  falseStr: "false"
};
var intOptions = {
  asBigInt: false
};
var nullOptions = {
  nullStr: "null"
};
var strOptions = {
  defaultType: Type.PLAIN,
  doubleQuoted: {
    jsonEncoding: false,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};
function resolveScalar(str2, tags2, scalarFallback) {
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, format2 = _step$value.format, test2 = _step$value.test, resolve28 = _step$value.resolve;
      if (test2) {
        var match2 = str2.match(test2);
        if (match2) {
          var res = resolve28.apply(null, match2);
          if (!(res instanceof Scalar$1))
            res = new Scalar$1(res);
          if (format2)
            res.format = format2;
          return res;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (scalarFallback)
    str2 = scalarFallback(str2);
  return new Scalar$1(str2);
}
var FOLD_FLOW$1 = "flow";
var FOLD_BLOCK$1 = "block";
var FOLD_QUOTED$1 = "quoted";
var consumeMoreIndentedLines$1 = function consumeMoreIndentedLines(text, i) {
  var ch2 = text[i + 1];
  while (ch2 === " " || ch2 === "	") {
    do {
      ch2 = text[i += 1];
    } while (ch2 && ch2 !== "\n");
    ch2 = text[i + 1];
  }
  return i;
};
function foldFlowLines$1(text, indent, mode2, _ref3) {
  var indentAtStart = _ref3.indentAtStart, _ref$lineWidth = _ref3.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref3.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref3.onFold, onOverflow = _ref3.onOverflow;
  if (!lineWidth || lineWidth < 0)
    return text;
  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  var folds = [];
  var escapedFolds = {};
  var end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  var split = void 0;
  var prev2 = void 0;
  var overflow = false;
  var i = -1;
  var escStart = -1;
  var escEnd = -1;
  if (mode2 === FOLD_BLOCK$1) {
    i = consumeMoreIndentedLines$1(text, i);
    if (i !== -1)
      end2 = i + endStep;
  }
  for (var ch2; ch2 = text[i += 1]; ) {
    if (mode2 === FOLD_QUOTED$1 && ch2 === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch2 === "\n") {
      if (mode2 === FOLD_BLOCK$1)
        i = consumeMoreIndentedLines$1(text, i);
      end2 = i + endStep;
      split = void 0;
    } else {
      if (ch2 === " " && prev2 && prev2 !== " " && prev2 !== "\n" && prev2 !== "	") {
        var next2 = text[i + 1];
        if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
          split = i;
      }
      if (i >= end2) {
        if (split) {
          folds.push(split);
          end2 = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED$1) {
          while (prev2 === " " || prev2 === "	") {
            prev2 = ch2;
            ch2 = text[i += 1];
            overflow = true;
          }
          var j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end2 = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev2 = ch2;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  var res = text.slice(0, folds[0]);
  for (var _i = 0; _i < folds.length; ++_i) {
    var fold = folds[_i];
    var _end = folds[_i + 1] || text.length;
    if (fold === 0)
      res = "\n".concat(indent).concat(text.slice(0, _end));
    else {
      if (mode2 === FOLD_QUOTED$1 && escapedFolds[fold])
        res += "".concat(text[fold], "\\");
      res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
    }
  }
  return res;
}
var getFoldOptions$1 = function getFoldOptions(_ref3) {
  var indentAtStart = _ref3.indentAtStart;
  return indentAtStart ? Object.assign({
    indentAtStart
  }, strOptions.fold) : strOptions.fold;
};
var containsDocumentMarker$1 = function containsDocumentMarker(str2) {
  return /^(%|---|\.\.\.)/m.test(str2);
};
function lineLengthOverLimit$1(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  var limit = lineWidth - indentLength;
  var strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (var i = 0, start2 = 0; i < strLen; ++i) {
    if (str2[i] === "\n") {
      if (i - start2 > limit)
        return true;
      start2 = i + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString$1(value, ctx) {
  var implicitKey = ctx.implicitKey;
  var _strOptions$doubleQuo = strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
  var json2 = JSON.stringify(value);
  if (jsonEncoding)
    return json2;
  var indent = ctx.indent || (containsDocumentMarker$1(value) ? "  " : "");
  var str2 = "";
  var start2 = 0;
  for (var i = 0, ch2 = json2[i]; ch2; ch2 = json2[++i]) {
    if (ch2 === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str2 += json2.slice(start2, i) + "\\ ";
      i += 1;
      start2 = i;
      ch2 = "\\";
    }
    if (ch2 === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str2 += json2.slice(start2, i);
            var code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json2.substr(i, 6);
            }
            i += 5;
            start2 = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str2 += json2.slice(start2, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str2 += "\n";
              i += 2;
            }
            str2 += indent;
            if (json2[i + 2] === " ")
              str2 += "\\";
            i += 1;
            start2 = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str2 = start2 ? str2 + json2.slice(start2) : json2;
  return implicitKey ? str2 : foldFlowLines$1(str2, indent, FOLD_QUOTED$1, getFoldOptions$1(ctx));
}
function singleQuotedString$1(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value))
      return doubleQuotedString$1(value, ctx);
  } else {
    if (/[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString$1(value, ctx);
  }
  var indent = ctx.indent || (containsDocumentMarker$1(value) ? "  " : "");
  var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
  return ctx.implicitKey ? res : foldFlowLines$1(res, indent, FOLD_FLOW$1, getFoldOptions$1(ctx));
}
function blockString$1(_ref22, ctx, onComment, onChompKeep) {
  var comment2 = _ref22.comment, type2 = _ref22.type, value = _ref22.value;
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString$1(value, ctx);
  }
  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker$1(value) ? "  " : "");
  var indentSize = indent ? "2" : "1";
  var literal = type2 === Type.BLOCK_FOLDED ? false : type2 === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit$1(value, strOptions.fold.lineWidth, indent.length);
  var header = literal ? "|" : ">";
  if (!value)
    return header + "\n";
  var wsStart = "";
  var wsEnd = "";
  value = value.replace(/[\n\t ]*$/, function(ws) {
    var n2 = ws.indexOf("\n");
    if (n2 === -1) {
      header += "-";
    } else if (value === ws || n2 !== ws.length - 1) {
      header += "+";
      if (onChompKeep)
        onChompKeep();
    }
    wsEnd = ws.replace(/\n$/, "");
    return "";
  }).replace(/^[\n ]*/, function(ws) {
    if (ws.indexOf(" ") !== -1)
      header += indentSize;
    var m2 = ws.match(/ +$/);
    if (m2) {
      wsStart = ws.slice(0, -m2[0].length);
      return m2[0];
    } else {
      wsStart = ws;
      return "";
    }
  });
  if (wsEnd)
    wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
  if (wsStart)
    wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
  if (comment2) {
    header += " #" + comment2.replace(/ ?[\r\n]+/g, " ");
    if (onComment)
      onComment();
  }
  if (!value)
    return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
  if (literal) {
    value = value.replace(/\n+/g, "$&".concat(indent));
    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
  var body = foldFlowLines$1("".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK$1, strOptions.fold);
  return "".concat(header, "\n").concat(indent).concat(body);
}
function plainString$1(item, ctx, onComment, onChompKeep) {
  var comment2 = item.comment, type2 = item.type, value = item.value;
  var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString$1(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString$1(value, ctx) : doubleQuotedString$1(value, ctx) : blockString$1(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type2 !== Type.PLAIN && value.indexOf("\n") !== -1) {
    return blockString$1(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker$1(value)) {
    ctx.forceBlockIndent = true;
    return blockString$1(item, ctx, onComment, onChompKeep);
  }
  var str2 = value.replace(/\n+/g, "$&\n".concat(indent));
  if (actualString) {
    var tags2 = ctx.doc.schema.tags;
    var resolved = resolveScalar(str2, tags2, tags2.scalarFallback).value;
    if (typeof resolved !== "string")
      return doubleQuotedString$1(value, ctx);
  }
  var body = implicitKey ? str2 : foldFlowLines$1(str2, indent, FOLD_FLOW$1, getFoldOptions$1(ctx));
  if (comment2 && !inFlow && (body.indexOf("\n") !== -1 || comment2.indexOf("\n") !== -1)) {
    if (onComment)
      onComment();
    return addCommentBefore$1(body, indent, comment2);
  }
  return body;
}
function stringifyString$1(item, ctx, onComment, onChompKeep) {
  var defaultType = strOptions.defaultType;
  var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
  var _item = item, type2 = _item.type, value = _item.value;
  if (typeof value !== "string") {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }
  var _stringify = function _stringify2(_type) {
    switch (_type) {
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
        return blockString$1(item, ctx, onComment, onChompKeep);
      case Type.QUOTE_DOUBLE:
        return doubleQuotedString$1(value, ctx);
      case Type.QUOTE_SINGLE:
        return singleQuotedString$1(value, ctx);
      case Type.PLAIN:
        return plainString$1(item, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  if (type2 !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    type2 = Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type2 === Type.BLOCK_FOLDED || type2 === Type.BLOCK_LITERAL)) {
    type2 = Type.QUOTE_DOUBLE;
  }
  var res = _stringify(type2);
  if (res === null) {
    res = _stringify(defaultType);
    if (res === null)
      throw new Error("Unsupported default string type ".concat(defaultType));
  }
  return res;
}
function stringifyNumber$1(_ref3) {
  var format2 = _ref3.format, minFractionDigits = _ref3.minFractionDigits, tag = _ref3.tag, value = _ref3.value;
  if (typeof value === "bigint")
    return String(value);
  if (!isFinite(value))
    return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
  var n2 = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    var i = n2.indexOf(".");
    if (i < 0) {
      i = n2.length;
      n2 += ".";
    }
    var d2 = minFractionDigits - (n2.length - i - 1);
    while (d2-- > 0) {
      n2 += "0";
    }
  }
  return n2;
}
function checkFlowCollectionEnd(errors, cst) {
  var char2, name2;
  switch (cst.type) {
    case Type.FLOW_MAP:
      char2 = "}";
      name2 = "flow map";
      break;
    case Type.FLOW_SEQ:
      char2 = "]";
      name2 = "flow sequence";
      break;
    default:
      errors.push(new YAMLSemanticError(cst, "Not a flow collection!?"));
      return;
  }
  var lastItem;
  for (var i = cst.items.length - 1; i >= 0; --i) {
    var item = cst.items[i];
    if (!item || item.type !== Type.COMMENT) {
      lastItem = item;
      break;
    }
  }
  if (lastItem && lastItem.char !== char2) {
    var msg = "Expected ".concat(name2, " to end with ").concat(char2);
    var err;
    if (typeof lastItem.offset === "number") {
      err = new YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end)
        err.offset = lastItem.range.end - lastItem.range.start;
    }
    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment2) {
  var prev2 = comment2.context.src[comment2.range.start - 1];
  if (prev2 !== "\n" && prev2 !== "	" && prev2 !== " ") {
    var msg = "Comments must be separated from other tokens by white space characters";
    errors.push(new YAMLSemanticError(comment2, msg));
  }
}
function getLongKeyError(source, key2) {
  var sk2 = String(key2);
  var k2 = sk2.substr(0, 8) + "..." + sk2.substr(-8);
  return new YAMLSemanticError(source, 'The "'.concat(k2, '" key is too long'));
}
function resolveComments(collection, comments) {
  var _iterator = _createForOfIteratorHelper(comments), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment2 = _step$value.comment;
      var item = collection.items[before];
      if (!item) {
        if (comment2 !== void 0) {
          if (collection.comment)
            collection.comment += "\n" + comment2;
          else
            collection.comment = comment2;
        }
      } else {
        if (afterKey && item.value)
          item = item.value;
        if (comment2 === void 0) {
          if (afterKey || !item.commentBefore)
            item.spaceBefore = true;
        } else {
          if (item.commentBefore)
            item.commentBefore += "\n" + comment2;
          else
            item.commentBefore = comment2;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function resolveString(doc, node2) {
  var res = node2.strValue;
  if (!res)
    return "";
  if (typeof res === "string")
    return res;
  res.errors.forEach(function(error) {
    if (!error.source)
      error.source = node2;
    doc.errors.push(error);
  });
  return res.str;
}
function resolveTagHandle(doc, node2) {
  var _node$tag = node2.tag, handle = _node$tag.handle, suffix = _node$tag.suffix;
  var prefix2 = doc.tagPrefixes.find(function(p2) {
    return p2.handle === handle;
  });
  if (!prefix2) {
    var dtp = doc.getDefaults().tagPrefixes;
    if (dtp)
      prefix2 = dtp.find(function(p2) {
        return p2.handle === handle;
      });
    if (!prefix2)
      throw new YAMLSemanticError(node2, "The ".concat(handle, " tag handle is non-default and was not declared."));
  }
  if (!suffix)
    throw new YAMLSemanticError(node2, "The ".concat(handle, " tag has no suffix."));
  if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
    if (suffix[0] === "^") {
      doc.warnings.push(new YAMLWarning(node2, "YAML 1.0 ^ tag expansion is not supported"));
      return suffix;
    }
    if (/[:/]/.test(suffix)) {
      var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
    }
  }
  return prefix2.prefix + decodeURIComponent(suffix);
}
function resolveTagName(doc, node2) {
  var tag = node2.tag, type2 = node2.type;
  var nonSpecific = false;
  if (tag) {
    var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
    if (verbatim) {
      if (verbatim !== "!" && verbatim !== "!!")
        return verbatim;
      var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
      doc.errors.push(new YAMLSemanticError(node2, msg));
    } else if (handle === "!" && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node2);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }
  switch (type2) {
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
    case Type.QUOTE_DOUBLE:
    case Type.QUOTE_SINGLE:
      return defaultTags.STR;
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    case Type.PLAIN:
      return nonSpecific ? defaultTags.STR : null;
    default:
      return null;
  }
}
function resolveByTagName(doc, node2, tagName) {
  var tags2 = doc.schema.tags;
  var matchWithTest = [];
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var tag = _step.value;
      if (tag.tag === tagName) {
        if (tag.test)
          matchWithTest.push(tag);
        else {
          var res = tag.resolve(doc, node2);
          return res instanceof Collection$1 ? res : new Scalar$1(res);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var str2 = resolveString(doc, node2);
  if (typeof str2 === "string" && matchWithTest.length > 0)
    return resolveScalar(str2, matchWithTest, tags2.scalarFallback);
  return null;
}
function getFallbackTagName(_ref3) {
  var type2 = _ref3.type;
  switch (type2) {
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    default:
      return defaultTags.STR;
  }
}
function resolveTag(doc, node2, tagName) {
  try {
    var res = resolveByTagName(doc, node2, tagName);
    if (res) {
      if (tagName && node2.tag)
        res.tag = tagName;
      return res;
    }
  } catch (error) {
    if (!error.source)
      error.source = node2;
    doc.errors.push(error);
    return null;
  }
  try {
    var fallback = getFallbackTagName(node2);
    if (!fallback)
      throw new Error("The tag ".concat(tagName, " is unavailable"));
    var msg = "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback);
    doc.warnings.push(new YAMLWarning(node2, msg));
    var _res = resolveByTagName(doc, node2, fallback);
    _res.tag = tagName;
    return _res;
  } catch (error) {
    var refError = new YAMLReferenceError(node2, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}
var isCollectionItem = function isCollectionItem2(node2) {
  if (!node2)
    return false;
  var type2 = node2.type;
  return type2 === Type.MAP_KEY || type2 === Type.MAP_VALUE || type2 === Type.SEQ_ITEM;
};
function resolveNodeProps(errors, node2) {
  var comments = {
    before: [],
    after: []
  };
  var hasAnchor2 = false;
  var hasTag = false;
  var props = isCollectionItem(node2.context.parent) ? node2.context.parent.props.concat(node2.props) : node2.props;
  var _iterator = _createForOfIteratorHelper(props), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, start2 = _step$value.start, end2 = _step$value.end;
      switch (node2.context.src[start2]) {
        case Char.COMMENT: {
          if (!node2.commentHasRequiredWhitespace(start2)) {
            var msg = "Comments must be separated from other tokens by white space characters";
            errors.push(new YAMLSemanticError(node2, msg));
          }
          var header = node2.header, valueRange = node2.valueRange;
          var cc2 = valueRange && (start2 > valueRange.start || header && start2 > header.start) ? comments.after : comments.before;
          cc2.push(node2.context.src.slice(start2 + 1, end2));
          break;
        }
        case Char.ANCHOR:
          if (hasAnchor2) {
            var _msg = "A node can have at most one anchor";
            errors.push(new YAMLSemanticError(node2, _msg));
          }
          hasAnchor2 = true;
          break;
        case Char.TAG:
          if (hasTag) {
            var _msg2 = "A node can have at most one tag";
            errors.push(new YAMLSemanticError(node2, _msg2));
          }
          hasTag = true;
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    comments,
    hasAnchor: hasAnchor2,
    hasTag
  };
}
function resolveNodeValue(doc, node2) {
  var anchors = doc.anchors, errors = doc.errors, schema2 = doc.schema;
  if (node2.type === Type.ALIAS) {
    var name2 = node2.rawValue;
    var src = anchors.getNode(name2);
    if (!src) {
      var msg = "Aliased anchor not found: ".concat(name2);
      errors.push(new YAMLReferenceError(node2, msg));
      return null;
    }
    var res = new Alias$1(src);
    anchors._cstAliases.push(res);
    return res;
  }
  var tagName = resolveTagName(doc, node2);
  if (tagName)
    return resolveTag(doc, node2, tagName);
  if (node2.type !== Type.PLAIN) {
    var _msg3 = "Failed to resolve ".concat(node2.type, " node here");
    errors.push(new YAMLSyntaxError(node2, _msg3));
    return null;
  }
  try {
    var str2 = resolveString(doc, node2);
    return resolveScalar(str2, schema2.tags, schema2.tags.scalarFallback);
  } catch (error) {
    if (!error.source)
      error.source = node2;
    errors.push(error);
    return null;
  }
}
function resolveNode(doc, node2) {
  if (!node2)
    return null;
  if (node2.error)
    doc.errors.push(node2.error);
  var _resolveNodeProps = resolveNodeProps(doc.errors, node2), comments = _resolveNodeProps.comments, hasAnchor2 = _resolveNodeProps.hasAnchor, hasTag = _resolveNodeProps.hasTag;
  if (hasAnchor2) {
    var anchors = doc.anchors;
    var name2 = node2.anchor;
    var prev2 = anchors.getNode(name2);
    if (prev2)
      anchors.map[anchors.newName(name2)] = prev2;
    anchors.map[name2] = node2;
  }
  if (node2.type === Type.ALIAS && (hasAnchor2 || hasTag)) {
    var msg = "An alias node must not specify any properties";
    doc.errors.push(new YAMLSemanticError(node2, msg));
  }
  var res = resolveNodeValue(doc, node2);
  if (res) {
    res.range = [node2.range.start, node2.range.end];
    if (doc.options.keepCstNodes)
      res.cstNode = node2;
    if (doc.options.keepNodeTypes)
      res.type = node2.type;
    var cb2 = comments.before.join("\n");
    if (cb2) {
      res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb2) : cb2;
    }
    var ca2 = comments.after.join("\n");
    if (ca2)
      res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca2) : ca2;
  }
  return node2.resolved = res;
}
function resolveMap(doc, cst) {
  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref3 = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref3.comments, items = _ref3.items;
  var map3 = new YAMLMap$1();
  map3.items = items;
  resolveComments(map3, comments);
  var hasCollectionKey = false;
  for (var i = 0; i < items.length; ++i) {
    var iKey = items[i].key;
    if (iKey instanceof Collection$1)
      hasCollectionKey = true;
    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY$1) {
      items[i] = new Merge(items[i]);
      var sources = items[i].value.items;
      var error = null;
      sources.some(function(node2) {
        if (node2 instanceof Alias$1) {
          var type2 = node2.source.type;
          if (type2 === Type.MAP || type2 === Type.FLOW_MAP)
            return false;
          return error = "Merge nodes aliases can only point to maps";
        }
        return error = "Merge nodes can only have Alias nodes as values";
      });
      if (error)
        doc.errors.push(new YAMLSemanticError(cst, error));
    } else {
      for (var j = i + 1; j < items.length; ++j) {
        var jKey = items[j].key;
        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
          var _msg = 'Map keys must be unique; "'.concat(iKey, '" is repeated');
          doc.errors.push(new YAMLSemanticError(cst, _msg));
          break;
        }
      }
    }
  }
  if (hasCollectionKey && !doc.options.mapAsMap) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = map3;
  return map3;
}
var valueHasPairComment = function valueHasPairComment2(_ref22) {
  var _ref2$context = _ref22.context, lineStart = _ref2$context.lineStart, node2 = _ref2$context.node, src = _ref2$context.src, props = _ref22.props;
  if (props.length === 0)
    return false;
  var start2 = props[0].start;
  if (node2 && start2 > node2.valueRange.start)
    return false;
  if (src[start2] !== Char.COMMENT)
    return false;
  for (var i = lineStart; i < start2; ++i) {
    if (src[i] === "\n")
      return false;
  }
  return true;
};
function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item))
    return;
  var comment2 = item.getPropValue(0, Char.COMMENT, true);
  var found = false;
  var cb2 = pair.value.commentBefore;
  if (cb2 && cb2.startsWith(comment2)) {
    pair.value.commentBefore = cb2.substr(comment2.length + 1);
    found = true;
  } else {
    var cc2 = pair.value.comment;
    if (!item.node && cc2 && cc2.startsWith(comment2)) {
      pair.value.comment = cc2.substr(comment2.length + 1);
      found = true;
    }
  }
  if (found)
    pair.comment = comment2;
}
function resolveBlockMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key2 = void 0;
  var keyStart = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          afterKey: !!key2,
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          afterKey: !!key2,
          before: items.length,
          comment: item.comment
        });
        break;
      case Type.MAP_KEY:
        if (key2 !== void 0)
          items.push(new Pair$1(key2));
        if (item.error)
          doc.errors.push(item.error);
        key2 = resolveNode(doc, item.node);
        keyStart = null;
        break;
      case Type.MAP_VALUE:
        {
          if (key2 === void 0)
            key2 = null;
          if (item.error)
            doc.errors.push(item.error);
          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
            var msg = "Nested mappings are not allowed in compact mappings";
            doc.errors.push(new YAMLSemanticError(item.node, msg));
          }
          var valueNode = item.node;
          if (!valueNode && item.props.length > 0) {
            valueNode = new PlainValue(Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            var pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };
            if (typeof item.range.origStart === "number") {
              var origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }
          var pair = new Pair$1(key2, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);
          if (key2 && typeof keyStart === "number") {
            if (item.range.start > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key2));
          }
          key2 = void 0;
          keyStart = null;
        }
        break;
      default:
        if (key2 !== void 0)
          items.push(new Pair$1(key2));
        key2 = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error)
          doc.errors.push(item.error);
        next:
          for (var j = i + 1; ; ++j) {
            var nextItem = cst.items[j];
            switch (nextItem && nextItem.type) {
              case Type.BLANK_LINE:
              case Type.COMMENT:
                continue next;
              case Type.MAP_VALUE:
                break next;
              default: {
                var _msg2 = "Implicit map keys need to be followed by map values";
                doc.errors.push(new YAMLSemanticError(item, _msg2));
                break next;
              }
            }
          }
        if (item.valueRangeContainsNewline) {
          var _msg3 = "Implicit map keys need to be on a single line";
          doc.errors.push(new YAMLSemanticError(item, _msg3));
        }
    }
  }
  if (key2 !== void 0)
    items.push(new Pair$1(key2));
  return {
    comments,
    items
  };
}
function resolveFlowMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key2 = void 0;
  var explicitKey = false;
  var next2 = "{";
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char2 = item.char, offset2 = item.offset;
      if (char2 === "?" && key2 === void 0 && !explicitKey) {
        explicitKey = true;
        next2 = ":";
        continue;
      }
      if (char2 === ":") {
        if (key2 === void 0)
          key2 = null;
        if (next2 === ":") {
          next2 = ",";
          continue;
        }
      } else {
        if (explicitKey) {
          if (key2 === void 0 && char2 !== ",")
            key2 = null;
          explicitKey = false;
        }
        if (key2 !== void 0) {
          items.push(new Pair$1(key2));
          key2 = void 0;
          if (char2 === ",") {
            next2 = ":";
            continue;
          }
        }
      }
      if (char2 === "}") {
        if (i === cst.items.length - 1)
          continue;
      } else if (char2 === next2) {
        next2 = ":";
        continue;
      }
      var msg = "Flow map contains an unexpected ".concat(char2);
      var err = new YAMLSyntaxError(cst, msg);
      err.offset = offset2;
      doc.errors.push(err);
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key2,
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key2,
        before: items.length,
        comment: item.comment
      });
    } else if (key2 === void 0) {
      if (next2 === ",")
        doc.errors.push(new YAMLSemanticError(item, "Separator , missing in flow map"));
      key2 = resolveNode(doc, item);
    } else {
      if (next2 !== ",")
        doc.errors.push(new YAMLSemanticError(item, "Indicator : missing in flow map entry"));
      items.push(new Pair$1(key2, resolveNode(doc, item)));
      key2 = void 0;
      explicitKey = false;
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key2 !== void 0)
    items.push(new Pair$1(key2));
  return {
    comments,
    items
  };
}
function resolveSeq(doc, cst) {
  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref3 = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref3.comments, items = _ref3.items;
  var seq2 = new YAMLSeq$1();
  seq2.items = items;
  resolveComments(seq2, comments);
  if (!doc.options.mapAsMap && items.some(function(it2) {
    return it2 instanceof Pair$1 && it2.key instanceof Collection$1;
  })) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = seq2;
  return seq2;
}
function resolveBlockSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;
      case Type.SEQ_ITEM:
        if (item.error)
          doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));
        if (item.hasProps) {
          var msg = "Sequence items cannot have tags or anchors before the - indicator";
          doc.errors.push(new YAMLSemanticError(item, msg));
        }
        break;
      default:
        if (item.error)
          doc.errors.push(item.error);
        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
    }
  }
  return {
    comments,
    items
  };
}
function resolveFlowSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  var explicitKey = false;
  var key2 = void 0;
  var keyStart = null;
  var next2 = "[";
  var prevItem = null;
  for (var i = 0; i < cst.items.length; ++i) {
    var item = cst.items[i];
    if (typeof item.char === "string") {
      var char2 = item.char, offset2 = item.offset;
      if (char2 !== ":" && (explicitKey || key2 !== void 0)) {
        if (explicitKey && key2 === void 0)
          key2 = next2 ? items.pop() : null;
        items.push(new Pair$1(key2));
        explicitKey = false;
        key2 = void 0;
        keyStart = null;
      }
      if (char2 === next2) {
        next2 = null;
      } else if (!next2 && char2 === "?") {
        explicitKey = true;
      } else if (next2 !== "[" && char2 === ":" && key2 === void 0) {
        if (next2 === ",") {
          key2 = items.pop();
          if (key2 instanceof Pair$1) {
            var msg = "Chaining flow sequence pairs is invalid";
            var err = new YAMLSemanticError(cst, msg);
            err.offset = offset2;
            doc.errors.push(err);
          }
          if (!explicitKey && typeof keyStart === "number") {
            var keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key2));
            var src = prevItem.context.src;
            for (var _i = keyStart; _i < keyEnd; ++_i) {
              if (src[_i] === "\n") {
                var _msg = "Implicit keys of flow sequence pairs need to be on a single line";
                doc.errors.push(new YAMLSemanticError(prevItem, _msg));
                break;
              }
            }
          }
        } else {
          key2 = null;
        }
        keyStart = null;
        explicitKey = false;
        next2 = null;
      } else if (next2 === "[" || char2 !== "]" || i < cst.items.length - 1) {
        var _msg2 = "Flow sequence contains an unexpected ".concat(char2);
        var _err = new YAMLSyntaxError(cst, _msg2);
        _err.offset = offset2;
        doc.errors.push(_err);
      }
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next2) {
        var _msg3 = "Expected a ".concat(next2, " in flow sequence");
        doc.errors.push(new YAMLSemanticError(item, _msg3));
      }
      var value = resolveNode(doc, item);
      if (key2 === void 0) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair$1(key2, value));
        key2 = void 0;
      }
      keyStart = item.range.start;
      next2 = ",";
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key2 !== void 0)
    items.push(new Pair$1(key2));
  return {
    comments,
    items
  };
}
var binary$2 = {
  identify: function identify(value) {
    return value instanceof Uint8Array;
  },
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: function resolve(doc, node2) {
    var src = resolveString(doc, node2);
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      var str2 = atob(src.replace(/[\n\r]/g, ""));
      var buffer = new Uint8Array(str2.length);
      for (var i = 0; i < str2.length; ++i) {
        buffer[i] = str2.charCodeAt(i);
      }
      return buffer;
    } else {
      var msg = "This environment does not support reading binary tags; either Buffer or atob is required";
      doc.errors.push(new YAMLReferenceError(node2, msg));
      return null;
    }
  },
  options: binaryOptions,
  stringify: function stringify(_ref3, ctx, onComment, onChompKeep) {
    var comment2 = _ref3.comment, type2 = _ref3.type, value = _ref3.value;
    var src;
    if (typeof Buffer === "function") {
      src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      var s = "";
      for (var i = 0; i < value.length; ++i) {
        s += String.fromCharCode(value[i]);
      }
      src = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type2)
      type2 = binaryOptions.defaultType;
    if (type2 === Type.QUOTE_DOUBLE) {
      value = src;
    } else {
      var lineWidth = binaryOptions.lineWidth;
      var n2 = Math.ceil(src.length / lineWidth);
      var lines = new Array(n2);
      for (var _i = 0, o = 0; _i < n2; ++_i, o += lineWidth) {
        lines[_i] = src.substr(o, lineWidth);
      }
      value = lines.join(type2 === Type.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString$1({
      comment: comment2,
      type: type2,
      value
    }, ctx, onComment, onChompKeep);
  }
};
function parsePairs(doc, cst) {
  var seq2 = resolveSeq(doc, cst);
  for (var i = 0; i < seq2.items.length; ++i) {
    var item = seq2.items[i];
    if (item instanceof Pair$1)
      continue;
    else if (item instanceof YAMLMap$1) {
      if (item.items.length > 1) {
        var msg = "Each pair must have its own sequence indicator";
        throw new YAMLSemanticError(cst, msg);
      }
      var pair = item.items[0] || new Pair$1();
      if (item.commentBefore)
        pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
      if (item.comment)
        pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
      item = pair;
    }
    seq2.items[i] = item instanceof Pair$1 ? item : new Pair$1(item);
  }
  return seq2;
}
function createPairs$1(schema2, iterable, ctx) {
  var pairs2 = new YAMLSeq$1(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it2 = _step.value;
      var key2 = void 0, value = void 0;
      if (Array.isArray(it2)) {
        if (it2.length === 2) {
          key2 = it2[0];
          value = it2[1];
        } else
          throw new TypeError("Expected [key, value] tuple: ".concat(it2));
      } else if (it2 && it2 instanceof Object) {
        var keys2 = Object.keys(it2);
        if (keys2.length === 1) {
          key2 = keys2[0];
          value = it2[key2];
        } else
          throw new TypeError("Expected { key: value } tuple: ".concat(it2));
      } else {
        key2 = it2;
      }
      var pair = schema2.createPair(key2, value, ctx);
      pairs2.items.push(pair);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return pairs2;
}
var pairs$2 = {
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: parsePairs,
  createNode: createPairs$1
};
var YAMLOMap$1 = /* @__PURE__ */ function(_YAMLSeq) {
  _inherits$1(YAMLOMap2, _YAMLSeq);
  var _super = _createSuper$1(YAMLOMap2);
  function YAMLOMap2() {
    var _this;
    _classCallCheck$1(this, YAMLOMap2);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized$2(_this), "add", YAMLMap$1.prototype.add.bind(_assertThisInitialized$2(_this)));
    _defineProperty(_assertThisInitialized$2(_this), "delete", YAMLMap$1.prototype.delete.bind(_assertThisInitialized$2(_this)));
    _defineProperty(_assertThisInitialized$2(_this), "get", YAMLMap$1.prototype.get.bind(_assertThisInitialized$2(_this)));
    _defineProperty(_assertThisInitialized$2(_this), "has", YAMLMap$1.prototype.has.bind(_assertThisInitialized$2(_this)));
    _defineProperty(_assertThisInitialized$2(_this), "set", YAMLMap$1.prototype.set.bind(_assertThisInitialized$2(_this)));
    _this.tag = YAMLOMap2.tag;
    return _this;
  }
  _createClass$2(YAMLOMap2, [{
    key: "toJSON",
    value: function toJSON$1(_2, ctx) {
      var map3 = /* @__PURE__ */ new Map();
      if (ctx && ctx.onCreate)
        ctx.onCreate(map3);
      var _iterator = _createForOfIteratorHelper(this.items), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var pair = _step.value;
          var key2 = void 0, value = void 0;
          if (pair instanceof Pair$1) {
            key2 = toJSON(pair.key, "", ctx);
            value = toJSON(pair.value, key2, ctx);
          } else {
            key2 = toJSON(pair, "", ctx);
          }
          if (map3.has(key2))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key2, value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return map3;
    }
  }]);
  return YAMLOMap2;
}(YAMLSeq$1);
_defineProperty(YAMLOMap$1, "tag", "tag:yaml.org,2002:omap");
function parseOMap(doc, cst) {
  var pairs2 = parsePairs(doc, cst);
  var seenKeys = [];
  var _iterator2 = _createForOfIteratorHelper(pairs2.items), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var key2 = _step2.value.key;
      if (key2 instanceof Scalar$1) {
        if (seenKeys.includes(key2.value)) {
          var msg = "Ordered maps must not include duplicate keys";
          throw new YAMLSemanticError(cst, msg);
        } else {
          seenKeys.push(key2.value);
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return Object.assign(new YAMLOMap$1(), pairs2);
}
function createOMap(schema2, iterable, ctx) {
  var pairs2 = createPairs$1(schema2, iterable, ctx);
  var omap2 = new YAMLOMap$1();
  omap2.items = pairs2.items;
  return omap2;
}
var omap$2 = {
  identify: function identify2(value) {
    return value instanceof Map;
  },
  nodeClass: YAMLOMap$1,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve: parseOMap,
  createNode: createOMap
};
var YAMLSet$1 = /* @__PURE__ */ function(_YAMLMap) {
  _inherits$1(YAMLSet2, _YAMLMap);
  var _super = _createSuper$1(YAMLSet2);
  function YAMLSet2() {
    var _this;
    _classCallCheck$1(this, YAMLSet2);
    _this = _super.call(this);
    _this.tag = YAMLSet2.tag;
    return _this;
  }
  _createClass$2(YAMLSet2, [{
    key: "add",
    value: function add2(key2) {
      var pair = key2 instanceof Pair$1 ? key2 : new Pair$1(key2);
      var prev2 = findPair$1(this.items, pair.key);
      if (!prev2)
        this.items.push(pair);
    }
  }, {
    key: "get",
    value: function get4(key2, keepPair) {
      var pair = findPair$1(this.items, key2);
      return !keepPair && pair instanceof Pair$1 ? pair.key instanceof Scalar$1 ? pair.key.value : pair.key : pair;
    }
  }, {
    key: "set",
    value: function set5(key2, value) {
      if (typeof value !== "boolean")
        throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof$1(value)));
      var prev2 = findPair$1(this.items, key2);
      if (prev2 && !value) {
        this.items.splice(this.items.indexOf(prev2), 1);
      } else if (!prev2 && value) {
        this.items.push(new Pair$1(key2));
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON3(_2, ctx) {
      return _get(_getPrototypeOf$1(YAMLSet2.prototype), "toJSON", this).call(this, _2, ctx, Set);
    }
  }, {
    key: "toString",
    value: function toString2(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues())
        return _get(_getPrototypeOf$1(YAMLSet2.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
  }]);
  return YAMLSet2;
}(YAMLMap$1);
_defineProperty(YAMLSet$1, "tag", "tag:yaml.org,2002:set");
function parseSet(doc, cst) {
  var map3 = resolveMap(doc, cst);
  if (!map3.hasAllNullValues())
    throw new YAMLSemanticError(cst, "Set items must all have null values");
  return Object.assign(new YAMLSet$1(), map3);
}
function createSet(schema2, iterable, ctx) {
  var set5 = new YAMLSet$1();
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var value = _step.value;
      set5.items.push(schema2.createPair(value, null, ctx));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return set5;
}
var set$5 = {
  identify: function identify3(value) {
    return value instanceof Set;
  },
  nodeClass: YAMLSet$1,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve: parseSet,
  createNode: createSet
};
var parseSexagesimal$1 = function parseSexagesimal(sign, parts) {
  var n2 = parts.split(":").reduce(function(n3, p2) {
    return n3 * 60 + Number(p2);
  }, 0);
  return sign === "-" ? -n2 : n2;
};
var stringifySexagesimal$1 = function stringifySexagesimal(_ref3) {
  var value = _ref3.value;
  if (isNaN(value) || !isFinite(value))
    return stringifyNumber$1(value);
  var sign = "";
  if (value < 0) {
    sign = "-";
    value = Math.abs(value);
  }
  var parts = [value % 60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60);
    if (value >= 60) {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value);
    }
  }
  return sign + parts.map(function(n2) {
    return n2 < 10 ? "0" + String(n2) : String(n2);
  }).join(":").replace(/000000\d*$/, "");
};
var intTime$1 = {
  identify: function identify4(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: function resolve2(str2, sign, parts) {
    return parseSexagesimal$1(sign, parts.replace(/_/g, ""));
  },
  stringify: stringifySexagesimal$1
};
var floatTime$1 = {
  identify: function identify5(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: function resolve3(str2, sign, parts) {
    return parseSexagesimal$1(sign, parts.replace(/_/g, ""));
  },
  stringify: stringifySexagesimal$1
};
var timestamp$2 = {
  identify: function identify6(value) {
    return value instanceof Date;
  },
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
  resolve: function resolve4(str2, year, month, day, hour, minute, second, millisec, tz) {
    if (millisec)
      millisec = (millisec + "00").substr(1, 3);
    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
    if (tz && tz !== "Z") {
      var d2 = parseSexagesimal$1(tz[0], tz.slice(1));
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: function stringify2(_ref22) {
    var value = _ref22.value;
    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
  }
};
function shouldWarn(deprecation) {
  var env2 = typeof process !== "undefined" && process.env || {};
  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
      return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env2.YAML_SILENCE_DEPRECATION_WARNINGS;
  }
  if (typeof YAML_SILENCE_WARNINGS !== "undefined")
    return !YAML_SILENCE_WARNINGS;
  return !env2.YAML_SILENCE_WARNINGS;
}
function warn$1(warning2, type2) {
  if (shouldWarn(false)) {
    var emit = typeof process !== "undefined" && process.emitWarning;
    if (emit)
      emit(warning2, type2);
    else {
      console.warn(type2 ? "".concat(type2, ": ").concat(warning2) : warning2);
    }
  }
}
var warned = {};
function warnOptionDeprecation(name2, alternative) {
  if (!warned[name2] && shouldWarn(true)) {
    warned[name2] = true;
    var msg = "The option '".concat(name2, "' will be removed in a future release");
    msg += alternative ? ", use '".concat(alternative, "' instead.") : ".";
    warn$1(msg, "DeprecationWarning");
  }
}
function createMap(schema2, obj, ctx) {
  var map3 = new YAMLMap$1(schema2);
  if (obj instanceof Map) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray$1(_step.value, 2), key2 = _step$value[0], value = _step$value[1];
        map3.items.push(schema2.createPair(key2, value, ctx));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (obj && _typeof$1(obj) === "object") {
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      map3.items.push(schema2.createPair(_key, obj[_key], ctx));
    }
  }
  if (typeof schema2.sortMapEntries === "function") {
    map3.items.sort(schema2.sortMapEntries);
  }
  return map3;
}
var map$2 = {
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap$1,
  tag: "tag:yaml.org,2002:map",
  resolve: resolveMap
};
function createSeq(schema2, obj, ctx) {
  var seq2 = new YAMLSeq$1(schema2);
  if (obj && obj[Symbol.iterator]) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it2 = _step.value;
        var v2 = schema2.createNode(it2, ctx.wrapScalars, null, ctx);
        seq2.items.push(v2);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return seq2;
}
var seq$2 = {
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq$1,
  tag: "tag:yaml.org,2002:seq",
  resolve: resolveSeq
};
var string$1 = {
  identify: function identify7(value) {
    return typeof value === "string";
  },
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: resolveString,
  stringify: function stringify3(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return stringifyString$1(item, ctx, onComment, onChompKeep);
  },
  options: strOptions
};
var failsafe$1 = [map$2, seq$2, string$1];
var intIdentify$2$1 = function intIdentify(value) {
  return typeof value === "bigint" || Number.isInteger(value);
};
var intResolve$1$1 = function intResolve(src, part, radix) {
  return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
};
function intStringify$1$1(node2, radix, prefix2) {
  var value = node2.value;
  if (intIdentify$2$1(value) && value >= 0)
    return prefix2 + value.toString(radix);
  return stringifyNumber$1(node2);
}
var nullObj = {
  identify: function identify8(value) {
    return value == null;
  },
  createNode: function createNode(schema2, value, ctx) {
    return ctx.wrapScalars ? new Scalar$1(null) : null;
  },
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function resolve5() {
    return null;
  },
  options: nullOptions,
  stringify: function stringify4() {
    return nullOptions.nullStr;
  }
};
var boolObj = {
  identify: function identify9(value) {
    return typeof value === "boolean";
  },
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: function resolve6(str2) {
    return str2[0] === "t" || str2[0] === "T";
  },
  options: boolOptions,
  stringify: function stringify5(_ref3) {
    var value = _ref3.value;
    return value ? boolOptions.trueStr : boolOptions.falseStr;
  }
};
var octObj = {
  identify: function identify10(value) {
    return intIdentify$2$1(value) && value >= 0;
  },
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o([0-7]+)$/,
  resolve: function resolve7(str2, oct) {
    return intResolve$1$1(str2, oct, 8);
  },
  options: intOptions,
  stringify: function stringify6(node2) {
    return intStringify$1$1(node2, 8, "0o");
  }
};
var intObj = {
  identify: intIdentify$2$1,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: function resolve8(str2) {
    return intResolve$1$1(str2, str2, 10);
  },
  options: intOptions,
  stringify: stringifyNumber$1
};
var hexObj = {
  identify: function identify11(value) {
    return intIdentify$2$1(value) && value >= 0;
  },
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: function resolve9(str2, hex2) {
    return intResolve$1$1(str2, hex2, 16);
  },
  options: intOptions,
  stringify: function stringify7(node2) {
    return intStringify$1$1(node2, 16, "0x");
  }
};
var nanObj = {
  identify: function identify12(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function resolve10(str2, nan) {
    return nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: stringifyNumber$1
};
var expObj = {
  identify: function identify13(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: function resolve11(str2) {
    return parseFloat(str2);
  },
  stringify: function stringify8(_ref22) {
    var value = _ref22.value;
    return Number(value).toExponential();
  }
};
var floatObj = {
  identify: function identify14(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
  resolve: function resolve12(str2, frac1, frac2) {
    var frac = frac1 || frac2;
    var node2 = new Scalar$1(parseFloat(str2));
    if (frac && frac[frac.length - 1] === "0")
      node2.minFractionDigits = frac.length;
    return node2;
  },
  stringify: stringifyNumber$1
};
var core$1 = failsafe$1.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
var intIdentify$1$1 = function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
};
var stringifyJSON$1 = function stringifyJSON(_ref3) {
  var value = _ref3.value;
  return JSON.stringify(value);
};
var json$2 = [map$2, seq$2, {
  identify: function identify15(value) {
    return typeof value === "string";
  },
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: resolveString,
  stringify: stringifyJSON$1
}, {
  identify: function identify16(value) {
    return value == null;
  },
  createNode: function createNode2(schema2, value, ctx) {
    return ctx.wrapScalars ? new Scalar$1(null) : null;
  },
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^null$/,
  resolve: function resolve13() {
    return null;
  },
  stringify: stringifyJSON$1
}, {
  identify: function identify17(value) {
    return typeof value === "boolean";
  },
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^true|false$/,
  resolve: function resolve14(str2) {
    return str2 === "true";
  },
  stringify: stringifyJSON$1
}, {
  identify: intIdentify$1$1,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: function resolve15(str2) {
    return intOptions.asBigInt ? BigInt(str2) : parseInt(str2, 10);
  },
  stringify: function stringify9(_ref22) {
    var value = _ref22.value;
    return intIdentify$1$1(value) ? value.toString() : JSON.stringify(value);
  }
}, {
  identify: function identify18(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: function resolve16(str2) {
    return parseFloat(str2);
  },
  stringify: stringifyJSON$1
}];
json$2.scalarFallback = function(str2) {
  throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str2)));
};
var boolStringify$1 = function boolStringify(_ref3) {
  var value = _ref3.value;
  return value ? boolOptions.trueStr : boolOptions.falseStr;
};
var intIdentify$3 = function intIdentify3(value) {
  return typeof value === "bigint" || Number.isInteger(value);
};
function intResolve$2(sign, src, radix) {
  var str2 = src.replace(/_/g, "");
  if (intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str2 = "0b".concat(str2);
        break;
      case 8:
        str2 = "0o".concat(str2);
        break;
      case 16:
        str2 = "0x".concat(str2);
        break;
    }
    var _n = BigInt(str2);
    return sign === "-" ? BigInt(-1) * _n : _n;
  }
  var n2 = parseInt(str2, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify$2(node2, radix, prefix2) {
  var value = node2.value;
  if (intIdentify$3(value)) {
    var str2 = value.toString(radix);
    return value < 0 ? "-" + prefix2 + str2.substr(1) : prefix2 + str2;
  }
  return stringifyNumber$1(node2);
}
var yaml11 = failsafe$1.concat([{
  identify: function identify19(value) {
    return value == null;
  },
  createNode: function createNode3(schema2, value, ctx) {
    return ctx.wrapScalars ? new Scalar$1(null) : null;
  },
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function resolve17() {
    return null;
  },
  options: nullOptions,
  stringify: function stringify10() {
    return nullOptions.nullStr;
  }
}, {
  identify: function identify20(value) {
    return typeof value === "boolean";
  },
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: function resolve18() {
    return true;
  },
  options: boolOptions,
  stringify: boolStringify$1
}, {
  identify: function identify21(value) {
    return typeof value === "boolean";
  },
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: function resolve19() {
    return false;
  },
  options: boolOptions,
  stringify: boolStringify$1
}, {
  identify: intIdentify$3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: function resolve20(str2, sign, bin) {
    return intResolve$2(sign, bin, 2);
  },
  stringify: function stringify11(node2) {
    return intStringify$2(node2, 2, "0b");
  }
}, {
  identify: intIdentify$3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: function resolve21(str2, sign, oct) {
    return intResolve$2(sign, oct, 8);
  },
  stringify: function stringify12(node2) {
    return intStringify$2(node2, 8, "0");
  }
}, {
  identify: intIdentify$3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: function resolve22(str2, sign, abs2) {
    return intResolve$2(sign, abs2, 10);
  },
  stringify: stringifyNumber$1
}, {
  identify: intIdentify$3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: function resolve23(str2, sign, hex2) {
    return intResolve$2(sign, hex2, 16);
  },
  stringify: function stringify13(node2) {
    return intStringify$2(node2, 16, "0x");
  }
}, {
  identify: function identify22(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function resolve24(str2, nan) {
    return nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: stringifyNumber$1
}, {
  identify: function identify23(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: function resolve25(str2) {
    return parseFloat(str2.replace(/_/g, ""));
  },
  stringify: function stringify14(_ref22) {
    var value = _ref22.value;
    return Number(value).toExponential();
  }
}, {
  identify: function identify24(value) {
    return typeof value === "number";
  },
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
  resolve: function resolve26(str2, frac) {
    var node2 = new Scalar$1(parseFloat(str2.replace(/_/g, "")));
    if (frac) {
      var f2 = frac.replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node2.minFractionDigits = f2.length;
    }
    return node2;
  },
  stringify: stringifyNumber$1
}], binary$2, omap$2, pairs$2, set$5, intTime$1, floatTime$1, timestamp$2);
var schemas$1 = {
  core: core$1,
  failsafe: failsafe$1,
  json: json$2,
  yaml11
};
var tags = {
  binary: binary$2,
  bool: boolObj,
  float: floatObj,
  floatExp: expObj,
  floatNaN: nanObj,
  floatTime: floatTime$1,
  int: intObj,
  intHex: hexObj,
  intOct: octObj,
  intTime: intTime$1,
  map: map$2,
  null: nullObj,
  omap: omap$2,
  pairs: pairs$2,
  seq: seq$2,
  set: set$5,
  timestamp: timestamp$2
};
function findTagObject$1(value, tagName, tags2) {
  if (tagName) {
    var match2 = tags2.filter(function(t2) {
      return t2.tag === tagName;
    });
    var tagObj = match2.find(function(t2) {
      return !t2.format;
    }) || match2[0];
    if (!tagObj)
      throw new Error("Tag ".concat(tagName, " not found"));
    return tagObj;
  }
  return tags2.find(function(t2) {
    return (t2.identify && t2.identify(value) || t2.class && value instanceof t2.class) && !t2.format;
  });
}
function createNode$2(value, tagName, ctx) {
  if (value instanceof Node$1)
    return value;
  var defaultPrefix = ctx.defaultPrefix, onTagObj = ctx.onTagObj, prevObjects = ctx.prevObjects, schema2 = ctx.schema, wrapScalars = ctx.wrapScalars;
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultPrefix + tagName.slice(2);
  var tagObj = findTagObject$1(value, tagName, schema2.tags);
  if (!tagObj) {
    if (typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || _typeof$1(value) !== "object")
      return wrapScalars ? new Scalar$1(value) : value;
    tagObj = value instanceof Map ? map$2 : value[Symbol.iterator] ? seq$2 : map$2;
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  var obj = {
    value: void 0,
    node: void 0
  };
  if (value && _typeof$1(value) === "object" && prevObjects) {
    var prev2 = prevObjects.get(value);
    if (prev2) {
      var alias = new Alias$1(prev2);
      ctx.aliasNodes.push(alias);
      return alias;
    }
    obj.value = value;
    prevObjects.set(value, obj);
  }
  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar$1(value) : value;
  if (tagName && obj.node instanceof Node$1)
    obj.node.tag = tagName;
  return obj.node;
}
function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
  var tags2 = schemas2[schemaId.replace(/\W/g, "")];
  if (!tags2) {
    var keys2 = Object.keys(schemas2).map(function(key2) {
      return JSON.stringify(key2);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(schemaId, '"; use one of ').concat(keys2));
  }
  if (Array.isArray(customTags)) {
    var _iterator = _createForOfIteratorHelper(customTags), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var tag = _step.value;
        tags2 = tags2.concat(tag);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  for (var i = 0; i < tags2.length; ++i) {
    var _tag = tags2[i];
    if (typeof _tag === "string") {
      var tagObj = knownTags[_tag];
      if (!tagObj) {
        var _keys = Object.keys(knownTags).map(function(key2) {
          return JSON.stringify(key2);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(_tag, '"; use one of ').concat(_keys));
      }
      tags2[i] = tagObj;
    }
  }
  return tags2;
}
var sortMapEntriesByKey$1 = function sortMapEntriesByKey(a, b2) {
  return a.key < b2.key ? -1 : a.key > b2.key ? 1 : 0;
};
var Schema$1 = /* @__PURE__ */ function() {
  function Schema2(_ref3) {
    var customTags = _ref3.customTags, merge2 = _ref3.merge, schema2 = _ref3.schema, sortMapEntries = _ref3.sortMapEntries, deprecatedCustomTags = _ref3.tags;
    _classCallCheck$1(this, Schema2);
    this.merge = !!merge2;
    this.name = schema2;
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey$1 : sortMapEntries || null;
    if (!customTags && deprecatedCustomTags)
      warnOptionDeprecation("tags", "customTags");
    this.tags = getSchemaTags(schemas$1, tags, customTags || deprecatedCustomTags, schema2);
  }
  _createClass$2(Schema2, [{
    key: "createNode",
    value: function createNode$12(value, wrapScalars, tagName, ctx) {
      var baseCtx = {
        defaultPrefix: Schema2.defaultPrefix,
        schema: this,
        wrapScalars
      };
      var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
      return createNode$2(value, tagName, createCtx);
    }
  }, {
    key: "createPair",
    value: function createPair2(key2, value, ctx) {
      if (!ctx)
        ctx = {
          wrapScalars: true
        };
      var k2 = this.createNode(key2, ctx.wrapScalars, null, ctx);
      var v2 = this.createNode(value, ctx.wrapScalars, null, ctx);
      return new Pair$1(k2, v2);
    }
  }]);
  return Schema2;
}();
_defineProperty(Schema$1, "defaultPrefix", defaultTagPrefix$1);
_defineProperty(Schema$1, "defaultTags", defaultTags);
var defaultOptions$1 = {
  anchorPrefix: "a",
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: "1.2"
};
var scalarOptions = {
  get binary() {
    return binaryOptions;
  },
  set binary(opt) {
    Object.assign(binaryOptions, opt);
  },
  get bool() {
    return boolOptions;
  },
  set bool(opt) {
    Object.assign(boolOptions, opt);
  },
  get int() {
    return intOptions;
  },
  set int(opt) {
    Object.assign(intOptions, opt);
  },
  get null() {
    return nullOptions;
  },
  set null(opt) {
    Object.assign(nullOptions, opt);
  },
  get str() {
    return strOptions;
  },
  set str(opt) {
    Object.assign(strOptions, opt);
  }
};
var documentOptions = {
  "1.0": {
    schema: "yaml-1.1",
    merge: true,
    tagPrefixes: [{
      handle: "!",
      prefix: defaultTagPrefix$1
    }, {
      handle: "!!",
      prefix: "tag:private.yaml.org,2002:"
    }]
  },
  1.1: {
    schema: "yaml-1.1",
    merge: true,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: defaultTagPrefix$1
    }]
  },
  1.2: {
    schema: "core",
    merge: false,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: defaultTagPrefix$1
    }]
  }
};
function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === "1.0") {
    var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv)
      return "!" + priv[1];
    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ""));
  }
  var p2 = doc.tagPrefixes.find(function(p3) {
    return tag.indexOf(p3.prefix) === 0;
  });
  if (!p2) {
    var dtp = doc.getDefaults().tagPrefixes;
    p2 = dtp && dtp.find(function(p3) {
      return tag.indexOf(p3.prefix) === 0;
    });
  }
  if (!p2)
    return tag[0] === "!" ? tag : "!<".concat(tag, ">");
  var suffix = tag.substr(p2.prefix.length).replace(/[!,[\]{}]/g, function(ch2) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[ch2];
  });
  return p2.handle + suffix;
}
function getTagObject$1(tags2, item) {
  if (item instanceof Alias$1)
    return Alias$1;
  if (item.tag) {
    var match2 = tags2.filter(function(t2) {
      return t2.tag === item.tag;
    });
    if (match2.length > 0)
      return match2.find(function(t2) {
        return t2.format === item.format;
      }) || match2[0];
  }
  var tagObj, obj;
  if (item instanceof Scalar$1) {
    obj = item.value;
    var _match = tags2.filter(function(t2) {
      return t2.identify && t2.identify(obj) || t2.class && obj instanceof t2.class;
    });
    tagObj = _match.find(function(t2) {
      return t2.format === item.format;
    }) || _match.find(function(t2) {
      return !t2.format;
    });
  } else {
    obj = item;
    tagObj = tags2.find(function(t2) {
      return t2.nodeClass && obj instanceof t2.nodeClass;
    });
  }
  if (!tagObj) {
    var name2 = obj && obj.constructor ? obj.constructor.name : _typeof$1(obj);
    throw new Error("Tag not resolved for ".concat(name2, " value"));
  }
  return tagObj;
}
function stringifyProps$1(node2, tagObj, _ref3) {
  var anchors = _ref3.anchors, doc = _ref3.doc;
  var props = [];
  var anchor = doc.anchors.getName(node2);
  if (anchor) {
    anchors[anchor] = node2;
    props.push("&".concat(anchor));
  }
  if (node2.tag) {
    props.push(stringifyTag(doc, node2.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }
  return props.join(" ");
}
function stringify$1$1(item, ctx, onComment, onChompKeep) {
  var _ctx$doc = ctx.doc, anchors = _ctx$doc.anchors, schema2 = _ctx$doc.schema;
  var tagObj;
  if (!(item instanceof Node$1)) {
    var createCtx = {
      aliasNodes: [],
      onTagObj: function onTagObj(o) {
        return tagObj = o;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    item = schema2.createNode(item, true, null, createCtx);
    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var alias = _step.value;
        alias.source = alias.source.node;
        var name2 = anchors.getName(alias.source);
        if (!name2) {
          name2 = anchors.newName();
          anchors.map[name2] = alias.source;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (item instanceof Pair$1)
    return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj)
    tagObj = getTagObject$1(schema2.tags, item);
  var props = stringifyProps$1(item, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  var str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar$1 ? stringifyString$1(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str2;
  return item instanceof Scalar$1 || str2[0] === "{" || str2[0] === "[" ? "".concat(props, " ").concat(str2) : "".concat(props, "\n").concat(ctx.indent).concat(str2);
}
var Anchors = /* @__PURE__ */ function() {
  function Anchors2(prefix2) {
    _classCallCheck$1(this, Anchors2);
    _defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
    this.prefix = prefix2;
  }
  _createClass$2(Anchors2, [{
    key: "createAlias",
    value: function createAlias(node2, name2) {
      this.setAnchor(node2, name2);
      return new Alias$1(node2);
    }
  }, {
    key: "createMergePair",
    value: function createMergePair() {
      var _this = this;
      var merge2 = new Merge();
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      merge2.value.items = sources.map(function(s) {
        if (s instanceof Alias$1) {
          if (s.source instanceof YAMLMap$1)
            return s;
        } else if (s instanceof YAMLMap$1) {
          return _this.createAlias(s);
        }
        throw new Error("Merge sources must be Map nodes or their Aliases");
      });
      return merge2;
    }
  }, {
    key: "getName",
    value: function getName(node2) {
      var map3 = this.map;
      return Object.keys(map3).find(function(a) {
        return map3[a] === node2;
      });
    }
  }, {
    key: "getNames",
    value: function getNames() {
      return Object.keys(this.map);
    }
  }, {
    key: "getNode",
    value: function getNode(name2) {
      return this.map[name2];
    }
  }, {
    key: "newName",
    value: function newName(prefix2) {
      if (!prefix2)
        prefix2 = this.prefix;
      var names = Object.keys(this.map);
      for (var i = 1; true; ++i) {
        var name2 = "".concat(prefix2).concat(i);
        if (!names.includes(name2))
          return name2;
      }
    }
    // During parsing, map & aliases contain CST nodes
  }, {
    key: "resolveNodes",
    value: function resolveNodes() {
      var map3 = this.map, _cstAliases = this._cstAliases;
      Object.keys(map3).forEach(function(a) {
        map3[a] = map3[a].resolved;
      });
      _cstAliases.forEach(function(a) {
        a.source = a.source.resolved;
      });
      delete this._cstAliases;
    }
  }, {
    key: "setAnchor",
    value: function setAnchor(node2, name2) {
      if (node2 != null && !Anchors2.validAnchorNode(node2)) {
        throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
      }
      if (name2 && /[\x00-\x19\s,[\]{}]/.test(name2)) {
        throw new Error("Anchor names must not contain whitespace or control characters");
      }
      var map3 = this.map;
      var prev2 = node2 && Object.keys(map3).find(function(a) {
        return map3[a] === node2;
      });
      if (prev2) {
        if (!name2) {
          return prev2;
        } else if (prev2 !== name2) {
          delete map3[prev2];
          map3[name2] = node2;
        }
      } else {
        if (!name2) {
          if (!node2)
            return null;
          name2 = this.newName();
        }
        map3[name2] = node2;
      }
      return name2;
    }
  }], [{
    key: "validAnchorNode",
    value: function validAnchorNode(node2) {
      return node2 instanceof Scalar$1 || node2 instanceof YAMLSeq$1 || node2 instanceof YAMLMap$1;
    }
  }]);
  return Anchors2;
}();
var visit$1 = function visit(node2, tags2) {
  if (node2 && _typeof$1(node2) === "object") {
    var tag = node2.tag;
    if (node2 instanceof Collection$1) {
      if (tag)
        tags2[tag] = true;
      node2.items.forEach(function(n2) {
        return visit(n2, tags2);
      });
    } else if (node2 instanceof Pair$1) {
      visit(node2.key, tags2);
      visit(node2.value, tags2);
    } else if (node2 instanceof Scalar$1) {
      if (tag)
        tags2[tag] = true;
    }
  }
  return tags2;
};
var listTagNames = function listTagNames2(node2) {
  return Object.keys(visit$1(node2, {}));
};
function parseContents(doc, contents) {
  var comments = {
    before: [],
    after: []
  };
  var body = void 0;
  var spaceBefore = false;
  var _iterator = _createForOfIteratorHelper(contents), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var node2 = _step.value;
      if (node2.valueRange) {
        if (body !== void 0) {
          var msg = "Document contains trailing content not separated by a ... or --- line";
          doc.errors.push(new YAMLSyntaxError(node2, msg));
          break;
        }
        var res = resolveNode(doc, node2);
        if (spaceBefore) {
          res.spaceBefore = true;
          spaceBefore = false;
        }
        body = res;
      } else if (node2.comment !== null) {
        var cc2 = body === void 0 ? comments.before : comments.after;
        cc2.push(node2.comment);
      } else if (node2.type === Type.BLANK_LINE) {
        spaceBefore = true;
        if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
          doc.commentBefore = comments.before.join("\n");
          comments.before = [];
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  doc.contents = body || null;
  if (!body) {
    doc.comment = comments.before.concat(comments.after).join("\n") || null;
  } else {
    var cb2 = comments.before.join("\n");
    if (cb2) {
      var cbNode = body instanceof Collection$1 && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb2, "\n").concat(cbNode.commentBefore) : cb2;
    }
    doc.comment = comments.after.join("\n") || null;
  }
}
function resolveTagDirective(_ref3, directive) {
  var tagPrefixes = _ref3.tagPrefixes;
  var _directive$parameters = _slicedToArray$1(directive.parameters, 2), handle = _directive$parameters[0], prefix2 = _directive$parameters[1];
  if (!handle || !prefix2) {
    var msg = "Insufficient parameters given for %TAG directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (tagPrefixes.some(function(p2) {
    return p2.handle === handle;
  })) {
    var _msg = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new YAMLSemanticError(directive, _msg);
  }
  return {
    handle,
    prefix: prefix2
  };
}
function resolveYamlDirective(doc, directive) {
  var _directive$parameters2 = _slicedToArray$1(directive.parameters, 1), version2 = _directive$parameters2[0];
  if (directive.name === "YAML:1.0")
    version2 = "1.0";
  if (!version2) {
    var msg = "Insufficient parameters given for %YAML directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (!documentOptions[version2]) {
    var v0 = doc.version || doc.options.version;
    var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version2);
    doc.warnings.push(new YAMLWarning(directive, _msg2));
  }
  return version2;
}
function parseDirectives(doc, directives, prevDoc) {
  var directiveComments = [];
  var hasDirectives = false;
  var _iterator = _createForOfIteratorHelper(directives), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var directive = _step.value;
      var comment2 = directive.comment, name2 = directive.name;
      switch (name2) {
        case "TAG":
          try {
            doc.tagPrefixes.push(resolveTagDirective(doc, directive));
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        case "YAML":
        case "YAML:1.0":
          if (doc.version) {
            var msg = "The %YAML directive must only be given at most once per document.";
            doc.errors.push(new YAMLSemanticError(directive, msg));
          }
          try {
            doc.version = resolveYamlDirective(doc, directive);
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        default:
          if (name2) {
            var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name2);
            doc.warnings.push(new YAMLWarning(directive, _msg3));
          }
      }
      if (comment2)
        directiveComments.push(comment2);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
    var copyTagPrefix = function copyTagPrefix2(_ref22) {
      var handle = _ref22.handle, prefix2 = _ref22.prefix;
      return {
        handle,
        prefix: prefix2
      };
    };
    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }
  doc.commentBefore = directiveComments.join("\n") || null;
}
function assertCollection$1(contents) {
  if (contents instanceof Collection$1)
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document$1 = /* @__PURE__ */ function() {
  function Document2(options2) {
    _classCallCheck$1(this, Document2);
    this.anchors = new Anchors(options2.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options2;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
  }
  _createClass$2(Document2, [{
    key: "add",
    value: function add2(value) {
      assertCollection$1(this.contents);
      return this.contents.add(value);
    }
  }, {
    key: "addIn",
    value: function addIn(path2, value) {
      assertCollection$1(this.contents);
      this.contents.addIn(path2, value);
    }
  }, {
    key: "delete",
    value: function _delete(key2) {
      assertCollection$1(this.contents);
      return this.contents.delete(key2);
    }
  }, {
    key: "deleteIn",
    value: function deleteIn(path2) {
      if (isEmptyPath$1(path2)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      assertCollection$1(this.contents);
      return this.contents.deleteIn(path2);
    }
  }, {
    key: "getDefaults",
    value: function getDefaults2() {
      return Document2.defaults[this.version] || Document2.defaults[this.options.version] || {};
    }
  }, {
    key: "get",
    value: function get4(key2, keepScalar) {
      return this.contents instanceof Collection$1 ? this.contents.get(key2, keepScalar) : void 0;
    }
  }, {
    key: "getIn",
    value: function getIn(path2, keepScalar) {
      if (isEmptyPath$1(path2))
        return !keepScalar && this.contents instanceof Scalar$1 ? this.contents.value : this.contents;
      return this.contents instanceof Collection$1 ? this.contents.getIn(path2, keepScalar) : void 0;
    }
  }, {
    key: "has",
    value: function has3(key2) {
      return this.contents instanceof Collection$1 ? this.contents.has(key2) : false;
    }
  }, {
    key: "hasIn",
    value: function hasIn(path2) {
      if (isEmptyPath$1(path2))
        return this.contents !== void 0;
      return this.contents instanceof Collection$1 ? this.contents.hasIn(path2) : false;
    }
  }, {
    key: "set",
    value: function set5(key2, value) {
      assertCollection$1(this.contents);
      this.contents.set(key2, value);
    }
  }, {
    key: "setIn",
    value: function setIn(path2, value) {
      if (isEmptyPath$1(path2))
        this.contents = value;
      else {
        assertCollection$1(this.contents);
        this.contents.setIn(path2, value);
      }
    }
  }, {
    key: "setSchema",
    value: function setSchema(id2, customTags) {
      if (!id2 && !customTags && this.schema)
        return;
      if (typeof id2 === "number")
        id2 = id2.toFixed(1);
      if (id2 === "1.0" || id2 === "1.1" || id2 === "1.2") {
        if (this.version)
          this.version = id2;
        else
          this.options.version = id2;
        delete this.options.schema;
      } else if (id2 && typeof id2 === "string") {
        this.options.schema = id2;
      }
      if (Array.isArray(customTags))
        this.options.customTags = customTags;
      var opt = Object.assign({}, this.getDefaults(), this.options);
      this.schema = new Schema$1(opt);
    }
  }, {
    key: "parse",
    value: function parse2(node2, prevDoc) {
      if (this.options.keepCstNodes)
        this.cstNode = node2;
      if (this.options.keepNodeTypes)
        this.type = "DOCUMENT";
      var _node$directives = node2.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node2.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node2.directivesEndMarker, error = node2.error, valueRange = node2.valueRange;
      if (error) {
        if (!error.source)
          error.source = this;
        this.errors.push(error);
      }
      parseDirectives(this, directives, prevDoc);
      if (directivesEndMarker)
        this.directivesEndMarker = true;
      this.range = valueRange ? [valueRange.start, valueRange.end] : null;
      this.setSchema();
      this.anchors._cstAliases = [];
      parseContents(this, contents);
      this.anchors.resolveNodes();
      if (this.options.prettyErrors) {
        var _iterator = _createForOfIteratorHelper(this.errors), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _error = _step.value;
            if (_error instanceof YAMLError)
              _error.makePretty();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper(this.warnings), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var warn2 = _step2.value;
            if (warn2 instanceof YAMLError)
              warn2.makePretty();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return this;
    }
  }, {
    key: "listNonDefaultTags",
    value: function listNonDefaultTags() {
      return listTagNames(this.contents).filter(function(t2) {
        return t2.indexOf(Schema$1.defaultPrefix) !== 0;
      });
    }
  }, {
    key: "setTagPrefix",
    value: function setTagPrefix(handle, prefix2) {
      if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
        throw new Error("Handle must start and end with !");
      if (prefix2) {
        var prev2 = this.tagPrefixes.find(function(p2) {
          return p2.handle === handle;
        });
        if (prev2)
          prev2.prefix = prefix2;
        else
          this.tagPrefixes.push({
            handle,
            prefix: prefix2
          });
      } else {
        this.tagPrefixes = this.tagPrefixes.filter(function(p2) {
          return p2.handle !== handle;
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON$1(arg, onAnchor) {
      var _this = this;
      var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
      var keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof Scalar$1));
      var ctx = {
        doc: this,
        indentStep: "  ",
        keep,
        mapAsMap: keep && !!mapAsMap,
        maxAliasCount,
        stringify: stringify$1$1
        // Requiring directly in Pair would create circular dependencies
      };
      var anchorNames2 = Object.keys(this.anchors.map);
      if (anchorNames2.length > 0)
        ctx.anchors = new Map(anchorNames2.map(function(name2) {
          return [_this.anchors.map[name2], {
            alias: [],
            aliasCount: 0,
            count: 1
          }];
        }));
      var res = toJSON(this.contents, arg, ctx);
      if (typeof onAnchor === "function" && ctx.anchors) {
        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _step3.value, count2 = _step3$value.count, _res = _step3$value.res;
            onAnchor(_res, count2);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return res;
    }
  }, {
    key: "toString",
    value: function toString2() {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      var indentSize = this.options.indent;
      if (!Number.isInteger(indentSize) || indentSize <= 0) {
        var s = JSON.stringify(indentSize);
        throw new Error('"indent" option must be a positive integer, not '.concat(s));
      }
      this.setSchema();
      var lines = [];
      var hasDirectives = false;
      if (this.version) {
        var vd2 = "%YAML 1.2";
        if (this.schema.name === "yaml-1.1") {
          if (this.version === "1.0")
            vd2 = "%YAML:1.0";
          else if (this.version === "1.1")
            vd2 = "%YAML 1.1";
        }
        lines.push(vd2);
        hasDirectives = true;
      }
      var tagNames = this.listNonDefaultTags();
      this.tagPrefixes.forEach(function(_ref3) {
        var handle = _ref3.handle, prefix2 = _ref3.prefix;
        if (tagNames.some(function(t2) {
          return t2.indexOf(prefix2) === 0;
        })) {
          lines.push("%TAG ".concat(handle, " ").concat(prefix2));
          hasDirectives = true;
        }
      });
      if (hasDirectives || this.directivesEndMarker)
        lines.push("---");
      if (this.commentBefore) {
        if (hasDirectives || !this.directivesEndMarker)
          lines.unshift("");
        lines.unshift(this.commentBefore.replace(/^/gm, "#"));
      }
      var ctx = {
        anchors: /* @__PURE__ */ Object.create(null),
        doc: this,
        indent: "",
        indentStep: " ".repeat(indentSize),
        stringify: stringify$1$1
        // Requiring directly in nodes would create circular dependencies
      };
      var chompKeep = false;
      var contentComment = null;
      if (this.contents) {
        if (this.contents instanceof Node$1) {
          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
            lines.push("");
          if (this.contents.commentBefore)
            lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
          ctx.forceBlockIndent = !!this.comment;
          contentComment = this.contents.comment;
        }
        var onChompKeep = contentComment ? null : function() {
          return chompKeep = true;
        };
        var body = stringify$1$1(this.contents, ctx, function() {
          return contentComment = null;
        }, onChompKeep);
        lines.push(addComment(body, "", contentComment));
      } else if (this.contents !== void 0) {
        lines.push(stringify$1$1(this.contents, ctx));
      }
      if (this.comment) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(this.comment.replace(/^/gm, "#"));
      }
      return lines.join("\n") + "\n";
    }
  }]);
  return Document2;
}();
_defineProperty(Document$1, "defaults", documentOptions);
function createNode$1(value) {
  var wrapScalars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var tag = arguments.length > 2 ? arguments[2] : void 0;
  if (tag === void 0 && typeof wrapScalars === "string") {
    tag = wrapScalars;
    wrapScalars = true;
  }
  var options2 = Object.assign({}, Document$1.defaults[defaultOptions$1.version], defaultOptions$1);
  var schema2 = new Schema$1(options2);
  return schema2.createNode(value, wrapScalars, tag);
}
var Document$2 = /* @__PURE__ */ function(_YAMLDocument) {
  _inherits$1(Document2, _YAMLDocument);
  var _super = _createSuper$1(Document2);
  function Document2(options2) {
    _classCallCheck$1(this, Document2);
    return _super.call(this, Object.assign({}, defaultOptions$1, options2));
  }
  return Document2;
}(Document$1);
function parseAllDocuments(src, options2) {
  var stream = [];
  var prev2;
  var _iterator = _createForOfIteratorHelper(parse$7(src)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var cstDoc = _step.value;
      var doc = new Document$2(options2);
      doc.parse(cstDoc, prev2);
      stream.push(doc);
      prev2 = doc;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return stream;
}
function parseDocument(src, options2) {
  var cst = parse$7(src);
  var doc = new Document$2(options2).parse(cst[0]);
  if (cst.length > 1) {
    var errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
  }
  return doc;
}
function parse$6(src, options2) {
  var doc = parseDocument(src, options2);
  doc.warnings.forEach(function(warning2) {
    return warn$1(warning2);
  });
  if (doc.errors.length > 0)
    throw doc.errors[0];
  return doc.toJSON();
}
function stringify$7(value, options2) {
  var doc = new Document$2(options2);
  doc.contents = value;
  return String(doc);
}
var YAML = {
  createNode: createNode$1,
  defaultOptions: defaultOptions$1,
  Document: Document$2,
  parse: parse$6,
  parseAllDocuments,
  parseCST: parse$7,
  parseDocument,
  scalarOptions,
  stringify: stringify$7
};
const dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  YAML
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
var browser$1;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1;
  hasRequiredBrowser = 1;
  browser$1 = require$$0.YAML;
  return browser$1;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeFunction(fn2) {
  try {
    return Function.toString.call(fn2).indexOf("[native code]") !== -1;
  } catch (e2) {
    return typeof fn2 === "function";
  }
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
function last() {
  var _ref3;
  return _ref3 = arguments.length - 1, _ref3 < 0 || arguments.length <= _ref3 ? void 0 : arguments[_ref3];
}
function negation(a) {
  return -a;
}
function addition(a, b2) {
  return a + b2;
}
function subtraction(a, b2) {
  return a - b2;
}
function multiplication(a, b2) {
  return a * b2;
}
function division(a, b2) {
  return a / b2;
}
function max$1() {
  return Math.max.apply(Math, arguments);
}
function min$1() {
  return Math.min.apply(Math, arguments);
}
function comma() {
  return Array.of.apply(Array, arguments);
}
var defaultSymbols = {
  symbols: {
    "*": {
      infix: {
        symbol: "*",
        f: multiplication,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "*",
      regSymbol: "\\*"
    },
    "/": {
      infix: {
        symbol: "/",
        f: division,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "/",
      regSymbol: "/"
    },
    "+": {
      infix: {
        symbol: "+",
        f: addition,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "+",
        f: last,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "+",
      regSymbol: "\\+"
    },
    "-": {
      infix: {
        symbol: "-",
        f: subtraction,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "-",
        f: negation,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "-",
      regSymbol: "-"
    },
    ",": {
      infix: {
        symbol: ",",
        f: comma,
        notation: "infix",
        precedence: 1,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: ",",
      regSymbol: ","
    },
    "(": {
      prefix: {
        symbol: "(",
        f: last,
        notation: "prefix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "(",
      regSymbol: "\\("
    },
    ")": {
      postfix: {
        symbol: ")",
        f: void 0,
        notation: "postfix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: ")",
      regSymbol: "\\)"
    },
    min: {
      func: {
        symbol: "min",
        f: min$1,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "min",
      regSymbol: "min\\b"
    },
    max: {
      func: {
        symbol: "max",
        f: max$1,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "max",
      regSymbol: "max\\b"
    }
  }
};
var defaultSymbolMap = defaultSymbols;
var PolishedError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose$1(PolishedError2, _Error);
  function PolishedError2(code) {
    var _this;
    {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    }
    return _assertThisInitialized$1(_this);
  }
  return PolishedError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var unitRegExp = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
function mergeSymbolMaps(additionalSymbols) {
  var symbolMap = {};
  symbolMap.symbols = additionalSymbols ? _extends$8({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : _extends$8({}, defaultSymbolMap.symbols);
  return symbolMap;
}
function exec(operators, values2) {
  var _ref3;
  var op = operators.pop();
  values2.push(op.f.apply(op, (_ref3 = []).concat.apply(_ref3, values2.splice(-op.argCount))));
  return op.precedence;
}
function calculate(expression, additionalSymbols) {
  var symbolMap = mergeSymbolMaps(additionalSymbols);
  var match2;
  var operators = [symbolMap.symbols["("].prefix];
  var values2 = [];
  var pattern = new RegExp(
    // Pattern for numbers
    "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
    Object.keys(symbolMap.symbols).map(function(key2) {
      return symbolMap.symbols[key2];
    }).sort(function(a, b2) {
      return b2.symbol.length - a.symbol.length;
    }).map(function(val) {
      return val.regSymbol;
    }).join("|") + "|(\\S)",
    "g"
  );
  pattern.lastIndex = 0;
  var afterValue = false;
  do {
    match2 = pattern.exec(expression);
    var _ref22 = match2 || [")", void 0], token2 = _ref22[0], bad = _ref22[1];
    var notNumber = symbolMap.symbols[token2];
    var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;
    var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;
    if (bad || (afterValue ? notAfterValue : notNewValue)) {
      throw new PolishedError(37, match2 ? match2.index : expression.length, expression);
    }
    if (afterValue) {
      var curr = notNumber.postfix || notNumber.infix;
      do {
        var prev2 = operators[operators.length - 1];
        if ((curr.precedence - prev2.precedence || prev2.rightToLeft) > 0)
          break;
      } while (exec(operators, values2));
      afterValue = curr.notation === "postfix";
      if (curr.symbol !== ")") {
        operators.push(curr);
        if (afterValue)
          exec(operators, values2);
      }
    } else if (notNumber) {
      operators.push(notNumber.prefix || notNumber.func);
      if (notNumber.func) {
        match2 = pattern.exec(expression);
        if (!match2 || match2[0] !== "(") {
          throw new PolishedError(38, match2 ? match2.index : expression.length, expression);
        }
      }
    } else {
      values2.push(+token2);
      afterValue = true;
    }
  } while (match2 && operators.length);
  if (operators.length) {
    throw new PolishedError(39, match2 ? match2.index : expression.length, expression);
  } else if (match2) {
    throw new PolishedError(40, match2 ? match2.index : expression.length, expression);
  } else {
    return values2.pop();
  }
}
function reverseString(str2) {
  return str2.split("").reverse().join("");
}
function math(formula, additionalSymbols) {
  var reversedFormula = reverseString(formula);
  var formulaMatch = reversedFormula.match(unitRegExp);
  if (formulaMatch && !formulaMatch.every(function(unit) {
    return unit === formulaMatch[0];
  })) {
    throw new PolishedError(41);
  }
  var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, ""));
  return "" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : "");
}
var cssVariableRegex = /--[\S]*/g;
function cssVar(cssVariable, defaultValue) {
  if (!cssVariable || !cssVariable.match(cssVariableRegex)) {
    throw new PolishedError(73);
  }
  var variableValue;
  if (typeof document !== "undefined" && document.documentElement !== null) {
    variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);
  }
  if (variableValue) {
    return variableValue.trim();
  } else if (defaultValue) {
    return defaultValue;
  }
  throw new PolishedError(74);
}
function capitalizeString(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var positionMap$1 = ["Top", "Right", "Bottom", "Left"];
function generateProperty(property, position2) {
  if (!property)
    return position2.toLowerCase();
  var splitProperty = property.split("-");
  if (splitProperty.length > 1) {
    splitProperty.splice(1, 0, position2);
    return splitProperty.reduce(function(acc, val) {
      return "" + acc + capitalizeString(val);
    });
  }
  var joinedProperty = property.replace(/([a-z])([A-Z])/g, "$1" + position2 + "$2");
  return property === joinedProperty ? "" + property + position2 : joinedProperty;
}
function generateStyles(property, valuesWithDefaults) {
  var styles2 = {};
  for (var i = 0; i < valuesWithDefaults.length; i += 1) {
    if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {
      styles2[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];
    }
  }
  return styles2;
}
function directionalProperty(property) {
  for (var _len = arguments.length, values2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values2[_key - 1] = arguments[_key];
  }
  var firstValue = values2[0], _values$ = values2[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values2[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values2[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;
  var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
  return generateStyles(property, valuesWithDefaults);
}
function endsWith(string2, suffix) {
  return string2.substr(-suffix.length) === suffix;
}
var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function stripUnit(value) {
  if (typeof value !== "string")
    return value;
  var matchedValue = value.match(cssRegex$1);
  return matchedValue ? parseFloat(value) : value;
}
var pxtoFactory = function pxtoFactory2(to) {
  return function(pxval, base) {
    if (base === void 0) {
      base = "16px";
    }
    var newPxval = pxval;
    var newBase = base;
    if (typeof pxval === "string") {
      if (!endsWith(pxval, "px")) {
        throw new PolishedError(69, to, pxval);
      }
      newPxval = stripUnit(pxval);
    }
    if (typeof base === "string") {
      if (!endsWith(base, "px")) {
        throw new PolishedError(70, to, base);
      }
      newBase = stripUnit(base);
    }
    if (typeof newPxval === "string") {
      throw new PolishedError(71, pxval, to);
    }
    if (typeof newBase === "string") {
      throw new PolishedError(72, base, to);
    }
    return "" + newPxval / newBase + to;
  };
};
var pixelsto = pxtoFactory;
var em = /* @__PURE__ */ pixelsto("em");
var em$1 = em;
var cssRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function getValueAndUnit(value) {
  if (typeof value !== "string")
    return [value, ""];
  var matchedValue = value.match(cssRegex);
  if (matchedValue)
    return [parseFloat(value), matchedValue[2]];
  return [value, void 0];
}
function important(styleBlock, rules2) {
  if (typeof styleBlock !== "object" || styleBlock === null) {
    throw new PolishedError(75, typeof styleBlock);
  }
  var newStyleBlock = {};
  Object.keys(styleBlock).forEach(function(key2) {
    if (typeof styleBlock[key2] === "object" && styleBlock[key2] !== null) {
      newStyleBlock[key2] = important(styleBlock[key2], rules2);
    } else if (!rules2 || rules2 && (rules2 === key2 || rules2.indexOf(key2) >= 0)) {
      newStyleBlock[key2] = styleBlock[key2] + " !important";
    } else {
      newStyleBlock[key2] = styleBlock[key2];
    }
  });
  return newStyleBlock;
}
var ratioNames = {
  minorSecond: 1.067,
  majorSecond: 1.125,
  minorThird: 1.2,
  majorThird: 1.25,
  perfectFourth: 1.333,
  augFourth: 1.414,
  perfectFifth: 1.5,
  minorSixth: 1.6,
  goldenSection: 1.618,
  majorSixth: 1.667,
  minorSeventh: 1.778,
  majorSeventh: 1.875,
  octave: 2,
  majorTenth: 2.5,
  majorEleventh: 2.667,
  majorTwelfth: 3,
  doubleOctave: 4
};
function getRatio(ratioName) {
  return ratioNames[ratioName];
}
function modularScale(steps2, base, ratio) {
  if (base === void 0) {
    base = "1em";
  }
  if (ratio === void 0) {
    ratio = 1.333;
  }
  if (typeof steps2 !== "number") {
    throw new PolishedError(42);
  }
  if (typeof ratio === "string" && !ratioNames[ratio]) {
    throw new PolishedError(43);
  }
  var _ref3 = typeof base === "string" ? getValueAndUnit(base) : [base, ""], realBase = _ref3[0], unit = _ref3[1];
  var realRatio = typeof ratio === "string" ? getRatio(ratio) : ratio;
  if (typeof realBase === "string") {
    throw new PolishedError(44, base);
  }
  return "" + realBase * Math.pow(realRatio, steps2) + (unit || "");
}
var rem = /* @__PURE__ */ pixelsto("rem");
var rem$1 = rem;
var defaultFontSize = 16;
function convertBase(base) {
  var deconstructedValue = getValueAndUnit(base);
  if (deconstructedValue[1] === "px") {
    return parseFloat(base);
  }
  if (deconstructedValue[1] === "%") {
    return parseFloat(base) / 100 * defaultFontSize;
  }
  throw new PolishedError(78, deconstructedValue[1]);
}
function getBaseFromDoc() {
  if (typeof document !== "undefined" && document.documentElement !== null) {
    var rootFontSize = getComputedStyle(document.documentElement).fontSize;
    return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;
  }
  return defaultFontSize;
}
function remToPx(value, base) {
  var deconstructedValue = getValueAndUnit(value);
  if (deconstructedValue[1] !== "rem" && deconstructedValue[1] !== "") {
    throw new PolishedError(77, deconstructedValue[1]);
  }
  var newBase = base ? convertBase(base) : getBaseFromDoc();
  return deconstructedValue[0] * newBase + "px";
}
var functionsMap$3 = {
  back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
};
function easeIn(functionName) {
  return functionsMap$3[functionName.toLowerCase().trim()];
}
var functionsMap$2 = {
  back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function easeInOut(functionName) {
  return functionsMap$2[functionName.toLowerCase().trim()];
}
var functionsMap$1 = {
  back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
};
function easeOut(functionName) {
  return functionsMap$1[functionName.toLowerCase().trim()];
}
function between(fromSize, toSize, minScreen, maxScreen) {
  if (minScreen === void 0) {
    minScreen = "320px";
  }
  if (maxScreen === void 0) {
    maxScreen = "1200px";
  }
  var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];
  var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];
  var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];
  var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];
  if (typeof unitlessMinScreen !== "number" || typeof unitlessMaxScreen !== "number" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {
    throw new PolishedError(47);
  }
  if (typeof unitlessFromSize !== "number" || typeof unitlessToSize !== "number" || fromSizeUnit !== toSizeUnit) {
    throw new PolishedError(48);
  }
  if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {
    throw new PolishedError(76);
  }
  var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);
  var base = unitlessToSize - slope * unitlessMaxScreen;
  return "calc(" + base.toFixed(2) + (fromSizeUnit || "") + " + " + (100 * slope).toFixed(2) + "vw)";
}
function clearFix(parent) {
  var _ref3;
  if (parent === void 0) {
    parent = "&";
  }
  var pseudoSelector = parent + "::after";
  return _ref3 = {}, _ref3[pseudoSelector] = {
    clear: "both",
    content: '""',
    display: "table"
  }, _ref3;
}
function cover(offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  return {
    position: "absolute",
    top: offset2,
    right: offset2,
    bottom: offset2,
    left: offset2
  };
}
function ellipsis(width, lines) {
  if (lines === void 0) {
    lines = 1;
  }
  var styles2 = {
    display: "inline-block",
    maxWidth: width || "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  return lines > 1 ? _extends$8({}, styles2, {
    WebkitBoxOrient: "vertical",
    WebkitLineClamp: lines,
    display: "-webkit-box",
    whiteSpace: "normal"
  }) : styles2;
}
function _createForOfIteratorHelperLoose$1(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function fluidRange(cssProp, minScreen, maxScreen) {
  if (minScreen === void 0) {
    minScreen = "320px";
  }
  if (maxScreen === void 0) {
    maxScreen = "1200px";
  }
  if (!Array.isArray(cssProp) && typeof cssProp !== "object" || cssProp === null) {
    throw new PolishedError(49);
  }
  if (Array.isArray(cssProp)) {
    var mediaQueries = {};
    var fallbacks = {};
    for (var _iterator = _createForOfIteratorHelperLoose$1(cssProp), _step; !(_step = _iterator()).done; ) {
      var _extends2, _extends3;
      var obj = _step.value;
      if (!obj.prop || !obj.fromSize || !obj.toSize) {
        throw new PolishedError(50);
      }
      fallbacks[obj.prop] = obj.fromSize;
      mediaQueries["@media (min-width: " + minScreen + ")"] = _extends$8({}, mediaQueries["@media (min-width: " + minScreen + ")"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));
      mediaQueries["@media (min-width: " + maxScreen + ")"] = _extends$8({}, mediaQueries["@media (min-width: " + maxScreen + ")"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));
    }
    return _extends$8({}, fallbacks, mediaQueries);
  } else {
    var _ref3, _ref22, _ref32;
    if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {
      throw new PolishedError(51);
    }
    return _ref32 = {}, _ref32[cssProp.prop] = cssProp.fromSize, _ref32["@media (min-width: " + minScreen + ")"] = (_ref3 = {}, _ref3[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref3), _ref32["@media (min-width: " + maxScreen + ")"] = (_ref22 = {}, _ref22[cssProp.prop] = cssProp.toSize, _ref22), _ref32;
  }
}
var dataURIRegex = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i;
var formatHintMap = {
  woff: "woff",
  woff2: "woff2",
  ttf: "truetype",
  otf: "opentype",
  eot: "embedded-opentype",
  svg: "svg",
  svgz: "svg"
};
function generateFormatHint(format2, formatHint) {
  if (!formatHint)
    return "";
  return ' format("' + formatHintMap[format2] + '")';
}
function isDataURI$1(fontFilePath) {
  return !!fontFilePath.replace(/\s+/g, " ").match(dataURIRegex);
}
function generateFileReferences(fontFilePath, fileFormats, formatHint) {
  if (isDataURI$1(fontFilePath)) {
    return 'url("' + fontFilePath + '")' + generateFormatHint(fileFormats[0], formatHint);
  }
  var fileFontReferences = fileFormats.map(function(format2) {
    return 'url("' + fontFilePath + "." + format2 + '")' + generateFormatHint(format2, formatHint);
  });
  return fileFontReferences.join(", ");
}
function generateLocalReferences(localFonts) {
  var localFontReferences = localFonts.map(function(font) {
    return 'local("' + font + '")';
  });
  return localFontReferences.join(", ");
}
function generateSources(fontFilePath, localFonts, fileFormats, formatHint) {
  var fontReferences = [];
  if (localFonts)
    fontReferences.push(generateLocalReferences(localFonts));
  if (fontFilePath) {
    fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));
  }
  return fontReferences.join(", ");
}
function fontFace(_ref3) {
  var fontFamily = _ref3.fontFamily, fontFilePath = _ref3.fontFilePath, fontStretch = _ref3.fontStretch, fontStyle = _ref3.fontStyle, fontVariant = _ref3.fontVariant, fontWeight = _ref3.fontWeight, _ref$fileFormats = _ref3.fileFormats, fileFormats = _ref$fileFormats === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : _ref$fileFormats, _ref$formatHint = _ref3.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref3.localFonts, localFonts = _ref$localFonts === void 0 ? [fontFamily] : _ref$localFonts, unicodeRange = _ref3.unicodeRange, fontDisplay = _ref3.fontDisplay, fontVariationSettings = _ref3.fontVariationSettings, fontFeatureSettings = _ref3.fontFeatureSettings;
  if (!fontFamily)
    throw new PolishedError(55);
  if (!fontFilePath && !localFonts) {
    throw new PolishedError(52);
  }
  if (localFonts && !Array.isArray(localFonts)) {
    throw new PolishedError(53);
  }
  if (!Array.isArray(fileFormats)) {
    throw new PolishedError(54);
  }
  var fontFaceDeclaration = {
    "@font-face": {
      fontFamily,
      src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),
      unicodeRange,
      fontStretch,
      fontStyle,
      fontVariant,
      fontWeight,
      fontDisplay,
      fontVariationSettings,
      fontFeatureSettings
    }
  };
  return JSON.parse(JSON.stringify(fontFaceDeclaration));
}
function hideText() {
  return {
    textIndent: "101%",
    overflow: "hidden",
    whiteSpace: "nowrap"
  };
}
function hideVisually() {
  return {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
}
function hiDPI(ratio) {
  if (ratio === void 0) {
    ratio = 1.3;
  }
  return "\n    @media only screen and (-webkit-min-device-pixel-ratio: " + ratio + "),\n    only screen and (min--moz-device-pixel-ratio: " + ratio + "),\n    only screen and (-o-min-device-pixel-ratio: " + ratio + "/1),\n    only screen and (min-resolution: " + Math.round(ratio * 96) + "dpi),\n    only screen and (min-resolution: " + ratio + "dppx)\n  ";
}
function constructGradientValue(literals) {
  var template2 = "";
  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    substitutions[_key - 1] = arguments[_key];
  }
  for (var i = 0; i < literals.length; i += 1) {
    template2 += literals[i];
    if (i === substitutions.length - 1 && substitutions[i]) {
      var definedValues = substitutions.filter(function(substitute) {
        return !!substitute;
      });
      if (definedValues.length > 1) {
        template2 = template2.slice(0, -1);
        template2 += ", " + substitutions[i];
      } else if (definedValues.length === 1) {
        template2 += "" + substitutions[i];
      }
    } else if (substitutions[i]) {
      template2 += substitutions[i] + " ";
    }
  }
  return template2.trim();
}
var _templateObject$1;
function linearGradient(_ref3) {
  var colorStops = _ref3.colorStops, fallback = _ref3.fallback, _ref$toDirection = _ref3.toDirection, toDirection = _ref$toDirection === void 0 ? "" : _ref$toDirection;
  if (!colorStops || colorStops.length < 2) {
    throw new PolishedError(56);
  }
  return {
    backgroundColor: fallback || colorStops[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
    backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["linear-gradient(", "", ")"])), toDirection, colorStops.join(", ").replace(/,(?=\S)/g, ", "))
  };
}
function normalize() {
  var _ref3;
  return [(_ref3 = {
    html: {
      lineHeight: "1.15",
      textSizeAdjust: "100%"
    },
    body: {
      margin: "0"
    },
    main: {
      display: "block"
    },
    h1: {
      fontSize: "2em",
      margin: "0.67em 0"
    },
    hr: {
      boxSizing: "content-box",
      height: "0",
      overflow: "visible"
    },
    pre: {
      fontFamily: "monospace, monospace",
      fontSize: "1em"
    },
    a: {
      backgroundColor: "transparent"
    },
    "abbr[title]": {
      borderBottom: "none",
      textDecoration: "underline"
    }
  }, _ref3["b,\n    strong"] = {
    fontWeight: "bolder"
  }, _ref3["code,\n    kbd,\n    samp"] = {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  }, _ref3.small = {
    fontSize: "80%"
  }, _ref3["sub,\n    sup"] = {
    fontSize: "75%",
    lineHeight: "0",
    position: "relative",
    verticalAlign: "baseline"
  }, _ref3.sub = {
    bottom: "-0.25em"
  }, _ref3.sup = {
    top: "-0.5em"
  }, _ref3.img = {
    borderStyle: "none"
  }, _ref3["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = {
    fontFamily: "inherit",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: "0"
  }, _ref3["button,\n    input"] = {
    overflow: "visible"
  }, _ref3["button,\n    select"] = {
    textTransform: "none"
  }, _ref3['button,\n    html [type="button"],\n    [type="reset"],\n    [type="submit"]'] = {
    WebkitAppearance: "button"
  }, _ref3['button::-moz-focus-inner,\n    [type="button"]::-moz-focus-inner,\n    [type="reset"]::-moz-focus-inner,\n    [type="submit"]::-moz-focus-inner'] = {
    borderStyle: "none",
    padding: "0"
  }, _ref3['button:-moz-focusring,\n    [type="button"]:-moz-focusring,\n    [type="reset"]:-moz-focusring,\n    [type="submit"]:-moz-focusring'] = {
    outline: "1px dotted ButtonText"
  }, _ref3.fieldset = {
    padding: "0.35em 0.625em 0.75em"
  }, _ref3.legend = {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: "0",
    whiteSpace: "normal"
  }, _ref3.progress = {
    verticalAlign: "baseline"
  }, _ref3.textarea = {
    overflow: "auto"
  }, _ref3['[type="checkbox"],\n    [type="radio"]'] = {
    boxSizing: "border-box",
    padding: "0"
  }, _ref3['[type="number"]::-webkit-inner-spin-button,\n    [type="number"]::-webkit-outer-spin-button'] = {
    height: "auto"
  }, _ref3['[type="search"]'] = {
    WebkitAppearance: "textfield",
    outlineOffset: "-2px"
  }, _ref3['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: "none"
  }, _ref3["::-webkit-file-upload-button"] = {
    WebkitAppearance: "button",
    font: "inherit"
  }, _ref3.details = {
    display: "block"
  }, _ref3.summary = {
    display: "list-item"
  }, _ref3.template = {
    display: "none"
  }, _ref3["[hidden]"] = {
    display: "none"
  }, _ref3), {
    "abbr[title]": {
      textDecoration: "underline dotted"
    }
  }];
}
var _templateObject$2;
function radialGradient(_ref3) {
  var colorStops = _ref3.colorStops, _ref$extent = _ref3.extent, extent = _ref$extent === void 0 ? "" : _ref$extent, fallback = _ref3.fallback, _ref$position = _ref3.position, position2 = _ref$position === void 0 ? "" : _ref$position, _ref$shape = _ref3.shape, shape = _ref$shape === void 0 ? "" : _ref$shape;
  if (!colorStops || colorStops.length < 2) {
    throw new PolishedError(57);
  }
  return {
    backgroundColor: fallback || colorStops[0].split(" ")[0],
    backgroundImage: constructGradientValue(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["radial-gradient(", "", "", "", ")"])), position2, shape, extent, colorStops.join(", "))
  };
}
function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {
  var _ref3;
  if (extension === void 0) {
    extension = "png";
  }
  if (retinaSuffix === void 0) {
    retinaSuffix = "_2x";
  }
  if (!filename) {
    throw new PolishedError(58);
  }
  var ext = extension.replace(/^\./, "");
  var rFilename = retinaFilename ? retinaFilename + "." + ext : "" + filename + retinaSuffix + "." + ext;
  return _ref3 = {
    backgroundImage: "url(" + filename + "." + ext + ")"
  }, _ref3[hiDPI()] = _extends$8({
    backgroundImage: "url(" + rFilename + ")"
  }, backgroundSize ? {
    backgroundSize
  } : {}), _ref3;
}
var functionsMap = {
  easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
  easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
  easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function getTimingFunction(functionName) {
  return functionsMap[functionName];
}
function timingFunctions(timingFunction) {
  return getTimingFunction(timingFunction);
}
var getBorderWidth = function getBorderWidth2(pointingDirection, height, width) {
  var fullWidth2 = "" + width[0] + (width[1] || "");
  var halfWidth2 = "" + width[0] / 2 + (width[1] || "");
  var fullHeight = "" + height[0] + (height[1] || "");
  var halfHeight = "" + height[0] / 2 + (height[1] || "");
  switch (pointingDirection) {
    case "top":
      return "0 " + halfWidth2 + " " + fullHeight + " " + halfWidth2;
    case "topLeft":
      return fullWidth2 + " " + fullHeight + " 0 0";
    case "left":
      return halfHeight + " " + fullWidth2 + " " + halfHeight + " 0";
    case "bottomLeft":
      return fullWidth2 + " 0 0 " + fullHeight;
    case "bottom":
      return fullHeight + " " + halfWidth2 + " 0 " + halfWidth2;
    case "bottomRight":
      return "0 0 " + fullWidth2 + " " + fullHeight;
    case "right":
      return halfHeight + " 0 " + halfHeight + " " + fullWidth2;
    case "topRight":
    default:
      return "0 " + fullWidth2 + " " + fullHeight + " 0";
  }
};
var getBorderColor = function getBorderColor2(pointingDirection, foregroundColor) {
  switch (pointingDirection) {
    case "top":
    case "bottomRight":
      return {
        borderBottomColor: foregroundColor
      };
    case "right":
    case "bottomLeft":
      return {
        borderLeftColor: foregroundColor
      };
    case "bottom":
    case "topLeft":
      return {
        borderTopColor: foregroundColor
      };
    case "left":
    case "topRight":
      return {
        borderRightColor: foregroundColor
      };
    default:
      throw new PolishedError(59);
  }
};
function triangle(_ref3) {
  var pointingDirection = _ref3.pointingDirection, height = _ref3.height, width = _ref3.width, foregroundColor = _ref3.foregroundColor, _ref$backgroundColor = _ref3.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? "transparent" : _ref$backgroundColor;
  var widthAndUnit = getValueAndUnit(width);
  var heightAndUnit = getValueAndUnit(height);
  if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {
    throw new PolishedError(60);
  }
  return _extends$8({
    width: "0",
    height: "0",
    borderColor: backgroundColor
  }, getBorderColor(pointingDirection, foregroundColor), {
    borderStyle: "solid",
    borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)
  });
}
function wordWrap(wrap2) {
  if (wrap2 === void 0) {
    wrap2 = "break-word";
  }
  var wordBreak = wrap2 === "break-word" ? "break-all" : wrap2;
  return {
    overflowWrap: wrap2,
    wordWrap: wrap2,
    wordBreak
  };
}
function colorToInt(color2) {
  return Math.round(color2 * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }
  if (saturation === 0) {
    return convert(lightness, lightness, lightness);
  }
  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}
var namedColorMap = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function nameToHex(color2) {
  if (typeof color2 !== "string")
    return color2;
  var normalizedColorName = color2.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
}
var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function parseToRgb(color2) {
  if (typeof color2 !== "string") {
    throw new PolishedError(3);
  }
  var normalizedColor = nameToHex(color2);
  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha2 = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha: alpha2
    };
  }
  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha2 = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha2
    };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
    };
  }
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }
    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);
    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }
    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
    };
  }
  throw new PolishedError(5);
}
function rgbToHsl(color2) {
  var red = color2.red / 255;
  var green = color2.green / 255;
  var blue = color2.blue / 255;
  var max2 = Math.max(red, green, blue);
  var min2 = Math.min(red, green, blue);
  var lightness = (max2 + min2) / 2;
  if (max2 === min2) {
    if (color2.alpha !== void 0) {
      return {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color2.alpha
      };
    } else {
      return {
        hue: 0,
        saturation: 0,
        lightness
      };
    }
  }
  var hue;
  var delta = max2 - min2;
  var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
  switch (max2) {
    case red:
      hue = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      hue = (blue - red) / delta + 2;
      break;
    default:
      hue = (red - green) / delta + 4;
      break;
  }
  hue *= 60;
  if (color2.alpha !== void 0) {
    return {
      hue,
      saturation,
      lightness,
      alpha: color2.alpha
    };
  }
  return {
    hue,
    saturation,
    lightness
  };
}
function parseToHsl(color2) {
  return rgbToHsl(parseToRgb(color2));
}
var reduceHexValue = function reduceHexValue2(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }
  return value;
};
var reduceHexValue$1 = reduceHexValue;
function numberToHex(value) {
  var hex2 = value.toString(16);
  return hex2.length === 1 ? "0" + hex2 : hex2;
}
function colorToHex(color2) {
  return numberToHex(Math.round(color2 * 255));
}
function convertToHex(red, green, blue) {
  return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}
function hslToHex(hue, saturation, lightness) {
  return hslToRgb(hue, saturation, lightness, convertToHex);
}
function hsl(value, saturation, lightness) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
    return hslToHex(value, saturation, lightness);
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
    return hslToHex(value.hue, value.saturation, value.lightness);
  }
  throw new PolishedError(1);
}
function hsla(value, saturation, lightness, alpha2) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha2 === "number") {
    return alpha2 >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha2 + ")";
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha2 === void 0) {
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  }
  throw new PolishedError(2);
}
function rgb(value, green, blue) {
  if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === "object" && green === void 0 && blue === void 0) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }
  throw new PolishedError(6);
}
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === "string" && typeof secondValue === "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
var isRgb = function isRgb2(color2) {
  return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
};
var isRgba = function isRgba2(color2) {
  return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && typeof color2.alpha === "number";
};
var isHsl = function isHsl2(color2) {
  return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
};
var isHsla = function isHsla2(color2) {
  return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && typeof color2.alpha === "number";
};
function toColorString(color2) {
  if (typeof color2 !== "object")
    throw new PolishedError(8);
  if (isRgba(color2))
    return rgba(color2);
  if (isRgb(color2))
    return rgb(color2);
  if (isHsla(color2))
    return hsla(color2);
  if (isHsl(color2))
    return hsl(color2);
  throw new PolishedError(8);
}
function curried(f2, length2, acc) {
  return function fn2() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length2 ? f2.apply(this, combined) : curried(f2, length2, combined);
  };
}
function curry(f2) {
  return curried(f2, f2.length, []);
}
function adjustHue(degree, color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    hue: hslColor.hue + parseFloat(degree)
  }));
}
var curriedAdjustHue = /* @__PURE__ */ curry(adjustHue);
var curriedAdjustHue$1 = curriedAdjustHue;
function complement(color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    hue: (hslColor.hue + 180) % 360
  }));
}
function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function darken(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
  }));
}
var curriedDarken = /* @__PURE__ */ curry(darken);
var curriedDarken$1 = curriedDarken;
function desaturate(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
  }));
}
var curriedDesaturate = /* @__PURE__ */ curry(desaturate);
var curriedDesaturate$1 = curriedDesaturate;
function getLuminance(color2) {
  if (color2 === "transparent")
    return 0;
  var rgbColor = parseToRgb(color2);
  var _Object$keys$map = Object.keys(rgbColor).map(function(key2) {
    var channel = rgbColor[key2] / 255;
    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
  }), r2 = _Object$keys$map[0], g2 = _Object$keys$map[1], b2 = _Object$keys$map[2];
  return parseFloat((0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2).toFixed(3));
}
function getContrast(color1, color2) {
  var luminance1 = getLuminance(color1);
  var luminance2 = getLuminance(color2);
  return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));
}
function grayscale(color2) {
  if (color2 === "transparent")
    return color2;
  return toColorString(_extends$8({}, parseToHsl(color2), {
    saturation: 0
  }));
}
function hslToColorString(color2) {
  if (typeof color2 === "object" && typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number") {
    if (color2.alpha && typeof color2.alpha === "number") {
      return hsla({
        hue: color2.hue,
        saturation: color2.saturation,
        lightness: color2.lightness,
        alpha: color2.alpha
      });
    }
    return hsl({
      hue: color2.hue,
      saturation: color2.saturation,
      lightness: color2.lightness
    });
  }
  throw new PolishedError(45);
}
function invert(color2) {
  if (color2 === "transparent")
    return color2;
  var value = parseToRgb(color2);
  return toColorString(_extends$8({}, value, {
    red: 255 - value.red,
    green: 255 - value.green,
    blue: 255 - value.blue
  }));
}
function lighten(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
  }));
}
var curriedLighten = /* @__PURE__ */ curry(lighten);
var curriedLighten$1 = curriedLighten;
function meetsContrastGuidelines(color1, color2) {
  var contrastRatio = getContrast(color1, color2);
  return {
    AA: contrastRatio >= 4.5,
    AALarge: contrastRatio >= 3,
    AAA: contrastRatio >= 7,
    AAALarge: contrastRatio >= 4.5
  };
}
function mix(weight, color2, otherColor) {
  if (color2 === "transparent")
    return otherColor;
  if (otherColor === "transparent")
    return color2;
  if (weight === 0)
    return otherColor;
  var parsedColor1 = parseToRgb(color2);
  var color1 = _extends$8({}, parsedColor1, {
    alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
  });
  var parsedColor2 = parseToRgb(otherColor);
  var color22 = _extends$8({}, parsedColor2, {
    alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
  });
  var alphaDelta = color1.alpha - color22.alpha;
  var x2 = parseFloat(weight) * 2 - 1;
  var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
  var z2 = 1 + x2 * alphaDelta;
  var weight1 = (y2 / z2 + 1) / 2;
  var weight2 = 1 - weight1;
  var mixedColor = {
    red: Math.floor(color1.red * weight1 + color22.red * weight2),
    green: Math.floor(color1.green * weight1 + color22.green * weight2),
    blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
    alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
  };
  return rgba(mixedColor);
}
var curriedMix = /* @__PURE__ */ curry(mix);
var mix$1 = curriedMix;
function opacify(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var parsedColor = parseToRgb(color2);
  var alpha2 = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends$8({}, parsedColor, {
    alpha: guard(0, 1, (alpha2 * 100 + parseFloat(amount) * 100) / 100)
  });
  return rgba(colorWithAlpha);
}
var curriedOpacify = /* @__PURE__ */ curry(opacify);
var curriedOpacify$1 = curriedOpacify;
var defaultReturnIfLightColor = "#000";
var defaultReturnIfDarkColor = "#fff";
function readableColor(color2, returnIfLightColor, returnIfDarkColor, strict) {
  if (returnIfLightColor === void 0) {
    returnIfLightColor = defaultReturnIfLightColor;
  }
  if (returnIfDarkColor === void 0) {
    returnIfDarkColor = defaultReturnIfDarkColor;
  }
  if (strict === void 0) {
    strict = true;
  }
  var isColorLight = getLuminance(color2) > 0.179;
  var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;
  if (!strict || getContrast(color2, preferredReturnColor) >= 4.5) {
    return preferredReturnColor;
  }
  return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;
}
function rgbToColorString(color2) {
  if (typeof color2 === "object" && typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number") {
    if (typeof color2.alpha === "number") {
      return rgba({
        red: color2.red,
        green: color2.green,
        blue: color2.blue,
        alpha: color2.alpha
      });
    }
    return rgb({
      red: color2.red,
      green: color2.green,
      blue: color2.blue
    });
  }
  throw new PolishedError(46);
}
function saturate(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var hslColor = parseToHsl(color2);
  return toColorString(_extends$8({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
  }));
}
var curriedSaturate = /* @__PURE__ */ curry(saturate);
var curriedSaturate$1 = curriedSaturate;
function setHue(hue, color2) {
  if (color2 === "transparent")
    return color2;
  return toColorString(_extends$8({}, parseToHsl(color2), {
    hue: parseFloat(hue)
  }));
}
var curriedSetHue = /* @__PURE__ */ curry(setHue);
var curriedSetHue$1 = curriedSetHue;
function setLightness(lightness, color2) {
  if (color2 === "transparent")
    return color2;
  return toColorString(_extends$8({}, parseToHsl(color2), {
    lightness: parseFloat(lightness)
  }));
}
var curriedSetLightness = /* @__PURE__ */ curry(setLightness);
var curriedSetLightness$1 = curriedSetLightness;
function setSaturation(saturation, color2) {
  if (color2 === "transparent")
    return color2;
  return toColorString(_extends$8({}, parseToHsl(color2), {
    saturation: parseFloat(saturation)
  }));
}
var curriedSetSaturation = /* @__PURE__ */ curry(setSaturation);
var curriedSetSaturation$1 = curriedSetSaturation;
function shade(percentage, color2) {
  if (color2 === "transparent")
    return color2;
  return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
}
var curriedShade = /* @__PURE__ */ curry(shade);
var curriedShade$1 = curriedShade;
function tint(percentage, color2) {
  if (color2 === "transparent")
    return color2;
  return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
}
var curriedTint = /* @__PURE__ */ curry(tint);
var curriedTint$1 = curriedTint;
function transparentize(amount, color2) {
  if (color2 === "transparent")
    return color2;
  var parsedColor = parseToRgb(color2);
  var alpha2 = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends$8({}, parsedColor, {
    alpha: guard(0, 1, +(alpha2 * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });
  return rgba(colorWithAlpha);
}
var curriedTransparentize = /* @__PURE__ */ curry(transparentize);
var curriedTransparentize$1 = curriedTransparentize;
function animation() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var multiMode = Array.isArray(args[0]);
  if (!multiMode && args.length > 8) {
    throw new PolishedError(64);
  }
  var code = args.map(function(arg) {
    if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {
      throw new PolishedError(65);
    }
    if (Array.isArray(arg) && arg.length > 8) {
      throw new PolishedError(66);
    }
    return Array.isArray(arg) ? arg.join(" ") : arg;
  }).join(", ");
  return {
    animation: code
  };
}
function backgroundImages() {
  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
    properties[_key] = arguments[_key];
  }
  return {
    backgroundImage: properties.join(", ")
  };
}
function backgrounds() {
  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
    properties[_key] = arguments[_key];
  }
  return {
    background: properties.join(", ")
  };
}
var sideMap = ["top", "right", "bottom", "left"];
function border(sideKeyword) {
  for (var _len = arguments.length, values2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values2[_key - 1] = arguments[_key];
  }
  if (typeof sideKeyword === "string" && sideMap.indexOf(sideKeyword) >= 0) {
    var _ref3;
    return _ref3 = {}, _ref3["border" + capitalizeString(sideKeyword) + "Width"] = values2[0], _ref3["border" + capitalizeString(sideKeyword) + "Style"] = values2[1], _ref3["border" + capitalizeString(sideKeyword) + "Color"] = values2[2], _ref3;
  } else {
    values2.unshift(sideKeyword);
    return {
      borderWidth: values2[0],
      borderStyle: values2[1],
      borderColor: values2[2]
    };
  }
}
function borderColor() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderColor"].concat(values2));
}
function borderRadius$1(side, radius) {
  var uppercaseSide = capitalizeString(side);
  if (!radius && radius !== 0) {
    throw new PolishedError(62);
  }
  if (uppercaseSide === "Top" || uppercaseSide === "Bottom") {
    var _ref3;
    return _ref3 = {}, _ref3["border" + uppercaseSide + "RightRadius"] = radius, _ref3["border" + uppercaseSide + "LeftRadius"] = radius, _ref3;
  }
  if (uppercaseSide === "Left" || uppercaseSide === "Right") {
    var _ref22;
    return _ref22 = {}, _ref22["borderTop" + uppercaseSide + "Radius"] = radius, _ref22["borderBottom" + uppercaseSide + "Radius"] = radius, _ref22;
  }
  throw new PolishedError(63);
}
function borderStyle() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderStyle"].concat(values2));
}
function borderWidth() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["borderWidth"].concat(values2));
}
function generateSelectors(template2, state2) {
  var stateSuffix = state2 ? ":" + state2 : "";
  return template2(stateSuffix);
}
function statefulSelectors(states, template2, stateMap2) {
  if (!template2)
    throw new PolishedError(67);
  if (states.length === 0)
    return generateSelectors(template2, null);
  var selectors = [];
  for (var i = 0; i < states.length; i += 1) {
    if (stateMap2 && stateMap2.indexOf(states[i]) < 0) {
      throw new PolishedError(68);
    }
    selectors.push(generateSelectors(template2, states[i]));
  }
  selectors = selectors.join(",");
  return selectors;
}
var stateMap$1 = [void 0, null, "active", "focus", "hover"];
function template$1(state2) {
  return "button" + state2 + ',\n  input[type="button"]' + state2 + ',\n  input[type="reset"]' + state2 + ',\n  input[type="submit"]' + state2;
}
function buttons() {
  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
    states[_key] = arguments[_key];
  }
  return statefulSelectors(states, template$1, stateMap$1);
}
function margin() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["margin"].concat(values2));
}
function padding() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  return directionalProperty.apply(void 0, ["padding"].concat(values2));
}
var positionMap = ["absolute", "fixed", "relative", "static", "sticky"];
function position$1(firstValue) {
  for (var _len = arguments.length, values2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values2[_key - 1] = arguments[_key];
  }
  if (positionMap.indexOf(firstValue) >= 0 && firstValue) {
    return _extends$8({}, directionalProperty.apply(void 0, [""].concat(values2)), {
      position: firstValue
    });
  } else {
    return directionalProperty.apply(void 0, ["", firstValue].concat(values2));
  }
}
function size$1(height, width) {
  if (width === void 0) {
    width = height;
  }
  return {
    height,
    width
  };
}
var stateMap = [void 0, null, "active", "focus", "hover"];
function template(state2) {
  return 'input[type="color"]' + state2 + ',\n    input[type="date"]' + state2 + ',\n    input[type="datetime"]' + state2 + ',\n    input[type="datetime-local"]' + state2 + ',\n    input[type="email"]' + state2 + ',\n    input[type="month"]' + state2 + ',\n    input[type="number"]' + state2 + ',\n    input[type="password"]' + state2 + ',\n    input[type="search"]' + state2 + ',\n    input[type="tel"]' + state2 + ',\n    input[type="text"]' + state2 + ',\n    input[type="time"]' + state2 + ',\n    input[type="url"]' + state2 + ',\n    input[type="week"]' + state2 + ",\n    input:not([type])" + state2 + ",\n    textarea" + state2;
}
function textInputs() {
  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
    states[_key] = arguments[_key];
  }
  return statefulSelectors(states, template, stateMap);
}
function transitions() {
  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
    properties[_key] = arguments[_key];
  }
  if (Array.isArray(properties[0]) && properties.length === 2) {
    var value = properties[1];
    if (typeof value !== "string") {
      throw new PolishedError(61);
    }
    var transitionsString = properties[0].map(function(property) {
      return property + " " + value;
    }).join(", ");
    return {
      transition: transitionsString
    };
  } else {
    return {
      transition: properties.join(", ")
    };
  }
}
const polished_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustHue: curriedAdjustHue$1,
  animation,
  backgroundImages,
  backgrounds,
  between,
  border,
  borderColor,
  borderRadius: borderRadius$1,
  borderStyle,
  borderWidth,
  buttons,
  clearFix,
  complement,
  cover,
  cssVar,
  darken: curriedDarken$1,
  desaturate: curriedDesaturate$1,
  directionalProperty,
  easeIn,
  easeInOut,
  easeOut,
  ellipsis,
  em: em$1,
  fluidRange,
  fontFace,
  getContrast,
  getLuminance,
  getValueAndUnit,
  grayscale,
  hiDPI,
  hideText,
  hideVisually,
  hsl,
  hslToColorString,
  hsla,
  important,
  invert,
  lighten: curriedLighten$1,
  linearGradient,
  margin,
  math,
  meetsContrastGuidelines,
  mix: mix$1,
  modularScale,
  normalize,
  opacify: curriedOpacify$1,
  padding,
  parseToHsl,
  parseToRgb,
  position: position$1,
  radialGradient,
  readableColor,
  rem: rem$1,
  remToPx,
  retinaImage,
  rgb,
  rgbToColorString,
  rgba,
  saturate: curriedSaturate$1,
  setHue: curriedSetHue$1,
  setLightness: curriedSetLightness$1,
  setSaturation: curriedSetSaturation$1,
  shade: curriedShade$1,
  size: size$1,
  stripUnit,
  textInputs,
  timingFunctions,
  tint: curriedTint$1,
  toColorString,
  transitions,
  transparentize: curriedTransparentize$1,
  triangle,
  wordWrap
}, Symbol.toStringTag, { value: "Module" }));
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(polished_esm);
var slugify = { exports: {} };
var hasRequiredSlugify;
function requireSlugify() {
  if (hasRequiredSlugify)
    return slugify.exports;
  hasRequiredSlugify = 1;
  (function(module, exports) {
    (function(name2, root, factory2) {
      {
        module.exports = factory2();
        module.exports["default"] = factory2();
      }
    })("slugify", commonjsGlobal, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"'","":"'","":"\\"","":"\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial"}`);
      var locales2 = JSON.parse('{"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"vi":{"":"D","":"d"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"}}');
      function replace3(string2, options2) {
        if (typeof string2 !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options2 = typeof options2 === "string" ? { replacement: options2 } : options2 || {};
        var locale = locales2[options2.locale] || {};
        var replacement = options2.replacement === void 0 ? "-" : options2.replacement;
        var slug = string2.split("").reduce(function(result, ch2) {
          return result + (locale[ch2] || charMap[ch2] || ch2).replace(options2.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "").trim().replace(new RegExp("[\\s" + replacement + "]+", "g"), replacement);
        if (options2.lower) {
          slug = slug.toLowerCase();
        }
        if (options2.strict) {
          slug = slug.replace(new RegExp("[^a-zA-Z0-9" + replacement + "]", "g"), "").replace(new RegExp("[\\s" + replacement + "]+", "g"), replacement);
        }
        return slug;
      }
      replace3.extend = function(customMap) {
        for (var key2 in customMap) {
          charMap[key2] = customMap[key2];
        }
      };
      return replace3;
    });
  })(slugify);
  return slugify.exports;
}
var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    var valueA = objA[key2];
    var valueB = objB[key2];
    ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
};
const p = /* @__PURE__ */ getDefaultExportFromCjs(shallowequal);
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
function filter(array2, pattern) {
  return array2.filter(function(value) {
    return !match(value, pattern);
  });
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type2, props, children, length2, siblings) {
  return { value, root, parent, type: type2, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign$1(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token$1(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim$1(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token$1(type2) > 2 || token$1(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token$1(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse$5("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$5(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules2;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index2, offset2, rules2, points, type2, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$5(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$5(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules2, points, type2, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$5(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules2, points, type2, props, children, length2, siblings) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules2 : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset2 === 0 ? RULESET : type2, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/))
        return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span") ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span") ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a, b2, c2, d2, e2, f2) {
        return MS + a + ":" + b2 + f2 + (c2 ? MS + a + "-span:" + (d2 ? e2 : +e2 - +b2) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
function serialize$1(children, callback) {
  var output = "";
  for (var i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$6(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize$1([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign$1(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign$1(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}
var f = "undefined" != typeof process && void 0 !== process.env && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", m = "6.1.0", y = "undefined" != typeof window && "HTMLElement" in window, v = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.REACT_APP_SC_DISABLE_SPEEDY && "" !== {}.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {}.REACT_APP_SC_DISABLE_SPEEDY && {}.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.SC_DISABLE_SPEEDY && "" !== {}.SC_DISABLE_SPEEDY ? "false" !== {}.SC_DISABLE_SPEEDY && {}.SC_DISABLE_SPEEDY : false), g = {}, E = Object.freeze([]), N = Object.freeze({});
function P(e2, t2, n2) {
  return void 0 === n2 && (n2 = N), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
}
var _ = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), C = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, I = /(^-|-$)/g;
function A(e2) {
  return e2.replace(C, "-").replace(I, "");
}
var O = /(a)(d)/gi, D = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function R(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = D(t2 % 52) + n2;
  return (D(t2 % 52) + n2).replace(O, "$1-$2");
}
var T, k = function(e2, t2) {
  for (var n2 = t2.length; n2; )
    e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
}, j$1 = function(e2) {
  return k(5381, e2);
};
function x(e2) {
  return R(j$1(e2) >>> 0);
}
function V(e2) {
  return e2.displayName || e2.name || "Component";
}
function F(e2) {
  return "string" == typeof e2 && true;
}
var M = "function" == typeof Symbol && Symbol.for, $ = M ? Symbol.for("react.memo") : 60115, z = M ? Symbol.for("react.forward_ref") : 60112, B = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, L = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, G = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Y = ((T = {})[z] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, T[$] = G, T);
function W(e2) {
  return ("type" in (t2 = e2) && t2.type.$$typeof) === $ ? G : "$$typeof" in e2 ? Y[e2.$$typeof] : B;
  var t2;
}
var q = Object.defineProperty, H = Object.getOwnPropertyNames, U = Object.getOwnPropertySymbols, J = Object.getOwnPropertyDescriptor, X = Object.getPrototypeOf, Z = Object.prototype;
function K(e2, t2, n2) {
  if ("string" != typeof t2) {
    if (Z) {
      var o = X(t2);
      o && o !== Z && K(e2, o, n2);
    }
    var r2 = H(t2);
    U && (r2 = r2.concat(U(t2)));
    for (var s = W(e2), i = W(t2), a = 0; a < r2.length; ++a) {
      var c2 = r2[a];
      if (!(c2 in L || n2 && n2[c2] || i && c2 in i || s && c2 in s)) {
        var l2 = J(t2, c2);
        try {
          q(e2, c2, l2);
        } catch (e3) {
        }
      }
    }
  }
  return e2;
}
function Q(e2) {
  return "function" == typeof e2;
}
function ee(e2) {
  return "object" == typeof e2 && "styledComponentId" in e2;
}
function te(e2, t2) {
  return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
}
function ne(e2, t2) {
  if (0 === e2.length)
    return "";
  for (var n2 = e2[0], o = 1; o < e2.length; o++)
    n2 += t2 ? t2 + e2[o] : e2[o];
  return n2;
}
function oe(e2) {
  return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function re(e2, t2, n2) {
  if (void 0 === n2 && (n2 = false), !n2 && !oe(e2) && !Array.isArray(e2))
    return t2;
  if (Array.isArray(t2))
    for (var o = 0; o < t2.length; o++)
      e2[o] = re(e2[o], t2[o]);
  else if (oe(t2))
    for (var o in t2)
      e2[o] = re(e2[o], t2[o]);
  return e2;
}
function se(e2, t2) {
  Object.defineProperty(e2, "toString", { value: t2 });
}
function ce(t2) {
  for (var n2 = [], o = 1; o < arguments.length; o++)
    n2[o - 1] = arguments[o];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : ""));
}
var le = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  return e2.prototype.indexOfGroup = function(e3) {
    for (var t2 = 0, n2 = 0; n2 < e3; n2++)
      t2 += this.groupSizes[n2];
    return t2;
  }, e2.prototype.insertRules = function(e3, t2) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, o = n2.length, r2 = o; e3 >= r2; )
        if ((r2 <<= 1) < 0)
          throw ce(16, "".concat(e3));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n2), this.length = r2;
      for (var s = o; s < r2; s++)
        this.groupSizes[s] = 0;
    }
    for (var i = this.indexOfGroup(e3 + 1), a = (s = 0, t2.length); s < a; s++)
      this.tag.insertRule(i, t2[s]) && (this.groupSizes[e3]++, i++);
  }, e2.prototype.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t2 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), o = n2 + t2;
      this.groupSizes[e3] = 0;
      for (var r2 = n2; r2 < o; r2++)
        this.tag.deleteRule(n2);
    }
  }, e2.prototype.getGroup = function(e3) {
    var t2 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3])
      return t2;
    for (var n2 = this.groupSizes[e3], o = this.indexOfGroup(e3), r2 = o + n2, s = o; s < r2; s++)
      t2 += "".concat(this.tag.getRule(s)).concat("/*!sc*/\n");
    return t2;
  }, e2;
}(), ue = /* @__PURE__ */ new Map(), pe = /* @__PURE__ */ new Map(), de = 1, he = function(e2) {
  if (ue.has(e2))
    return ue.get(e2);
  for (; pe.has(de); )
    de++;
  var t2 = de++;
  return ue.set(e2, t2), pe.set(t2, e2), t2;
}, fe = function(e2, t2) {
  ue.set(e2, t2), pe.set(t2, e2);
}, me = "style[".concat(f, "][").concat("data-styled-version", '="').concat("6.1.0", '"]'), ye = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), ve = function(e2, t2, n2) {
  for (var o, r2 = n2.split(","), s = 0, i = r2.length; s < i; s++)
    (o = r2[s]) && e2.registerName(t2, o);
}, ge = function(e2, t2) {
  for (var n2, o = (null !== (n2 = t2.textContent) && void 0 !== n2 ? n2 : "").split("/*!sc*/\n"), r2 = [], s = 0, i = o.length; s < i; s++) {
    var a = o[s].trim();
    if (a) {
      var c2 = a.match(ye);
      if (c2) {
        var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
        0 !== l2 && (fe(u2, l2), ve(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
      } else
        r2.push(a);
    }
  }
};
function Se() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var we = function(e2) {
  var t2 = document.head, n2 = e2 || t2, o = document.createElement("style"), r2 = function(e3) {
    var t3 = Array.from(e3.querySelectorAll("style[".concat(f, "]")));
    return t3[t3.length - 1];
  }(n2), s = void 0 !== r2 ? r2.nextSibling : null;
  o.setAttribute(f, "active"), o.setAttribute("data-styled-version", "6.1.0");
  var i = Se();
  return i && o.setAttribute("nonce", i), n2.insertBefore(o, s), o;
}, be = function() {
  function e2(e3) {
    this.element = we(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet)
        return e4.sheet;
      for (var t2 = document.styleSheets, n2 = 0, o = t2.length; n2 < o; n2++) {
        var r2 = t2[n2];
        if (r2.ownerNode === e4)
          return r2;
      }
      throw ce(17);
    }(this.element), this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    try {
      return this.sheet.insertRule(t2, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, e2.prototype.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, e2.prototype.getRule = function(e3) {
    var t2 = this.sheet.cssRules[e3];
    return t2 && t2.cssText ? t2.cssText : "";
  }, e2;
}(), Ee = function() {
  function e2(e3) {
    this.element = we(e3), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t2);
      return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
    }
    return false;
  }, e2.prototype.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}(), Ne = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t2), this.length++, true);
  }, e2.prototype.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}(), Pe = y, _e = { isServer: !y, useCSSOMInjection: !v }, Ce = function() {
  function e2(e3, n2, o) {
    void 0 === e3 && (e3 = N), void 0 === n2 && (n2 = {});
    var r2 = this;
    this.options = __assign(__assign({}, _e), e3), this.gs = n2, this.names = new Map(o), this.server = !!e3.isServer, !this.server && y && Pe && (Pe = false, function(e4) {
      for (var t2 = document.querySelectorAll(me), n3 = 0, o2 = t2.length; n3 < o2; n3++) {
        var r3 = t2[n3];
        r3 && "active" !== r3.getAttribute(f) && (ge(e4, r3), r3.parentNode && r3.parentNode.removeChild(r3));
      }
    }(this)), se(this, function() {
      return function(e4) {
        for (var t2 = e4.getTag(), n3 = t2.length, o2 = "", r3 = function(n4) {
          var r4 = function(e5) {
            return pe.get(e5);
          }(n4);
          if (void 0 === r4)
            return "continue";
          var s2 = e4.names.get(r4), i = t2.getGroup(n4);
          if (void 0 === s2 || 0 === i.length)
            return "continue";
          var a = "".concat(f, ".g").concat(n4, '[id="').concat(r4, '"]'), c2 = "";
          void 0 !== s2 && s2.forEach(function(e5) {
            e5.length > 0 && (c2 += "".concat(e5, ","));
          }), o2 += "".concat(i).concat(a, '{content:"').concat(c2, '"}').concat("/*!sc*/\n");
        }, s = 0; s < n3; s++)
          r3(s);
        return o2;
      }(r2);
    });
  }
  return e2.registerId = function(e3) {
    return he(e3);
  }, e2.prototype.reconstructWithOptions = function(n2, o) {
    return void 0 === o && (o = true), new e2(__assign(__assign({}, this.options), n2), this.gs, o && this.names || void 0);
  }, e2.prototype.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, e2.prototype.getTag = function() {
    return this.tag || (this.tag = (e3 = function(e4) {
      var t2 = e4.useCSSOMInjection, n2 = e4.target;
      return e4.isServer ? new Ne(n2) : t2 ? new be(n2) : new Ee(n2);
    }(this.options), new le(e3)));
    var e3;
  }, e2.prototype.hasNameForId = function(e3, t2) {
    return this.names.has(e3) && this.names.get(e3).has(t2);
  }, e2.prototype.registerName = function(e3, t2) {
    if (he(e3), this.names.has(e3))
      this.names.get(e3).add(t2);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t2), this.names.set(e3, n2);
    }
  }, e2.prototype.insertRules = function(e3, t2, n2) {
    this.registerName(e3, t2), this.getTag().insertRules(he(e3), n2);
  }, e2.prototype.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, e2.prototype.clearRules = function(e3) {
    this.getTag().clearGroup(he(e3)), this.clearNames(e3);
  }, e2.prototype.clearTag = function() {
    this.tag = void 0;
  }, e2;
}(), Ie = /&/g, Ae = /^\s*\/\/.*$/gm;
function Oe(e2, t2) {
  return e2.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t2, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t2, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t2, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Oe(e3.children, t2)), e3;
  });
}
function De(e2) {
  var t2, n2, o, r2 = void 0 === e2 ? N : e2, s = r2.options, i = void 0 === s ? N : s, a = r2.plugins, c2 = void 0 === a ? E : a, l2 = function(e3, o2, r3) {
    return r3 === n2 || r3.startsWith(n2) && r3.endsWith(n2) && r3.replaceAll(n2, "").length > 0 ? ".".concat(t2) : e3;
  }, u2 = c2.slice();
  u2.push(function(e3) {
    e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(Ie, n2).replace(o, l2));
  }), i.prefix && u2.push(prefixer2), u2.push(stringify$6);
  var p2 = function(e3, r3, s2, a2) {
    void 0 === r3 && (r3 = ""), void 0 === s2 && (s2 = ""), void 0 === a2 && (a2 = "&"), t2 = a2, n2 = r3, o = new RegExp("\\".concat(n2, "\\b"), "g");
    var c3 = e3.replace(Ae, ""), l3 = compile(s2 || r3 ? "".concat(s2, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i.namespace && (l3 = Oe(l3, i.namespace));
    var p3 = [];
    return serialize$1(l3, middleware(u2.concat(rulesheet(function(e4) {
      return p3.push(e4);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e3, t3) {
    return t3.name || ce(15), k(e3, t3.name);
  }, 5381).toString() : "", p2;
}
var Re = new Ce(), Te = De(), ke = React.createContext({ shouldForwardProp: void 0, styleSheet: Re, stylis: Te }), je = ke.Consumer, xe = React.createContext(void 0);
function Ve() {
  return reactExports.useContext(ke);
}
function Fe(e2) {
  var t2 = reactExports.useState(e2.stylisPlugins), n2 = t2[0], r2 = t2[1], c2 = Ve().styleSheet, l2 = reactExports.useMemo(function() {
    var t3 = c2;
    return e2.sheet ? t3 = e2.sheet : e2.target && (t3 = t3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target, c2]), u2 = reactExports.useMemo(function() {
    return De({ options: { namespace: e2.namespace, prefix: e2.enableVendorPrefixes }, plugins: n2 });
  }, [e2.enableVendorPrefixes, e2.namespace, n2]);
  reactExports.useEffect(function() {
    p(n2, e2.stylisPlugins) || r2(e2.stylisPlugins);
  }, [e2.stylisPlugins]);
  var d2 = reactExports.useMemo(function() {
    return { shouldForwardProp: e2.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e2.shouldForwardProp, l2, u2]);
  return React.createElement(ke.Provider, { value: d2 }, React.createElement(xe.Provider, { value: u2 }, e2.children));
}
var Me = function() {
  function e2(e3, t2) {
    var n2 = this;
    this.inject = function(e4, t3) {
      void 0 === t3 && (t3 = Te);
      var o = n2.name + t3.hash;
      e4.hasNameForId(n2.id, o) || e4.insertRules(n2.id, o, t3(n2.rules, o, "@keyframes"));
    }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t2, se(this, function() {
      throw ce(12, String(n2.name));
    });
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = Te), this.name + e3.hash;
  }, e2;
}(), $e = function(e2) {
  return e2 >= "A" && e2 <= "Z";
};
function ze(e2) {
  for (var t2 = "", n2 = 0; n2 < e2.length; n2++) {
    var o = e2[n2];
    if (1 === n2 && "-" === o && "-" === e2[0])
      return e2;
    $e(o) ? t2 += "-" + o.toLowerCase() : t2 += o;
  }
  return t2.startsWith("ms-") ? "-" + t2 : t2;
}
var Be = function(e2) {
  return null == e2 || false === e2 || "" === e2;
}, Le = function(t2) {
  var n2, o, r2 = [];
  for (var s in t2) {
    var i = t2[s];
    t2.hasOwnProperty(s) && !Be(i) && (Array.isArray(i) && i.isCss || Q(i) ? r2.push("".concat(ze(s), ":"), i, ";") : oe(i) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s, " {")], Le(i), false), ["}"], false)) : r2.push("".concat(ze(s), ": ").concat((n2 = s, null == (o = i) || "boolean" == typeof o || "" === o ? "" : "number" != typeof o || 0 === o || n2 in unitlessKeys || n2.startsWith("--") ? String(o).trim() : "".concat(o, "px")), ";")));
  }
  return r2;
};
function Ge(e2, t2, n2, o) {
  if (Be(e2))
    return [];
  if (ee(e2))
    return [".".concat(e2.styledComponentId)];
  if (Q(e2)) {
    if (!Q(s = e2) || s.prototype && s.prototype.isReactComponent || !t2)
      return [e2];
    var r2 = e2(t2);
    return Ge(r2, t2, n2, o);
  }
  var s;
  return e2 instanceof Me ? n2 ? (e2.inject(n2, o), [e2.getName(o)]) : [e2] : oe(e2) ? Le(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(E, e2.map(function(e3) {
    return Ge(e3, t2, n2, o);
  })) : [e2.toString()];
}
function Ye(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (Q(n2) && !ee(n2))
      return false;
  }
  return true;
}
var We = j$1("6.1.0"), qe = function() {
  function e2(e3, t2, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && Ye(e3), this.componentId = t2, this.baseHash = k(We, t2), this.baseStyle = n2, Ce.registerId(t2);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
    var o = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t2, n2) : "";
    if (this.isStatic && !n2.hash)
      if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId))
        o = te(o, this.staticRulesId);
      else {
        var r2 = ne(Ge(this.rules, e3, t2, n2)), s = R(k(this.baseHash, r2) >>> 0);
        if (!t2.hasNameForId(this.componentId, s)) {
          var i = n2(r2, ".".concat(s), void 0, this.componentId);
          t2.insertRules(this.componentId, s, i);
        }
        o = te(o, s), this.staticRulesId = s;
      }
    else {
      for (var a = k(this.baseHash, n2.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2)
          c2 += u2;
        else if (u2) {
          var p2 = ne(Ge(u2, e3, t2, n2));
          a = k(a, p2 + l2), c2 += p2;
        }
      }
      if (c2) {
        var d2 = R(a >>> 0);
        t2.hasNameForId(this.componentId, d2) || t2.insertRules(this.componentId, d2, n2(c2, ".".concat(d2), void 0, this.componentId)), o = te(o, d2);
      }
    }
    return o;
  }, e2;
}(), He = React.createContext(void 0), Ue = He.Consumer;
function Je() {
  var e2 = reactExports.useContext(He);
  if (!e2)
    throw ce(18);
  return e2;
}
function Xe(e2) {
  var n2 = React.useContext(He), r2 = reactExports.useMemo(function() {
    return function(e3, n3) {
      if (!e3)
        throw ce(14);
      if (Q(e3)) {
        var o = e3(n3);
        return o;
      }
      if (Array.isArray(e3) || "object" != typeof e3)
        throw ce(8);
      return n3 ? __assign(__assign({}, n3), e3) : e3;
    }(e2.theme, n2);
  }, [e2.theme, n2]);
  return e2.children ? React.createElement(He.Provider, { value: r2 }, e2.children) : null;
}
var Ze = {}, Ke = /* @__PURE__ */ new Set();
function Qe(e2, r2, s) {
  var i = ee(e2), a = e2, c2 = !F(e2), p2 = r2.attrs, d2 = void 0 === p2 ? E : p2, h2 = r2.componentId, f2 = void 0 === h2 ? function(e3, t2) {
    var n2 = "string" != typeof e3 ? "sc" : A(e3);
    Ze[n2] = (Ze[n2] || 0) + 1;
    var o = "".concat(n2, "-").concat(x("6.1.0" + n2 + Ze[n2]));
    return t2 ? "".concat(t2, "-").concat(o) : o;
  }(r2.displayName, r2.parentComponentId) : h2, m2 = r2.displayName;
  void 0 === m2 ? function(e3) {
    return F(e3) ? "styled.".concat(e3) : "Styled(".concat(V(e3), ")");
  }(e2) : m2;
  var v2 = r2.displayName && r2.componentId ? "".concat(A(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, g2 = i && a.attrs ? a.attrs.concat(d2).filter(Boolean) : d2, S2 = r2.shouldForwardProp;
  if (i && a.shouldForwardProp) {
    var w2 = a.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var C2 = r2.shouldForwardProp;
      S2 = function(e3, t2) {
        return w2(e3, t2) && C2(e3, t2);
      };
    } else
      S2 = w2;
  }
  var I2 = new qe(s, v2, i ? a.componentStyle : void 0);
  function O2(e3, r3) {
    return function(e4, r4, s2) {
      var i2 = e4.attrs, a2 = e4.componentStyle, c3 = e4.defaultProps, p3 = e4.foldedComponentIds, d3 = e4.styledComponentId, h3 = e4.target, f3 = React.useContext(He), m3 = Ve(), y2 = e4.shouldForwardProp || m3.shouldForwardProp;
      var v3 = function(e5, n2, o) {
        for (var r5, s3 = __assign(__assign({}, n2), { className: void 0, theme: o }), i3 = 0; i3 < e5.length; i3 += 1) {
          var a3 = Q(r5 = e5[i3]) ? r5(s3) : r5;
          for (var c4 in a3)
            s3[c4] = "className" === c4 ? te(s3[c4], a3[c4]) : "style" === c4 ? __assign(__assign({}, s3[c4]), a3[c4]) : a3[c4];
        }
        return n2.className && (s3.className = te(s3.className, n2.className)), s3;
      }(i2, r4, P(r4, f3, c3) || N), g3 = v3.as || h3, S3 = {};
      for (var w3 in v3)
        void 0 === v3[w3] || "$" === w3[0] || "as" === w3 || "theme" === w3 || ("forwardedAs" === w3 ? S3.as = v3.forwardedAs : y2 && !y2(w3, g3) || (S3[w3] = v3[w3], y2 || true));
      var b2 = function(e5, t2) {
        var n2 = Ve(), o = e5.generateAndInjectStyles(t2, n2.styleSheet, n2.stylis);
        return o;
      }(a2, v3);
      var E2 = te(p3, d3);
      return b2 && (E2 += " " + b2), v3.className && (E2 += " " + v3.className), S3[F(g3) && !_.has(g3) ? "class" : "className"] = E2, S3.ref = s2, reactExports.createElement(g3, S3);
    }(D2, e3, r3);
  }
  var D2 = React.forwardRef(O2);
  return D2.attrs = g2, D2.componentStyle = I2, D2.shouldForwardProp = S2, D2.foldedComponentIds = i ? te(a.foldedComponentIds, a.styledComponentId) : "", D2.styledComponentId = v2, D2.target = i ? a.target : e2, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = i ? function(e4) {
      for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
      for (var o = 0, r3 = t2; o < r3.length; o++)
        re(e4, r3[o], true);
      return e4;
    }({}, a.defaultProps, e3) : e3;
  } }), se(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && K(D2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function et(e2, t2) {
  for (var n2 = [e2[0]], o = 0, r2 = t2.length; o < r2; o += 1)
    n2.push(t2[o], e2[o + 1]);
  return n2;
}
var tt = function(e2) {
  return Object.assign(e2, { isCss: true });
};
function nt(t2) {
  for (var n2 = [], o = 1; o < arguments.length; o++)
    n2[o - 1] = arguments[o];
  if (Q(t2) || oe(t2)) {
    var r2 = t2;
    return tt(Ge(et(E, __spreadArray([r2], n2, true))));
  }
  var s = t2;
  return 0 === n2.length && 1 === s.length && "string" == typeof s[0] ? Ge(s) : tt(Ge(et(s, n2)));
}
function ot(n2, o, r2) {
  if (void 0 === r2 && (r2 = N), !o)
    throw ce(1, o);
  var s = function(t2) {
    for (var s2 = [], i = 1; i < arguments.length; i++)
      s2[i - 1] = arguments[i];
    return n2(o, r2, nt.apply(void 0, __spreadArray([t2], s2, false)));
  };
  return s.attrs = function(e2) {
    return ot(n2, o, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean) }));
  }, s.withConfig = function(e2) {
    return ot(n2, o, __assign(__assign({}, r2), e2));
  }, s;
}
var rt = function(e2) {
  return ot(Qe, e2);
}, st = rt;
_.forEach(function(e2) {
  st[e2] = rt(e2);
});
var it = function() {
  function e2(e3, t2) {
    this.rules = e3, this.componentId = t2, this.isStatic = Ye(e3), Ce.registerId(this.componentId + 1);
  }
  return e2.prototype.createStyles = function(e3, t2, n2, o) {
    var r2 = o(ne(Ge(this.rules, t2, n2, o)), ""), s = this.componentId + e3;
    n2.insertRules(s, s, r2);
  }, e2.prototype.removeStyles = function(e3, t2) {
    t2.clearRules(this.componentId + e3);
  }, e2.prototype.renderStyles = function(e3, t2, n2, o) {
    e3 > 2 && Ce.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t2, n2, o);
  }, e2;
}();
function at(n2) {
  for (var r2 = [], s = 1; s < arguments.length; s++)
    r2[s - 1] = arguments[s];
  var i = nt.apply(void 0, __spreadArray([n2], r2, false)), a = "sc-global-".concat(x(JSON.stringify(i))), c2 = new it(i, a);
  var l2 = function(e2) {
    var t2 = Ve(), n3 = React.useContext(He), r3 = React.useRef(t2.styleSheet.allocateGSInstance(a)).current;
    return t2.styleSheet.server && u2(r3, e2, t2.styleSheet, n3, t2.stylis), React.useLayoutEffect(function() {
      if (!t2.styleSheet.server)
        return u2(r3, e2, t2.styleSheet, n3, t2.stylis), function() {
          return c2.removeStyles(r3, t2.styleSheet);
        };
    }, [r3, e2, t2.styleSheet, n3, t2.stylis]), null;
  };
  function u2(e2, n3, o, r3, s2) {
    if (c2.isStatic)
      c2.renderStyles(e2, g, o, s2);
    else {
      var i2 = __assign(__assign({}, n3), { theme: P(n3, r3, l2.defaultProps) });
      c2.renderStyles(e2, i2, o, s2);
    }
  }
  return React.memo(l2);
}
function ct(t2) {
  for (var n2 = [], o = 1; o < arguments.length; o++)
    n2[o - 1] = arguments[o];
  var r2 = ne(nt.apply(void 0, __spreadArray([t2], n2, false))), s = x(r2);
  return new Me(s, r2);
}
function lt(e2) {
  var n2 = React.forwardRef(function(n3, r2) {
    var s = P(n3, React.useContext(He), e2.defaultProps);
    return React.createElement(e2, __assign({}, n3, { theme: s, ref: r2 }));
  });
  return K(n2, e2);
}
var ut = function() {
  function e2() {
    var e3 = this;
    this._emitSheetCSS = function() {
      var t2 = e3.instance.toString(), n2 = Se(), o = ne([n2 && 'nonce="'.concat(n2, '"'), "".concat(f, '="true"'), "".concat("data-styled-version", '="').concat("6.1.0", '"')].filter(Boolean), " ");
      return "<style ".concat(o, ">").concat(t2, "</style>");
    }, this.getStyleTags = function() {
      if (e3.sealed)
        throw ce(2);
      return e3._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n2;
      if (e3.sealed)
        throw ce(2);
      var r2 = ((n2 = {})[f] = "", n2["data-styled-version"] = "6.1.0", n2.dangerouslySetInnerHTML = { __html: e3.instance.toString() }, n2), s = Se();
      return s && (r2.nonce = s), [React.createElement("style", __assign({}, r2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e3.sealed = true;
    }, this.instance = new Ce({ isServer: true }), this.sealed = false;
  }
  return e2.prototype.collectStyles = function(e3) {
    if (this.sealed)
      throw ce(2);
    return React.createElement(Fe, { sheet: this.instance }, e3);
  }, e2.prototype.interleaveWithNodeStream = function(e3) {
    throw ce(3);
  }, e2;
}(), pt = { StyleSheet: Ce, mainSheet: Re };
const styledComponents_browser_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ServerStyleSheet: ut,
  StyleSheetConsumer: je,
  StyleSheetContext: ke,
  StyleSheetManager: Fe,
  ThemeConsumer: Ue,
  ThemeContext: He,
  ThemeProvider: Xe,
  __PRIVATE__: pt,
  createGlobalStyle: at,
  css: nt,
  default: st,
  isStyledComponent: ee,
  keyframes: ct,
  styled: st,
  useTheme: Je,
  version: m,
  withTheme: lt
}, Symbol.toStringTag, { value: "Module" }));
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(styledComponents_browser_esm);
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die("Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop$2 = function noop() {
};
function isFunction(fn2) {
  return typeof fn2 === "function";
}
function isStringish(value) {
  var t2 = typeof value;
  switch (t2) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name2, theClass) {
  var propName = "isMobX" + name2;
  theClass.prototype[propName] = true;
  return function(x2) {
    return isObject$1(x2) && x2[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys2 = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys2;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys2;
  }
  return [].concat(keys2, symbols.filter(function(s) {
    return objectPrototype.propertyIsEnumerable.call(object2, s);
  }));
}
var ownKeys$1 = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys$1(target).forEach(function(key2) {
    res[key2] = getDescriptor(target, key2);
  });
  return res;
};
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key2, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends$7({}, prototype[storedAnnotationsSymbol]));
  }
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key2] = annotation;
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends$7({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.batchId_ = void 0;
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
    this.batchId_ = globalState.inBatch ? globalState.batchId : NaN;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    if (!globalState.inBatch || this.batchId_ !== globalState.batchId) {
      globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
      this.batchId_ = NaN;
    }
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return Atom2;
}();
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name2, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop$2;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop$2;
  }
  var atom = new Atom(name2);
  if (onBecomeObservedHandler !== noop$2) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop$2) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a, b2) {
  return a === b2;
}
function structuralComparer(a, b2) {
  return deepEqual(a, b2);
}
function shallowComparer(a, b2) {
  return deepEqual(a, b2, 1);
}
function defaultComparer(a, b2) {
  if (Object.is) {
    return Object.is(a, b2);
  }
  return a === b2 ? a !== 0 || 1 / a === 1 / b2 : a !== a && b2 !== b2;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v2, _2, name2) {
  if (isObservable(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, {
      name: name2
    });
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, void 0, {
      name: name2
    });
  }
  if (isES6Map(v2)) {
    return observable.map(v2, {
      name: name2
    });
  }
  if (isES6Set(v2)) {
    return observable.set(v2, {
      name: name2
    });
  }
  if (typeof v2 === "function" && !isAction(v2) && !isFlow(v2)) {
    if (isGenerator(v2)) {
      return flow(v2);
    } else {
      return autoAction(name2, v2);
    }
  }
  return v2;
}
function shallowEnhancer(v2, _2, name2) {
  if (v2 === void 0 || v2 === null) {
    return v2;
  }
  if (isObservableObject(v2) || isObservableArray(v2) || isObservableMap(v2) || isObservableSet(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, {
      name: name2,
      deep: false
    });
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, void 0, {
      name: name2,
      deep: false
    });
  }
  if (isES6Map(v2)) {
    return observable.map(v2, {
      name: name2,
      deep: false
    });
  }
  if (isES6Set(v2)) {
    return observable.set(v2, {
      name: name2,
      deep: false
    });
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v2, oldValue) {
  if (deepEqual(v2, oldValue)) {
    return oldValue;
  }
  return v2;
}
var OVERRIDE = "override";
var override = /* @__PURE__ */ createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_,
  extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key2) {
  return 0;
}
function extend_(adm, key2, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function createActionAnnotation(name2, options2) {
  return {
    annotationType_: name2,
    options_: options2,
    make_: make_$1,
    extend_: extend_$1
  };
}
function make_$1(adm, key2, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key2, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key2, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key2, descriptor, false);
  defineProperty(source, key2, actionDescriptor);
  return 2;
}
function extend_$1(adm, key2, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key2, descriptor);
  return adm.defineProperty_(key2, actionDescriptor, proxyTrap);
}
function assertActionDescriptor(adm, _ref3, key2, _ref22) {
  _ref3.annotationType_;
  _ref22.value;
}
function createActionDescriptor(adm, annotation, key2, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key2, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key2.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name2, options2) {
  return {
    annotationType_: name2,
    options_: options2,
    make_: make_$2,
    extend_: extend_$2
  };
}
function make_$2(adm, key2, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key2, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key2) || !isFlow(adm.target_[key2]))) {
    if (this.extend_(adm, key2, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key2, descriptor, false, false);
  defineProperty(source, key2, flowDescriptor);
  return 2;
}
function extend_$2(adm, key2, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key2, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key2, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor(adm, _ref3, key2, _ref22) {
  _ref3.annotationType_;
  _ref22.value;
}
function createFlowDescriptor(adm, annotation, key2, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key2, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name2, options2) {
  return {
    annotationType_: name2,
    options_: options2,
    make_: make_$3,
    extend_: extend_$3
  };
}
function make_$3(adm, key2, descriptor) {
  return this.extend_(adm, key2, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key2, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key2, descriptor);
  return adm.defineComputedProperty_(key2, _extends$7({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor(adm, _ref3, key2, _ref22) {
  _ref3.annotationType_;
  _ref22.get;
}
function createObservableAnnotation(name2, options2) {
  return {
    annotationType_: name2,
    options_: options2,
    make_: make_$4,
    extend_: extend_$4
  };
}
function make_$4(adm, key2, descriptor) {
  return this.extend_(adm, key2, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key2, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this);
  return adm.defineObservableProperty_(key2, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function assertObservableDescriptor(adm, _ref3, key2, descriptor) {
  _ref3.annotationType_;
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options2) {
  return {
    annotationType_: AUTO,
    options_: options2,
    make_: make_$5,
    extend_: extend_$5
  };
}
function make_$5(adm, key2, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key2, descriptor, source);
  }
  if (descriptor.set) {
    var set5 = createAction(key2.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key2, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set5
      }) === null ? 0 : 2;
    }
    defineProperty(source, key2, {
      configurable: true,
      set: set5
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key2, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key2, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key2, descriptor, source);
}
function extend_$5(adm, key2, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key2, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key2, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key2.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key2, descriptor, proxyTrap);
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options2) {
  return options2.deep === true ? deepEnhancer : options2.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options2.defaultDecorator);
}
function getAnnotationFromOptions(options2) {
  var _options$defaultDecor;
  return options2 ? (_options$defaultDecor = options2.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options2) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v2, arg2, arg3) {
  if (isStringish(arg2)) {
    storeAnnotation(v2, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v2)) {
    return v2;
  }
  if (isPlainObject(v2)) {
    return observable.object(v2, arg2, arg3);
  }
  if (Array.isArray(v2)) {
    return observable.array(v2, arg2);
  }
  if (isES6Map(v2)) {
    return observable.map(v2, arg2);
  }
  if (isES6Set(v2)) {
    return observable.set(v2, arg2);
  }
  if (typeof v2 === "object" && v2 !== null) {
    return v2;
  }
  return observable.box(v2, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options2) {
    var o = asCreateObservableOptions(options2);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options2) {
    var o = asCreateObservableOptions(options2);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options2) {
    var o = asCreateObservableOptions(options2);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options2) {
    var o = asCreateObservableOptions(options2);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options2) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options2 == null ? void 0 : options2.proxy) === false ? asObservableObject({}, options2) : asDynamicObservableObject({}, options2), props, decorators);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn2, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  function res() {
    return executeAction(actionName, autoAction2, fn2, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn2, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation);
  try {
    return fn2.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev2 = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev2);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev2 = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev2;
}
function allowStateChangesEnd(prev2) {
  globalState.allowStateChanges = prev2;
}
var _Symbol$toPrimitive;
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  _inheritsLoose(ObservableValue2, _Atom);
  function ObservableValue2(value, enhancer, name_, notifySpy, equals2) {
    var _this;
    if (name_ === void 0) {
      name_ = "ObservableValue";
    }
    if (equals2 === void 0) {
      equals2 = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals2;
    _this.value_ = enhancer(value, void 0, name_);
    return _this;
  }
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set5(newValue) {
    this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      this.setNewValue_(newValue);
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get4() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON3() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
var _Symbol$toPrimitive$1;
_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue2(options2) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options2.get) {
      die(31);
    }
    this.derivation = options2.get;
    this.name_ = options2.name || "ComputedValue";
    if (options2.set) {
      this.setter_ = createAction("ComputedValue-setter", options2.set);
    }
    this.equals_ = options2.equals || (options2.compareStructural || options2.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options2.context;
    this.requiresReaction_ = options2.requiresReaction;
    this.keepAlive_ = !!options2.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get4() {
    if (this.isComputing_) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set5(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) {
        die(33, this.name_);
      }
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true;
    var prev2 = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e2) {
          res = new CaughtException(e2);
        }
      }
    }
    allowStateChangesEnd(prev2);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    {
      return;
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive$1] = function() {
    return this.valueOf();
  };
  return ComputedValue2;
}();
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e2) {
  return e2 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l2 = obs.length;
      for (var i = 0; i < l2; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e2) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null;
}
function checkIfStateModificationsAreAllowed(atom) {
  {
    return;
  }
}
function trackDerivedFunction(derivation, f2, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f2.call(context);
  } else {
    try {
      result = f2.call(context);
    } catch (e2) {
      result = new CaughtException(e2);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l2 = derivation.unboundDepsCount_;
  for (var i = 0; i < l2; i++) {
    var dep = observing[i];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l2 = prevObserving.length;
  while (l2--) {
    var _dep = prevObserving[l2];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev2 = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev2);
  }
}
function untrackedStart() {
  var prev2 = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev2;
}
function untrackedEnd(prev2) {
  globalState.trackingDerivation = prev2;
}
function allowStateReadsStart(allowStateReads) {
  var prev2 = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev2;
}
function allowStateReadsEnd(prev2) {
  globalState.allowStateReads = prev2;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.batchId = Number.MIN_SAFE_INTEGER;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
  this.stateVersion = Number.MIN_SAFE_INTEGER;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();
  for (var key2 in defaultGlobals) {
    if (persistentKeys.indexOf(key2) === -1) {
      globalState[key2] = defaultGlobals[key2];
    }
  }
  globalState.allowStateChanges = !globalState.enforceActions;
}
function hasObservers(observable2) {
  return observable2.observers_ && observable2.observers_.size > 0;
}
function getObservers(observable2) {
  return observable2.observers_;
}
function addObserver(observable2, node2) {
  observable2.observers_.add(node2);
  if (observable2.lowestObserverState_ > node2.dependenciesState_) {
    observable2.lowestObserverState_ = node2.dependenciesState_;
  }
}
function removeObserver(observable2, node2) {
  observable2.observers_["delete"](node2);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation_ === false) {
    observable2.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  if (globalState.inBatch === 0) {
    globalState.batchId = globalState.batchId < Number.MAX_SAFE_INTEGER ? globalState.batchId + 1 : Number.MIN_SAFE_INTEGER;
  }
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list2 = globalState.pendingUnobservations;
    for (var i = 0; i < list2.length; i++) {
      var observable2 = list2[i];
      observable2.isPendingUnobservation_ = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved_) {
          observable2.isBeingObserved_ = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved_ && globalState.trackingContext) {
        observable2.isBeingObserved_ = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved_;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.onBecomeStale_();
    }
    d2.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d2.dependenciesState_ = IDerivationState_.STALE_;
    } else if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d2.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev2 = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (false)
            ;
        } catch (e2) {
          this.reportExceptionInDerivation_(e2);
        }
      }
      globalState.trackingContext = prev2;
      endBatch();
    }
  };
  _proto.track = function track(fn2) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn2, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    }
    globalState.globalReactionErrorHandlers.forEach(function(f2) {
      return f2(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null ? void 0 : abortSignal.removeEventListener == null ? void 0 : abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null ? void 0 : abortSignal.addEventListener == null ? void 0 : abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
  };
  return Reaction2;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function() {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) {
      globalState.globalReactionErrorHandlers.splice(idx, 1);
    }
  };
}
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f2) {
  return f2();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l2 = remainingReactions.length; i < l2; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn2) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f2) {
    return fn2(function() {
      return baseScheduler(f2);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spyReport(event) {
  {
    return;
  }
}
function spyReportStart(event) {
  {
    return;
  }
}
function spyReportEnd(change) {
  {
    return;
  }
}
function spy(listener) {
  {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn2) {
  return executeAction(fn2.name || DEFAULT_ACTION_NAME, false, fn2, this, void 0);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts2$signal, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name2 = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name2, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler2 = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name2, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler2(function() {
          isScheduled = false;
          if (!reaction2.isDisposed_) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2$signal = _opts2.signal) != null && _opts2$signal.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f2) {
  return f2();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
    return setTimeout(f2, opts.delay);
  } : run;
}
function reaction(expression, effect2, opts) {
  var _opts$name2, _opts4, _opts4$signal, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name2 = (_opts$name2 = opts.name) != null ? _opts$name2 : "Reaction";
  var effectAction = action(name2, opts.onError ? wrapErrorHandler(opts.onError, effect2) : effect2);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler2 = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue;
  var equals2 = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r2 = new Reaction(name2, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler2(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r2.isDisposed_) {
      return;
    }
    var changed = false;
    r2.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r2);
      });
      changed = firstTime || !equals2(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r2);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r2);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4$signal = _opts4.signal) != null && _opts4$signal.aborted)) {
    r2.schedule_();
  }
  return r2.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e2) {
      errorHandler.call(this, e2);
    }
  };
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb2 = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb2);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb2]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb2);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options2) {
  if (options2.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options2.useProxies, enforceActions = options2.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea2 = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea2;
    globalState.allowStateChanges = ea2 === true || ea2 === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key2) {
    if (key2 in options2) {
      globalState[key2] = !!options2[key2];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (options2.reactionScheduler) {
    setReactionScheduler(options2.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options2) {
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options2)[$mobx];
    ownKeys$1(descriptors).forEach(function(key2) {
      adm.extend_(
        key2,
        descriptors[key2],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key2 in annotations ? annotations[key2] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node2) {
  var result = {
    name: node2.name_
  };
  if (node2.observing_ && node2.observing_.length > 0) {
    result.dependencies = unique(node2.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node2) {
  var result = {
    name: node2.name_
  };
  if (hasObservers(node2)) {
    result.observers = Array.from(getObservers(node2)).map(nodeToObserverTree);
  }
  return result;
}
function unique(list2) {
  return Array.from(new Set(list2));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  var generator = arg1;
  var name2 = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name2 + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve28, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e2) {
          return reject(e2);
        }
        next2(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e2) {
          return reject(e2);
        }
        next2(ret);
      }
      function next2(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next2, reject);
          return;
        }
        if (ret.done) {
          return resolve28(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name2 + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop$2, noop$2);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e2) {
        rejector(e2);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function flowResult(result) {
  return result;
}
function isFlow(fn2) {
  return (fn2 == null ? void 0 : fn2.isMobXFlow) === true;
}
function interceptReads(thing, propOrHandler, handler) {
  var target;
  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    target = getAdministration(thing, propOrHandler);
  } else
    ;
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function() {
    target.dehancer = void 0;
  };
}
function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) {
    return interceptProperty(thing, propOrHandler, handler);
  } else {
    return interceptInterceptable(thing, propOrHandler);
  }
}
function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}
function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}
function _isComputed(value, property) {
  if (property === void 0) {
    return isComputedValue(value);
  }
  if (isObservableObject(value) === false) {
    return false;
  }
  if (!value[$mobx].values_.has(property)) {
    return false;
  }
  var atom = getAtom(value, property);
  return isComputedValue(atom);
}
function isComputed(value) {
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  return _isComputed(value, propName);
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  return _isObservable(value, propName);
}
function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }
  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(_2, index2) {
      return index2;
    });
  }
  die(5);
}
function values$1(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key2) {
      return obj[key2];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key2) {
      return obj.get(key2);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key2) {
      return [key2, obj[key2]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key2) {
      return [key2, obj.get(key2)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(key2, index2) {
      return [index2, key2];
    });
  }
  die(7);
}
function set$4(obj, key2, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key2;
    try {
      for (var _key in _values) {
        set$4(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    obj[$mobx].set_(key2, value);
  } else if (isObservableMap(obj)) {
    obj.set(key2, value);
  } else if (isObservableSet(obj)) {
    obj.add(key2);
  } else if (isObservableArray(obj)) {
    if (typeof key2 !== "number") {
      key2 = parseInt(key2, 10);
    }
    if (key2 < 0) {
      die("Invalid index: '" + key2 + "'");
    }
    startBatch();
    if (key2 >= obj.length) {
      obj.length = key2 + 1;
    }
    obj[key2] = value;
    endBatch();
  } else {
    die(8);
  }
}
function remove$3(obj, key2) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key2);
  } else if (isObservableMap(obj)) {
    obj["delete"](key2);
  } else if (isObservableSet(obj)) {
    obj["delete"](key2);
  } else if (isObservableArray(obj)) {
    if (typeof key2 !== "number") {
      key2 = parseInt(key2, 10);
    }
    obj.splice(key2, 1);
  } else {
    die(9);
  }
}
function has(obj, key2) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key2);
  } else if (isObservableMap(obj)) {
    return obj.has(key2);
  } else if (isObservableSet(obj)) {
    return obj.has(key2);
  } else if (isObservableArray(obj)) {
    return key2 >= 0 && key2 < obj.length;
  }
  die(10);
}
function get$3(obj, key2) {
  if (!has(obj, key2)) {
    return void 0;
  }
  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key2);
  } else if (isObservableMap(obj)) {
    return obj.get(key2);
  } else if (isObservableArray(obj)) {
    return obj[key2];
  }
  die(11);
}
function apiDefineProperty(obj, key2, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key2, descriptor);
  }
  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) {
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  } else {
    return observeObservable(thing, propOrCb, cbOrFire);
  }
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}
function cache(map3, key2, value) {
  map3.set(key2, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
    source.forEach(function(value, key2) {
      _res2.set(key2, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function(key2) {
      if (objectPrototype.propertyIsEnumerable.call(source, key2)) {
        _res3[key2] = toJSHelper(source[key2], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS$1(source, options2) {
  return toJSHelper(source, /* @__PURE__ */ new Map());
}
function trace() {
  {
    return;
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") {
    return whenPromise(predicate, arg1);
  }
  return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect2, opts) {
  var timeoutHandle;
  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function() {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) {
          opts.onError(error);
        } else {
          throw error;
        }
      }
    }, opts.timeout);
  }
  opts.name = "When";
  var effectAction = createAction("When-effect", effect2);
  var disposer = autorun(function(r2) {
    var cond = allowStateChanges(false, predicate);
    if (cond) {
      r2.dispose();
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      effectAction();
    }
  }, opts);
  return disposer;
}
function whenPromise(predicate, opts) {
  var _opts$signal;
  if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function cancel2() {
        return null;
      }
    });
  }
  var cancel;
  var abort;
  var res = new Promise(function(resolve28, reject) {
    var _opts$signal2;
    var disposer = _when(predicate, resolve28, _extends$7({}, opts, {
      onError: reject
    }));
    cancel = function cancel2() {
      disposer();
      reject(new Error("WHEN_CANCELLED"));
    };
    abort = function abort2() {
      disposer();
      reject(new Error("WHEN_ABORTED"));
    };
    opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener == null ? void 0 : _opts$signal2.addEventListener("abort", abort);
  })["finally"](function() {
    var _opts$signal3;
    return opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener("abort", abort);
  });
  res.cancel = cancel;
  return res;
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has2(target, name2) {
    return getAdm(target).has_(name2);
  },
  get: function get(target, name2) {
    return getAdm(target).get_(name2);
  },
  set: function set2(target, name2, value) {
    var _getAdm$set_;
    if (!isStringish(name2)) {
      return false;
    }
    return (_getAdm$set_ = getAdm(target).set_(name2, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name2) {
    var _getAdm$delete_;
    if (!isStringish(name2)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name2, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name2, descriptor) {
    var _getAdm$definePropert;
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name2, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options2) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options2);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l2 = interceptors.length; i < l2; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l2 = listeners.length; i < l2; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options2) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options2)[$mobx];
    if (false)
      ;
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys$1(annotations).forEach(function(key2) {
      return adm.make_(key2, annotations[key2]);
    });
  });
  return target;
}
var keysSymbol = /* @__PURE__ */ Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options2) {
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options2);
  }
  initObservable(function() {
    var adm = asObservableObject(target, options2)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys2 = new Set([].concat(ownKeys$1(target), ownKeys$1(proto)));
      keys2["delete"]("constructor");
      keys2["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys2);
    }
    target[keysSymbol].forEach(function(key2) {
      return adm.make_(
        key2,
        // must pass "undefined" for { key: undefined }
        !overrides ? true : key2 in overrides ? overrides[key2] : true
      );
    });
  });
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name2) {
    var adm = target[$mobx];
    if (name2 === $mobx) {
      return adm;
    }
    if (name2 === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name2 === "string" && !isNaN(name2)) {
      return adm.get_(parseInt(name2));
    }
    if (hasProp(arrayExtensions, name2)) {
      return arrayExtensions[name2];
    }
    return target[name2];
  },
  set: function set3(target, name2, value) {
    var adm = target[$mobx];
    if (name2 === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name2 === "symbol" || isNaN(name2)) {
      target[name2] = value;
    } else {
      adm.set_(parseInt(name2), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name2, enhancer, owned_, legacyMode_) {
    if (name2 === void 0) {
      name2 = "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name2);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values2) {
    if (this.dehancer !== void 0 && values2.length > 0) {
      return values2.map(this.dehancer);
    }
    return values2;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length2 = this.values_.length;
    if (index2 === void 0) {
      index2 = 0;
    } else if (index2 > length2) {
      index2 = length2;
    } else if (index2 < 0) {
      index2 = Math.max(0, length2 + index2);
    }
    if (arguments.length === 1) {
      deleteCount = length2 - index2;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length2 - index2));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v2) {
      return _this.enhancer_(v2, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length2, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index2, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index2 + i] = newItems[i];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get_ = function get_(index2) {
    if (this.legacyMode_ && index2 >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + index2);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index2]);
  };
  _proto.set_ = function set_(index2, newValue) {
    var values2 = this.values_;
    if (this.legacyMode_ && index2 > values2.length) {
      die(17, index2, values2.length);
    }
    if (index2 < values2.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values2[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values2[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index2 + 1 - values2.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values2.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name2, owned) {
  if (name2 === void 0) {
    name2 = "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name2, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace2(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON2() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy2 = this.slice();
    copy2.sort.apply(copy2, arguments);
    this.replace(copy2);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject$1(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(false ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key2) {
    return this.data_.has(key2);
  };
  _proto.has = function has3(key2) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key2);
    }
    var entry = this.hasMap_.get(key2);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key2), referenceEnhancer, "ObservableMap.key?", false);
      this.hasMap_.set(key2, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key2);
      });
    }
    return entry.get();
  };
  _proto.set = function set5(key2, value) {
    var hasKey = this.has_(key2);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key2
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key2, value);
    } else {
      this.addValue_(key2, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key2) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key2
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key2)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key2).value_,
        name: key2
      } : null;
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key2)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key2);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key2);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key2, newValue) {
    var observable2 = this.data_.get(key2);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key2,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
    }
  };
  _proto.addValue_ = function addValue_(key2, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
      _this4.data_.set(key2, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key2)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key2,
      newValue
    } : null;
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get = function get4(key2) {
    if (this.has(key2)) {
      return this.dehanceValue_(this.data_.get(key2).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys2() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values2() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next2() {
        var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries2() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next2() {
        var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key2 = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key2, this);
    }
  };
  _proto.merge = function merge2(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function(key2) {
          return _this5.set(key2, other[key2]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref3) {
          var key2 = _ref3[0], value = _ref3[1];
          return _this5.set(key2, value);
        });
      } else if (isES6Map(other)) {
        if (other.constructor !== Map) {
          die(19, other);
        }
        other.forEach(function(value, key2) {
          return _this5.set(key2, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear3() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key2 = _step2.value;
          _this6["delete"](key2);
        }
      });
    });
  };
  _proto.replace = function replace3(values2) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values2);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key2 = _step3.value;
        if (!replacementMap.has(key2)) {
          var deleted = _this7["delete"](key2);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key2);
            orderedData.set(key2, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON3() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _createClass$1(ObservableMap2, [{
    key: "size",
    get: function get4() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get4() {
      return "Map";
    }
  }]);
  return ObservableMap2;
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map3 = /* @__PURE__ */ new Map();
    for (var key2 in dataStructure) {
      map3.set(key2, dataStructure[key2]);
    }
    return map3;
  } else {
    return die(21, dataStructure);
  }
}
var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear3() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add2(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      return true;
    }
    return false;
  };
  _proto.has = function has3(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries2() {
    var nextIndex = 0;
    var keys2 = Array.from(this.keys());
    var values2 = Array.from(this.values());
    return makeIterable({
      next: function next2() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values2.length ? {
          value: [keys2[index2], values2[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys2() {
    return this.values();
  };
  _proto.values = function values2() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next2() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace3(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON3() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator$1] = function() {
    return this.values();
  };
  _createClass$1(ObservableSet2, [{
    key: "size",
    get: function get4() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get4() {
      return "Set";
    }
  }]);
  return ObservableSet2;
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE$1 = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom("ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key2) {
    return this.values_.get(key2).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key2, newValue) {
    var observable2 = this.values_.get(key2);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key2,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key2,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return true;
  };
  _proto.get_ = function get_(key2) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key2)) {
      this.has_(key2);
    }
    return this.target_[key2];
  };
  _proto.set_ = function set_(key2, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key2)) {
      if (this.values_.has(key2)) {
        return this.setObservablePropValue_(key2, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key2, value);
      } else {
        this.target_[key2] = value;
        return true;
      }
    } else {
      return this.extend_(key2, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key2) {
    if (!globalState.trackingDerivation) {
      return key2 in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key2);
    if (!entry) {
      entry = new ObservableValue(key2 in this.target_, referenceEnhancer, "ObservableObject.key?", false);
      this.pendingKeys_.set(key2, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_2(key2, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    if (!(key2 in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key2]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key2.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key2);
      if (descriptor) {
        var outcome = annotation.make_(this, key2, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key2);
  };
  _proto.extend_ = function extend_2(key2, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key2, descriptor, proxyTrap);
    }
    var outcome = annotation.extend_(this, key2, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key2);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key2, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key2);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key2,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends$7({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key2, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key2, descriptor);
      }
      this.notifyPropertyAddition_(key2, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key2, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key2);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key2,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key2);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key2, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key2, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key2.toString() : "ObservableObject.key", false);
      this.values_.set(key2, observable2);
      this.notifyPropertyAddition_(key2, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key2, options2, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key2);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key2,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options2.name || (options2.name = false ? this.name_ + "." + key2.toString() : "ObservableObject.key");
      options2.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key2);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key2, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key2, descriptor);
      }
      this.values_.set(key2, new ComputedValue(options2));
      this.notifyPropertyAddition_(key2, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key2, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key2)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key2,
        type: REMOVE$1
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key2);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key2)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key2)) {
          return false;
        }
      } else {
        delete this.target_[key2];
      }
      if (false)
        ;
      if (observable2) {
        this.values_["delete"](key2);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key2)) == null ? void 0 : _this$pendingKeys_$ge.set(key2 in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE$1,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key2
        };
        if (false)
          ;
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false)
          ;
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key2, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key2,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, change);
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key2)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys$1(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options2) {
  var _options$name;
  if (hasProp(target, $mobx)) {
    return target;
  }
  var name2 = (_options$name = options2 == null ? void 0 : options2.name) != null ? _options$name : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name2), getAnnotationFromOptions(options2));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key2) {
  return descriptorCache[key2] || (descriptorCache[key2] = {
    get: function get4() {
      return this[$mobx].getObservablePropValue_(key2);
    },
    set: function set5(value) {
      return this[$mobx].setObservablePropValue_(key2, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject$1(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key2) {
  var _adm$target_$storedAn;
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key2];
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var v2 = false;
  var p2 = {};
  Object.defineProperty(p2, "0", {
    set: function set5() {
      v2 = true;
    }
  });
  Object.create(p2)["0"] = 1;
  return v2 === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  function LegacyObservableArray2(initialValues, enhancer, name2, owned) {
    var _this;
    if (name2 === void 0) {
      name2 = "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name2, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
      }
    });
    return _this;
  }
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      })
    );
  };
  _proto[_Symbol$iterator2] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next2() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass$1(LegacyObservableArray2, [{
    key: "length",
    get: function get4() {
      return this[$mobx].getArrayLength_();
    },
    set: function set5(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Array";
    }
  }]);
  return LegacyObservableArray2;
}(StubArray, Symbol.toStringTag, Symbol.iterator);
Object.entries(arrayExtensions).forEach(function(_ref3) {
  var prop = _ref3[0], fn2 = _ref3[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn2);
  }
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get4() {
      return this[$mobx].get_(index2);
    },
    set: function set5(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max2) {
  if (max2 > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max2 + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max2;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name2) {
  return new LegacyObservableArray(initialValues, enhancer, name2);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb2) {
  var derivation = untrackedStart();
  var allowStateChanges2 = allowStateChangesStart(true);
  startBatch();
  try {
    return cb2();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges2);
    untrackedEnd(derivation);
  }
}
var toString$3 = objectPrototype.toString;
function deepEqual(a, b2, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b2, depth);
}
function eq(a, b2, depth, aStack, bStack) {
  if (a === b2) {
    return a !== 0 || 1 / a === 1 / b2;
  }
  if (a == null || b2 == null) {
    return false;
  }
  if (a !== a) {
    return b2 !== b2;
  }
  var type2 = typeof a;
  if (type2 !== "function" && type2 !== "object" && typeof b2 != "object") {
    return false;
  }
  var className = toString$3.call(a);
  if (className !== toString$3.call(b2)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b2;
    case "[object Number]":
      if (+a !== +a) {
        return +b2 !== +b2;
      }
      return +a === 0 ? 1 / +a === 1 / b2 : +a === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b2;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b2);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a = unwrap(a);
  b2 = unwrap(b2);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b2 != "object") {
      return false;
    }
    var aCtor = a.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b2) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length2 = aStack.length;
  while (length2--) {
    if (aStack[length2] === a) {
      return bStack[length2] === b2;
    }
  }
  aStack.push(a);
  bStack.push(b2);
  if (areArrays) {
    length2 = a.length;
    if (length2 !== b2.length) {
      return false;
    }
    while (length2--) {
      if (!eq(a[length2], b2[length2], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys2 = Object.keys(a);
    var key2;
    length2 = keys2.length;
    if (Object.keys(b2).length !== length2) {
      return false;
    }
    while (length2--) {
      key2 = keys2[length2];
      if (!(hasProp(b2, key2) && eq(a[key2], b2[key2], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m2) {
  var g2 = getGlobal();
  if (typeof g2[m2] === "undefined") {
    die("MobX requires global '" + m2 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}
const mobx_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $mobx,
  FlowCancellationError,
  ObservableMap,
  ObservableSet,
  Reaction,
  _allowStateChanges: allowStateChanges,
  _allowStateChangesInsideComputed: runInAction,
  _allowStateReadsEnd: allowStateReadsEnd,
  _allowStateReadsStart: allowStateReadsStart,
  _autoAction: autoAction,
  _endAction,
  _getAdministration: getAdministration,
  _getGlobalState: getGlobalState,
  _interceptReads: interceptReads,
  _isComputingDerivation: isComputingDerivation,
  _resetGlobalState: resetGlobalState,
  _startAction,
  action,
  autorun,
  comparer,
  computed,
  configure,
  createAtom,
  defineProperty: apiDefineProperty,
  entries,
  extendObservable,
  flow,
  flowResult,
  get: get$3,
  getAtom,
  getDebugName,
  getDependencyTree,
  getObserverTree,
  has,
  intercept,
  isAction,
  isBoxedObservable: isObservableValue,
  isComputed,
  isComputedProp,
  isFlow,
  isFlowCancellationError,
  isObservable,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  isObservableProp,
  isObservableSet,
  keys,
  makeAutoObservable,
  makeObservable,
  observable,
  observe,
  onBecomeObserved,
  onBecomeUnobserved,
  onReactionError,
  override,
  ownKeys: apiOwnKeys,
  reaction,
  remove: remove$3,
  runInAction,
  set: set$4,
  spy,
  toJS: toJS$1,
  trace,
  transaction,
  untracked,
  values: values$1,
  when
}, Symbol.toStringTag, { value: "Module" }));
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(mobx_esm);
var bundle = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal)
    return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array2, values2) {
      var index2 = -1, length2 = values2.length, offset2 = array2.length;
      while (++index2 < length2) {
        array2[offset2 + index2] = values2[index2];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache2, key2) {
      return cache2.has(key2);
    }
    function getValue(object2, key2) {
      return object2 == null ? void 0 : object2[key2];
    }
    function mapToArray(map3) {
      var index2 = -1, result = Array(map3.size);
      map3.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set5) {
      var index2 = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
    }
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
    }
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key2) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice2.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key2) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      if (index2 < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries2) {
      var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size2 = data.size;
      data.set(key2, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values2) {
      var index2 = -1, length2 = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache();
      while (++index2 < length2) {
        this.add(values2[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack2(entries2) {
      var data = this.__data__ = new ListCache(entries2);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key2) {
      var length2 = array2.length;
      while (length2--) {
        if (eq2(array2[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag2;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike2(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack2());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack2());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack2());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key2 in Object(object2)) {
        if (hasOwnProperty2.call(object2, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag2:
        case dateTag:
        case numberTag:
          return eq2(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key2 = objProps[index2];
        if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key2 = objProps[index2];
        var objValue = object2[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    function getMapData(map3, key2) {
      var data = map3.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key2) {
      var value = getValue(object2, key2);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag2 = baseGetTag;
    if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength2(value.length) && !isFunction2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual3(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength2(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual3;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var resolve27 = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var pathBrowserify;
var hasRequiredPathBrowserify;
function requirePathBrowserify() {
  if (hasRequiredPathBrowserify)
    return pathBrowserify;
  hasRequiredPathBrowserify = 1;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i = 0; i <= path2.length; ++i) {
      if (i < path2.length)
        code = path2.charCodeAt(i);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1)
          ;
        else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path2.slice(lastSlash + 1, i);
          else
            res = path2.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve28() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path2;
        if (i >= 0)
          path2 = arguments[i];
        else {
          if (cwd === void 0)
            cwd = process.cwd();
          path2 = cwd;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize3(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var isAbsolute = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute);
      if (path2.length === 0 && !isAbsolute)
        path2 = ".";
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from2, to) {
      assertPath(from2);
      assertPath(to);
      if (from2 === to)
        return "";
      from2 = posix.resolve(from2);
      to = posix.resolve(to);
      if (from2 === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from2.length; ++fromStart) {
        if (from2.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from2.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length2 = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i = 0;
      for (; i <= length2; ++i) {
        if (i === length2) {
          if (toLen > length2) {
            if (to.charCodeAt(toStart + i) === 47) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length2) {
            if (from2.charCodeAt(fromStart + i) === 47) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from2.charCodeAt(fromStart + i);
        var toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i;
      }
      var out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from2.charCodeAt(i) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path2) {
      return path2;
    },
    dirname: function dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end2 = -1;
      var matchedSlash = true;
      for (var i = path2.length - 1; i >= 1; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end2 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end2 === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end2 === 1)
        return "//";
      return path2.slice(0, end2);
    },
    basename: function basename(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start2 = 0;
      var end2 = -1;
      var matchedSlash = true;
      var i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          var code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end2 = i;
                }
              } else {
                extIdx = -1;
                end2 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start2 === end2)
          end2 = firstNonSlashEnd;
        else if (end2 === -1)
          end2 = path2.length;
        return path2.slice(start2, end2);
      } else {
        for (i = path2.length - 1; i >= 0; --i) {
          if (path2.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start2 = i + 1;
              break;
            }
          } else if (end2 === -1) {
            matchedSlash = false;
            end2 = i + 1;
          }
        }
        if (end2 === -1)
          return "";
        return path2.slice(start2, end2);
      }
    },
    extname: function extname(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i = path2.length - 1; i >= 0; --i) {
        var code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end2 === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end2);
    },
    format: function format2(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse2(path2) {
      assertPath(path2);
      var ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute = code === 47;
      var start2;
      if (isAbsolute) {
        ret.root = "/";
        start2 = 1;
      } else {
        start2 = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var matchedSlash = true;
      var i = path2.length - 1;
      var preDotState = 0;
      for (; i >= start2; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end2 === -1) {
          matchedSlash = false;
          end2 = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end2 === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        if (end2 !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end2);
          else
            ret.base = ret.name = path2.slice(startPart, end2);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end2);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end2);
        }
        ret.ext = path2.slice(startDot, end2);
      }
      if (startPart > 0)
        ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  pathBrowserify = posix;
  return pathBrowserify;
}
var refUtils = {};
var utils$1 = {};
var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath)
    return path;
  hasRequiredPath = 1;
  const isWindows = typeof process === "object" && process && process.platform === "win32";
  path = isWindows ? { sep: "\\" } : { sep: "/" };
  return path;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch)
    return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b2, str2) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str2);
    if (b2 instanceof RegExp)
      b2 = maybeMatch(b2, str2);
    var r2 = range(a, b2, str2);
    return r2 && {
      start: r2[0],
      end: r2[1],
      pre: str2.slice(0, r2[0]),
      body: str2.slice(r2[0] + a.length, r2[1]),
      post: str2.slice(r2[1] + b2.length)
    };
  }
  function maybeMatch(reg, str2) {
    var m2 = str2.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a, b2, str2) {
    var begs, beg, left2, right2, result;
    var ai2 = str2.indexOf(a);
    var bi2 = str2.indexOf(b2, ai2 + 1);
    var i = ai2;
    if (ai2 >= 0 && bi2 > 0) {
      if (a === b2) {
        return [ai2, bi2];
      }
      begs = [];
      left2 = str2.length;
      while (i >= 0 && !result) {
        if (i == ai2) {
          begs.push(i);
          ai2 = str2.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi2];
        } else {
          beg = begs.pop();
          if (beg < left2) {
            left2 = beg;
            right2 = bi2;
          }
          bi2 = str2.indexOf(b2, i + 1);
        }
        i = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
      }
      if (begs.length) {
        result = [left2, right2];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion)
    return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str2);
    if (!m2)
      return str2.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p2 = pre.split(",");
    p2[p2.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p2[p2.length - 1] += postParts.shift();
      p2.push.apply(p2, postParts);
    }
    parts.push.apply(parts, p2);
    return parts;
  }
  function expandTop(str2) {
    if (!str2)
      return [];
    if (str2.substr(0, 2) === "{}") {
      str2 = "\\{\\}" + str2.substr(2);
    }
    return expand(escapeBraces(str2), true).map(unescapeBraces);
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el2) {
    return /^-?0\d/.test(el2);
  }
  function lte(i, y2) {
    return i <= y2;
  }
  function gte(i, y2) {
    return i >= y2;
  }
  function expand(str2, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str2);
    if (!m2)
      return [str2];
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    if (/\$$/.test(m2.pre)) {
      for (var k2 = 0; k2 < post.length; k2++) {
        var expansion = pre + "{" + m2.body + "}" + post[k2];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m2.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m2.post.match(/,.*\}/)) {
          str2 = m2.pre + "{" + m2.body + escClose + m2.post;
          return expand(str2);
        }
        return [str2];
      }
      var n2;
      if (isSequence) {
        n2 = m2.body.split(/\.\./);
      } else {
        n2 = parseCommaParts(m2.body);
        if (n2.length === 1) {
          n2 = expand(n2[0], false).map(embrace);
          if (n2.length === 1) {
            return post.map(function(p2) {
              return m2.pre + n2[0] + p2;
            });
          }
        }
      }
      var N2;
      if (isSequence) {
        var x2 = numeric(n2[0]);
        var y2 = numeric(n2[1]);
        var width = Math.max(n2[0].length, n2[1].length);
        var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
        var test2 = lte;
        var reverse2 = y2 < x2;
        if (reverse2) {
          incr *= -1;
          test2 = gte;
        }
        var pad2 = n2.some(isPadded);
        N2 = [];
        for (var i = x2; test2(i, y2); i += incr) {
          var c2;
          if (isAlphaSequence) {
            c2 = String.fromCharCode(i);
            if (c2 === "\\")
              c2 = "";
          } else {
            c2 = String(i);
            if (pad2) {
              var need = width - c2.length;
              if (need > 0) {
                var z2 = new Array(need + 1).join("0");
                if (i < 0)
                  c2 = "-" + z2 + c2.slice(1);
                else
                  c2 = z2 + c2;
              }
            }
          }
          N2.push(c2);
        }
      } else {
        N2 = [];
        for (var j = 0; j < n2.length; j++) {
          N2.push.apply(N2, expand(n2[j], false));
        }
      }
      for (var j = 0; j < N2.length; j++) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + N2[j] + post[k2];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch)
    return minimatch_1;
  hasRequiredMinimatch = 1;
  const minimatch = minimatch_1 = (p2, pattern, options2 = {}) => {
    assertValidPattern(pattern);
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options2).match(p2);
  };
  minimatch_1 = minimatch;
  const path2 = requirePath();
  minimatch.sep = path2.sep;
  const GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  const expand = requireBraceExpansion();
  const plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  const qmark = "[^/]";
  const star = qmark + "*?";
  const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  const charSet = (s) => s.split("").reduce((set5, c2) => {
    set5[c2] = true;
    return set5;
  }, {});
  const reSpecials = charSet("().*{}+?[]^$\\!");
  const addPatternStartSet = charSet("[.(");
  const slashSplit = /\/+/;
  minimatch.filter = (pattern, options2 = {}) => (p2, i, list2) => minimatch(p2, pattern, options2);
  const ext = (a, b2 = {}) => {
    const t2 = {};
    Object.keys(a).forEach((k2) => t2[k2] = a[k2]);
    Object.keys(b2).forEach((k2) => t2[k2] = b2[k2]);
    return t2;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m2 = (p2, pattern, options2) => orig(p2, pattern, ext(def, options2));
    m2.Minimatch = class Minimatch extends orig.Minimatch {
      constructor(pattern, options2) {
        super(pattern, ext(def, options2));
      }
    };
    m2.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch;
    m2.filter = (pattern, options2) => orig.filter(pattern, ext(def, options2));
    m2.defaults = (options2) => orig.defaults(ext(def, options2));
    m2.makeRe = (pattern, options2) => orig.makeRe(pattern, ext(def, options2));
    m2.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext(def, options2));
    m2.match = (list2, pattern, options2) => orig.match(list2, pattern, ext(def, options2));
    return m2;
  };
  minimatch.braceExpand = (pattern, options2) => braceExpand(pattern, options2);
  const braceExpand = (pattern, options2 = {}) => {
    assertValidPattern(pattern);
    if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  const MAX_PATTERN_LENGTH = 1024 * 64;
  const assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  const SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options2) => new Minimatch(pattern, options2 || {}).makeRe();
  minimatch.match = (list2, pattern, options2 = {}) => {
    const mm = new Minimatch(pattern, options2);
    list2 = list2.filter((f2) => mm.match(f2));
    if (mm.options.nonull && !list2.length) {
      list2.push(pattern);
    }
    return list2;
  };
  const globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  const charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  const braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
  class Minimatch {
    constructor(pattern, options2) {
      assertValidPattern(pattern);
      if (!options2)
        options2 = {};
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options2.partial;
      this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern;
      const options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set5 = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set5);
      set5 = this.globParts = set5.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set5);
      set5 = set5.map((s, si2, set6) => s.map(this.parse, this));
      this.debug(this.pattern, set5);
      set5 = set5.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set5);
      this.set = set5;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const pattern = this.pattern;
      let negate2 = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate2 = !negate2;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate2;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial) {
      var options2 = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
        this.debug("matchOne loop");
        var p2 = pattern[pi2];
        var f2 = file[fi2];
        this.debug(pattern, p2, f2);
        if (p2 === false)
          return false;
        if (p2 === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p2, f2]);
          var fr = fi2;
          var pr = pi2 + 1;
          if (pr === pl2) {
            this.debug("** at the end");
            for (; fi2 < fl2; fi2++) {
              if (file[fi2] === "." || file[fi2] === ".." || !options2.dot && file[fi2].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl2) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl2, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl2)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p2 === "string") {
          hit = f2 === p2;
          this.debug("string match", p2, f2, hit);
        } else {
          hit = f2.match(p2);
          this.debug("pattern match", p2, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi2 === fl2 && pi2 === pl2) {
        return true;
      } else if (fi2 === fl2) {
        return partial;
      } else if (pi2 === pl2) {
        return fi2 === fl2 - 1 && file[fi2] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options2 = this.options;
      if (pattern === "**") {
        if (!options2.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      let re2 = "";
      let hasMagic = false;
      let escaping2 = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl2;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options2.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p2) => p2.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re2 += star;
              hasMagic = true;
              break;
            case "?":
              re2 += qmark;
              hasMagic = true;
              break;
            default:
              re2 += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re2);
          stateChar = false;
        }
      };
      for (let i = 0, c2; i < pattern.length && (c2 = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re2, c2);
        if (escaping2) {
          if (c2 === "/") {
            return false;
          }
          if (reSpecials[c2]) {
            re2 += "\\";
          }
          re2 += c2;
          escaping2 = false;
          continue;
        }
        switch (c2) {
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re2 += c2;
              continue;
            }
            clearStateChar();
            escaping2 = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re2, c2);
            if (inClass) {
              this.debug("  in class");
              if (c2 === "!" && i === classStart + 1)
                c2 = "^";
              re2 += c2;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c2;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re2 += "(";
              continue;
            }
            if (!stateChar) {
              re2 += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re2.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "	", plEntry);
            patternListStack.push(plEntry);
            re2 += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re2 += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re2);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re2 += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl2 = plEntry;
            re2 += pl2.close;
            if (pl2.type === "!") {
              negativeLists.push(Object.assign(pl2, { reEnd: re2.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re2 += "\\|";
              continue;
            }
            clearStateChar();
            re2 += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re2 += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          case "[":
            clearStateChar();
            if (inClass) {
              re2 += "\\" + c2;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re2.length;
            re2 += c2;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re2 += "\\" + c2;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re2 += c2;
            } catch (er) {
              re2 = re2.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c2] && !(c2 === "^" && inClass)) {
              re2 += "\\";
            }
            re2 += c2;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re2 = re2.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl2 = patternListStack.pop(); pl2; pl2 = patternListStack.pop()) {
        let tail;
        tail = re2.slice(pl2.reStart + pl2.open.length);
        this.debug("setting tail", re2, pl2);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl2, re2);
        const t2 = pl2.type === "*" ? star : pl2.type === "?" ? qmark : "\\" + pl2.type;
        hasMagic = true;
        re2 = re2.slice(0, pl2.reStart) + t2 + "\\(" + tail;
      }
      clearStateChar();
      if (escaping2) {
        re2 += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re2.charAt(0)];
      for (let n2 = negativeLists.length - 1; n2 > -1; n2--) {
        const nl2 = negativeLists[n2];
        const nlBefore = re2.slice(0, nl2.reStart);
        const nlFirst = re2.slice(nl2.reStart, nl2.reEnd - 8);
        let nlAfter = re2.slice(nl2.reEnd);
        const nlLast = re2.slice(nl2.reEnd - 8, nl2.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re2 = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re2 !== "" && hasMagic) {
        re2 = "(?=.)" + re2;
      }
      if (addPatternStart) {
        re2 = patternStart() + re2;
      }
      if (isSub === SUBPARSE) {
        return [re2, hasMagic];
      }
      if (options2.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options2.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re2 + "$", flags), {
          _glob: pattern,
          _src: re2
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set5 = this.set;
      if (!set5.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options2 = this.options;
      const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      const flags = options2.nocase ? "i" : "";
      let re2 = set5.map((pattern) => {
        pattern = pattern.map(
          (p2) => typeof p2 === "string" ? regExpEscape(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src
        ).reduce((set6, p2) => {
          if (!(set6[set6.length - 1] === GLOBSTAR && p2 === GLOBSTAR)) {
            set6.push(p2);
          }
          return set6;
        }, []);
        pattern.forEach((p2, i) => {
          if (p2 !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p2) => p2 !== GLOBSTAR).join("/");
      }).join("|");
      re2 = "^(?:" + re2 + ")$";
      if (this.negate)
        re2 = "^(?!" + re2 + ").*$";
      try {
        this.regexp = new RegExp(re2, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f2, partial = this.partial) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial)
        return true;
      const options2 = this.options;
      if (path2.sep !== "/") {
        f2 = f2.split(path2.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      const set5 = this.set;
      this.debug(this.pattern, "set", set5);
      let filename;
      for (let i = f2.length - 1; i >= 0; i--) {
        filename = f2[i];
        if (filename)
          break;
      }
      for (let i = 0; i < set5.length; i++) {
        const pattern = set5[i];
        let file = f2;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
  return minimatch_1;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pluralize = { exports: {} };
var hasRequiredPluralize;
function requirePluralize() {
  if (hasRequiredPluralize)
    return pluralize.exports;
  hasRequiredPluralize = 1;
  (function(module, exports) {
    (function(root, pluralize2) {
      if (typeof commonjsRequire === "function" && true && true) {
        module.exports = pluralize2();
      } else {
        root.pluralize = pluralize2();
      }
    })(commonjsGlobal, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2)
          return token2;
        if (word === word.toLowerCase())
          return token2.toLowerCase();
        if (word === word.toUpperCase())
          return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate2(str2, args) {
        return str2.replace(/\$(\d{1,2})/g, function(match2, index2) {
          return args[index2] || "";
        });
      }
      function replace3(word, rule) {
        return word.replace(rule[0], function(match2, index2) {
          var result = interpolate2(rule[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match2, result);
        });
      }
      function sanitizeWord(token2, word, rules2) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules2.length;
        while (len--) {
          var rule = rules2[len];
          if (rule[0].test(word))
            return replace3(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules2) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules2);
        };
      }
      function checkWord(replaceMap, keepMap, rules2, bool2) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2))
            return true;
          if (replaceMap.hasOwnProperty(token2))
            return false;
          return sanitizeWord(token2, token2, rules2) === token2;
        };
      }
      function pluralize2(word, count2, inclusive) {
        var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count2 + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[e]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  })(pluralize);
  return pluralize.exports;
}
var jsYaml$1 = {};
var jsYaml = {};
var loader = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray2(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend(target, source) {
    var index2, length2, key2, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index2 = 0, length2 = sourceKeys.length; index2 < length2; index2 += 1) {
        key2 = sourceKeys[index2];
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function repeat(string2, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1) {
      result += string2;
    }
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  common.isNothing = isNothing;
  common.isObject = isObject2;
  common.toArray = toArray2;
  common.repeat = repeat;
  common.isNegativeZero = isNegativeZero;
  common.extend = extend;
  return common;
}
var exception;
var hasRequiredException;
function requireException() {
  if (hasRequiredException)
    return exception;
  hasRequiredException = 1;
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark)
      return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException(reason, mark2) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark2;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString2(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  exception = YAMLException;
  return exception;
}
var snippet;
var hasRequiredSnippet;
function requireSnippet() {
  if (hasRequiredSnippet)
    return snippet;
  hasRequiredSnippet = 1;
  var common2 = requireCommon();
  function getLine2(buffer, lineStart, lineEnd, position2, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position2 - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position2 - maxHalfLength + head.length;
    }
    if (lineEnd - position2 > maxHalfLength) {
      tail = " ...";
      lineEnd = position2 + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
      pos: position2 - lineStart + head.length
      // relative position
    };
  }
  function padStart(string2, max2) {
    return common2.repeat(" ", max2 - string2.length) + string2;
  }
  function makeSnippet(mark2, options2) {
    options2 = Object.create(options2 || null);
    if (!mark2.buffer)
      return null;
    if (!options2.maxLength)
      options2.maxLength = 79;
    if (typeof options2.indent !== "number")
      options2.indent = 1;
    if (typeof options2.linesBefore !== "number")
      options2.linesBefore = 3;
    if (typeof options2.linesAfter !== "number")
      options2.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match2;
    var foundLineNo = -1;
    while (match2 = re2.exec(mark2.buffer)) {
      lineEnds.push(match2.index);
      lineStarts.push(match2.index + match2[0].length);
      if (mark2.position <= match2.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0)
      foundLineNo = lineStarts.length - 1;
    var result = "", i, line2;
    var lineNoLength = Math.min(mark2.line + options2.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
    for (i = 1; i <= options2.linesBefore; i++) {
      if (foundLineNo - i < 0)
        break;
      line2 = getLine2(
        mark2.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common2.repeat(" ", options2.indent) + padStart((mark2.line - i + 1).toString(), lineNoLength) + " | " + line2.str + "\n" + result;
    }
    line2 = getLine2(mark2.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark2.position, maxLineLength);
    result += common2.repeat(" ", options2.indent) + padStart((mark2.line + 1).toString(), lineNoLength) + " | " + line2.str + "\n";
    result += common2.repeat("-", options2.indent + lineNoLength + 3 + line2.pos) + "^\n";
    for (i = 1; i <= options2.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length)
        break;
      line2 = getLine2(
        mark2.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common2.repeat(" ", options2.indent) + padStart((mark2.line + i + 1).toString(), lineNoLength) + " | " + line2.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  snippet = makeSnippet;
  return snippet;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType)
    return type;
  hasRequiredType = 1;
  var YAMLException = requireException();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map3) {
    var result = {};
    if (map3 !== null) {
      Object.keys(map3).forEach(function(style) {
        map3[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type2(tag, options2) {
    options2 = options2 || {};
    Object.keys(options2).forEach(function(name2) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
        throw new YAMLException('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options2;
    this.tag = tag;
    this.kind = options2["kind"] || null;
    this.resolve = options2["resolve"] || function() {
      return true;
    };
    this.construct = options2["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options2["instanceOf"] || null;
    this.predicate = options2["predicate"] || null;
    this.represent = options2["represent"] || null;
    this.representName = options2["representName"] || null;
    this.defaultStyle = options2["defaultStyle"] || null;
    this.multi = options2["multi"] || false;
    this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  type = Type2;
  return type;
}
var schema$3;
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema)
    return schema$3;
  hasRequiredSchema = 1;
  var YAMLException = requireException();
  var Type2 = requireType();
  function compileList(schema2, name2) {
    var result = [];
    schema2[name2].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index2, length2;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index2 = 0, length2 = arguments.length; index2 < length2; index2 += 1) {
      arguments[index2].forEach(collectType);
    }
    return result;
  }
  function Schema2(definition) {
    return this.extend(definition);
  }
  Schema2.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof Type2) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit)
        implicit = implicit.concat(definition.implicit);
      if (definition.explicit)
        explicit = explicit.concat(definition.explicit);
    } else {
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type2)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type2.loadKind && type2.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type2.multi) {
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type2) {
      if (!(type2 instanceof Type2)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema2.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  schema$3 = Schema2;
  return schema$3;
}
var str;
var hasRequiredStr;
function requireStr() {
  if (hasRequiredStr)
    return str;
  hasRequiredStr = 1;
  var Type2 = requireType();
  str = new Type2("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  return str;
}
var seq$1;
var hasRequiredSeq;
function requireSeq() {
  if (hasRequiredSeq)
    return seq$1;
  hasRequiredSeq = 1;
  var Type2 = requireType();
  seq$1 = new Type2("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  return seq$1;
}
var map$1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map$1;
  hasRequiredMap = 1;
  var Type2 = requireType();
  map$1 = new Type2("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  return map$1;
}
var failsafe;
var hasRequiredFailsafe;
function requireFailsafe() {
  if (hasRequiredFailsafe)
    return failsafe;
  hasRequiredFailsafe = 1;
  var Schema2 = requireSchema();
  failsafe = new Schema2({
    explicit: [
      requireStr(),
      requireSeq(),
      requireMap()
    ]
  });
  return failsafe;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  var Type2 = requireType();
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object2) {
    return object2 === null;
  }
  _null = new Type2("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  return _null;
}
var bool;
var hasRequiredBool;
function requireBool() {
  if (hasRequiredBool)
    return bool;
  hasRequiredBool = 1;
  var Type2 = requireType();
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean2(object2) {
    return Object.prototype.toString.call(object2) === "[object Boolean]";
  }
  bool = new Type2("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean2,
    represent: {
      lowercase: function(object2) {
        return object2 ? "true" : "false";
      },
      uppercase: function(object2) {
        return object2 ? "TRUE" : "FALSE";
      },
      camelcase: function(object2) {
        return object2 ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  return bool;
}
var int$2;
var hasRequiredInt;
function requireInt() {
  if (hasRequiredInt)
    return int$2;
  hasRequiredInt = 1;
  var common2 = requireCommon();
  var Type2 = requireType();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max2 = data.length, index2 = 0, hasDigits = false, ch2;
    if (!max2)
      return false;
    ch2 = data[index2];
    if (ch2 === "-" || ch2 === "+") {
      ch2 = data[++index2];
    }
    if (ch2 === "0") {
      if (index2 + 1 === max2)
        return true;
      ch2 = data[++index2];
      if (ch2 === "b") {
        index2++;
        for (; index2 < max2; index2++) {
          ch2 = data[index2];
          if (ch2 === "_")
            continue;
          if (ch2 !== "0" && ch2 !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      if (ch2 === "x") {
        index2++;
        for (; index2 < max2; index2++) {
          ch2 = data[index2];
          if (ch2 === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      if (ch2 === "o") {
        index2++;
        for (; index2 < max2; index2++) {
          ch2 = data[index2];
          if (ch2 === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
    }
    if (ch2 === "_")
      return false;
    for (; index2 < max2; index2++) {
      ch2 = data[index2];
      if (ch2 === "_")
        continue;
      if (!isDecCode(data.charCodeAt(index2))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch2 === "_")
      return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch2;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch2 = value[0];
    if (ch2 === "-" || ch2 === "+") {
      if (ch2 === "-")
        sign = -1;
      value = value.slice(1);
      ch2 = value[0];
    }
    if (value === "0")
      return 0;
    if (ch2 === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o")
        return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object2) {
    return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common2.isNegativeZero(object2));
  }
  int$2 = new Type2("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  return int$2;
}
var float$2;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat)
    return float$2;
  hasRequiredFloat = 1;
  var common2 = requireCommon();
  var Type2 = requireType();
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object2, style) {
    var res;
    if (isNaN(object2)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object2) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object2) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common2.isNegativeZero(object2)) {
      return "-0.0";
    }
    res = object2.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object2) {
    return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common2.isNegativeZero(object2));
  }
  float$2 = new Type2("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  return float$2;
}
var json$1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson)
    return json$1;
  hasRequiredJson = 1;
  json$1 = requireFailsafe().extend({
    implicit: [
      require_null(),
      requireBool(),
      requireInt(),
      requireFloat()
    ]
  });
  return json$1;
}
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core;
  hasRequiredCore = 1;
  core = requireJson();
  return core;
}
var timestamp$1;
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp)
    return timestamp$1;
  hasRequiredTimestamp = 1;
  var Type2 = requireType();
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match2 = YAML_DATE_REGEXP.exec(data);
    if (match2 === null)
      match2 = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match2 === null)
      throw new Error("Date resolve error");
    year = +match2[1];
    month = +match2[2] - 1;
    day = +match2[3];
    if (!match2[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match2[4];
    minute = +match2[5];
    second = +match2[6];
    if (match2[7]) {
      fraction = match2[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match2[9]) {
      tz_hour = +match2[10];
      tz_minute = +(match2[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match2[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object2) {
    return object2.toISOString();
  }
  timestamp$1 = new Type2("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  return timestamp$1;
}
var merge$1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge)
    return merge$1;
  hasRequiredMerge = 1;
  var Type2 = requireType();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  merge$1 = new Type2("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  return merge$1;
}
var binary$1;
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary)
    return binary$1;
  hasRequiredBinary = 1;
  var Type2 = requireType();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max2 = data.length, map3 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      code = map3.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map3 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map3.indexOf(input.charAt(idx));
    }
    tailbits = max2 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object2) {
    var result = "", bits = 0, idx, tail, max2 = object2.length, map3 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map3[bits >> 18 & 63];
        result += map3[bits >> 12 & 63];
        result += map3[bits >> 6 & 63];
        result += map3[bits & 63];
      }
      bits = (bits << 8) + object2[idx];
    }
    tail = max2 % 3;
    if (tail === 0) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    } else if (tail === 2) {
      result += map3[bits >> 10 & 63];
      result += map3[bits >> 4 & 63];
      result += map3[bits << 2 & 63];
      result += map3[64];
    } else if (tail === 1) {
      result += map3[bits >> 2 & 63];
      result += map3[bits << 4 & 63];
      result += map3[64];
      result += map3[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  binary$1 = new Type2("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  return binary$1;
}
var omap$1;
var hasRequiredOmap;
function requireOmap() {
  if (hasRequiredOmap)
    return omap$1;
  hasRequiredOmap = 1;
  var Type2 = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys2 = [], index2, length2, pair, pairKey, pairHasKey, object2 = data;
    for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
      pair = object2[index2];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys2.indexOf(pairKey) === -1)
        objectKeys2.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  omap$1 = new Type2("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  return omap$1;
}
var pairs$1;
var hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs)
    return pairs$1;
  hasRequiredPairs = 1;
  var Type2 = requireType();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index2, length2, pair, keys2, result, object2 = data;
    result = new Array(object2.length);
    for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
      pair = object2[index2];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys2 = Object.keys(pair);
      if (keys2.length !== 1)
        return false;
      result[index2] = [keys2[0], pair[keys2[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index2, length2, pair, keys2, result, object2 = data;
    result = new Array(object2.length);
    for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
      pair = object2[index2];
      keys2 = Object.keys(pair);
      result[index2] = [keys2[0], pair[keys2[0]]];
    }
    return result;
  }
  pairs$1 = new Type2("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  return pairs$1;
}
var set$3;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet)
    return set$3;
  hasRequiredSet = 1;
  var Type2 = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key2, object2 = data;
    for (key2 in object2) {
      if (_hasOwnProperty.call(object2, key2)) {
        if (object2[key2] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  set$3 = new Type2("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  return set$3;
}
var _default;
var hasRequired_default;
function require_default() {
  if (hasRequired_default)
    return _default;
  hasRequired_default = 1;
  _default = requireCore().extend({
    implicit: [
      requireTimestamp(),
      requireMerge()
    ],
    explicit: [
      requireBinary(),
      requireOmap(),
      requirePairs(),
      requireSet()
    ]
  });
  return _default;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader)
    return loader;
  hasRequiredLoader = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var makeSnippet = requireSnippet();
  var DEFAULT_SCHEMA = require_default();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc2;
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    lc2 = c2 | 32;
    if (97 <= lc2 && lc2 <= 102) {
      return lc2 - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c2) {
    if (c2 === 120) {
      return 2;
    }
    if (c2 === 117) {
      return 4;
    }
    if (c2 === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c2) {
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? "" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    if (c2 <= 65535) {
      return String.fromCharCode(c2);
    }
    return String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options2) {
    this.input = input;
    this.filename = options2["filename"] || null;
    this.schema = options2["schema"] || DEFAULT_SCHEMA;
    this.onWarning = options2["onWarning"] || null;
    this.legacy = options2["legacy"] || false;
    this.json = options2["json"] || false;
    this.listener = options2["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state2, message) {
    var mark2 = {
      name: state2.filename,
      buffer: state2.input.slice(0, -1),
      // omit trailing \0
      position: state2.position,
      line: state2.line,
      column: state2.position - state2.lineStart
    };
    mark2.snippet = makeSnippet(mark2);
    return new YAMLException(message, mark2);
  }
  function throwError(state2, message) {
    throw generateError(state2, message);
  }
  function throwWarning(state2, message) {
    if (state2.onWarning) {
      state2.onWarning.call(null, generateError(state2, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state2, name2, args) {
      var match2, major, minor;
      if (state2.version !== null) {
        throwError(state2, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state2, "YAML directive accepts exactly one argument");
      }
      match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match2 === null) {
        throwError(state2, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match2[1], 10);
      minor = parseInt(match2[2], 10);
      if (major !== 1) {
        throwError(state2, "unacceptable YAML version of the document");
      }
      state2.version = args[0];
      state2.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state2, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state2, name2, args) {
      var handle, prefix2;
      if (args.length !== 2) {
        throwError(state2, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix2 = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state2.tagMap, handle)) {
        throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix2)) {
        throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix2 = decodeURIComponent(prefix2);
      } catch (err) {
        throwError(state2, "tag prefix is malformed: " + prefix2);
      }
      state2.tagMap[handle] = prefix2;
    }
  };
  function captureSegment(state2, start2, end2, checkJson) {
    var _position, _length, _character, _result;
    if (start2 < end2) {
      _result = state2.input.slice(start2, end2);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state2, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state2, "the stream contains non-printable characters");
      }
      state2.result += _result;
    }
  }
  function mergeMappings(state2, destination, source, overridableKeys) {
    var sourceKeys, key2, index2, quantity;
    if (!common2.isObject(source)) {
      throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
      key2 = sourceKeys[index2];
      if (!_hasOwnProperty.call(destination, key2)) {
        destination[key2] = source[key2];
        overridableKeys[key2] = true;
      }
    }
  }
  function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index2, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
        if (Array.isArray(keyNode[index2])) {
          throwError(state2, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
          keyNode[index2] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
          mergeMappings(state2, _result, valueNode[index2], overridableKeys);
        }
      } else {
        mergeMappings(state2, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state2.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state2.line = startLine || state2.line;
        state2.lineStart = startLineStart || state2.lineStart;
        state2.position = startPos || state2.position;
        throwError(state2, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state2) {
    var ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 === 10) {
      state2.position++;
    } else if (ch2 === 13) {
      state2.position++;
      if (state2.input.charCodeAt(state2.position) === 10) {
        state2.position++;
      }
    } else {
      throwError(state2, "a line break is expected");
    }
    state2.line += 1;
    state2.lineStart = state2.position;
    state2.firstTabInLine = -1;
  }
  function skipSeparationSpace(state2, allowComments, checkIndent) {
    var lineBreaks = 0, ch2 = state2.input.charCodeAt(state2.position);
    while (ch2 !== 0) {
      while (is_WHITE_SPACE(ch2)) {
        if (ch2 === 9 && state2.firstTabInLine === -1) {
          state2.firstTabInLine = state2.position;
        }
        ch2 = state2.input.charCodeAt(++state2.position);
      }
      if (allowComments && ch2 === 35) {
        do {
          ch2 = state2.input.charCodeAt(++state2.position);
        } while (ch2 !== 10 && ch2 !== 13 && ch2 !== 0);
      }
      if (is_EOL(ch2)) {
        readLineBreak(state2);
        ch2 = state2.input.charCodeAt(state2.position);
        lineBreaks++;
        state2.lineIndent = 0;
        while (ch2 === 32) {
          state2.lineIndent++;
          ch2 = state2.input.charCodeAt(++state2.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
      throwWarning(state2, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state2) {
    var _position = state2.position, ch2;
    ch2 = state2.input.charCodeAt(_position);
    if ((ch2 === 45 || ch2 === 46) && ch2 === state2.input.charCodeAt(_position + 1) && ch2 === state2.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch2 = state2.input.charCodeAt(_position);
      if (ch2 === 0 || is_WS_OR_EOL(ch2)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state2, count2) {
    if (count2 === 1) {
      state2.result += " ";
    } else if (count2 > 1) {
      state2.result += common2.repeat("\n", count2 - 1);
    }
  }
  function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (is_WS_OR_EOL(ch2) || is_FLOW_INDICATOR(ch2) || ch2 === 35 || ch2 === 38 || ch2 === 42 || ch2 === 33 || ch2 === 124 || ch2 === 62 || ch2 === 39 || ch2 === 34 || ch2 === 37 || ch2 === 64 || ch2 === 96) {
      return false;
    }
    if (ch2 === 63 || ch2 === 45) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state2.kind = "scalar";
    state2.result = "";
    captureStart = captureEnd = state2.position;
    hasPendingContent = false;
    while (ch2 !== 0) {
      if (ch2 === 58) {
        following = state2.input.charCodeAt(state2.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch2 === 35) {
        preceding = state2.input.charCodeAt(state2.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch2)) {
        break;
      } else if (is_EOL(ch2)) {
        _line = state2.line;
        _lineStart = state2.lineStart;
        _lineIndent = state2.lineIndent;
        skipSeparationSpace(state2, false, -1);
        if (state2.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch2 = state2.input.charCodeAt(state2.position);
          continue;
        } else {
          state2.position = captureEnd;
          state2.line = _line;
          state2.lineStart = _lineStart;
          state2.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state2, captureStart, captureEnd, false);
        writeFoldedLines(state2, state2.line - _line);
        captureStart = captureEnd = state2.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch2)) {
        captureEnd = state2.position + 1;
      }
      ch2 = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, captureEnd, false);
    if (state2.result) {
      return true;
    }
    state2.kind = _kind;
    state2.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state2, nodeIndent) {
    var ch2, captureStart, captureEnd;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 !== 39) {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    state2.position++;
    captureStart = captureEnd = state2.position;
    while ((ch2 = state2.input.charCodeAt(state2.position)) !== 0) {
      if (ch2 === 39) {
        captureSegment(state2, captureStart, state2.position, true);
        ch2 = state2.input.charCodeAt(++state2.position);
        if (ch2 === 39) {
          captureStart = state2.position;
          state2.position++;
          captureEnd = state2.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch2)) {
        captureSegment(state2, captureStart, captureEnd, true);
        writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
        captureStart = captureEnd = state2.position;
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
        throwError(state2, "unexpected end of the document within a single quoted scalar");
      } else {
        state2.position++;
        captureEnd = state2.position;
      }
    }
    throwError(state2, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state2, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 !== 34) {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    state2.position++;
    captureStart = captureEnd = state2.position;
    while ((ch2 = state2.input.charCodeAt(state2.position)) !== 0) {
      if (ch2 === 34) {
        captureSegment(state2, captureStart, state2.position, true);
        state2.position++;
        return true;
      } else if (ch2 === 92) {
        captureSegment(state2, captureStart, state2.position, true);
        ch2 = state2.input.charCodeAt(++state2.position);
        if (is_EOL(ch2)) {
          skipSeparationSpace(state2, false, nodeIndent);
        } else if (ch2 < 256 && simpleEscapeCheck[ch2]) {
          state2.result += simpleEscapeMap[ch2];
          state2.position++;
        } else if ((tmp = escapedHexLen(ch2)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch2 = state2.input.charCodeAt(++state2.position);
            if ((tmp = fromHexCode(ch2)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state2, "expected hexadecimal character");
            }
          }
          state2.result += charFromCodepoint(hexResult);
          state2.position++;
        } else {
          throwError(state2, "unknown escape sequence");
        }
        captureStart = captureEnd = state2.position;
      } else if (is_EOL(ch2)) {
        captureSegment(state2, captureStart, captureEnd, true);
        writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
        captureStart = captureEnd = state2.position;
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
        throwError(state2, "unexpected end of the document within a double quoted scalar");
      } else {
        state2.position++;
        captureEnd = state2.position;
      }
    }
    throwError(state2, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state2, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair2, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch2 === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch2 = state2.input.charCodeAt(++state2.position);
    while (ch2 !== 0) {
      skipSeparationSpace(state2, true, nodeIndent);
      ch2 = state2.input.charCodeAt(state2.position);
      if (ch2 === terminator) {
        state2.position++;
        state2.tag = _tag;
        state2.anchor = _anchor;
        state2.kind = isMapping ? "mapping" : "sequence";
        state2.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state2, "missed comma between flow collection entries");
      } else if (ch2 === 44) {
        throwError(state2, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair2 = isExplicitPair = false;
      if (ch2 === 63) {
        following = state2.input.charCodeAt(state2.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair2 = isExplicitPair = true;
          state2.position++;
          skipSeparationSpace(state2, true, nodeIndent);
        }
      }
      _line = state2.line;
      _lineStart = state2.lineStart;
      _pos = state2.position;
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state2.tag;
      keyNode = state2.result;
      skipSeparationSpace(state2, true, nodeIndent);
      ch2 = state2.input.charCodeAt(state2.position);
      if ((isExplicitPair || state2.line === _line) && ch2 === 58) {
        isPair2 = true;
        ch2 = state2.input.charCodeAt(++state2.position);
        skipSeparationSpace(state2, true, nodeIndent);
        composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state2.result;
      }
      if (isMapping) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair2) {
        _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state2, true, nodeIndent);
      ch2 = state2.input.charCodeAt(state2.position);
      if (ch2 === 44) {
        readNext = true;
        ch2 = state2.input.charCodeAt(++state2.position);
      } else {
        readNext = false;
      }
    }
    throwError(state2, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state2, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 === 124) {
      folding = false;
    } else if (ch2 === 62) {
      folding = true;
    } else {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    while (ch2 !== 0) {
      ch2 = state2.input.charCodeAt(++state2.position);
      if (ch2 === 43 || ch2 === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch2 === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state2, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch2)) >= 0) {
        if (tmp === 0) {
          throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state2, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch2)) {
      do {
        ch2 = state2.input.charCodeAt(++state2.position);
      } while (is_WHITE_SPACE(ch2));
      if (ch2 === 35) {
        do {
          ch2 = state2.input.charCodeAt(++state2.position);
        } while (!is_EOL(ch2) && ch2 !== 0);
      }
    }
    while (ch2 !== 0) {
      readLineBreak(state2);
      state2.lineIndent = 0;
      ch2 = state2.input.charCodeAt(state2.position);
      while ((!detectedIndent || state2.lineIndent < textIndent) && ch2 === 32) {
        state2.lineIndent++;
        ch2 = state2.input.charCodeAt(++state2.position);
      }
      if (!detectedIndent && state2.lineIndent > textIndent) {
        textIndent = state2.lineIndent;
      }
      if (is_EOL(ch2)) {
        emptyLines++;
        continue;
      }
      if (state2.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state2.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state2.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch2)) {
          atMoreIndented = true;
          state2.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state2.result += common2.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state2.result += " ";
          }
        } else {
          state2.result += common2.repeat("\n", emptyLines);
        }
      } else {
        state2.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state2.position;
      while (!is_EOL(ch2) && ch2 !== 0) {
        ch2 = state2.input.charCodeAt(++state2.position);
      }
      captureSegment(state2, captureStart, state2.position, false);
    }
    return true;
  }
  function readBlockSequence(state2, nodeIndent) {
    var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch2;
    if (state2.firstTabInLine !== -1)
      return false;
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch2 = state2.input.charCodeAt(state2.position);
    while (ch2 !== 0) {
      if (state2.firstTabInLine !== -1) {
        state2.position = state2.firstTabInLine;
        throwError(state2, "tab characters must not be used in indentation");
      }
      if (ch2 !== 45) {
        break;
      }
      following = state2.input.charCodeAt(state2.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state2.position++;
      if (skipSeparationSpace(state2, true, -1)) {
        if (state2.lineIndent <= nodeIndent) {
          _result.push(null);
          ch2 = state2.input.charCodeAt(state2.position);
          continue;
        }
      }
      _line = state2.line;
      composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state2.result);
      skipSeparationSpace(state2, true, -1);
      ch2 = state2.input.charCodeAt(state2.position);
      if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch2 !== 0) {
        throwError(state2, "bad indentation of a sequence entry");
      } else if (state2.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = "sequence";
      state2.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state2, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch2;
    if (state2.firstTabInLine !== -1)
      return false;
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch2 = state2.input.charCodeAt(state2.position);
    while (ch2 !== 0) {
      if (!atExplicitKey && state2.firstTabInLine !== -1) {
        state2.position = state2.firstTabInLine;
        throwError(state2, "tab characters must not be used in indentation");
      }
      following = state2.input.charCodeAt(state2.position + 1);
      _line = state2.line;
      if ((ch2 === 63 || ch2 === 58) && is_WS_OR_EOL(following)) {
        if (ch2 === 63) {
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state2.position += 1;
        ch2 = following;
      } else {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
        if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state2.line === _line) {
          ch2 = state2.input.charCodeAt(state2.position);
          while (is_WHITE_SPACE(ch2)) {
            ch2 = state2.input.charCodeAt(++state2.position);
          }
          if (ch2 === 58) {
            ch2 = state2.input.charCodeAt(++state2.position);
            if (!is_WS_OR_EOL(ch2)) {
              throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state2.tag;
            keyNode = state2.result;
          } else if (detected) {
            throwError(state2, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state2.tag = _tag;
            state2.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      }
      if (state2.line === _line || state2.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state2.line;
          _keyLineStart = state2.lineStart;
          _keyPos = state2.position;
        }
        if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state2.result;
          } else {
            valueNode = state2.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state2, true, -1);
        ch2 = state2.input.charCodeAt(state2.position);
      }
      if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch2 !== 0) {
        throwError(state2, "bad indentation of a mapping entry");
      } else if (state2.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = "mapping";
      state2.result = _result;
    }
    return detected;
  }
  function readTagProperty(state2) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 !== 33)
      return false;
    if (state2.tag !== null) {
      throwError(state2, "duplication of a tag property");
    }
    ch2 = state2.input.charCodeAt(++state2.position);
    if (ch2 === 60) {
      isVerbatim = true;
      ch2 = state2.input.charCodeAt(++state2.position);
    } else if (ch2 === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch2 = state2.input.charCodeAt(++state2.position);
    } else {
      tagHandle = "!";
    }
    _position = state2.position;
    if (isVerbatim) {
      do {
        ch2 = state2.input.charCodeAt(++state2.position);
      } while (ch2 !== 0 && ch2 !== 62);
      if (state2.position < state2.length) {
        tagName = state2.input.slice(_position, state2.position);
        ch2 = state2.input.charCodeAt(++state2.position);
      } else {
        throwError(state2, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        if (ch2 === 33) {
          if (!isNamed) {
            tagHandle = state2.input.slice(_position - 1, state2.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state2, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state2.position + 1;
          } else {
            throwError(state2, "tag suffix cannot contain exclamation marks");
          }
        }
        ch2 = state2.input.charCodeAt(++state2.position);
      }
      tagName = state2.input.slice(_position, state2.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state2, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state2, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state2, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state2.tag = tagName;
    } else if (_hasOwnProperty.call(state2.tagMap, tagHandle)) {
      state2.tag = state2.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state2.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state2.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state2) {
    var _position, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 !== 38)
      return false;
    if (state2.anchor !== null) {
      throwError(state2, "duplication of an anchor property");
    }
    ch2 = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state2.input.charCodeAt(++state2.position);
    }
    if (state2.position === _position) {
      throwError(state2, "name of an anchor node must contain at least one character");
    }
    state2.anchor = state2.input.slice(_position, state2.position);
    return true;
  }
  function readAlias(state2) {
    var _position, alias, ch2;
    ch2 = state2.input.charCodeAt(state2.position);
    if (ch2 !== 42)
      return false;
    ch2 = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state2.input.charCodeAt(++state2.position);
    }
    if (state2.position === _position) {
      throwError(state2, "name of an alias node must contain at least one character");
    }
    alias = state2.input.slice(_position, state2.position);
    if (!_hasOwnProperty.call(state2.anchorMap, alias)) {
      throwError(state2, 'unidentified alias "' + alias + '"');
    }
    state2.result = state2.anchorMap[alias];
    skipSeparationSpace(state2, true, -1);
    return true;
  }
  function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state2.listener !== null) {
      state2.listener("open", state2);
    }
    state2.tag = null;
    state2.anchor = null;
    state2.kind = null;
    state2.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state2) || readAnchorProperty(state2)) {
        if (skipSeparationSpace(state2, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state2.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state2.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state2.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state2.position - state2.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state2)) {
            hasContent = true;
            if (state2.tag !== null || state2.anchor !== null) {
              throwError(state2, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state2.tag === null) {
              state2.tag = "?";
            }
          }
          if (state2.anchor !== null) {
            state2.anchorMap[state2.anchor] = state2.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
      }
    }
    if (state2.tag === null) {
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    } else if (state2.tag === "?") {
      if (state2.result !== null && state2.kind !== "scalar") {
        throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state2.implicitTypes[typeIndex];
        if (type2.resolve(state2.result)) {
          state2.result = type2.construct(state2.result);
          state2.tag = type2.tag;
          if (state2.anchor !== null) {
            state2.anchorMap[state2.anchor] = state2.result;
          }
          break;
        }
      }
    } else if (state2.tag !== "!") {
      if (_hasOwnProperty.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
        type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
      } else {
        type2 = null;
        typeList = state2.typeMap.multi[state2.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state2, "unknown tag !<" + state2.tag + ">");
      }
      if (state2.result !== null && type2.kind !== state2.kind) {
        throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
      }
      if (!type2.resolve(state2.result, state2.tag)) {
        throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
      } else {
        state2.result = type2.construct(state2.result, state2.tag);
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    }
    if (state2.listener !== null) {
      state2.listener("close", state2);
    }
    return state2.tag !== null || state2.anchor !== null || hasContent;
  }
  function readDocument(state2) {
    var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch2;
    state2.version = null;
    state2.checkLineBreaks = state2.legacy;
    state2.tagMap = /* @__PURE__ */ Object.create(null);
    state2.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch2 = state2.input.charCodeAt(state2.position)) !== 0) {
      skipSeparationSpace(state2, true, -1);
      ch2 = state2.input.charCodeAt(state2.position);
      if (state2.lineIndent > 0 || ch2 !== 37) {
        break;
      }
      hasDirectives = true;
      ch2 = state2.input.charCodeAt(++state2.position);
      _position = state2.position;
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        ch2 = state2.input.charCodeAt(++state2.position);
      }
      directiveName = state2.input.slice(_position, state2.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state2, "directive name must not be less than one character in length");
      }
      while (ch2 !== 0) {
        while (is_WHITE_SPACE(ch2)) {
          ch2 = state2.input.charCodeAt(++state2.position);
        }
        if (ch2 === 35) {
          do {
            ch2 = state2.input.charCodeAt(++state2.position);
          } while (ch2 !== 0 && !is_EOL(ch2));
          break;
        }
        if (is_EOL(ch2))
          break;
        _position = state2.position;
        while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
          ch2 = state2.input.charCodeAt(++state2.position);
        }
        directiveArgs.push(state2.input.slice(_position, state2.position));
      }
      if (ch2 !== 0)
        readLineBreak(state2);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state2, directiveName, directiveArgs);
      } else {
        throwWarning(state2, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state2, true, -1);
    if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    } else if (hasDirectives) {
      throwError(state2, "directives end mark is expected");
    }
    composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state2, true, -1);
    if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
      throwWarning(state2, "non-ASCII line breaks are interpreted as content");
    }
    state2.documents.push(state2.result);
    if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      if (state2.input.charCodeAt(state2.position) === 46) {
        state2.position += 3;
        skipSeparationSpace(state2, true, -1);
      }
      return;
    }
    if (state2.position < state2.length - 1) {
      throwError(state2, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options2) {
    input = String(input);
    options2 = options2 || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state2 = new State(input, options2);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state2.position = nullpos;
      throwError(state2, "null byte is not allowed in input");
    }
    state2.input += "\0";
    while (state2.input.charCodeAt(state2.position) === 32) {
      state2.lineIndent += 1;
      state2.position += 1;
    }
    while (state2.position < state2.length - 1) {
      readDocument(state2);
    }
    return state2.documents;
  }
  function loadAll(input, iterator, options2) {
    if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options2);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index2 = 0, length2 = documents.length; index2 < length2; index2 += 1) {
      iterator(documents[index2]);
    }
  }
  function load(input, options2) {
    var documents = loadDocuments(input, options2);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  loader.loadAll = loadAll;
  loader.load = load;
  return loader;
}
var dumper = {};
var hasRequiredDumper;
function requireDumper() {
  if (hasRequiredDumper)
    return dumper;
  hasRequiredDumper = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var DEFAULT_SCHEMA = require_default();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map3) {
    var result, keys2, index2, length2, tag, style, type2;
    if (map3 === null)
      return {};
    result = {};
    keys2 = Object.keys(map3);
    for (index2 = 0, length2 = keys2.length; index2 < length2; index2 += 1) {
      tag = keys2[index2];
      style = String(map3[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character2) {
    var string2, handle, length2;
    string2 = character2.toString(16).toUpperCase();
    if (character2 <= 255) {
      handle = "x";
      length2 = 2;
    } else if (character2 <= 65535) {
      handle = "u";
      length2 = 4;
    } else if (character2 <= 4294967295) {
      handle = "U";
      length2 = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common2.repeat("0", length2 - string2.length) + string2;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options2) {
    this.schema = options2["schema"] || DEFAULT_SCHEMA;
    this.indent = Math.max(1, options2["indent"] || 2);
    this.noArrayIndent = options2["noArrayIndent"] || false;
    this.skipInvalid = options2["skipInvalid"] || false;
    this.flowLevel = common2.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
    this.sortKeys = options2["sortKeys"] || false;
    this.lineWidth = options2["lineWidth"] || 80;
    this.noRefs = options2["noRefs"] || false;
    this.noCompatMode = options2["noCompatMode"] || false;
    this.condenseFlow = options2["condenseFlow"] || false;
    this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options2["forceQuotes"] || false;
    this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string2, spaces) {
    var ind = common2.repeat(" ", spaces), position2 = 0, next2 = -1, result = "", line2, length2 = string2.length;
    while (position2 < length2) {
      next2 = string2.indexOf("\n", position2);
      if (next2 === -1) {
        line2 = string2.slice(position2);
        position2 = length2;
      } else {
        line2 = string2.slice(position2, next2 + 1);
        position2 = next2 + 1;
      }
      if (line2.length && line2 !== "\n")
        result += ind;
      result += line2;
    }
    return result;
  }
  function generateNextLine(state2, level) {
    return "\n" + common2.repeat(" ", state2.indent * level);
  }
  function testImplicitResolving(state2, str2) {
    var index2, length2, type2;
    for (index2 = 0, length2 = state2.implicitTypes.length; index2 < length2; index2 += 1) {
      type2 = state2.implicitTypes[index2];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsCharOrWhitespace(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev2, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev2 === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev2) && !isWhitespace(prev2) && c2 === CHAR_SHARP || prev2 === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c2) {
    return !isWhitespace(c2) && c2 !== CHAR_COLON;
  }
  function codePointAt(string2, pos) {
    var first = string2.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
      second = string2.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string2) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string2);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char2 = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0; i < string2.length; char2 >= 65536 ? i += 2 : i++) {
        char2 = codePointAt(string2, i);
        if (!isPrintable(char2)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char2, prevChar, inblock);
        prevChar = char2;
      }
    } else {
      for (i = 0; i < string2.length; char2 >= 65536 ? i += 2 : i++) {
        char2 = codePointAt(string2, i);
        if (char2 === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char2)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char2, prevChar, inblock);
        prevChar = char2;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string2)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string2)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state2, string2, level, iskey, inblock) {
    state2.dump = function() {
      if (string2.length === 0) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state2.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
          return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
        }
      }
      var indent = state2.indent * Math.max(1, level);
      var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
      var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
      function testAmbiguity(string3) {
        return testImplicitResolving(state2, string3);
      }
      switch (chooseScalarStyle(
        string2,
        singleLineOnly,
        state2.indent,
        lineWidth,
        testAmbiguity,
        state2.quotingType,
        state2.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string2;
        case STYLE_SINGLE:
          return "'" + string2.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string2, state2.indent) + dropEndingNewline(indentString(string2, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string2, state2.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string2) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string2, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
    var clip = string2[string2.length - 1] === "\n";
    var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string2) {
    return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
  }
  function foldString(string2, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string2.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string2.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string2.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
    var moreIndented;
    var match2;
    while (match2 = lineRe.exec(string2)) {
      var prefix2 = match2[1], line2 = match2[2];
      moreIndented = line2[0] === " ";
      result += prefix2 + (!prevMoreIndented && !moreIndented && line2 !== "" ? "\n" : "") + foldLine(line2, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line2, width) {
    if (line2 === "" || line2[0] === " ")
      return line2;
    var breakRe = / [^ ]/g;
    var match2;
    var start2 = 0, end2, curr = 0, next2 = 0;
    var result = "";
    while (match2 = breakRe.exec(line2)) {
      next2 = match2.index;
      if (next2 - start2 > width) {
        end2 = curr > start2 ? curr : next2;
        result += "\n" + line2.slice(start2, end2);
        start2 = end2 + 1;
      }
      curr = next2;
    }
    result += "\n";
    if (line2.length - start2 > width && curr > start2) {
      result += line2.slice(start2, curr) + "\n" + line2.slice(curr + 1);
    } else {
      result += line2.slice(start2);
    }
    return result.slice(1);
  }
  function escapeString(string2) {
    var result = "";
    var char2 = 0;
    var escapeSeq;
    for (var i = 0; i < string2.length; char2 >= 65536 ? i += 2 : i++) {
      char2 = codePointAt(string2, i);
      escapeSeq = ESCAPE_SEQUENCES[char2];
      if (!escapeSeq && isPrintable(char2)) {
        result += string2[i];
        if (char2 >= 65536)
          result += string2[i + 1];
      } else {
        result += escapeSeq || encodeHex(char2);
      }
    }
    return result;
  }
  function writeFlowSequence(state2, level, object2) {
    var _result = "", _tag = state2.tag, index2, length2, value;
    for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
      value = object2[index2];
      if (state2.replacer) {
        value = state2.replacer.call(object2, String(index2), value);
      }
      if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
        if (_result !== "")
          _result += "," + (!state2.condenseFlow ? " " : "");
        _result += state2.dump;
      }
    }
    state2.tag = _tag;
    state2.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state2, level, object2, compact) {
    var _result = "", _tag = state2.tag, index2, length2, value;
    for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
      value = object2[index2];
      if (state2.replacer) {
        value = state2.replacer.call(object2, String(index2), value);
      }
      if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state2, level);
        }
        if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state2.dump;
      }
    }
    state2.tag = _tag;
    state2.dump = _result || "[]";
  }
  function writeFlowMapping(state2, level, object2) {
    var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object2), index2, length2, objectKey, objectValue, pairBuffer;
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (_result !== "")
        pairBuffer += ", ";
      if (state2.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index2];
      objectValue = object2[objectKey];
      if (state2.replacer) {
        objectValue = state2.replacer.call(object2, objectKey, objectValue);
      }
      if (!writeNode(state2, level, objectKey, false, false)) {
        continue;
      }
      if (state2.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
      if (!writeNode(state2, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state2.dump;
      _result += pairBuffer;
    }
    state2.tag = _tag;
    state2.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state2, level, object2, compact) {
    var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object2), index2, length2, objectKey, objectValue, explicitPair, pairBuffer;
    if (state2.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state2.sortKeys === "function") {
      objectKeyList.sort(state2.sortKeys);
    } else if (state2.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state2, level);
      }
      objectKey = objectKeyList[index2];
      objectValue = object2[objectKey];
      if (state2.replacer) {
        objectValue = state2.replacer.call(object2, objectKey, objectValue);
      }
      if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
      if (explicitPair) {
        if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state2.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state2, level);
      }
      if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state2.dump;
      _result += pairBuffer;
    }
    state2.tag = _tag;
    state2.dump = _result || "{}";
  }
  function detectType(state2, object2, explicit) {
    var _result, typeList, index2, length2, type2, style;
    typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
    for (index2 = 0, length2 = typeList.length; index2 < length2; index2 += 1) {
      type2 = typeList[index2];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state2.tag = type2.representName(object2);
          } else {
            state2.tag = type2.tag;
          }
        } else {
          state2.tag = "?";
        }
        if (type2.represent) {
          style = state2.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object2, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object2, style);
          } else {
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state2.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state2, level, object2, block, compact, iskey, isblockseq) {
    state2.tag = null;
    state2.dump = object2;
    if (!detectType(state2, object2, false)) {
      detectType(state2, object2, true);
    }
    var type2 = _toString.call(state2.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state2.flowLevel < 0 || state2.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state2.duplicates.indexOf(object2);
      duplicate = duplicateIndex !== -1;
    }
    if (state2.tag !== null && state2.tag !== "?" || duplicate || state2.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state2.usedDuplicates[duplicateIndex]) {
      state2.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state2.usedDuplicates[duplicateIndex]) {
        state2.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state2.dump).length !== 0) {
          writeBlockMapping(state2, level, state2.dump, compact);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + state2.dump;
          }
        } else {
          writeFlowMapping(state2, level, state2.dump);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state2.dump.length !== 0) {
          if (state2.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state2, level - 1, state2.dump, compact);
          } else {
            writeBlockSequence(state2, level, state2.dump, compact);
          }
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + state2.dump;
          }
        } else {
          writeFlowSequence(state2, level, state2.dump);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state2.tag !== "?") {
          writeScalar(state2, state2.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state2.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      if (state2.tag !== null && state2.tag !== "?") {
        tagStr = encodeURI(
          state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
        ).replace(/!/g, "%21");
        if (state2.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state2.dump = tagStr + " " + state2.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object2, state2) {
    var objects = [], duplicatesIndexes = [], index2, length2;
    inspectNode(object2, objects, duplicatesIndexes);
    for (index2 = 0, length2 = duplicatesIndexes.length; index2 < length2; index2 += 1) {
      state2.duplicates.push(objects[duplicatesIndexes[index2]]);
    }
    state2.usedDuplicates = new Array(length2);
  }
  function inspectNode(object2, objects, duplicatesIndexes) {
    var objectKeyList, index2, length2;
    if (object2 !== null && typeof object2 === "object") {
      index2 = objects.indexOf(object2);
      if (index2 !== -1) {
        if (duplicatesIndexes.indexOf(index2) === -1) {
          duplicatesIndexes.push(index2);
        }
      } else {
        objects.push(object2);
        if (Array.isArray(object2)) {
          for (index2 = 0, length2 = object2.length; index2 < length2; index2 += 1) {
            inspectNode(object2[index2], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object2);
          for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
            inspectNode(object2[objectKeyList[index2]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options2) {
    options2 = options2 || {};
    var state2 = new State(options2);
    if (!state2.noRefs)
      getDuplicateReferences(input, state2);
    var value = input;
    if (state2.replacer) {
      value = state2.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state2, 0, value, true, true))
      return state2.dump + "\n";
    return "";
  }
  dumper.dump = dump;
  return dumper;
}
var hasRequiredJsYaml$1;
function requireJsYaml$1() {
  if (hasRequiredJsYaml$1)
    return jsYaml;
  hasRequiredJsYaml$1 = 1;
  var loader2 = requireLoader();
  var dumper2 = requireDumper();
  function renamed(from2, to) {
    return function() {
      throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  jsYaml.Type = requireType();
  jsYaml.Schema = requireSchema();
  jsYaml.FAILSAFE_SCHEMA = requireFailsafe();
  jsYaml.JSON_SCHEMA = requireJson();
  jsYaml.CORE_SCHEMA = requireCore();
  jsYaml.DEFAULT_SCHEMA = require_default();
  jsYaml.load = loader2.load;
  jsYaml.loadAll = loader2.loadAll;
  jsYaml.dump = dumper2.dump;
  jsYaml.YAMLException = requireException();
  jsYaml.types = {
    binary: requireBinary(),
    float: requireFloat(),
    map: requireMap(),
    null: require_null(),
    pairs: requirePairs(),
    set: requireSet(),
    timestamp: requireTimestamp(),
    bool: requireBool(),
    int: requireInt(),
    merge: requireMerge(),
    omap: requireOmap(),
    seq: requireSeq(),
    str: requireStr()
  };
  jsYaml.safeLoad = renamed("safeLoad", "load");
  jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
  jsYaml.safeDump = renamed("safeDump", "dump");
  return jsYaml;
}
var hasRequiredJsYaml;
function requireJsYaml() {
  if (hasRequiredJsYaml)
    return jsYaml$1;
  hasRequiredJsYaml = 1;
  Object.defineProperty(jsYaml$1, "__esModule", { value: true });
  jsYaml$1.stringifyYaml = jsYaml$1.parseYaml = void 0;
  const js_yaml_1 = requireJsYaml$1();
  const DEFAULT_SCHEMA_WITHOUT_TIMESTAMP = js_yaml_1.JSON_SCHEMA.extend({
    implicit: [js_yaml_1.types.merge],
    explicit: [js_yaml_1.types.binary, js_yaml_1.types.omap, js_yaml_1.types.pairs, js_yaml_1.types.set]
  });
  const parseYaml = (str2, opts) => js_yaml_1.load(str2, Object.assign({ schema: DEFAULT_SCHEMA_WITHOUT_TIMESTAMP }, opts));
  jsYaml$1.parseYaml = parseYaml;
  const stringifyYaml = (obj, opts) => js_yaml_1.dump(obj, opts);
  jsYaml$1.stringifyYaml = stringifyYaml;
  return jsYaml$1;
}
var env$1 = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env$1;
  hasRequiredEnv = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.env = exports.isBrowser = void 0;
    exports.isBrowser = // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    typeof window !== "undefined" || typeof self !== "undefined" || typeof process === "undefined";
    exports.env = exports.isBrowser ? {} : process.env || {};
  })(env$1);
  return env$1;
}
var logger = {};
var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger)
    return logger;
  hasRequiredLogger = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = exports.colorize = exports.colorOptions = void 0;
    const colorette = require$$2;
    var colorette_1 = require$$2;
    Object.defineProperty(exports, "colorOptions", { enumerable: true, get: function() {
      return colorette_1.options;
    } });
    const env_1 = requireEnv();
    const utils_1 = requireUtils$1();
    exports.colorize = new Proxy(colorette, {
      get(target, prop) {
        if (env_1.isBrowser) {
          return utils_1.identity;
        }
        return target[prop];
      }
    });
    class Logger {
      stderr(str2) {
        return process.stderr.write(str2);
      }
      info(str2) {
        return env_1.isBrowser ? console.log(str2) : this.stderr(str2);
      }
      warn(str2) {
        return env_1.isBrowser ? console.warn(str2) : this.stderr(exports.colorize.yellow(str2));
      }
      error(str2) {
        return env_1.isBrowser ? console.error(str2) : this.stderr(exports.colorize.red(str2));
      }
    }
    exports.logger = new Logger();
  })(logger);
  return logger;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1)
    return utils$1;
  hasRequiredUtils$1 = 1;
  (function(exports) {
    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve28) {
          resolve28(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve28, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve28(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextTick = exports.pickDefined = exports.keysOf = exports.identity = exports.isTruthy = exports.showErrorForDeprecatedField = exports.showWarningForDeprecatedField = exports.doesYamlFileExist = exports.isCustomRuleId = exports.getMatchingStatusCodeRange = exports.assignExisting = exports.isNotString = exports.isString = exports.isNotEmptyObject = exports.slash = exports.isPathParameter = exports.yamlAndJsonSyncReader = exports.readFileAsStringSync = exports.isSingular = exports.validateMimeTypeOAS3 = exports.validateMimeType = exports.splitCamelCaseIntoWords = exports.omitObjectProps = exports.pickObjectProps = exports.readFileFromUrl = exports.isEmptyArray = exports.isEmptyObject = exports.isPlainObject = exports.isDefined = exports.loadYaml = exports.popStack = exports.pushStack = exports.stringifyYaml = exports.parseYaml = void 0;
    const fs = require$$2;
    const path_1 = requirePathBrowserify();
    const minimatch = requireMinimatch();
    const node_fetch_1 = require$$2;
    const pluralize2 = requirePluralize();
    const js_yaml_1 = requireJsYaml();
    const env_1 = requireEnv();
    const logger_1 = requireLogger();
    var js_yaml_2 = requireJsYaml();
    Object.defineProperty(exports, "parseYaml", { enumerable: true, get: function() {
      return js_yaml_2.parseYaml;
    } });
    Object.defineProperty(exports, "stringifyYaml", { enumerable: true, get: function() {
      return js_yaml_2.stringifyYaml;
    } });
    function pushStack(head, value) {
      return { prev: head, value };
    }
    exports.pushStack = pushStack;
    function popStack(head) {
      var _a4;
      return (_a4 = head === null || head === void 0 ? void 0 : head.prev) !== null && _a4 !== void 0 ? _a4 : null;
    }
    exports.popStack = popStack;
    function loadYaml(filename) {
      return __awaiter(this, void 0, void 0, function* () {
        const contents = yield fs.promises.readFile(filename, "utf-8");
        return js_yaml_1.parseYaml(contents);
      });
    }
    exports.loadYaml = loadYaml;
    function isDefined2(x2) {
      return x2 !== void 0;
    }
    exports.isDefined = isDefined2;
    function isPlainObject2(value) {
      return value !== null && typeof value === "object" && !Array.isArray(value);
    }
    exports.isPlainObject = isPlainObject2;
    function isEmptyObject2(value) {
      return isPlainObject2(value) && Object.keys(value).length === 0;
    }
    exports.isEmptyObject = isEmptyObject2;
    function isEmptyArray(value) {
      return Array.isArray(value) && value.length === 0;
    }
    exports.isEmptyArray = isEmptyArray;
    function readFileFromUrl(url, config2) {
      return __awaiter(this, void 0, void 0, function* () {
        const headers = {};
        for (const header of config2.headers) {
          if (match2(url, header.matches)) {
            headers[header.name] = header.envVariable !== void 0 ? env_1.env[header.envVariable] || "" : header.value;
          }
        }
        const req = yield (config2.customFetch || node_fetch_1.default)(url, {
          headers
        });
        if (!req.ok) {
          throw new Error(`Failed to load ${url}: ${req.status} ${req.statusText}`);
        }
        return { body: yield req.text(), mimeType: req.headers.get("content-type") };
      });
    }
    exports.readFileFromUrl = readFileFromUrl;
    function match2(url, pattern) {
      if (!pattern.match(/^https?:\/\//)) {
        url = url.replace(/^https?:\/\//, "");
      }
      return minimatch(url, pattern);
    }
    function pickObjectProps(object2, keys2) {
      return Object.fromEntries(keys2.filter((key2) => key2 in object2).map((key2) => [key2, object2[key2]]));
    }
    exports.pickObjectProps = pickObjectProps;
    function omitObjectProps(object2, keys2) {
      return Object.fromEntries(Object.entries(object2).filter(([key2]) => !keys2.includes(key2)));
    }
    exports.omitObjectProps = omitObjectProps;
    function splitCamelCaseIntoWords(str2) {
      const camel = str2.split(/(?:[-._])|([A-Z][a-z]+)/).filter(isTruthy).map((item) => item.toLocaleLowerCase());
      const caps = str2.split(/([A-Z]{2,})/).filter((e2) => e2 && e2 === e2.toUpperCase()).map((item) => item.toLocaleLowerCase());
      return /* @__PURE__ */ new Set([...camel, ...caps]);
    }
    exports.splitCamelCaseIntoWords = splitCamelCaseIntoWords;
    function validateMimeType({ type: type2, value }, { report, location }, allowedValues) {
      const ruleType = type2 === "consumes" ? "request" : "response";
      if (!allowedValues)
        throw new Error(`Parameter "allowedValues" is not provided for "${ruleType}-mime-type" rule`);
      if (!value[type2])
        return;
      for (const mime of value[type2]) {
        if (!allowedValues.includes(mime)) {
          report({
            message: `Mime type "${mime}" is not allowed`,
            location: location.child(value[type2].indexOf(mime)).key()
          });
        }
      }
    }
    exports.validateMimeType = validateMimeType;
    function validateMimeTypeOAS3({ type: type2, value }, { report, location }, allowedValues) {
      const ruleType = type2 === "consumes" ? "request" : "response";
      if (!allowedValues)
        throw new Error(`Parameter "allowedValues" is not provided for "${ruleType}-mime-type" rule`);
      if (!value.content)
        return;
      for (const mime of Object.keys(value.content)) {
        if (!allowedValues.includes(mime)) {
          report({
            message: `Mime type "${mime}" is not allowed`,
            location: location.child("content").child(mime).key()
          });
        }
      }
    }
    exports.validateMimeTypeOAS3 = validateMimeTypeOAS3;
    function isSingular(path2) {
      return pluralize2.isSingular(path2);
    }
    exports.isSingular = isSingular;
    function readFileAsStringSync(filePath) {
      return fs.readFileSync(filePath, "utf-8");
    }
    exports.readFileAsStringSync = readFileAsStringSync;
    function yamlAndJsonSyncReader(filePath) {
      const content = fs.readFileSync(filePath, "utf-8");
      return js_yaml_1.parseYaml(content);
    }
    exports.yamlAndJsonSyncReader = yamlAndJsonSyncReader;
    function isPathParameter(pathSegment) {
      return pathSegment.startsWith("{") && pathSegment.endsWith("}");
    }
    exports.isPathParameter = isPathParameter;
    function slash(path2) {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path2);
      if (isExtendedLengthPath) {
        return path2;
      }
      return path2.replace(/\\/g, "/");
    }
    exports.slash = slash;
    function isNotEmptyObject(obj) {
      return !!obj && Object.keys(obj).length > 0;
    }
    exports.isNotEmptyObject = isNotEmptyObject;
    function isString2(value) {
      return typeof value === "string";
    }
    exports.isString = isString2;
    function isNotString(value) {
      return !isString2(value);
    }
    exports.isNotString = isNotString;
    function assignExisting(target, obj) {
      for (const k2 of Object.keys(obj)) {
        if (target.hasOwnProperty(k2)) {
          target[k2] = obj[k2];
        }
      }
    }
    exports.assignExisting = assignExisting;
    function getMatchingStatusCodeRange(code) {
      return `${code}`.replace(/^(\d)\d\d$/, (_2, firstDigit) => `${firstDigit}XX`);
    }
    exports.getMatchingStatusCodeRange = getMatchingStatusCodeRange;
    function isCustomRuleId(id2) {
      return id2.includes("/");
    }
    exports.isCustomRuleId = isCustomRuleId;
    function doesYamlFileExist(filePath) {
      return (path_1.extname(filePath) === ".yaml" || path_1.extname(filePath) === ".yml") && fs.hasOwnProperty("existsSync") && fs.existsSync(filePath);
    }
    exports.doesYamlFileExist = doesYamlFileExist;
    function showWarningForDeprecatedField(deprecatedField, updatedField, updatedObject) {
      logger_1.logger.warn(`The '${logger_1.colorize.red(deprecatedField)}' field is deprecated. ${updatedField ? `Use ${logger_1.colorize.green(getUpdatedFieldName(updatedField, updatedObject))} instead. ` : ""}Read more about this change: https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties
`);
    }
    exports.showWarningForDeprecatedField = showWarningForDeprecatedField;
    function showErrorForDeprecatedField(deprecatedField, updatedField, updatedObject) {
      throw new Error(`Do not use '${deprecatedField}' field. ${updatedField ? `Use '${getUpdatedFieldName(updatedField, updatedObject)}' instead. ` : ""}
`);
    }
    exports.showErrorForDeprecatedField = showErrorForDeprecatedField;
    function isTruthy(value) {
      return !!value;
    }
    exports.isTruthy = isTruthy;
    function identity(value) {
      return value;
    }
    exports.identity = identity;
    function keysOf(obj) {
      if (!obj)
        return [];
      return Object.keys(obj);
    }
    exports.keysOf = keysOf;
    function pickDefined(obj) {
      if (!obj)
        return void 0;
      const res = {};
      for (const key2 in obj) {
        if (obj[key2] !== void 0) {
          res[key2] = obj[key2];
        }
      }
      return res;
    }
    exports.pickDefined = pickDefined;
    function nextTick() {
      new Promise((resolve28) => {
        setTimeout(resolve28);
      });
    }
    exports.nextTick = nextTick;
    function getUpdatedFieldName(updatedField, updatedObject) {
      return `${typeof updatedObject !== "undefined" ? `${updatedObject}.` : ""}${updatedField}`;
    }
  })(utils$1);
  return utils$1;
}
var hasRequiredRefUtils;
function requireRefUtils() {
  if (hasRequiredRefUtils)
    return refUtils;
  hasRequiredRefUtils = 1;
  Object.defineProperty(refUtils, "__esModule", { value: true });
  refUtils.isAnchor = refUtils.isMappingRef = refUtils.isAbsoluteUrl = refUtils.refBaseName = refUtils.pointerBaseName = refUtils.parsePointer = refUtils.parseRef = refUtils.escapePointer = refUtils.unescapePointer = refUtils.Location = refUtils.isRef = refUtils.joinPointer = void 0;
  const utils_1 = requireUtils$1();
  function joinPointer(base, key2) {
    if (base === "")
      base = "#/";
    return base[base.length - 1] === "/" ? base + key2 : base + "/" + key2;
  }
  refUtils.joinPointer = joinPointer;
  function isRef(node2) {
    return node2 && typeof node2.$ref === "string";
  }
  refUtils.isRef = isRef;
  class Location {
    constructor(source, pointer) {
      this.source = source;
      this.pointer = pointer;
    }
    child(components2) {
      return new Location(this.source, joinPointer(this.pointer, (Array.isArray(components2) ? components2 : [components2]).map(escapePointer).join("/")));
    }
    key() {
      return Object.assign(Object.assign({}, this), { reportOnKey: true });
    }
    get absolutePointer() {
      return this.source.absoluteRef + (this.pointer === "#/" ? "" : this.pointer);
    }
  }
  refUtils.Location = Location;
  function unescapePointer(fragment) {
    return decodeURIComponent(fragment.replace(/~1/g, "/").replace(/~0/g, "~"));
  }
  refUtils.unescapePointer = unescapePointer;
  function escapePointer(fragment) {
    if (typeof fragment === "number")
      return fragment;
    return fragment.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  refUtils.escapePointer = escapePointer;
  function parseRef(ref) {
    const [uri, pointer] = ref.split("#/");
    return {
      uri: uri || null,
      pointer: pointer ? pointer.split("/").map(unescapePointer).filter(utils_1.isTruthy) : []
    };
  }
  refUtils.parseRef = parseRef;
  function parsePointer(pointer) {
    return pointer.substr(2).split("/").map(unescapePointer);
  }
  refUtils.parsePointer = parsePointer;
  function pointerBaseName(pointer) {
    const parts = pointer.split("/");
    return parts[parts.length - 1];
  }
  refUtils.pointerBaseName = pointerBaseName;
  function refBaseName(ref) {
    const parts = ref.split(/[\/\\]/);
    return parts[parts.length - 1].replace(/\.[^.]+$/, "");
  }
  refUtils.refBaseName = refBaseName;
  function isAbsoluteUrl(ref) {
    return ref.startsWith("http://") || ref.startsWith("https://");
  }
  refUtils.isAbsoluteUrl = isAbsoluteUrl;
  function isMappingRef(mapping) {
    return mapping.startsWith("#") || mapping.startsWith("https://") || mapping.startsWith("http://") || mapping.startsWith("./") || mapping.startsWith("../") || mapping.indexOf("/") > -1;
  }
  refUtils.isMappingRef = isMappingRef;
  function isAnchor(ref) {
    return /^#[A-Za-z][A-Za-z0-9\-_:.]*$/.test(ref);
  }
  refUtils.isAnchor = isAnchor;
  return refUtils;
}
var types$1 = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types$1;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNamedType = exports.normalizeTypes = exports.SpecExtension = exports.mapOf = exports.listOf = void 0;
    function listOf(typeName) {
      return {
        name: `${typeName}List`,
        properties: {},
        items: typeName
      };
    }
    exports.listOf = listOf;
    function mapOf(typeName) {
      return {
        name: `${typeName}Map`,
        properties: {},
        additionalProperties: () => typeName
      };
    }
    exports.mapOf = mapOf;
    exports.SpecExtension = {
      name: "SpecExtension",
      properties: {},
      // skip validation of additional properties for unknown extensions
      additionalProperties: { resolvable: true }
    };
    function normalizeTypes(types2, options2 = {}) {
      const normalizedTypes = {};
      for (const typeName of Object.keys(types2)) {
        normalizedTypes[typeName] = Object.assign(Object.assign({}, types2[typeName]), { name: typeName });
      }
      for (const type2 of Object.values(normalizedTypes)) {
        normalizeType(type2);
      }
      normalizedTypes["SpecExtension"] = exports.SpecExtension;
      return normalizedTypes;
      function normalizeType(type2) {
        if (type2.additionalProperties) {
          type2.additionalProperties = resolveType(type2.additionalProperties);
        }
        if (type2.items) {
          type2.items = resolveType(type2.items);
        }
        if (type2.properties) {
          const mappedProps = {};
          for (const [propName, prop] of Object.entries(type2.properties)) {
            mappedProps[propName] = resolveType(prop);
            if (options2.doNotResolveExamples && prop && prop.isExample) {
              mappedProps[propName] = Object.assign(Object.assign({}, prop), { resolvable: false });
            }
          }
          type2.properties = mappedProps;
        }
      }
      function resolveType(type2) {
        if (typeof type2 === "string") {
          if (!normalizedTypes[type2]) {
            throw new Error(`Unknown type name found: ${type2}`);
          }
          return normalizedTypes[type2];
        } else if (typeof type2 === "function") {
          return (value, key2) => {
            return resolveType(type2(value, key2));
          };
        } else if (type2 && type2.name) {
          type2 = Object.assign({}, type2);
          normalizeType(type2);
          return type2;
        } else if (type2 && type2.directResolveAs) {
          return Object.assign(Object.assign({}, type2), { directResolveAs: resolveType(type2.directResolveAs) });
        } else {
          return type2;
        }
      }
    }
    exports.normalizeTypes = normalizeTypes;
    function isNamedType(t2) {
      return typeof (t2 === null || t2 === void 0 ? void 0 : t2.name) === "string";
    }
    exports.isNamedType = isNamedType;
  })(types$1);
  return types$1;
}
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve)
    return resolve27;
  hasRequiredResolve = 1;
  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve28) {
        resolve28(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve28, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve28(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(resolve27, "__esModule", { value: true });
  resolve27.resolveDocument = resolve27.BaseResolver = resolve27.makeDocumentFromString = resolve27.makeRefId = resolve27.YamlParseError = resolve27.ResolveError = resolve27.Source = void 0;
  const fs = require$$2;
  const path2 = requirePathBrowserify();
  const ref_utils_1 = requireRefUtils();
  const types_12 = requireTypes();
  const utils_1 = requireUtils$1();
  class Source {
    constructor(absoluteRef, body, mimeType) {
      this.absoluteRef = absoluteRef;
      this.body = body;
      this.mimeType = mimeType;
    }
    // pass safeLoad as argument to separate it from browser bundle
    getAst(safeLoad) {
      var _a4;
      if (this._ast === void 0) {
        this._ast = (_a4 = safeLoad(this.body, { filename: this.absoluteRef })) !== null && _a4 !== void 0 ? _a4 : void 0;
        if (this._ast && this._ast.kind === 0 && // KIND.scalar = 0
        this._ast.value === "" && this._ast.startPosition !== 1) {
          this._ast.startPosition = 1;
          this._ast.endPosition = 1;
        }
      }
      return this._ast;
    }
    getLines() {
      if (this._lines === void 0) {
        this._lines = this.body.split(/\r\n|[\n\r]/g);
      }
      return this._lines;
    }
  }
  resolve27.Source = Source;
  class ResolveError extends Error {
    constructor(originalError) {
      super(originalError.message);
      this.originalError = originalError;
      Object.setPrototypeOf(this, ResolveError.prototype);
    }
  }
  resolve27.ResolveError = ResolveError;
  const jsYamlErrorLineColRegexp = /\((\d+):(\d+)\)$/;
  class YamlParseError extends Error {
    constructor(originalError, source) {
      super(originalError.message.split("\n")[0]);
      this.originalError = originalError;
      this.source = source;
      Object.setPrototypeOf(this, YamlParseError.prototype);
      const [, line2, col] = this.message.match(jsYamlErrorLineColRegexp) || [];
      this.line = parseInt(line2, 10);
      this.col = parseInt(col, 10);
    }
  }
  resolve27.YamlParseError = YamlParseError;
  function makeRefId(absoluteRef, pointer) {
    return absoluteRef + "::" + pointer;
  }
  resolve27.makeRefId = makeRefId;
  function makeDocumentFromString(sourceString, absoluteRef) {
    const source = new Source(absoluteRef, sourceString);
    try {
      return {
        source,
        parsed: utils_1.parseYaml(sourceString, { filename: absoluteRef })
      };
    } catch (e2) {
      throw new YamlParseError(e2, source);
    }
  }
  resolve27.makeDocumentFromString = makeDocumentFromString;
  class BaseResolver {
    constructor(config2 = { http: { headers: [] } }) {
      this.config = config2;
      this.cache = /* @__PURE__ */ new Map();
    }
    getFiles() {
      return new Set(Array.from(this.cache.keys()));
    }
    resolveExternalRef(base, ref) {
      if (ref_utils_1.isAbsoluteUrl(ref)) {
        return ref;
      }
      if (base && ref_utils_1.isAbsoluteUrl(base)) {
        return new URL(ref, base).href;
      }
      return path2.resolve(base ? path2.dirname(base) : process.cwd(), ref);
    }
    loadExternalRef(absoluteRef) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if (ref_utils_1.isAbsoluteUrl(absoluteRef)) {
            const { body, mimeType } = yield utils_1.readFileFromUrl(absoluteRef, this.config.http);
            return new Source(absoluteRef, body, mimeType);
          } else {
            if (fs.lstatSync(absoluteRef).isDirectory()) {
              throw new Error(`Expected a file but received a folder at ${absoluteRef}`);
            }
            const content = yield fs.promises.readFile(absoluteRef, "utf-8");
            return new Source(absoluteRef, content.replace(/\r\n/g, "\n"));
          }
        } catch (error) {
          error.message = error.message.replace(", lstat", "");
          throw new ResolveError(error);
        }
      });
    }
    parseDocument(source, isRoot = false) {
      var _a4;
      const ext = source.absoluteRef.substr(source.absoluteRef.lastIndexOf("."));
      if (![".json", ".json", ".yml", ".yaml"].includes(ext) && !((_a4 = source.mimeType) === null || _a4 === void 0 ? void 0 : _a4.match(/(json|yaml|openapi)/)) && !isRoot) {
        return { source, parsed: source.body };
      }
      try {
        return {
          source,
          parsed: utils_1.parseYaml(source.body, { filename: source.absoluteRef })
        };
      } catch (e2) {
        throw new YamlParseError(e2, source);
      }
    }
    resolveDocument(base, ref, isRoot = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const absoluteRef = this.resolveExternalRef(base, ref);
        const cachedDocument = this.cache.get(absoluteRef);
        if (cachedDocument) {
          return cachedDocument;
        }
        const doc = this.loadExternalRef(absoluteRef).then((source) => {
          return this.parseDocument(source, isRoot);
        });
        this.cache.set(absoluteRef, doc);
        return doc;
      });
    }
  }
  resolve27.BaseResolver = BaseResolver;
  function pushRef(head, node2) {
    return {
      prev: head,
      node: node2
    };
  }
  function hasRef(head, node2) {
    while (head) {
      if (head.node === node2) {
        return true;
      }
      head = head.prev;
    }
    return false;
  }
  const unknownType = { name: "unknown", properties: {} };
  const resolvableScalarType = { name: "scalar", properties: {} };
  function resolveDocument(opts) {
    return __awaiter(this, void 0, void 0, function* () {
      const { rootDocument, externalRefResolver, rootType } = opts;
      const resolvedRefMap = /* @__PURE__ */ new Map();
      const seedNodes = /* @__PURE__ */ new Set();
      const resolvePromises = [];
      resolveRefsInParallel(rootDocument.parsed, rootDocument, "#/", rootType);
      let resolved;
      do {
        resolved = yield Promise.all(resolvePromises);
      } while (resolvePromises.length !== resolved.length);
      return resolvedRefMap;
      function resolveRefsInParallel(rootNode, rootNodeDocument, rootNodePointer, type2) {
        const rootNodeDocAbsoluteRef = rootNodeDocument.source.absoluteRef;
        const anchorRefsMap = /* @__PURE__ */ new Map();
        walk2(rootNode, type2, rootNodeDocAbsoluteRef + rootNodePointer);
        function walk2(node2, type3, nodeAbsoluteRef) {
          if (typeof node2 !== "object" || node2 === null) {
            return;
          }
          const nodeId = `${type3.name}::${nodeAbsoluteRef}`;
          if (seedNodes.has(nodeId)) {
            return;
          }
          seedNodes.add(nodeId);
          const [_2, anchor] = Object.entries(node2).find(([key2]) => key2 === "$anchor") || [];
          if (anchor) {
            anchorRefsMap.set(`#${anchor}`, node2);
          }
          if (Array.isArray(node2)) {
            const itemsType = type3.items;
            if (itemsType === void 0 && type3 !== unknownType && type3 !== types_12.SpecExtension) {
              return;
            }
            for (let i = 0; i < node2.length; i++) {
              walk2(node2[i], itemsType || unknownType, ref_utils_1.joinPointer(nodeAbsoluteRef, i));
            }
            return;
          }
          for (const propName of Object.keys(node2)) {
            let propValue = node2[propName];
            let propType = type3.properties[propName];
            if (propType === void 0)
              propType = type3.additionalProperties;
            if (typeof propType === "function")
              propType = propType(propValue, propName);
            if (propType === void 0)
              propType = unknownType;
            if (type3.extensionsPrefix && propName.startsWith(type3.extensionsPrefix) && propType === unknownType) {
              propType = types_12.SpecExtension;
            }
            if (!types_12.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {
              propType = propType.directResolveAs;
              propValue = { $ref: propValue };
            }
            if (propType && propType.name === void 0 && propType.resolvable !== false) {
              propType = resolvableScalarType;
            }
            if (!types_12.isNamedType(propType) || typeof propValue !== "object") {
              continue;
            }
            walk2(propValue, propType, ref_utils_1.joinPointer(nodeAbsoluteRef, ref_utils_1.escapePointer(propName)));
          }
          if (ref_utils_1.isRef(node2)) {
            const promise = followRef(rootNodeDocument, node2, {
              prev: null,
              node: node2
            }).then((resolvedRef) => {
              if (resolvedRef.resolved) {
                resolveRefsInParallel(resolvedRef.node, resolvedRef.document, resolvedRef.nodePointer, type3);
              }
            });
            resolvePromises.push(promise);
          }
        }
        function followRef(document2, ref, refStack) {
          return __awaiter(this, void 0, void 0, function* () {
            if (hasRef(refStack.prev, ref)) {
              throw new Error("Self-referencing circular pointer");
            }
            if (ref_utils_1.isAnchor(ref.$ref)) {
              yield utils_1.nextTick();
              const resolvedRef2 = {
                resolved: true,
                isRemote: false,
                node: anchorRefsMap.get(ref.$ref),
                document: document2,
                nodePointer: ref.$ref
              };
              const refId2 = makeRefId(document2.source.absoluteRef, ref.$ref);
              resolvedRefMap.set(refId2, resolvedRef2);
              return resolvedRef2;
            }
            const { uri, pointer } = ref_utils_1.parseRef(ref.$ref);
            const isRemote = uri !== null;
            let targetDoc;
            try {
              targetDoc = isRemote ? yield externalRefResolver.resolveDocument(document2.source.absoluteRef, uri) : document2;
            } catch (error) {
              const resolvedRef2 = {
                resolved: false,
                isRemote,
                document: void 0,
                error
              };
              const refId2 = makeRefId(document2.source.absoluteRef, ref.$ref);
              resolvedRefMap.set(refId2, resolvedRef2);
              return resolvedRef2;
            }
            let resolvedRef = {
              resolved: true,
              document: targetDoc,
              isRemote,
              node: document2.parsed,
              nodePointer: "#/"
            };
            let target = targetDoc.parsed;
            const segments = pointer;
            for (const segment of segments) {
              if (typeof target !== "object") {
                target = void 0;
                break;
              } else if (target[segment] !== void 0) {
                target = target[segment];
                resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));
              } else if (ref_utils_1.isRef(target)) {
                resolvedRef = yield followRef(targetDoc, target, pushRef(refStack, target));
                targetDoc = resolvedRef.document || targetDoc;
                if (typeof resolvedRef.node !== "object") {
                  target = void 0;
                  break;
                }
                target = resolvedRef.node[segment];
                resolvedRef.nodePointer = ref_utils_1.joinPointer(resolvedRef.nodePointer, ref_utils_1.escapePointer(segment));
              } else {
                target = void 0;
                break;
              }
            }
            resolvedRef.node = target;
            resolvedRef.document = targetDoc;
            const refId = makeRefId(document2.source.absoluteRef, ref.$ref);
            if (resolvedRef.document && ref_utils_1.isRef(target)) {
              resolvedRef = yield followRef(resolvedRef.document, target, pushRef(refStack, target));
            }
            resolvedRefMap.set(refId, resolvedRef);
            return Object.assign({}, resolvedRef);
          });
        }
      }
    });
  }
  resolve27.resolveDocument = resolveDocument;
  return resolve27;
}
var visitors = {};
var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors)
    return visitors;
  hasRequiredVisitors = 1;
  Object.defineProperty(visitors, "__esModule", { value: true });
  visitors.normalizeVisitors = void 0;
  const types_12 = requireTypes();
  const legacyTypesMap = {
    Root: "DefinitionRoot",
    ServerVariablesMap: "ServerVariableMap",
    Paths: ["PathMap", "PathsMap"],
    CallbacksMap: "CallbackMap",
    MediaTypesMap: "MediaTypeMap",
    ExamplesMap: "ExampleMap",
    EncodingMap: "EncodingsMap",
    HeadersMap: "HeaderMap",
    LinksMap: "LinkMap",
    OAuth2Flows: "SecuritySchemeFlows",
    Responses: "ResponsesMap"
  };
  function normalizeVisitors(visitorsConfig, types2) {
    const normalizedVisitors = {};
    normalizedVisitors.any = {
      enter: [],
      leave: []
    };
    for (const typeName of Object.keys(types2)) {
      normalizedVisitors[typeName] = {
        enter: [],
        leave: []
      };
    }
    normalizedVisitors.ref = {
      enter: [],
      leave: []
    };
    for (const { ruleId, severity, visitor } of visitorsConfig) {
      normalizeVisitorLevel({ ruleId, severity }, visitor, null);
    }
    for (const v2 of Object.keys(normalizedVisitors)) {
      normalizedVisitors[v2].enter.sort((a, b2) => b2.depth - a.depth);
      normalizedVisitors[v2].leave.sort((a, b2) => a.depth - b2.depth);
    }
    return normalizedVisitors;
    function addWeakNodes(ruleConf, from2, to, parentContext, stack = []) {
      if (stack.includes(from2))
        return;
      stack = [...stack, from2];
      const possibleChildren = /* @__PURE__ */ new Set();
      for (const type2 of Object.values(from2.properties)) {
        if (type2 === to) {
          addWeakFromStack(ruleConf, stack);
          continue;
        }
        if (typeof type2 === "object" && type2 !== null && type2.name) {
          possibleChildren.add(type2);
        }
      }
      if (from2.additionalProperties && typeof from2.additionalProperties !== "function") {
        if (from2.additionalProperties === to) {
          addWeakFromStack(ruleConf, stack);
        } else if (from2.additionalProperties.name !== void 0) {
          possibleChildren.add(from2.additionalProperties);
        }
      }
      if (from2.items) {
        if (from2.items === to) {
          addWeakFromStack(ruleConf, stack);
        } else if (from2.items.name !== void 0) {
          possibleChildren.add(from2.items);
        }
      }
      if (from2.extensionsPrefix) {
        possibleChildren.add(types_12.SpecExtension);
      }
      for (const fromType of Array.from(possibleChildren.values())) {
        addWeakNodes(ruleConf, fromType, to, parentContext, stack);
      }
      function addWeakFromStack(ruleConf2, stack2) {
        for (const interType of stack2.slice(1)) {
          normalizedVisitors[interType.name] = normalizedVisitors[interType.name] || {
            enter: [],
            leave: []
          };
          normalizedVisitors[interType.name].enter.push(Object.assign(Object.assign({}, ruleConf2), { visit: () => void 0, depth: 0, context: {
            isSkippedLevel: true,
            seen: /* @__PURE__ */ new Set(),
            parent: parentContext
          } }));
        }
      }
    }
    function findLegacyVisitorNode(visitor, typeName) {
      if (Array.isArray(typeName)) {
        const name2 = typeName.find((name3) => visitor[name3]) || void 0;
        return name2 && visitor[name2];
      }
      return visitor[typeName];
    }
    function normalizeVisitorLevel(ruleConf, visitor, parentContext, depth = 0) {
      const visitorKeys = Object.keys(types2);
      if (depth === 0) {
        visitorKeys.push("any");
        visitorKeys.push("ref");
      } else {
        if (visitor.any) {
          throw new Error("any() is allowed only on top level");
        }
        if (visitor.ref) {
          throw new Error("ref() is allowed only on top level");
        }
      }
      for (const typeName of visitorKeys) {
        const typeVisitor = visitor[typeName] || findLegacyVisitorNode(visitor, legacyTypesMap[typeName]);
        const normalizedTypeVisitor = normalizedVisitors[typeName];
        if (!typeVisitor)
          continue;
        let visitorEnter;
        let visitorLeave;
        let visitorSkip;
        const isObjectVisitor = typeof typeVisitor === "object";
        if (typeName === "ref" && isObjectVisitor && typeVisitor.skip) {
          throw new Error("ref() visitor does not support skip");
        }
        if (typeof typeVisitor === "function") {
          visitorEnter = typeVisitor;
        } else if (isObjectVisitor) {
          visitorEnter = typeVisitor.enter;
          visitorLeave = typeVisitor.leave;
          visitorSkip = typeVisitor.skip;
        }
        const context = {
          activatedOn: null,
          type: types2[typeName],
          parent: parentContext,
          isSkippedLevel: false
        };
        if (typeof typeVisitor === "object") {
          normalizeVisitorLevel(ruleConf, typeVisitor, context, depth + 1);
        }
        if (parentContext) {
          addWeakNodes(ruleConf, parentContext.type, types2[typeName], parentContext);
        }
        if (visitorEnter || isObjectVisitor) {
          if (visitorEnter && typeof visitorEnter !== "function") {
            throw new Error("DEV: should be function");
          }
          normalizedTypeVisitor.enter.push(Object.assign(Object.assign({}, ruleConf), {
            visit: visitorEnter || (() => void 0),
            skip: visitorSkip,
            depth,
            context
          }));
        }
        if (visitorLeave) {
          if (typeof visitorLeave !== "function") {
            throw new Error("DEV: should be function");
          }
          normalizedTypeVisitor.leave.push(Object.assign(Object.assign({}, ruleConf), {
            visit: visitorLeave,
            depth,
            context
          }));
        }
      }
    }
  }
  visitors.normalizeVisitors = normalizeVisitors;
  return visitors;
}
var walk = {};
var hasRequiredWalk;
function requireWalk() {
  if (hasRequiredWalk)
    return walk;
  hasRequiredWalk = 1;
  Object.defineProperty(walk, "__esModule", { value: true });
  walk.walkDocument = void 0;
  const ref_utils_1 = requireRefUtils();
  const utils_1 = requireUtils$1();
  const resolve_1 = requireResolve();
  const types_12 = requireTypes();
  function collectParents(ctx) {
    var _a4;
    const parents = {};
    while (ctx.parent) {
      parents[ctx.parent.type.name] = (_a4 = ctx.parent.activatedOn) === null || _a4 === void 0 ? void 0 : _a4.value.node;
      ctx = ctx.parent;
    }
    return parents;
  }
  function collectParentsLocations(ctx) {
    var _a4, _b3;
    const locations = {};
    while (ctx.parent) {
      if ((_a4 = ctx.parent.activatedOn) === null || _a4 === void 0 ? void 0 : _a4.value.location) {
        locations[ctx.parent.type.name] = (_b3 = ctx.parent.activatedOn) === null || _b3 === void 0 ? void 0 : _b3.value.location;
      }
      ctx = ctx.parent;
    }
    return locations;
  }
  function walkDocument(opts) {
    const { document: document2, rootType, normalizedVisitors, resolvedRefMap, ctx } = opts;
    const seenNodesPerType = {};
    const ignoredNodes = /* @__PURE__ */ new Set();
    walkNode(document2.parsed, rootType, new ref_utils_1.Location(document2.source, "#/"), void 0, "");
    function walkNode(node2, type2, location, parent, key2) {
      var _a4, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _j, _k, _l;
      const resolve28 = (ref, from2 = currentLocation.source.absoluteRef) => {
        if (!ref_utils_1.isRef(ref))
          return { location, node: ref };
        const refId = resolve_1.makeRefId(from2, ref.$ref);
        const resolvedRef = resolvedRefMap.get(refId);
        if (!resolvedRef) {
          return {
            location: void 0,
            node: void 0
          };
        }
        const { resolved, node: node3, document: document3, nodePointer, error: error2 } = resolvedRef;
        const newLocation = resolved ? new ref_utils_1.Location(document3.source, nodePointer) : error2 instanceof resolve_1.YamlParseError ? new ref_utils_1.Location(error2.source, "") : void 0;
        return { location: newLocation, node: node3, error: error2 };
      };
      const rawLocation = location;
      let currentLocation = location;
      const { node: resolvedNode, location: resolvedLocation, error } = resolve28(node2);
      const enteredContexts = /* @__PURE__ */ new Set();
      if (ref_utils_1.isRef(node2)) {
        const refEnterVisitors = normalizedVisitors.ref.enter;
        for (const { visit: visitor, ruleId, severity, context } of refEnterVisitors) {
          enteredContexts.add(context);
          const report = reportFn.bind(void 0, ruleId, severity);
          visitor(node2, {
            report,
            resolve: resolve28,
            rawNode: node2,
            rawLocation,
            location,
            type: type2,
            parent,
            key: key2,
            parentLocations: {},
            oasVersion: ctx.oasVersion,
            getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
          }, { node: resolvedNode, location: resolvedLocation, error });
          if ((resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef) && ctx.refTypes) {
            ctx.refTypes.set(resolvedLocation === null || resolvedLocation === void 0 ? void 0 : resolvedLocation.source.absoluteRef, type2);
          }
        }
      }
      if (resolvedNode !== void 0 && resolvedLocation && type2.name !== "scalar") {
        currentLocation = resolvedLocation;
        const isNodeSeen = (_b3 = (_a4 = seenNodesPerType[type2.name]) === null || _a4 === void 0 ? void 0 : _a4.has) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, resolvedNode);
        let visitedBySome = false;
        const anyEnterVisitors = normalizedVisitors.any.enter;
        const currentEnterVisitors = anyEnterVisitors.concat(((_c2 = normalizedVisitors[type2.name]) === null || _c2 === void 0 ? void 0 : _c2.enter) || []);
        const activatedContexts = [];
        for (const { context, visit: visit3, skip, ruleId, severity } of currentEnterVisitors) {
          if (ignoredNodes.has(currentLocation.pointer))
            break;
          if (context.isSkippedLevel) {
            if (context.parent.activatedOn && !context.parent.activatedOn.value.nextLevelTypeActivated && !context.seen.has(node2)) {
              context.seen.add(node2);
              visitedBySome = true;
              activatedContexts.push(context);
            }
          } else {
            if (context.parent && // if nested
            context.parent.activatedOn && ((_d2 = context.activatedOn) === null || _d2 === void 0 ? void 0 : _d2.value.withParentNode) !== context.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)
            ((_e2 = context.parent.activatedOn.value.nextLevelTypeActivated) === null || _e2 === void 0 ? void 0 : _e2.value) !== type2 || !context.parent && !isNodeSeen) {
              activatedContexts.push(context);
              const activatedOn = {
                node: resolvedNode,
                location: resolvedLocation,
                nextLevelTypeActivated: null,
                withParentNode: (_g2 = (_f2 = context.parent) === null || _f2 === void 0 ? void 0 : _f2.activatedOn) === null || _g2 === void 0 ? void 0 : _g2.value.node,
                skipped: (_k = ((_j = (_h2 = context.parent) === null || _h2 === void 0 ? void 0 : _h2.activatedOn) === null || _j === void 0 ? void 0 : _j.value.skipped) || (skip === null || skip === void 0 ? void 0 : skip(resolvedNode, key2, {
                  location,
                  rawLocation,
                  resolve: resolve28,
                  rawNode: node2
                }))) !== null && _k !== void 0 ? _k : false
              };
              context.activatedOn = utils_1.pushStack(context.activatedOn, activatedOn);
              let ctx2 = context.parent;
              while (ctx2) {
                ctx2.activatedOn.value.nextLevelTypeActivated = utils_1.pushStack(ctx2.activatedOn.value.nextLevelTypeActivated, type2);
                ctx2 = ctx2.parent;
              }
              if (!activatedOn.skipped) {
                visitedBySome = true;
                enteredContexts.add(context);
                visitWithContext(visit3, resolvedNode, node2, context, ruleId, severity);
              }
            }
          }
        }
        if (visitedBySome || !isNodeSeen) {
          seenNodesPerType[type2.name] = seenNodesPerType[type2.name] || /* @__PURE__ */ new Set();
          seenNodesPerType[type2.name].add(resolvedNode);
          if (Array.isArray(resolvedNode)) {
            const itemsType = type2.items;
            if (itemsType !== void 0) {
              for (let i = 0; i < resolvedNode.length; i++) {
                walkNode(resolvedNode[i], itemsType, resolvedLocation.child([i]), resolvedNode, i);
              }
            }
          } else if (typeof resolvedNode === "object" && resolvedNode !== null) {
            const props = Object.keys(type2.properties);
            if (type2.additionalProperties) {
              props.push(...Object.keys(resolvedNode).filter((k2) => !props.includes(k2)));
            } else if (type2.extensionsPrefix) {
              props.push(...Object.keys(resolvedNode).filter((k2) => k2.startsWith(type2.extensionsPrefix)));
            }
            if (ref_utils_1.isRef(node2)) {
              props.push(...Object.keys(node2).filter((k2) => k2 !== "$ref" && !props.includes(k2)));
            }
            for (const propName of props) {
              let value = resolvedNode[propName];
              let loc = resolvedLocation;
              if (value === void 0) {
                value = node2[propName];
                loc = location;
              }
              let propType = type2.properties[propName];
              if (propType === void 0)
                propType = type2.additionalProperties;
              if (typeof propType === "function")
                propType = propType(value, propName);
              if (propType === void 0 && type2.extensionsPrefix && propName.startsWith(type2.extensionsPrefix)) {
                propType = types_12.SpecExtension;
              }
              if (!types_12.isNamedType(propType) && (propType === null || propType === void 0 ? void 0 : propType.directResolveAs)) {
                propType = propType.directResolveAs;
                value = { $ref: value };
              }
              if (propType && propType.name === void 0 && propType.resolvable !== false) {
                propType = { name: "scalar", properties: {} };
              }
              if (!types_12.isNamedType(propType) || propType.name === "scalar" && !ref_utils_1.isRef(value)) {
                continue;
              }
              walkNode(value, propType, loc.child([propName]), resolvedNode, propName);
            }
          }
        }
        const anyLeaveVisitors = normalizedVisitors.any.leave;
        const currentLeaveVisitors = (((_l = normalizedVisitors[type2.name]) === null || _l === void 0 ? void 0 : _l.leave) || []).concat(anyLeaveVisitors);
        for (const context of activatedContexts.reverse()) {
          if (context.isSkippedLevel) {
            context.seen.delete(resolvedNode);
          } else {
            context.activatedOn = utils_1.popStack(context.activatedOn);
            if (context.parent) {
              let ctx2 = context.parent;
              while (ctx2) {
                ctx2.activatedOn.value.nextLevelTypeActivated = utils_1.popStack(ctx2.activatedOn.value.nextLevelTypeActivated);
                ctx2 = ctx2.parent;
              }
            }
          }
        }
        for (const { context, visit: visit3, ruleId, severity } of currentLeaveVisitors) {
          if (!context.isSkippedLevel && enteredContexts.has(context)) {
            visitWithContext(visit3, resolvedNode, node2, context, ruleId, severity);
          }
        }
      }
      currentLocation = location;
      if (ref_utils_1.isRef(node2)) {
        const refLeaveVisitors = normalizedVisitors.ref.leave;
        for (const { visit: visitor, ruleId, severity, context } of refLeaveVisitors) {
          if (enteredContexts.has(context)) {
            const report = reportFn.bind(void 0, ruleId, severity);
            visitor(node2, {
              report,
              resolve: resolve28,
              rawNode: node2,
              rawLocation,
              location,
              type: type2,
              parent,
              key: key2,
              parentLocations: {},
              oasVersion: ctx.oasVersion,
              getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
            }, { node: resolvedNode, location: resolvedLocation, error });
          }
        }
      }
      function visitWithContext(visit3, resolvedNode2, node3, context, ruleId, severity) {
        const report = reportFn.bind(void 0, ruleId, severity);
        visit3(resolvedNode2, {
          report,
          resolve: resolve28,
          rawNode: node3,
          location: currentLocation,
          rawLocation,
          type: type2,
          parent,
          key: key2,
          parentLocations: collectParentsLocations(context),
          oasVersion: ctx.oasVersion,
          ignoreNextVisitorsOnNode: () => {
            ignoredNodes.add(currentLocation.pointer);
          },
          getVisitorData: getVisitorDataFn.bind(void 0, ruleId)
        }, collectParents(context), context);
      }
      function reportFn(ruleId, severity, opts2) {
        const normalizedLocation = opts2.location ? Array.isArray(opts2.location) ? opts2.location : [opts2.location] : [Object.assign(Object.assign({}, currentLocation), { reportOnKey: false })];
        const location2 = normalizedLocation.map((l2) => Object.assign(Object.assign(Object.assign({}, currentLocation), { reportOnKey: false }), l2));
        const ruleSeverity = opts2.forceSeverity || severity;
        if (ruleSeverity !== "off") {
          ctx.problems.push(Object.assign(Object.assign({ ruleId: opts2.ruleId || ruleId, severity: ruleSeverity }, opts2), { suggest: opts2.suggest || [], location: location2 }));
        }
      }
      function getVisitorDataFn(ruleId) {
        ctx.visitorsData[ruleId] = ctx.visitorsData[ruleId] || {};
        return ctx.visitorsData[ruleId];
      }
    }
  }
  walk.walkDocument = walkDocument;
  return walk;
}
var oasTypes = {};
var oas2 = {};
var hasRequiredOas2;
function requireOas2() {
  if (hasRequiredOas2)
    return oas2;
  hasRequiredOas2 = 1;
  Object.defineProperty(oas2, "__esModule", { value: true });
  oas2.Oas2Types = void 0;
  const _1 = requireTypes();
  const responseCodeRegexp = /^[0-9][0-9Xx]{2}$/;
  const Root = {
    properties: {
      swagger: { type: "string" },
      info: "Info",
      host: { type: "string" },
      basePath: { type: "string" },
      schemes: { type: "array", items: { type: "string" } },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      paths: "Paths",
      definitions: "NamedSchemas",
      parameters: "NamedParameters",
      responses: "NamedResponses",
      securityDefinitions: "NamedSecuritySchemes",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      "x-servers": "XServerList",
      "x-tagGroups": "TagGroups",
      "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
    },
    required: ["swagger", "paths", "info"],
    extensionsPrefix: "x-"
  };
  const Info = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      version: { type: "string" },
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  };
  const Logo = {
    properties: {
      url: { type: "string" },
      altText: { type: "string" },
      backgroundColor: { type: "string" },
      href: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  const Contact = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  const License = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  };
  const Paths = {
    properties: {},
    additionalProperties: (_value, key2) => key2.startsWith("/") ? "PathItem" : void 0
  };
  const PathItem = {
    properties: {
      $ref: { type: "string" },
      parameters: "ParameterList",
      get: "Operation",
      put: "Operation",
      post: "Operation",
      delete: "Operation",
      options: "Operation",
      head: "Operation",
      patch: "Operation"
    },
    extensionsPrefix: "x-"
  };
  const Operation = {
    properties: {
      tags: { type: "array", items: { type: "string" } },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      parameters: "ParameterList",
      responses: "Responses",
      schemes: { type: "array", items: { type: "string" } },
      deprecated: { type: "boolean" },
      security: "SecurityRequirementList",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      "x-hideTryItPanel": { type: "boolean" }
    },
    required: ["responses"],
    extensionsPrefix: "x-"
  };
  const XCodeSample = {
    properties: {
      lang: { type: "string" },
      label: { type: "string" },
      source: { type: "string" }
    }
  };
  const XServer = {
    properties: {
      url: { type: "string" },
      description: { type: "string" }
    },
    required: ["url"]
  };
  const ExternalDocs = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    extensionsPrefix: "x-"
  };
  const Parameter = {
    properties: {
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "path", "formData", "body"] },
      description: { type: "string" },
      required: { type: "boolean" },
      schema: "Schema",
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array", "file"] },
      format: { type: "string" },
      allowEmptyValue: { type: "boolean" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" },
      "x-example": "Example",
      "x-examples": "ExamplesMap"
    },
    required(value) {
      if (!value || !value.in) {
        return ["name", "in"];
      }
      if (value.in === "body") {
        return ["name", "in", "schema"];
      } else {
        if (value.type === "array") {
          return ["name", "in", "type", "items"];
        } else {
          return ["name", "in", "type"];
        }
      }
    },
    extensionsPrefix: "x-"
  };
  const ParameterItems = {
    properties: {
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(value) {
      if (value && value.type === "array") {
        return ["type", "items"];
      } else {
        return ["type"];
      }
    },
    extensionsPrefix: "x-"
  };
  const Responses = {
    properties: {
      default: "Response"
    },
    additionalProperties: (_v, key2) => responseCodeRegexp.test(key2) ? "Response" : void 0
  };
  const Response = {
    properties: {
      description: { type: "string" },
      schema: "Schema",
      headers: _1.mapOf("Header"),
      examples: "Examples",
      "x-summary": { type: "string" }
    },
    required: ["description"],
    extensionsPrefix: "x-"
  };
  const Examples = {
    properties: {},
    additionalProperties: { isExample: true }
  };
  const Header = {
    properties: {
      description: { type: "string" },
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(value) {
      if (value && value.type === "array") {
        return ["type", "items"];
      } else {
        return ["type"];
      }
    },
    extensionsPrefix: "x-"
  };
  const Tag = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      "x-traitTag": { type: "boolean" },
      "x-displayName": { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  };
  const TagGroup = {
    properties: {
      name: { type: "string" },
      tags: { type: "array", items: { type: "string" } }
    }
  };
  const Schema2 = {
    properties: {
      format: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: null,
      multipleOf: { type: "number" },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "boolean" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "number" },
      minLength: { type: "number" },
      pattern: { type: "string" },
      maxItems: { type: "number" },
      minItems: { type: "number" },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "number" },
      minProperties: { type: "number" },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: {
        type: "string",
        enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
      },
      items: (value) => {
        if (Array.isArray(value)) {
          return _1.listOf("Schema");
        } else {
          return "Schema";
        }
      },
      allOf: _1.listOf("Schema"),
      properties: "SchemaProperties",
      additionalProperties: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      discriminator: { type: "string" },
      readOnly: { type: "boolean" },
      xml: "Xml",
      externalDocs: "ExternalDocs",
      example: { isExample: true },
      "x-tags": { type: "array", items: { type: "string" } },
      "x-nullable": { type: "boolean" },
      "x-extendedDiscriminator": { type: "string" },
      "x-additionalPropertiesName": { type: "string" },
      "x-explicitMappingOnly": { type: "boolean" },
      "x-enumDescriptions": "EnumDescriptions"
    },
    extensionsPrefix: "x-"
  };
  const EnumDescriptions = {
    properties: {},
    additionalProperties: { type: "string" }
  };
  const SchemaProperties = {
    properties: {},
    additionalProperties: "Schema"
  };
  const Xml = {
    properties: {
      name: { type: "string" },
      namespace: { type: "string" },
      prefix: { type: "string" },
      attribute: { type: "boolean" },
      wrapped: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  };
  const SecurityScheme = {
    properties: {
      type: { enum: ["basic", "apiKey", "oauth2"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header"] },
      flow: { enum: ["implicit", "password", "application", "accessCode"] },
      authorizationUrl: { type: "string" },
      tokenUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      "x-defaultClientId": { type: "string" }
    },
    required(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "oauth2":
          switch (value === null || value === void 0 ? void 0 : value.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "scopes"];
            default:
              return ["type", "flow", "scopes"];
          }
        default:
          return ["type"];
      }
    },
    allowed(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "basic":
          return ["type", "description"];
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "oauth2":
          switch (value === null || value === void 0 ? void 0 : value.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "description", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "description", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "description", "scopes"];
            default:
              return ["type", "flow", "tokenUrl", "authorizationUrl", "description", "scopes"];
          }
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  const SecurityRequirement = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  };
  const Example = {
    properties: {
      value: { isExample: true },
      summary: { type: "string" },
      description: { type: "string" },
      externalValue: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  oas2.Oas2Types = {
    Root,
    Tag,
    TagList: _1.listOf("Tag"),
    TagGroups: _1.listOf("TagGroup"),
    TagGroup,
    ExternalDocs,
    Example,
    ExamplesMap: _1.mapOf("Example"),
    EnumDescriptions,
    SecurityRequirement,
    SecurityRequirementList: _1.listOf("SecurityRequirement"),
    Info,
    Contact,
    License,
    Logo,
    Paths,
    PathItem,
    Parameter,
    ParameterItems,
    ParameterList: _1.listOf("Parameter"),
    Operation,
    Examples,
    Header,
    Responses,
    Response,
    Schema: Schema2,
    Xml,
    SchemaProperties,
    NamedSchemas: _1.mapOf("Schema"),
    NamedResponses: _1.mapOf("Response"),
    NamedParameters: _1.mapOf("Parameter"),
    NamedSecuritySchemes: _1.mapOf("SecurityScheme"),
    SecurityScheme,
    XCodeSample,
    XCodeSampleList: _1.listOf("XCodeSample"),
    XServerList: _1.listOf("XServer"),
    XServer
  };
  return oas2;
}
var oas3 = {};
var hasRequiredOas3;
function requireOas3() {
  if (hasRequiredOas3)
    return oas3;
  hasRequiredOas3 = 1;
  Object.defineProperty(oas3, "__esModule", { value: true });
  oas3.Oas3Types = void 0;
  const _1 = requireTypes();
  const ref_utils_1 = requireRefUtils();
  const responseCodeRegexp = /^[0-9][0-9Xx]{2}$/;
  const Root = {
    properties: {
      openapi: null,
      info: "Info",
      servers: "ServerList",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      paths: "Paths",
      components: "Components",
      "x-webhooks": "WebhooksMap",
      "x-tagGroups": "TagGroups",
      "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
    },
    required: ["openapi", "paths", "info"],
    extensionsPrefix: "x-"
  };
  const Tag = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      "x-traitTag": { type: "boolean" },
      "x-displayName": { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  };
  const TagGroup = {
    properties: {
      name: { type: "string" },
      tags: { type: "array", items: { type: "string" } }
    },
    extensionsPrefix: "x-"
  };
  const ExternalDocs = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    extensionsPrefix: "x-"
  };
  const Server = {
    properties: {
      url: { type: "string" },
      description: { type: "string" },
      variables: "ServerVariablesMap"
    },
    required: ["url"],
    extensionsPrefix: "x-"
  };
  const ServerVariable = {
    properties: {
      enum: {
        type: "array",
        items: { type: "string" }
      },
      default: { type: "string" },
      description: { type: "string" }
    },
    required: ["default"],
    extensionsPrefix: "x-"
  };
  const SecurityRequirement = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  };
  const Info = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  };
  const Logo = {
    properties: {
      url: { type: "string" },
      altText: { type: "string" },
      backgroundColor: { type: "string" },
      href: { type: "string" }
    }
  };
  const Contact = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  const License = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  };
  const Paths = {
    properties: {},
    additionalProperties: (_value, key2) => key2.startsWith("/") ? "PathItem" : void 0
  };
  const WebhooksMap = {
    properties: {},
    additionalProperties: () => "PathItem"
  };
  const PathItem = {
    properties: {
      $ref: { type: "string" },
      servers: "ServerList",
      parameters: "ParameterList",
      summary: { type: "string" },
      description: { type: "string" },
      get: "Operation",
      put: "Operation",
      post: "Operation",
      delete: "Operation",
      options: "Operation",
      head: "Operation",
      patch: "Operation",
      trace: "Operation"
    },
    extensionsPrefix: "x-"
  };
  const Parameter = {
    properties: {
      name: { type: "string" },
      in: { enum: ["query", "header", "path", "cookie"] },
      description: { type: "string" },
      required: { type: "boolean" },
      deprecated: { type: "boolean" },
      allowEmptyValue: { type: "boolean" },
      style: {
        enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
      },
      explode: { type: "boolean" },
      allowReserved: { type: "boolean" },
      schema: "Schema",
      example: { isExample: true },
      examples: "ExamplesMap",
      content: "MediaTypesMap"
    },
    required: ["name", "in"],
    requiredOneOf: ["schema", "content"],
    extensionsPrefix: "x-"
  };
  const Operation = {
    properties: {
      tags: {
        type: "array",
        items: { type: "string" }
      },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      parameters: "ParameterList",
      security: "SecurityRequirementList",
      servers: "ServerList",
      requestBody: "RequestBody",
      responses: "Responses",
      deprecated: { type: "boolean" },
      callbacks: "CallbacksMap",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      "x-hideTryItPanel": { type: "boolean" }
    },
    required: ["responses"],
    extensionsPrefix: "x-"
  };
  const XCodeSample = {
    properties: {
      lang: { type: "string" },
      label: { type: "string" },
      source: { type: "string" }
    }
  };
  const RequestBody = {
    properties: {
      description: { type: "string" },
      required: { type: "boolean" },
      content: "MediaTypesMap"
    },
    required: ["content"],
    extensionsPrefix: "x-"
  };
  const MediaTypesMap = {
    properties: {},
    additionalProperties: "MediaType"
  };
  const MediaType = {
    properties: {
      schema: "Schema",
      example: { isExample: true },
      examples: "ExamplesMap",
      encoding: "EncodingMap"
    },
    extensionsPrefix: "x-"
  };
  const Example = {
    properties: {
      value: { isExample: true },
      summary: { type: "string" },
      description: { type: "string" },
      externalValue: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  const Encoding = {
    properties: {
      contentType: { type: "string" },
      headers: "HeadersMap",
      style: {
        enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
      },
      explode: { type: "boolean" },
      allowReserved: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  };
  const EnumDescriptions = {
    properties: {},
    additionalProperties: { type: "string" }
  };
  const Header = {
    properties: {
      description: { type: "string" },
      required: { type: "boolean" },
      deprecated: { type: "boolean" },
      allowEmptyValue: { type: "boolean" },
      style: {
        enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
      },
      explode: { type: "boolean" },
      allowReserved: { type: "boolean" },
      schema: "Schema",
      example: { isExample: true },
      examples: "ExamplesMap",
      content: "MediaTypesMap"
    },
    requiredOneOf: ["schema", "content"],
    extensionsPrefix: "x-"
  };
  const Responses = {
    properties: { default: "Response" },
    additionalProperties: (_v, key2) => responseCodeRegexp.test(key2) ? "Response" : void 0
  };
  const Response = {
    properties: {
      description: { type: "string" },
      headers: "HeadersMap",
      content: "MediaTypesMap",
      links: "LinksMap",
      "x-summary": { type: "string" }
    },
    required: ["description"],
    extensionsPrefix: "x-"
  };
  const Link = {
    properties: {
      operationRef: { type: "string" },
      operationId: { type: "string" },
      parameters: null,
      requestBody: null,
      description: { type: "string" },
      server: "Server"
    },
    extensionsPrefix: "x-"
  };
  const Schema2 = {
    properties: {
      externalDocs: "ExternalDocs",
      discriminator: "Discriminator",
      title: { type: "string" },
      multipleOf: { type: "number", minimum: 0 },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "boolean" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer", minimum: 0 },
      minLength: { type: "integer", minimum: 0 },
      pattern: { type: "string" },
      maxItems: { type: "integer", minimum: 0 },
      minItems: { type: "integer", minimum: 0 },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "integer", minimum: 0 },
      minProperties: { type: "integer", minimum: 0 },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: {
        enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
      },
      allOf: _1.listOf("Schema"),
      anyOf: _1.listOf("Schema"),
      oneOf: _1.listOf("Schema"),
      not: "Schema",
      properties: "SchemaProperties",
      items: (value) => {
        if (Array.isArray(value)) {
          return _1.listOf("Schema");
        } else {
          return "Schema";
        }
      },
      additionalItems: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      additionalProperties: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      description: { type: "string" },
      format: { type: "string" },
      default: null,
      nullable: { type: "boolean" },
      readOnly: { type: "boolean" },
      writeOnly: { type: "boolean" },
      xml: "Xml",
      example: { isExample: true },
      deprecated: { type: "boolean" },
      "x-tags": { type: "array", items: { type: "string" } },
      "x-additionalPropertiesName": { type: "string" },
      "x-explicitMappingOnly": { type: "boolean" }
    },
    extensionsPrefix: "x-"
  };
  const Xml = {
    properties: {
      name: { type: "string" },
      namespace: { type: "string" },
      prefix: { type: "string" },
      attribute: { type: "boolean" },
      wrapped: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  };
  const SchemaProperties = {
    properties: {},
    additionalProperties: "Schema"
  };
  const DiscriminatorMapping = {
    properties: {},
    additionalProperties: (value) => {
      if (ref_utils_1.isMappingRef(value)) {
        return { type: "string", directResolveAs: "Schema" };
      } else {
        return { type: "string" };
      }
    }
  };
  const Discriminator = {
    properties: {
      propertyName: { type: "string" },
      mapping: "DiscriminatorMapping"
    },
    required: ["propertyName"],
    extensionsPrefix: "x-"
  };
  const Components = {
    properties: {
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      responses: "NamedResponses",
      examples: "NamedExamples",
      requestBodies: "NamedRequestBodies",
      headers: "NamedHeaders",
      securitySchemes: "NamedSecuritySchemes",
      links: "NamedLinks",
      callbacks: "NamedCallbacks"
    },
    extensionsPrefix: "x-"
  };
  const ImplicitFlow = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      authorizationUrl: { type: "string" }
    },
    required: ["authorizationUrl", "scopes"],
    extensionsPrefix: "x-"
  };
  const PasswordFlow = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "scopes"],
    extensionsPrefix: "x-"
  };
  const ClientCredentials = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "scopes"],
    extensionsPrefix: "x-"
  };
  const AuthorizationCode = {
    properties: {
      refreshUrl: { type: "string" },
      authorizationUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" },
      "x-usePkce": (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "XUsePkce";
        }
      }
    },
    required: ["authorizationUrl", "tokenUrl", "scopes"],
    extensionsPrefix: "x-"
  };
  const OAuth2Flows = {
    properties: {
      implicit: "ImplicitFlow",
      password: "PasswordFlow",
      clientCredentials: "ClientCredentials",
      authorizationCode: "AuthorizationCode"
    },
    extensionsPrefix: "x-"
  };
  const SecurityScheme = {
    properties: {
      type: { enum: ["apiKey", "http", "oauth2", "openIdConnect"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "OAuth2Flows",
      openIdConnectUrl: { type: "string" },
      "x-defaultClientId": { type: "string" }
    },
    required(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          return ["type", "flows", "description"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  const XUsePkce = {
    properties: {
      disableManualConfiguration: { type: "boolean" },
      hideClientSecretInput: { type: "boolean" }
    }
  };
  oas3.Oas3Types = {
    Root,
    Tag,
    TagList: _1.listOf("Tag"),
    TagGroups: _1.listOf("TagGroup"),
    TagGroup,
    ExternalDocs,
    Server,
    ServerList: _1.listOf("Server"),
    ServerVariable,
    ServerVariablesMap: _1.mapOf("ServerVariable"),
    SecurityRequirement,
    SecurityRequirementList: _1.listOf("SecurityRequirement"),
    Info,
    Contact,
    License,
    Paths,
    PathItem,
    Parameter,
    ParameterList: _1.listOf("Parameter"),
    Operation,
    Callback: _1.mapOf("PathItem"),
    CallbacksMap: _1.mapOf("Callback"),
    RequestBody,
    MediaTypesMap,
    MediaType,
    Example,
    ExamplesMap: _1.mapOf("Example"),
    Encoding,
    EncodingMap: _1.mapOf("Encoding"),
    EnumDescriptions,
    Header,
    HeadersMap: _1.mapOf("Header"),
    Responses,
    Response,
    Link,
    Logo,
    Schema: Schema2,
    Xml,
    SchemaProperties,
    DiscriminatorMapping,
    Discriminator,
    Components,
    LinksMap: _1.mapOf("Link"),
    NamedSchemas: _1.mapOf("Schema"),
    NamedResponses: _1.mapOf("Response"),
    NamedParameters: _1.mapOf("Parameter"),
    NamedExamples: _1.mapOf("Example"),
    NamedRequestBodies: _1.mapOf("RequestBody"),
    NamedHeaders: _1.mapOf("Header"),
    NamedSecuritySchemes: _1.mapOf("SecurityScheme"),
    NamedLinks: _1.mapOf("Link"),
    NamedCallbacks: _1.mapOf("Callback"),
    ImplicitFlow,
    PasswordFlow,
    ClientCredentials,
    AuthorizationCode,
    OAuth2Flows,
    SecurityScheme,
    XCodeSample,
    XCodeSampleList: _1.listOf("XCodeSample"),
    XUsePkce,
    WebhooksMap
  };
  return oas3;
}
var oas3_1 = {};
var hasRequiredOas3_1;
function requireOas3_1() {
  if (hasRequiredOas3_1)
    return oas3_1;
  hasRequiredOas3_1 = 1;
  Object.defineProperty(oas3_1, "__esModule", { value: true });
  oas3_1.Oas3_1Types = void 0;
  const _1 = requireTypes();
  const oas3_1$1 = requireOas3();
  const Root = {
    properties: {
      openapi: null,
      info: "Info",
      servers: "ServerList",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      paths: "Paths",
      webhooks: "WebhooksMap",
      components: "Components",
      jsonSchemaDialect: { type: "string" }
    },
    required: ["openapi", "info"],
    requiredOneOf: ["paths", "components", "webhooks"],
    extensionsPrefix: "x-"
  };
  const License = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      identifier: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  };
  const Info = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      summary: { type: "string" },
      contact: "Contact",
      license: "License",
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  };
  const Components = {
    properties: {
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      responses: "NamedResponses",
      examples: "NamedExamples",
      requestBodies: "NamedRequestBodies",
      headers: "NamedHeaders",
      securitySchemes: "NamedSecuritySchemes",
      links: "NamedLinks",
      callbacks: "NamedCallbacks",
      pathItems: "NamedPathItems"
    },
    extensionsPrefix: "x-"
  };
  const Operation = {
    properties: {
      tags: {
        type: "array",
        items: { type: "string" }
      },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      parameters: "ParameterList",
      security: "SecurityRequirementList",
      servers: "ServerList",
      requestBody: "RequestBody",
      responses: "Responses",
      deprecated: { type: "boolean" },
      callbacks: "CallbacksMap",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      "x-hideTryItPanel": { type: "boolean" }
    },
    extensionsPrefix: "x-"
  };
  const Schema2 = {
    properties: {
      $id: { type: "string" },
      $anchor: { type: "string" },
      id: { type: "string" },
      $schema: { type: "string" },
      definitions: "NamedSchemas",
      $defs: "NamedSchemas",
      $vocabulary: { type: "string" },
      externalDocs: "ExternalDocs",
      discriminator: "Discriminator",
      title: { type: "string" },
      multipleOf: { type: "number", minimum: 0 },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { type: "integer", minimum: 0 },
      minLength: { type: "integer", minimum: 0 },
      pattern: { type: "string" },
      maxItems: { type: "integer", minimum: 0 },
      minItems: { type: "integer", minimum: 0 },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "integer", minimum: 0 },
      minProperties: { type: "integer", minimum: 0 },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: (value) => {
        if (Array.isArray(value)) {
          return {
            type: "array",
            items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
          };
        } else {
          return {
            enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
          };
        }
      },
      allOf: _1.listOf("Schema"),
      anyOf: _1.listOf("Schema"),
      oneOf: _1.listOf("Schema"),
      not: "Schema",
      if: "Schema",
      then: "Schema",
      else: "Schema",
      dependentSchemas: _1.listOf("Schema"),
      prefixItems: _1.listOf("Schema"),
      contains: "Schema",
      minContains: { type: "integer", minimum: 0 },
      maxContains: { type: "integer", minimum: 0 },
      patternProperties: { type: "object" },
      propertyNames: "Schema",
      unevaluatedItems: "Schema",
      unevaluatedProperties: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      summary: { type: "string" },
      properties: "SchemaProperties",
      items: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      additionalProperties: (value) => {
        return typeof value === "boolean" ? { type: "boolean" } : "Schema";
      },
      description: { type: "string" },
      format: { type: "string" },
      contentEncoding: { type: "string" },
      contentMediaType: { type: "string" },
      default: null,
      readOnly: { type: "boolean" },
      writeOnly: { type: "boolean" },
      xml: "Xml",
      examples: { type: "array" },
      example: { isExample: true },
      deprecated: { type: "boolean" },
      const: null,
      $comment: { type: "string" },
      "x-tags": { type: "array", items: { type: "string" } }
    },
    extensionsPrefix: "x-"
  };
  const SecurityScheme = {
    properties: {
      type: { enum: ["apiKey", "http", "oauth2", "openIdConnect", "mutualTLS"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "OAuth2Flows",
      openIdConnectUrl: { type: "string" }
    },
    required(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          switch (value === null || value === void 0 ? void 0 : value.flows) {
            case "implicit":
              return ["type", "flows", "authorizationUrl", "refreshUrl", "description", "scopes"];
            case "password":
            case "clientCredentials":
              return ["type", "flows", "tokenUrl", "refreshUrl", "description", "scopes"];
            case "authorizationCode":
              return [
                "type",
                "flows",
                "authorizationUrl",
                "refreshUrl",
                "tokenUrl",
                "description",
                "scopes"
              ];
            default:
              return [
                "type",
                "flows",
                "authorizationUrl",
                "refreshUrl",
                "tokenUrl",
                "description",
                "scopes"
              ];
          }
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description"];
        case "mutualTLS":
          return ["type", "description"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  oas3_1.Oas3_1Types = Object.assign(Object.assign({}, oas3_1$1.Oas3Types), {
    Info,
    Root,
    Schema: Schema2,
    License,
    Components,
    NamedPathItems: _1.mapOf("PathItem"),
    SecurityScheme,
    Operation
  });
  return oas3_1;
}
var asyncapi = {};
var hasRequiredAsyncapi;
function requireAsyncapi() {
  if (hasRequiredAsyncapi)
    return asyncapi;
  hasRequiredAsyncapi = 1;
  Object.defineProperty(asyncapi, "__esModule", { value: true });
  asyncapi.AsyncApi2Types = void 0;
  const _1 = requireTypes();
  const ref_utils_1 = requireRefUtils();
  const Root = {
    properties: {
      asyncapi: null,
      info: "Info",
      id: { type: "string" },
      servers: "ServerMap",
      channels: "ChannelMap",
      components: "Components",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      defaultContentType: { type: "string" }
    },
    required: ["asyncapi", "channels", "info"]
  };
  const Channel = {
    properties: {
      description: { type: "string" },
      subscribe: "Operation",
      publish: "Operation",
      parameters: "ParametersMap",
      bindings: "ChannelBindings",
      servers: { type: "array", items: { type: "string" } }
    }
  };
  const ChannelMap = {
    properties: {},
    additionalProperties: "Channel"
  };
  const ChannelBindings = {
    properties: {},
    allowed() {
      return [
        "http",
        "ws",
        "kafka",
        "anypointmq",
        "amqp",
        "amqp1",
        "mqtt",
        "mqtt5",
        "nats",
        "jms",
        "sns",
        "solace",
        "sqs",
        "stomp",
        "redis",
        "mercure",
        "ibmmq",
        "googlepubsub",
        "pulsar"
      ];
    },
    additionalProperties: { type: "object" }
  };
  const Tag = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs"
    },
    required: ["name"]
  };
  const ExternalDocs = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"]
  };
  const SecurityRequirement = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  };
  const ServerBindings = {
    properties: {},
    allowed() {
      return [
        "http",
        "ws",
        "kafka",
        "anypointmq",
        "amqp",
        "amqp1",
        "mqtt",
        "mqtt5",
        "nats",
        "jms",
        "sns",
        "solace",
        "sqs",
        "stomp",
        "redis",
        "mercure",
        "ibmmq",
        "googlepubsub",
        "pulsar"
      ];
    },
    additionalProperties: { type: "object" }
  };
  const Server = {
    properties: {
      url: { type: "string" },
      protocol: { type: "string" },
      protocolVersion: { type: "string" },
      description: { type: "string" },
      variables: "ServerVariablesMap",
      security: "SecurityRequirementList",
      bindings: "ServerBindings",
      tags: "TagList"
    },
    required: ["url", "protocol"]
  };
  const ServerMap = {
    properties: {},
    additionalProperties: (_value, key2) => key2.match(/^[A-Za-z0-9_\-]+$/) ? "Server" : void 0
  };
  const ServerVariable = {
    properties: {
      enum: {
        type: "array",
        items: { type: "string" }
      },
      default: { type: "string" },
      description: { type: "string" },
      examples: {
        type: "array",
        items: { type: "string" }
      }
    },
    required: []
  };
  const Info = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License"
    },
    required: ["title", "version"]
  };
  const Contact = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    }
  };
  const License = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"]
  };
  const Parameter = {
    properties: {
      description: { type: "string" },
      schema: "Schema",
      location: { type: "string" }
    }
  };
  const CorrelationId = {
    properties: {
      description: { type: "string" },
      location: { type: "string" }
    },
    required: ["location"]
  };
  const Message = {
    properties: {
      messageId: { type: "string" },
      headers: "Schema",
      payload: "Schema",
      correlationId: "CorrelationId",
      schemaFormat: { type: "string" },
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      // examples: 'MessageExampleList', // TODO: add support for message examples
      traits: "MessageTraitList"
    },
    additionalProperties: {}
  };
  const MessageBindings = {
    properties: {},
    allowed() {
      return [
        "http",
        "ws",
        "kafka",
        "anypointmq",
        "amqp",
        "amqp1",
        "mqtt",
        "mqtt5",
        "nats",
        "jms",
        "sns",
        "solace",
        "sqs",
        "stomp",
        "redis",
        "mercure",
        "ibmmq",
        "googlepubsub",
        "pulsar"
      ];
    },
    additionalProperties: { type: "object" }
  };
  const OperationBindings = {
    properties: {},
    allowed() {
      return [
        "http",
        "ws",
        "kafka",
        "anypointmq",
        "amqp",
        "amqp1",
        "mqtt",
        "mqtt5",
        "nats",
        "jms",
        "sns",
        "solace",
        "sqs",
        "stomp",
        "redis",
        "mercure",
        "ibmmq",
        "googlepubsub",
        "pulsar"
      ];
    },
    additionalProperties: { type: "object" }
  };
  const OperationTrait = {
    properties: {
      tags: {
        type: "array",
        items: { type: "string" }
      },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      security: "SecurityRequirementList",
      bindings: "OperationBindings"
    },
    required: []
  };
  const MessageTrait = {
    properties: {
      messageId: { type: "string" },
      headers: "Schema",
      correlationId: "CorrelationId",
      schemaFormat: { type: "string" },
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings"
      // examples: 'MessageExampleList', // TODO: support examples for message traits
    },
    additionalProperties: {}
  };
  const Operation = {
    properties: {
      tags: {
        type: "array",
        items: { type: "string" }
      },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      security: "SecurityRequirementList",
      bindings: "OperationBindings",
      traits: "OperationTraitList",
      message: "Message"
    },
    required: []
  };
  const MessageExample = {
    properties: {
      payload: { isExample: true },
      summary: { type: "string" },
      name: { type: "string" },
      headers: { type: "object" }
    }
  };
  const Schema2 = {
    properties: {
      $id: { type: "string" },
      id: { type: "string" },
      $schema: { type: "string" },
      definitions: "NamedSchemas",
      $defs: "NamedSchemas",
      $vocabulary: { type: "string" },
      externalDocs: "ExternalDocs",
      discriminator: "Discriminator",
      myArbitraryKeyword: { type: "boolean" },
      title: { type: "string" },
      multipleOf: { type: "number", minimum: 0 },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "number" },
      exclusiveMinimum: { type: "number" },
      maxLength: { type: "integer", minimum: 0 },
      minLength: { type: "integer", minimum: 0 },
      pattern: { type: "string" },
      maxItems: { type: "integer", minimum: 0 },
      minItems: { type: "integer", minimum: 0 },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "integer", minimum: 0 },
      minProperties: { type: "integer", minimum: 0 },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: (value) => {
        if (Array.isArray(value)) {
          return {
            type: "array",
            items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
          };
        } else {
          return {
            enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
          };
        }
      },
      allOf: _1.listOf("Schema"),
      anyOf: _1.listOf("Schema"),
      oneOf: _1.listOf("Schema"),
      not: "Schema",
      if: "Schema",
      then: "Schema",
      else: "Schema",
      dependentSchemas: _1.listOf("Schema"),
      prefixItems: _1.listOf("Schema"),
      contains: "Schema",
      minContains: { type: "integer", minimum: 0 },
      maxContains: { type: "integer", minimum: 0 },
      patternProperties: { type: "object" },
      propertyNames: "Schema",
      unevaluatedItems: "Schema",
      unevaluatedProperties: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      summary: { type: "string" },
      properties: "SchemaProperties",
      items: (value) => {
        if (typeof value === "boolean") {
          return { type: "boolean" };
        } else {
          return "Schema";
        }
      },
      additionalProperties: (value) => {
        return typeof value === "boolean" ? { type: "boolean" } : "Schema";
      },
      description: { type: "string" },
      format: { type: "string" },
      contentEncoding: { type: "string" },
      contentMediaType: { type: "string" },
      default: null,
      readOnly: { type: "boolean" },
      writeOnly: { type: "boolean" },
      // xml: 'Xml',
      examples: { type: "array" },
      example: { isExample: true },
      deprecated: { type: "boolean" },
      const: null,
      $comment: { type: "string" },
      dependencies: { type: "object" }
      // TODO
    }
  };
  const SchemaProperties = {
    properties: {},
    additionalProperties: (value) => {
      if (typeof value === "boolean") {
        return { type: "boolean" };
      }
      return "Schema";
    }
  };
  const DiscriminatorMapping = {
    properties: {},
    additionalProperties: (value) => {
      if (ref_utils_1.isMappingRef(value)) {
        return { type: "string", directResolveAs: "Schema" };
      } else {
        return { type: "string" };
      }
    }
  };
  const Discriminator = {
    properties: {
      propertyName: { type: "string" },
      mapping: "DiscriminatorMapping"
    },
    required: ["propertyName"]
  };
  const Components = {
    properties: {
      messages: "NamedMessages",
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      correlationIds: "NamedCorrelationIds",
      messageTraits: "NamedMessageTraits",
      operationTraits: "NamedOperationTraits",
      streamHeaders: "NamedStreamHeaders",
      securitySchemes: "NamedSecuritySchemes",
      servers: "ServerMap",
      serverVariables: "ServerVariablesMap",
      channels: "ChannelMap",
      serverBindings: "ServerBindings",
      channelBindings: "ChannelBindings",
      operationBindings: "OperationBindings",
      messageBindings: "MessageBindings"
    }
  };
  const ImplicitFlow = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      authorizationUrl: { type: "string" }
    },
    required: ["authorizationUrl", "scopes"]
  };
  const PasswordFlow = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "scopes"]
  };
  const ClientCredentials = {
    properties: {
      refreshUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "scopes"]
  };
  const AuthorizationCode = {
    properties: {
      refreshUrl: { type: "string" },
      authorizationUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["authorizationUrl", "tokenUrl", "scopes"]
  };
  const SecuritySchemeFlows = {
    properties: {
      implicit: "ImplicitFlow",
      password: "PasswordFlow",
      clientCredentials: "ClientCredentials",
      authorizationCode: "AuthorizationCode"
    }
  };
  const SecurityScheme = {
    properties: {
      type: {
        enum: [
          "userPassword",
          "apiKey",
          "X509",
          "symmetricEncryption",
          "asymmetricEncryption",
          "httpApiKey",
          "http",
          "oauth2",
          "openIdConnect",
          "plain",
          "scramSha256",
          "scramSha512",
          "gssapi"
        ]
      },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "SecuritySchemeFlows",
      openIdConnectUrl: { type: "string" }
    },
    required(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "in"];
        case "httpApiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(value) {
      switch (value === null || value === void 0 ? void 0 : value.type) {
        case "apiKey":
          return ["type", "in", "description"];
        case "httpApiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          return ["type", "flows", "description"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  const HttpChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.http = HttpChannelBinding;
  const HttpServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.http = HttpServerBinding;
  const HttpMessageBinding = {
    properties: {
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.http = HttpMessageBinding;
  const HttpOperationBinding = {
    properties: {
      type: { type: "string" },
      method: {
        type: "string",
        enum: ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"]
      },
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.http = HttpOperationBinding;
  const WsChannelBinding = {
    properties: {
      method: { type: "string" },
      query: "Schema",
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  ChannelBindings.properties.ws = WsChannelBinding;
  const WsServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.ws = WsServerBinding;
  const WsMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.ws = WsMessageBinding;
  const WsOperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.ws = WsOperationBinding;
  const KafkaTopicConfiguration = {
    properties: {
      "cleanup.policy": { type: "array", items: { enum: ["delete", "compact"] } },
      "retention.ms": { type: "integer" },
      "retention.bytes": { type: "integer" },
      "delete.retention.ms": { type: "integer" },
      "max.message.bytes": { type: "integer" }
    }
  };
  const KafkaChannelBinding = {
    properties: {
      topic: { type: "string" },
      partitions: { type: "integer" },
      replicas: { type: "integer" },
      topicConfiguration: "KafkaTopicConfiguration",
      bindingVersion: { type: "string" }
    }
  };
  ChannelBindings.properties.kafka = KafkaChannelBinding;
  const KafkaServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.kafka = KafkaServerBinding;
  const KafkaMessageBinding = {
    properties: {
      key: "Schema",
      schemaIdLocation: { type: "string" },
      schemaIdPayloadEncoding: { type: "string" },
      schemaLookupStrategy: { type: "string" },
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.kafka = KafkaMessageBinding;
  const KafkaOperationBinding = {
    properties: {
      groupId: "Schema",
      clientId: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.kafka = KafkaOperationBinding;
  const AnypointmqChannelBinding = {
    properties: {
      destination: { type: "string" },
      destinationType: { type: "string" },
      bindingVersion: { type: "string" }
    }
  };
  ChannelBindings.properties.anypointmq = AnypointmqChannelBinding;
  const AnypointmqServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.anypointmq = AnypointmqServerBinding;
  const AnypointmqMessageBinding = {
    properties: {
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.anypointmq = AnypointmqMessageBinding;
  const AnypointmqOperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.anypointmq = AnypointmqOperationBinding;
  const AmqpChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.amqp = AmqpChannelBinding;
  const AmqpServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.amqp = AmqpServerBinding;
  const AmqpMessageBinding = {
    properties: {
      contentEncoding: { type: "string" },
      messageType: { type: "string" },
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.amqp = AmqpMessageBinding;
  const AmqpOperationBinding = {
    // TODO: some fields are subscribe only
    properties: {
      expiration: { type: "integer" },
      userId: { type: "string" },
      cc: { type: "array", items: { type: "string" } },
      priority: { type: "integer" },
      deliveryMode: { type: "integer" },
      mandatory: { type: "boolean" },
      bcc: { type: "array", items: { type: "string" } },
      replyTo: { type: "string" },
      timestamp: { type: "boolean" },
      ack: { type: "boolean" },
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.amqp = AmqpOperationBinding;
  const Amqp1ChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.amqp1 = Amqp1ChannelBinding;
  const Amqp1ServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.amqp1 = Amqp1ServerBinding;
  const Amqp1MessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.amqp1 = Amqp1MessageBinding;
  const Amqp1OperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.amqp1 = Amqp1OperationBinding;
  const MqttChannelBinding = {
    properties: {
      qos: { type: "integer" },
      retain: { type: "boolean" },
      bindingVersion: { type: "string" }
    }
  };
  ChannelBindings.properties.mqtt = MqttChannelBinding;
  const MqttServerBindingLastWill = {
    properties: {
      topic: { type: "string" },
      qos: { type: "integer" },
      message: { type: "string" },
      retain: { type: "boolean" }
    }
  };
  const MqttServerBinding = {
    properties: {
      clientId: { type: "string" },
      cleanSession: { type: "boolean" },
      lastWill: "MqttServerBindingLastWill",
      keepAlive: { type: "integer" },
      bindingVersion: { type: "string" }
    }
  };
  ServerBindings.properties.mqtt = MqttServerBinding;
  const MqttMessageBinding = {
    properties: {
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.mqtt = MqttMessageBinding;
  const MqttOperationBinding = {
    properties: {
      qos: { type: "integer" },
      retain: { type: "boolean" },
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.mqtt = MqttOperationBinding;
  const Mqtt5ChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.mqtt5 = Mqtt5ChannelBinding;
  const Mqtt5ServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.mqtt5 = Mqtt5ServerBinding;
  const Mqtt5MessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.mqtt5 = Mqtt5MessageBinding;
  const Mqtt5OperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.mqtt5 = Mqtt5OperationBinding;
  const NatsChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.nats = NatsChannelBinding;
  const NatsServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.nats = NatsServerBinding;
  const NatsMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.nats = NatsMessageBinding;
  const NatsOperationBinding = {
    properties: {
      queue: { type: "string" },
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.nats = NatsOperationBinding;
  const JmsChannelBinding = {
    properties: {
      destination: { type: "string" },
      destinationType: { type: "string" },
      bindingVersion: { type: "string" }
    }
  };
  ChannelBindings.properties.jms = JmsChannelBinding;
  const JmsServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.jms = JmsServerBinding;
  const JmsMessageBinding = {
    properties: {
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  MessageBindings.properties.jms = JmsMessageBinding;
  const JmsOperationBinding = {
    properties: {
      headers: "Schema",
      bindingVersion: { type: "string" }
    }
  };
  OperationBindings.properties.jms = JmsOperationBinding;
  const SolaceChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.solace = SolaceChannelBinding;
  const SolaceServerBinding = {
    properties: {
      bindingVersion: { type: "string" },
      msgVpn: { type: "string" }
    }
  };
  ServerBindings.properties.solace = SolaceServerBinding;
  const SolaceMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.solace = SolaceMessageBinding;
  const SolaceDestination = {
    properties: {
      destinationType: { type: "string", enum: ["queue", "topic"] },
      deliveryMode: { type: "string", enum: ["direct", "persistent"] },
      "queue.name": { type: "string" },
      "queue.topicSubscriptions": { type: "array", items: { type: "string" } },
      "queue.accessType": { type: "string", enum: ["exclusive", "nonexclusive"] },
      "queue.maxMsgSpoolSize": { type: "string" },
      "queue.maxTtl": { type: "string" },
      "topic.topicSubscriptions": { type: "array", items: { type: "string" } }
    }
  };
  const SolaceOperationBinding = {
    properties: {
      bindingVersion: { type: "string" },
      destinations: _1.listOf("SolaceDestination")
    }
  };
  OperationBindings.properties.solace = SolaceOperationBinding;
  const StompChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.stomp = StompChannelBinding;
  const StompServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.stomp = StompServerBinding;
  const StompMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.stomp = StompMessageBinding;
  const StompOperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.stomp = StompOperationBinding;
  const RedisChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.redis = RedisChannelBinding;
  const RedisServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.redis = RedisServerBinding;
  const RedisMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.redis = RedisMessageBinding;
  const RedisOperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.redis = RedisOperationBinding;
  const MercureChannelBinding = {
    properties: {}
    // empty object
  };
  ChannelBindings.properties.mercure = MercureChannelBinding;
  const MercureServerBinding = {
    properties: {}
    // empty object
  };
  ServerBindings.properties.mercure = MercureServerBinding;
  const MercureMessageBinding = {
    properties: {}
    // empty object
  };
  MessageBindings.properties.mercure = MercureMessageBinding;
  const MercureOperationBinding = {
    properties: {}
    // empty object
  };
  OperationBindings.properties.mercure = MercureOperationBinding;
  asyncapi.AsyncApi2Types = {
    Root,
    Tag,
    TagList: _1.listOf("Tag"),
    ServerMap,
    ExternalDocs,
    Server,
    ServerVariable,
    ServerVariablesMap: _1.mapOf("ServerVariable"),
    SecurityRequirement,
    SecurityRequirementList: _1.listOf("SecurityRequirement"),
    Info,
    Contact,
    License,
    HttpServerBinding,
    HttpChannelBinding,
    HttpMessageBinding,
    HttpOperationBinding,
    WsServerBinding,
    WsChannelBinding,
    WsMessageBinding,
    WsOperationBinding,
    KafkaServerBinding,
    KafkaTopicConfiguration,
    KafkaChannelBinding,
    KafkaMessageBinding,
    KafkaOperationBinding,
    AnypointmqServerBinding,
    AnypointmqChannelBinding,
    AnypointmqMessageBinding,
    AnypointmqOperationBinding,
    AmqpServerBinding,
    AmqpChannelBinding,
    AmqpMessageBinding,
    AmqpOperationBinding,
    Amqp1ServerBinding,
    Amqp1ChannelBinding,
    Amqp1MessageBinding,
    Amqp1OperationBinding,
    MqttServerBindingLastWill,
    MqttServerBinding,
    MqttChannelBinding,
    MqttMessageBinding,
    MqttOperationBinding,
    Mqtt5ServerBinding,
    Mqtt5ChannelBinding,
    Mqtt5MessageBinding,
    Mqtt5OperationBinding,
    NatsServerBinding,
    NatsChannelBinding,
    NatsMessageBinding,
    NatsOperationBinding,
    JmsServerBinding,
    JmsChannelBinding,
    JmsMessageBinding,
    JmsOperationBinding,
    SolaceServerBinding,
    SolaceChannelBinding,
    SolaceMessageBinding,
    SolaceDestination,
    SolaceOperationBinding,
    StompServerBinding,
    StompChannelBinding,
    StompMessageBinding,
    StompOperationBinding,
    RedisServerBinding,
    RedisChannelBinding,
    RedisMessageBinding,
    RedisOperationBinding,
    MercureServerBinding,
    MercureChannelBinding,
    MercureMessageBinding,
    MercureOperationBinding,
    ServerBindings,
    ChannelBindings,
    ChannelMap,
    Channel,
    Parameter,
    ParametersMap: _1.mapOf("Parameter"),
    Operation,
    Schema: Schema2,
    MessageExample,
    SchemaProperties,
    DiscriminatorMapping,
    Discriminator,
    Components,
    NamedSchemas: _1.mapOf("Schema"),
    NamedMessages: _1.mapOf("Message"),
    NamedMessageTraits: _1.mapOf("MessageTrait"),
    NamedOperationTraits: _1.mapOf("OperationTrait"),
    NamedParameters: _1.mapOf("Parameter"),
    NamedSecuritySchemes: _1.mapOf("SecurityScheme"),
    NamedCorrelationIds: _1.mapOf("CorrelationId"),
    NamedStreamHeaders: _1.mapOf("StreamHeader"),
    ImplicitFlow,
    PasswordFlow,
    ClientCredentials,
    AuthorizationCode,
    SecuritySchemeFlows,
    SecurityScheme,
    Message,
    MessageBindings,
    OperationBindings,
    OperationTrait,
    OperationTraitList: _1.listOf("OperationTrait"),
    MessageTrait,
    MessageTraitList: _1.listOf("MessageTrait"),
    CorrelationId
  };
  return asyncapi;
}
var hasRequiredOasTypes;
function requireOasTypes() {
  if (hasRequiredOasTypes)
    return oasTypes;
  hasRequiredOasTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTypes = exports.getMajorSpecVersion = exports.detectSpec = exports.SpecMajorVersion = exports.SpecVersion = void 0;
    const oas2_1 = requireOas2();
    const oas3_12 = requireOas3();
    const oas3_1_1 = requireOas3_1();
    const asyncapi_1 = requireAsyncapi();
    var SpecVersion;
    (function(SpecVersion2) {
      SpecVersion2["OAS2"] = "oas2";
      SpecVersion2["OAS3_0"] = "oas3_0";
      SpecVersion2["OAS3_1"] = "oas3_1";
      SpecVersion2["Async2"] = "async2";
    })(SpecVersion = exports.SpecVersion || (exports.SpecVersion = {}));
    var SpecMajorVersion;
    (function(SpecMajorVersion2) {
      SpecMajorVersion2["OAS2"] = "oas2";
      SpecMajorVersion2["OAS3"] = "oas3";
      SpecMajorVersion2["Async2"] = "async2";
    })(SpecMajorVersion = exports.SpecMajorVersion || (exports.SpecMajorVersion = {}));
    const typesMap = {
      [SpecVersion.OAS2]: oas2_1.Oas2Types,
      [SpecVersion.OAS3_0]: oas3_12.Oas3Types,
      [SpecVersion.OAS3_1]: oas3_1_1.Oas3_1Types,
      [SpecVersion.Async2]: asyncapi_1.AsyncApi2Types
    };
    function detectSpec(root) {
      if (typeof root !== "object") {
        throw new Error(`Document must be JSON object, got ${typeof root}`);
      }
      if (root.openapi && typeof root.openapi !== "string") {
        throw new Error(`Invalid OpenAPI version: should be a string but got "${typeof root.openapi}"`);
      }
      if (root.openapi && root.openapi.startsWith("3.0")) {
        return SpecVersion.OAS3_0;
      }
      if (root.openapi && root.openapi.startsWith("3.1")) {
        return SpecVersion.OAS3_1;
      }
      if (root.swagger && root.swagger === "2.0") {
        return SpecVersion.OAS2;
      }
      if (root.openapi || root.swagger) {
        throw new Error(`Unsupported OpenAPI version: ${root.openapi || root.swagger}`);
      }
      if (root.asyncapi && root.asyncapi.startsWith("2.")) {
        return SpecVersion.Async2;
      }
      if (root.asyncapi) {
        throw new Error(`Unsupported AsyncAPI version: ${root.asyncapi}`);
      }
      throw new Error(`Unsupported specification`);
    }
    exports.detectSpec = detectSpec;
    function getMajorSpecVersion(version2) {
      if (version2 === SpecVersion.OAS2) {
        return SpecMajorVersion.OAS2;
      } else if (version2 === SpecVersion.Async2) {
        return SpecMajorVersion.Async2;
      } else {
        return SpecMajorVersion.OAS3;
      }
    }
    exports.getMajorSpecVersion = getMajorSpecVersion;
    function getTypes(spec) {
      return typesMap[spec];
    }
    exports.getTypes = getTypes;
  })(oasTypes);
  return oasTypes;
}
var rules = {};
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules)
    return rules;
  hasRequiredRules = 1;
  Object.defineProperty(rules, "__esModule", { value: true });
  rules.initRules = void 0;
  const utils_1 = requireUtils$1();
  function initRules(rules2, config2, type2, oasVersion) {
    return rules2.flatMap((ruleset2) => Object.keys(ruleset2).map((ruleId) => {
      const rule = ruleset2[ruleId];
      const ruleSettings = type2 === "rules" ? config2.getRuleSettings(ruleId, oasVersion) : type2 === "preprocessors" ? config2.getPreprocessorSettings(ruleId, oasVersion) : config2.getDecoratorSettings(ruleId, oasVersion);
      if (ruleSettings.severity === "off") {
        return void 0;
      }
      const severity = ruleSettings.severity;
      const visitors2 = rule(ruleSettings);
      if (Array.isArray(visitors2)) {
        return visitors2.map((visitor) => ({
          severity,
          ruleId,
          visitor
        }));
      }
      return {
        severity,
        ruleId,
        visitor: visitors2
        // note: actually it is only one visitor object
      };
    })).flatMap((visitor) => visitor).filter(utils_1.isDefined);
  }
  rules.initRules = initRules;
  return rules;
}
var noUnresolvedRefs = {};
var hasRequiredNoUnresolvedRefs;
function requireNoUnresolvedRefs() {
  if (hasRequiredNoUnresolvedRefs)
    return noUnresolvedRefs;
  hasRequiredNoUnresolvedRefs = 1;
  Object.defineProperty(noUnresolvedRefs, "__esModule", { value: true });
  noUnresolvedRefs.reportUnresolvedRef = noUnresolvedRefs.NoUnresolvedRefs = void 0;
  const resolve_1 = requireResolve();
  const NoUnresolvedRefs = () => {
    return {
      ref: {
        leave(_2, { report, location }, resolved) {
          if (resolved.node !== void 0)
            return;
          reportUnresolvedRef(resolved, report, location);
        }
      },
      DiscriminatorMapping(mapping, { report, resolve: resolve28, location }) {
        for (const mappingName of Object.keys(mapping)) {
          const resolved = resolve28({ $ref: mapping[mappingName] });
          if (resolved.node !== void 0)
            return;
          reportUnresolvedRef(resolved, report, location.child(mappingName));
        }
      }
    };
  };
  noUnresolvedRefs.NoUnresolvedRefs = NoUnresolvedRefs;
  function reportUnresolvedRef(resolved, report, location) {
    var _a4;
    const error = resolved.error;
    if (error instanceof resolve_1.YamlParseError) {
      report({
        message: "Failed to parse: " + error.message,
        location: {
          source: error.source,
          pointer: void 0,
          start: {
            col: error.col,
            line: error.line
          }
        }
      });
    }
    const message = (_a4 = resolved.error) === null || _a4 === void 0 ? void 0 : _a4.message;
    report({
      location,
      message: `Can't resolve $ref${message ? ": " + message : ""}`
    });
  }
  noUnresolvedRefs.reportUnresolvedRef = reportUnresolvedRef;
  return noUnresolvedRefs;
}
var redocly = {};
var registryApi = {};
var config$1 = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.getUniquePlugins = utils.getResolveConfig = utils.transformConfig = utils.checkForDeprecatedFields = utils.getMergedConfig = utils.mergeExtends = utils.prefixRules = utils.transformApiDefinitionsToApis = utils.parsePresetName = void 0;
  const utils_1 = requireUtils$1();
  const config_1 = requireConfig();
  const logger_1 = requireLogger();
  function parsePresetName(presetName) {
    if (presetName.indexOf("/") > -1) {
      const [pluginId, configName] = presetName.split("/");
      return { pluginId, configName };
    } else {
      return { pluginId: "", configName: presetName };
    }
  }
  utils.parsePresetName = parsePresetName;
  function transformApiDefinitionsToApis(apiDefinitions) {
    if (!apiDefinitions)
      return void 0;
    const apis = {};
    for (const [apiName, apiPath] of Object.entries(apiDefinitions)) {
      apis[apiName] = { root: apiPath };
    }
    return apis;
  }
  utils.transformApiDefinitionsToApis = transformApiDefinitionsToApis;
  function extractFlatConfig(_a4) {
    var _b3;
    var { plugins, extends: _extends2, rules: rules2, oas2Rules, oas3_0Rules, oas3_1Rules, preprocessors, oas2Preprocessors, oas3_0Preprocessors, oas3_1Preprocessors, decorators, oas2Decorators, oas3_0Decorators, oas3_1Decorators } = _a4, rawConfigRest = __rest2(_a4, ["plugins", "extends", "rules", "oas2Rules", "oas3_0Rules", "oas3_1Rules", "preprocessors", "oas2Preprocessors", "oas3_0Preprocessors", "oas3_1Preprocessors", "decorators", "oas2Decorators", "oas3_0Decorators", "oas3_1Decorators"]);
    const styleguideConfig = {
      plugins,
      extends: _extends2,
      rules: rules2,
      oas2Rules,
      oas3_0Rules,
      oas3_1Rules,
      preprocessors,
      oas2Preprocessors,
      oas3_0Preprocessors,
      oas3_1Preprocessors,
      decorators,
      oas2Decorators,
      oas3_0Decorators,
      oas3_1Decorators,
      doNotResolveExamples: (_b3 = rawConfigRest.resolve) === null || _b3 === void 0 ? void 0 : _b3.doNotResolveExamples
    };
    if (rawConfigRest.lint && rawConfigRest.styleguide || Object.values(styleguideConfig).some(utils_1.isDefined) && (rawConfigRest.lint || rawConfigRest.styleguide)) {
      throw new Error(`Do not use 'lint', 'styleguide' and flat syntax together. 
See more about the configuration in the docs: https://redocly.com/docs/cli/configuration/ 
`);
    }
    return {
      styleguideConfig: Object.values(styleguideConfig).some(utils_1.isDefined) ? styleguideConfig : void 0,
      rawConfigRest
    };
  }
  function transformApis(legacyApis) {
    if (!legacyApis)
      return void 0;
    const apis = {};
    for (let _a4 of Object.entries(legacyApis)) {
      const [apiName, _b3] = _a4, { lint } = _b3, apiContent = __rest2(_b3, ["lint"]);
      const { styleguideConfig, rawConfigRest } = extractFlatConfig(apiContent);
      apis[apiName] = Object.assign({ styleguide: styleguideConfig || lint }, rawConfigRest);
    }
    return apis;
  }
  function prefixRules(rules2, prefix2) {
    if (!prefix2)
      return rules2;
    const res = {};
    for (const name2 of Object.keys(rules2)) {
      res[`${prefix2}/${name2}`] = rules2[name2];
    }
    return res;
  }
  utils.prefixRules = prefixRules;
  function mergeExtends(rulesConfList) {
    const result = {
      rules: {},
      oas2Rules: {},
      oas3_0Rules: {},
      oas3_1Rules: {},
      preprocessors: {},
      oas2Preprocessors: {},
      oas3_0Preprocessors: {},
      oas3_1Preprocessors: {},
      decorators: {},
      oas2Decorators: {},
      oas3_0Decorators: {},
      oas3_1Decorators: {},
      plugins: [],
      pluginPaths: [],
      extendPaths: []
    };
    for (const rulesConf of rulesConfList) {
      if (rulesConf.extends) {
        throw new Error(`'extends' is not supported in shared configs yet: ${JSON.stringify(rulesConf, null, 2)}.`);
      }
      Object.assign(result.rules, rulesConf.rules);
      Object.assign(result.oas2Rules, rulesConf.oas2Rules);
      utils_1.assignExisting(result.oas2Rules, rulesConf.rules || {});
      Object.assign(result.oas3_0Rules, rulesConf.oas3_0Rules);
      utils_1.assignExisting(result.oas3_0Rules, rulesConf.rules || {});
      Object.assign(result.oas3_1Rules, rulesConf.oas3_1Rules);
      utils_1.assignExisting(result.oas3_1Rules, rulesConf.rules || {});
      Object.assign(result.preprocessors, rulesConf.preprocessors);
      Object.assign(result.oas2Preprocessors, rulesConf.oas2Preprocessors);
      utils_1.assignExisting(result.oas2Preprocessors, rulesConf.preprocessors || {});
      Object.assign(result.oas3_0Preprocessors, rulesConf.oas3_0Preprocessors);
      utils_1.assignExisting(result.oas3_0Preprocessors, rulesConf.preprocessors || {});
      Object.assign(result.oas3_1Preprocessors, rulesConf.oas3_1Preprocessors);
      utils_1.assignExisting(result.oas3_1Preprocessors, rulesConf.preprocessors || {});
      Object.assign(result.decorators, rulesConf.decorators);
      Object.assign(result.oas2Decorators, rulesConf.oas2Decorators);
      utils_1.assignExisting(result.oas2Decorators, rulesConf.decorators || {});
      Object.assign(result.oas3_0Decorators, rulesConf.oas3_0Decorators);
      utils_1.assignExisting(result.oas3_0Decorators, rulesConf.decorators || {});
      Object.assign(result.oas3_1Decorators, rulesConf.oas3_1Decorators);
      utils_1.assignExisting(result.oas3_1Decorators, rulesConf.decorators || {});
      result.plugins.push(...rulesConf.plugins || []);
      result.pluginPaths.push(...rulesConf.pluginPaths || []);
      result.extendPaths.push(...new Set(rulesConf.extendPaths));
    }
    return result;
  }
  utils.mergeExtends = mergeExtends;
  function getMergedConfig(config2, apiName) {
    var _a4, _b3, _c2, _d2, _e2, _f2, _g2, _h2;
    const extendPaths = [
      ...Object.values(config2.apis).map((api) => {
        var _a5;
        return (_a5 = api === null || api === void 0 ? void 0 : api.styleguide) === null || _a5 === void 0 ? void 0 : _a5.extendPaths;
      }),
      (_b3 = (_a4 = config2.rawConfig) === null || _a4 === void 0 ? void 0 : _a4.styleguide) === null || _b3 === void 0 ? void 0 : _b3.extendPaths
    ].flat().filter(utils_1.isTruthy);
    const pluginPaths = [
      ...Object.values(config2.apis).map((api) => {
        var _a5;
        return (_a5 = api === null || api === void 0 ? void 0 : api.styleguide) === null || _a5 === void 0 ? void 0 : _a5.pluginPaths;
      }),
      (_d2 = (_c2 = config2.rawConfig) === null || _c2 === void 0 ? void 0 : _c2.styleguide) === null || _d2 === void 0 ? void 0 : _d2.pluginPaths
    ].flat().filter(utils_1.isTruthy);
    return apiName ? new config_1.Config(Object.assign(Object.assign({}, config2.rawConfig), { styleguide: Object.assign(Object.assign({}, config2.apis[apiName] ? config2.apis[apiName].styleguide : config2.rawConfig.styleguide), {
      extendPaths,
      pluginPaths
    }), theme: Object.assign(Object.assign({}, config2.rawConfig.theme), (_e2 = config2.apis[apiName]) === null || _e2 === void 0 ? void 0 : _e2.theme), files: [...config2.files, ...(_h2 = (_g2 = (_f2 = config2.apis) === null || _f2 === void 0 ? void 0 : _f2[apiName]) === null || _g2 === void 0 ? void 0 : _g2.files) !== null && _h2 !== void 0 ? _h2 : []] }), config2.configFile) : config2;
  }
  utils.getMergedConfig = getMergedConfig;
  function checkForDeprecatedFields(deprecatedField, updatedField, rawConfig, updatedObject) {
    const isDeprecatedFieldInApis = rawConfig.apis && Object.values(rawConfig.apis).some((api) => api[deprecatedField]);
    if (rawConfig[deprecatedField] && updatedField === null) {
      utils_1.showWarningForDeprecatedField(deprecatedField);
    }
    if (rawConfig[deprecatedField] && updatedField && rawConfig[updatedField]) {
      utils_1.showErrorForDeprecatedField(deprecatedField, updatedField);
    }
    if (rawConfig[deprecatedField] && updatedObject && rawConfig[updatedObject]) {
      utils_1.showErrorForDeprecatedField(deprecatedField, updatedField, updatedObject);
    }
    if (rawConfig[deprecatedField] || isDeprecatedFieldInApis) {
      utils_1.showWarningForDeprecatedField(deprecatedField, updatedField, updatedObject);
    }
  }
  utils.checkForDeprecatedFields = checkForDeprecatedFields;
  function transformConfig(rawConfig) {
    var _a4, _b3;
    const migratedFields = [
      ["apiDefinitions", "apis", void 0],
      ["referenceDocs", "openapi", "theme"],
      ["lint", void 0, void 0],
      ["styleguide", void 0, void 0],
      ["features.openapi", "openapi", "theme"]
    ];
    for (const [deprecatedField, updatedField, updatedObject] of migratedFields) {
      checkForDeprecatedFields(deprecatedField, updatedField, rawConfig, updatedObject);
    }
    const { apis, apiDefinitions, referenceDocs, lint } = rawConfig, rest = __rest2(rawConfig, ["apis", "apiDefinitions", "referenceDocs", "lint"]);
    const { styleguideConfig, rawConfigRest } = extractFlatConfig(rest);
    const transformedConfig = Object.assign({ theme: {
      openapi: Object.assign(Object.assign(Object.assign({}, referenceDocs), rawConfig["features.openapi"]), (_a4 = rawConfig.theme) === null || _a4 === void 0 ? void 0 : _a4.openapi),
      mockServer: Object.assign(Object.assign({}, rawConfig["features.mockServer"]), (_b3 = rawConfig.theme) === null || _b3 === void 0 ? void 0 : _b3.mockServer)
    }, apis: transformApis(apis) || transformApiDefinitionsToApis(apiDefinitions), styleguide: styleguideConfig || lint }, rawConfigRest);
    showDeprecationMessages(transformedConfig);
    return transformedConfig;
  }
  utils.transformConfig = transformConfig;
  function showDeprecationMessages(config2) {
    var _a4, _b3;
    let allRules = Object.assign({}, (_a4 = config2.styleguide) === null || _a4 === void 0 ? void 0 : _a4.rules);
    for (const api of Object.values(config2.apis || {})) {
      allRules = Object.assign(Object.assign({}, allRules), (_b3 = api === null || api === void 0 ? void 0 : api.styleguide) === null || _b3 === void 0 ? void 0 : _b3.rules);
    }
    for (const ruleKey of Object.keys(allRules)) {
      if (ruleKey.startsWith("assert/")) {
        logger_1.logger.warn(`
The 'assert/' syntax in ${ruleKey} is deprecated. Update your configuration to use 'rule/' instead. Examples and more information: https://redocly.com/docs/cli/rules/configurable-rules/
`);
      }
    }
  }
  function getResolveConfig(resolve28) {
    var _a4, _b3;
    return {
      http: {
        headers: (_b3 = (_a4 = resolve28 === null || resolve28 === void 0 ? void 0 : resolve28.http) === null || _a4 === void 0 ? void 0 : _a4.headers) !== null && _b3 !== void 0 ? _b3 : [],
        customFetch: void 0
      }
    };
  }
  utils.getResolveConfig = getResolveConfig;
  function getUniquePlugins(plugins) {
    const seen = /* @__PURE__ */ new Set();
    const results = [];
    for (const p2 of plugins) {
      if (!seen.has(p2.id)) {
        results.push(p2);
        seen.add(p2.id);
      } else if (p2.id) {
        logger_1.logger.warn(`Duplicate plugin id "${logger_1.colorize.red(p2.id)}".
`);
      }
    }
    return results;
  }
  utils.getUniquePlugins = getUniquePlugins;
  return utils;
}
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig)
    return config$1;
  hasRequiredConfig = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Config = exports.StyleguideConfig = exports.AVAILABLE_REGIONS = exports.DOMAINS = exports.DEFAULT_REGION = exports.IGNORE_FILE = void 0;
    const fs = require$$2;
    const path2 = requirePathBrowserify();
    const js_yaml_1 = requireJsYaml();
    const utils_1 = requireUtils$1();
    const oas_types_1 = requireOasTypes();
    const env_1 = requireEnv();
    const utils_2 = requireUtils();
    const ref_utils_1 = requireRefUtils();
    exports.IGNORE_FILE = ".redocly.lint-ignore.yaml";
    const IGNORE_BANNER = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.
# See https://redoc.ly/docs/cli/ for more information.
`;
    exports.DEFAULT_REGION = "us";
    function getDomains() {
      const domains = {
        us: "redocly.com",
        eu: "eu.redocly.com"
      };
      const domain = env_1.env.REDOCLY_DOMAIN;
      if (domain === null || domain === void 0 ? void 0 : domain.endsWith(".redocly.host")) {
        domains[domain.split(".")[0]] = domain;
      }
      if (domain === "redoc.online") {
        domains[domain] = domain;
      }
      return domains;
    }
    function getIgnoreFilePath(configFile) {
      if (configFile) {
        return utils_1.doesYamlFileExist(configFile) ? path2.join(path2.dirname(configFile), exports.IGNORE_FILE) : path2.join(configFile, exports.IGNORE_FILE);
      } else {
        return env_1.isBrowser ? void 0 : path2.join(process.cwd(), exports.IGNORE_FILE);
      }
    }
    exports.DOMAINS = getDomains();
    exports.AVAILABLE_REGIONS = Object.keys(exports.DOMAINS);
    class StyleguideConfig {
      constructor(rawConfig, configFile) {
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.ignore = {};
        this._usedRules = /* @__PURE__ */ new Set();
        this._usedVersions = /* @__PURE__ */ new Set();
        this.plugins = rawConfig.plugins || [];
        this.doNotResolveExamples = !!rawConfig.doNotResolveExamples;
        this.recommendedFallback = rawConfig.recommendedFallback || false;
        this.rules = {
          [oas_types_1.SpecVersion.OAS2]: Object.assign(Object.assign({}, rawConfig.rules), rawConfig.oas2Rules),
          [oas_types_1.SpecVersion.OAS3_0]: Object.assign(Object.assign({}, rawConfig.rules), rawConfig.oas3_0Rules),
          [oas_types_1.SpecVersion.OAS3_1]: Object.assign(Object.assign({}, rawConfig.rules), rawConfig.oas3_1Rules),
          [oas_types_1.SpecVersion.Async2]: Object.assign(Object.assign({}, rawConfig.rules), rawConfig.async2Rules)
        };
        this.preprocessors = {
          [oas_types_1.SpecVersion.OAS2]: Object.assign(Object.assign({}, rawConfig.preprocessors), rawConfig.oas2Preprocessors),
          [oas_types_1.SpecVersion.OAS3_0]: Object.assign(Object.assign({}, rawConfig.preprocessors), rawConfig.oas3_0Preprocessors),
          [oas_types_1.SpecVersion.OAS3_1]: Object.assign(Object.assign({}, rawConfig.preprocessors), rawConfig.oas3_1Preprocessors),
          [oas_types_1.SpecVersion.Async2]: Object.assign(Object.assign({}, rawConfig.preprocessors), rawConfig.async2Preprocessors)
        };
        this.decorators = {
          [oas_types_1.SpecVersion.OAS2]: Object.assign(Object.assign({}, rawConfig.decorators), rawConfig.oas2Decorators),
          [oas_types_1.SpecVersion.OAS3_0]: Object.assign(Object.assign({}, rawConfig.decorators), rawConfig.oas3_0Decorators),
          [oas_types_1.SpecVersion.OAS3_1]: Object.assign(Object.assign({}, rawConfig.decorators), rawConfig.oas3_1Decorators),
          [oas_types_1.SpecVersion.Async2]: Object.assign(Object.assign({}, rawConfig.decorators), rawConfig.async2Decorators)
        };
        this.extendPaths = rawConfig.extendPaths || [];
        this.pluginPaths = rawConfig.pluginPaths || [];
        this.resolveIgnore(getIgnoreFilePath(configFile));
      }
      resolveIgnore(ignoreFile) {
        if (!ignoreFile || !utils_1.doesYamlFileExist(ignoreFile))
          return;
        this.ignore = js_yaml_1.parseYaml(fs.readFileSync(ignoreFile, "utf-8")) || {};
        for (const fileName of Object.keys(this.ignore)) {
          this.ignore[ref_utils_1.isAbsoluteUrl(fileName) ? fileName : path2.resolve(path2.dirname(ignoreFile), fileName)] = this.ignore[fileName];
          for (const ruleId of Object.keys(this.ignore[fileName])) {
            this.ignore[fileName][ruleId] = new Set(this.ignore[fileName][ruleId]);
          }
          if (!ref_utils_1.isAbsoluteUrl(fileName)) {
            delete this.ignore[fileName];
          }
        }
      }
      saveIgnore() {
        const dir = this.configFile ? path2.dirname(this.configFile) : process.cwd();
        const ignoreFile = path2.join(dir, exports.IGNORE_FILE);
        const mapped = {};
        for (const absFileName of Object.keys(this.ignore)) {
          const mappedDefinitionName = ref_utils_1.isAbsoluteUrl(absFileName) ? absFileName : utils_1.slash(path2.relative(dir, absFileName));
          const ignoredRules = mapped[mappedDefinitionName] = this.ignore[absFileName];
          for (const ruleId of Object.keys(ignoredRules)) {
            ignoredRules[ruleId] = Array.from(ignoredRules[ruleId]);
          }
        }
        fs.writeFileSync(ignoreFile, IGNORE_BANNER + js_yaml_1.stringifyYaml(mapped));
      }
      addIgnore(problem) {
        const ignore = this.ignore;
        const loc = problem.location[0];
        if (loc.pointer === void 0)
          return;
        const fileIgnore = ignore[loc.source.absoluteRef] = ignore[loc.source.absoluteRef] || {};
        const ruleIgnore = fileIgnore[problem.ruleId] = fileIgnore[problem.ruleId] || /* @__PURE__ */ new Set();
        ruleIgnore.add(loc.pointer);
      }
      addProblemToIgnore(problem) {
        const loc = problem.location[0];
        if (loc.pointer === void 0)
          return problem;
        const fileIgnore = this.ignore[loc.source.absoluteRef] || {};
        const ruleIgnore = fileIgnore[problem.ruleId];
        const ignored = ruleIgnore && ruleIgnore.has(loc.pointer);
        return ignored ? Object.assign(Object.assign({}, problem), { ignored }) : problem;
      }
      extendTypes(types2, version2) {
        let extendedTypes = types2;
        for (const plugin of this.plugins) {
          if (plugin.typeExtension !== void 0) {
            switch (version2) {
              case oas_types_1.SpecVersion.OAS3_0:
              case oas_types_1.SpecVersion.OAS3_1:
                if (!plugin.typeExtension.oas3)
                  continue;
                extendedTypes = plugin.typeExtension.oas3(extendedTypes, version2);
                break;
              case oas_types_1.SpecVersion.OAS2:
                if (!plugin.typeExtension.oas2)
                  continue;
                extendedTypes = plugin.typeExtension.oas2(extendedTypes, version2);
                break;
              case oas_types_1.SpecVersion.Async2:
                if (!plugin.typeExtension.async2)
                  continue;
                extendedTypes = plugin.typeExtension.async2(extendedTypes, version2);
                break;
              default:
                throw new Error("Not implemented");
            }
          }
        }
        return extendedTypes;
      }
      getRuleSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.rules[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings
          };
        } else {
          return Object.assign({ severity: "error" }, settings);
        }
      }
      getPreprocessorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.preprocessors[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings === "on" ? "error" : settings
          };
        } else {
          return Object.assign({ severity: "error" }, settings);
        }
      }
      getDecoratorSettings(ruleId, oasVersion) {
        this._usedRules.add(ruleId);
        this._usedVersions.add(oasVersion);
        const settings = this.decorators[oasVersion][ruleId] || "off";
        if (typeof settings === "string") {
          return {
            severity: settings === "on" ? "error" : settings
          };
        } else {
          return Object.assign({ severity: "error" }, settings);
        }
      }
      getUnusedRules() {
        const rules2 = [];
        const decorators = [];
        const preprocessors = [];
        for (const usedVersion of Array.from(this._usedVersions)) {
          rules2.push(...Object.keys(this.rules[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
          decorators.push(...Object.keys(this.decorators[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
          preprocessors.push(...Object.keys(this.preprocessors[usedVersion]).filter((name2) => !this._usedRules.has(name2)));
        }
        return {
          rules: rules2,
          preprocessors,
          decorators
        };
      }
      getRulesForOasVersion(version2) {
        switch (version2) {
          case oas_types_1.SpecMajorVersion.OAS3:
            const oas3Rules = [];
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.preprocessors) === null || _a4 === void 0 ? void 0 : _a4.oas3) && oas3Rules.push(p2.preprocessors.oas3);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.rules) === null || _a4 === void 0 ? void 0 : _a4.oas3) && oas3Rules.push(p2.rules.oas3);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.decorators) === null || _a4 === void 0 ? void 0 : _a4.oas3) && oas3Rules.push(p2.decorators.oas3);
            });
            return oas3Rules;
          case oas_types_1.SpecMajorVersion.OAS2:
            const oas2Rules = [];
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.preprocessors) === null || _a4 === void 0 ? void 0 : _a4.oas2) && oas2Rules.push(p2.preprocessors.oas2);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.rules) === null || _a4 === void 0 ? void 0 : _a4.oas2) && oas2Rules.push(p2.rules.oas2);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.decorators) === null || _a4 === void 0 ? void 0 : _a4.oas2) && oas2Rules.push(p2.decorators.oas2);
            });
            return oas2Rules;
          case oas_types_1.SpecMajorVersion.Async2:
            const asyncApiRules = [];
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.preprocessors) === null || _a4 === void 0 ? void 0 : _a4.async2) && asyncApiRules.push(p2.preprocessors.async2);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.rules) === null || _a4 === void 0 ? void 0 : _a4.async2) && asyncApiRules.push(p2.rules.async2);
            });
            this.plugins.forEach((p2) => {
              var _a4;
              return ((_a4 = p2.decorators) === null || _a4 === void 0 ? void 0 : _a4.async2) && asyncApiRules.push(p2.decorators.async2);
            });
            return asyncApiRules;
        }
      }
      skipRules(rules2) {
        for (const ruleId of rules2 || []) {
          for (const version2 of Object.values(oas_types_1.SpecVersion)) {
            if (this.rules[version2][ruleId]) {
              this.rules[version2][ruleId] = "off";
            }
          }
        }
      }
      skipPreprocessors(preprocessors) {
        for (const preprocessorId of preprocessors || []) {
          for (const version2 of Object.values(oas_types_1.SpecVersion)) {
            if (this.preprocessors[version2][preprocessorId]) {
              this.preprocessors[version2][preprocessorId] = "off";
            }
          }
        }
      }
      skipDecorators(decorators) {
        for (const decoratorId of decorators || []) {
          for (const version2 of Object.values(oas_types_1.SpecVersion)) {
            if (this.decorators[version2][decoratorId]) {
              this.decorators[version2][decoratorId] = "off";
            }
          }
        }
      }
    }
    exports.StyleguideConfig = StyleguideConfig;
    class Config2 {
      constructor(rawConfig, configFile) {
        this.rawConfig = rawConfig;
        this.configFile = configFile;
        this.apis = rawConfig.apis || {};
        this.styleguide = new StyleguideConfig(rawConfig.styleguide || {}, configFile);
        this.theme = rawConfig.theme || {};
        this.resolve = utils_2.getResolveConfig(rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.resolve);
        this.region = rawConfig.region;
        this.organization = rawConfig.organization;
        this.files = rawConfig.files || [];
        this.telemetry = rawConfig.telemetry;
      }
    }
    exports.Config = Config2;
  })(config$1);
  return config$1;
}
const name = "@redocly/openapi-core";
const version = "1.2.0";
const description = "";
const main = "lib/index.js";
const engines = {
  node: ">=14.0.0"
};
const engineStrict = true;
const license = "MIT";
const repository = {
  type: "git",
  url: "https://github.com/Redocly/redocly-cli.git"
};
const browser = {
  fs: false,
  path: "path-browserify",
  os: false,
  "node-fetch": false,
  colorette: false
};
const homepage = "https://github.com/Redocly/redocly-cli";
const keywords = [
  "linter",
  "OpenAPI",
  "Swagger",
  "OpenAPI linter",
  "Swagger linter",
  "AsyncAPI linter",
  "oas"
];
const contributors = [
  "Roman Hotsiy <roman@redoc.ly> (https://redoc.ly/)"
];
const dependencies = {
  "@redocly/ajv": "^8.11.0",
  "@types/node": "^14.11.8",
  colorette: "^1.2.0",
  "js-levenshtein": "^1.1.6",
  "js-yaml": "^4.1.0",
  "lodash.isequal": "^4.5.0",
  minimatch: "^5.0.1",
  "node-fetch": "^2.6.1",
  pluralize: "^8.0.0",
  "yaml-ast-parser": "0.0.43"
};
const devDependencies = {
  "@types/js-levenshtein": "^1.1.0",
  "@types/js-yaml": "^4.0.3",
  "@types/lodash.isequal": "^4.5.5",
  "@types/minimatch": "^3.0.5",
  "@types/node-fetch": "^2.5.7",
  "@types/pluralize": "^0.0.29",
  typescript: "^4.0.5"
};
const require$$3 = {
  name,
  version,
  description,
  main,
  engines,
  engineStrict,
  license,
  repository,
  browser,
  homepage,
  keywords,
  contributors,
  dependencies,
  devDependencies
};
var hasRequiredRegistryApi;
function requireRegistryApi() {
  if (hasRequiredRegistryApi)
    return registryApi;
  hasRequiredRegistryApi = 1;
  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve28) {
        resolve28(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve28, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve28(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(registryApi, "__esModule", { value: true });
  registryApi.RegistryApi = void 0;
  const node_fetch_1 = require$$2;
  const config_1 = requireConfig();
  const utils_1 = requireUtils$1();
  const version2 = require$$3.version;
  class RegistryApi {
    constructor(accessTokens, region) {
      this.accessTokens = accessTokens;
      this.region = region;
    }
    get accessToken() {
      return utils_1.isNotEmptyObject(this.accessTokens) && this.accessTokens[this.region];
    }
    getBaseUrl(region = config_1.DEFAULT_REGION) {
      return `https://api.${config_1.DOMAINS[region]}/registry`;
    }
    setAccessTokens(accessTokens) {
      this.accessTokens = accessTokens;
      return this;
    }
    request(path2 = "", options2 = {}, region) {
      var _a4, _b3;
      return __awaiter(this, void 0, void 0, function* () {
        const currentCommand = typeof process !== "undefined" ? ((_a4 = process.env) === null || _a4 === void 0 ? void 0 : _a4.REDOCLY_CLI_COMMAND) || "" : "";
        const redoclyEnv = typeof process !== "undefined" ? ((_b3 = process.env) === null || _b3 === void 0 ? void 0 : _b3.REDOCLY_ENVIRONMENT) || "" : "";
        const headers = Object.assign({}, options2.headers || {}, {
          "x-redocly-cli-version": version2,
          "user-agent": `redocly-cli / ${version2} ${currentCommand} ${redoclyEnv}`
        });
        if (!headers.hasOwnProperty("authorization")) {
          throw new Error("Unauthorized");
        }
        const response = yield node_fetch_1.default(`${this.getBaseUrl(region)}${path2}`, Object.assign({}, options2, { headers }));
        if (response.status === 401) {
          throw new Error("Unauthorized");
        }
        if (response.status === 404) {
          const body = yield response.json();
          throw new Error(body.code);
        }
        return response;
      });
    }
    authStatus(accessToken, region, verbose = false) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const response = yield this.request("", { headers: { authorization: accessToken } }, region);
          return yield response.json();
        } catch (error) {
          if (verbose) {
            console.log(error);
          }
          throw error;
        }
      });
    }
    prepareFileUpload({ organizationId, name: name2, version: version3, filesHash, filename, isUpsert }) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield this.request(`/${organizationId}/${name2}/${version3}/prepare-file-upload`, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            authorization: this.accessToken
          },
          body: JSON.stringify({
            filesHash,
            filename,
            isUpsert
          })
        }, this.region);
        if (response.ok) {
          return response.json();
        }
        throw new Error("Could not prepare file upload");
      });
    }
    pushApi({ organizationId, name: name2, version: version3, rootFilePath, filePaths, branch, isUpsert, isPublic, batchId, batchSize }) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield this.request(`/${organizationId}/${name2}/${version3}`, {
          method: "PUT",
          headers: {
            "content-type": "application/json",
            authorization: this.accessToken
          },
          body: JSON.stringify({
            rootFilePath,
            filePaths,
            branch,
            isUpsert,
            isPublic,
            batchId,
            batchSize
          })
        }, this.region);
        if (response.ok) {
          return;
        }
        throw new Error("Could not push api");
      });
    }
  }
  registryApi.RegistryApi = RegistryApi;
  return registryApi;
}
var hasRequiredRedocly;
function requireRedocly() {
  if (hasRequiredRedocly)
    return redocly;
  hasRequiredRedocly = 1;
  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve28) {
        resolve28(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve28, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve28(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(redocly, "__esModule", { value: true });
  redocly.isRedoclyRegistryURL = redocly.RedoclyClient = void 0;
  const fs_1 = require$$2;
  const path_1 = requirePathBrowserify();
  const os_1 = require$$2;
  const registry_api_1 = requireRegistryApi();
  const config_1 = requireConfig();
  const env_1 = requireEnv();
  const utils_1 = requireUtils$1();
  const logger_1 = requireLogger();
  const TOKEN_FILENAME = ".redocly-config.json";
  class RedoclyClient {
    constructor(region) {
      this.accessTokens = {};
      this.region = this.loadRegion(region);
      this.loadTokens();
      this.domain = region ? config_1.DOMAINS[region] : env_1.env.REDOCLY_DOMAIN || config_1.DOMAINS[config_1.DEFAULT_REGION];
      env_1.env.REDOCLY_DOMAIN = this.domain;
      this.registryApi = new registry_api_1.RegistryApi(this.accessTokens, this.region);
    }
    loadRegion(region) {
      if (region && !config_1.DOMAINS[region]) {
        throw new Error(`Invalid argument: region in config file.
Given: ${logger_1.colorize.green(region)}, choices: "us", "eu".`);
      }
      if (env_1.env.REDOCLY_DOMAIN) {
        return config_1.AVAILABLE_REGIONS.find((region2) => config_1.DOMAINS[region2] === env_1.env.REDOCLY_DOMAIN) || config_1.DEFAULT_REGION;
      }
      return region || config_1.DEFAULT_REGION;
    }
    getRegion() {
      return this.region;
    }
    hasTokens() {
      return utils_1.isNotEmptyObject(this.accessTokens);
    }
    // <backward compatibility: old versions of portal>
    hasToken() {
      return !!this.accessTokens[this.region];
    }
    getAuthorizationHeader() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.accessTokens[this.region];
      });
    }
    // </backward compatibility: portal>
    setAccessTokens(accessTokens) {
      this.accessTokens = accessTokens;
    }
    loadTokens() {
      const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
      const credentials = this.readCredentialsFile(credentialsPath);
      if (utils_1.isNotEmptyObject(credentials)) {
        this.setAccessTokens(Object.assign(Object.assign({}, credentials), credentials.token && !credentials[this.region] && {
          [this.region]: credentials.token
        }));
      }
      if (env_1.env.REDOCLY_AUTHORIZATION) {
        this.setAccessTokens(Object.assign(Object.assign({}, this.accessTokens), { [this.region]: env_1.env.REDOCLY_AUTHORIZATION }));
      }
    }
    getAllTokens() {
      return Object.entries(this.accessTokens).filter(([region]) => config_1.AVAILABLE_REGIONS.includes(region)).map(([region, token2]) => ({ region, token: token2 }));
    }
    getValidTokens() {
      return __awaiter(this, void 0, void 0, function* () {
        const allTokens = this.getAllTokens();
        const verifiedTokens = yield Promise.allSettled(allTokens.map(({ token: token2, region }) => this.verifyToken(token2, region)));
        return allTokens.filter((_2, index2) => verifiedTokens[index2].status === "fulfilled").map(({ token: token2, region }) => ({ token: token2, region, valid: true }));
      });
    }
    getTokens() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.hasTokens() ? yield this.getValidTokens() : [];
      });
    }
    isAuthorizedWithRedoclyByRegion() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.hasTokens()) {
          return false;
        }
        const accessToken = this.accessTokens[this.region];
        if (!accessToken) {
          return false;
        }
        try {
          yield this.verifyToken(accessToken, this.region);
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    isAuthorizedWithRedocly() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.hasTokens() && utils_1.isNotEmptyObject(yield this.getValidTokens());
      });
    }
    readCredentialsFile(credentialsPath) {
      return fs_1.existsSync(credentialsPath) ? JSON.parse(fs_1.readFileSync(credentialsPath, "utf-8")) : {};
    }
    verifyToken(accessToken, region, verbose = false) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.registryApi.authStatus(accessToken, region, verbose);
      });
    }
    login(accessToken, verbose = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
        try {
          yield this.verifyToken(accessToken, this.region, verbose);
        } catch (err) {
          throw new Error("Authorization failed. Please check if you entered a valid API key.");
        }
        const credentials = Object.assign(Object.assign({}, this.readCredentialsFile(credentialsPath)), { [this.region]: accessToken, token: accessToken });
        this.accessTokens = credentials;
        this.registryApi.setAccessTokens(credentials);
        fs_1.writeFileSync(credentialsPath, JSON.stringify(credentials, null, 2));
      });
    }
    logout() {
      const credentialsPath = path_1.resolve(os_1.homedir(), TOKEN_FILENAME);
      if (fs_1.existsSync(credentialsPath)) {
        fs_1.unlinkSync(credentialsPath);
      }
    }
  }
  redocly.RedoclyClient = RedoclyClient;
  function isRedoclyRegistryURL(link) {
    const domain = env_1.env.REDOCLY_DOMAIN || config_1.DOMAINS[config_1.DEFAULT_REGION];
    const legacyDomain = domain === "redocly.com" ? "redoc.ly" : domain;
    if (!link.startsWith(`https://api.${domain}/registry/`) && !link.startsWith(`https://api.${legacyDomain}/registry/`)) {
      return false;
    }
    return true;
  }
  redocly.isRedoclyRegistryURL = isRedoclyRegistryURL;
  return redocly;
}
var removeUnusedComponents$1 = {};
var hasRequiredRemoveUnusedComponents$1;
function requireRemoveUnusedComponents$1() {
  if (hasRequiredRemoveUnusedComponents$1)
    return removeUnusedComponents$1;
  hasRequiredRemoveUnusedComponents$1 = 1;
  Object.defineProperty(removeUnusedComponents$1, "__esModule", { value: true });
  removeUnusedComponents$1.RemoveUnusedComponents = void 0;
  const utils_1 = requireUtils$1();
  const RemoveUnusedComponents = () => {
    const components2 = /* @__PURE__ */ new Map();
    function registerComponent(location, componentType, name2) {
      var _a4;
      components2.set(location.absolutePointer, {
        used: ((_a4 = components2.get(location.absolutePointer)) === null || _a4 === void 0 ? void 0 : _a4.used) || false,
        componentType,
        name: name2
      });
    }
    return {
      ref: {
        leave(ref, { type: type2, resolve: resolve28, key: key2 }) {
          if (["Schema", "Parameter", "Response", "SecurityScheme"].includes(type2.name)) {
            const resolvedRef = resolve28(ref);
            if (!resolvedRef.location)
              return;
            const [fileLocation, localPointer] = resolvedRef.location.absolutePointer.split("#", 2);
            const componentLevelLocalPointer = localPointer.split("/").slice(0, 3).join("/");
            const pointer = `${fileLocation}#${componentLevelLocalPointer}`;
            components2.set(pointer, {
              used: true,
              name: key2.toString()
            });
          }
        }
      },
      Root: {
        leave(root, ctx) {
          const data = ctx.getVisitorData();
          data.removedCount = 0;
          const rootComponents = /* @__PURE__ */ new Set();
          components2.forEach((usageInfo) => {
            const { used, name: name2, componentType } = usageInfo;
            if (!used && componentType) {
              rootComponents.add(componentType);
              delete root[componentType][name2];
              data.removedCount++;
            }
          });
          for (const component of rootComponents) {
            if (utils_1.isEmptyObject(root[component])) {
              delete root[component];
            }
          }
        }
      },
      NamedSchemas: {
        Schema(schema2, { location, key: key2 }) {
          if (!schema2.allOf) {
            registerComponent(location, "definitions", key2.toString());
          }
        }
      },
      NamedParameters: {
        Parameter(_parameter, { location, key: key2 }) {
          registerComponent(location, "parameters", key2.toString());
        }
      },
      NamedResponses: {
        Response(_response, { location, key: key2 }) {
          registerComponent(location, "responses", key2.toString());
        }
      },
      NamedSecuritySchemes: {
        SecurityScheme(_securityScheme, { location, key: key2 }) {
          registerComponent(location, "securityDefinitions", key2.toString());
        }
      }
    };
  };
  removeUnusedComponents$1.RemoveUnusedComponents = RemoveUnusedComponents;
  return removeUnusedComponents$1;
}
var removeUnusedComponents = {};
var hasRequiredRemoveUnusedComponents;
function requireRemoveUnusedComponents() {
  if (hasRequiredRemoveUnusedComponents)
    return removeUnusedComponents;
  hasRequiredRemoveUnusedComponents = 1;
  Object.defineProperty(removeUnusedComponents, "__esModule", { value: true });
  removeUnusedComponents.RemoveUnusedComponents = void 0;
  const utils_1 = requireUtils$1();
  const RemoveUnusedComponents = () => {
    const components2 = /* @__PURE__ */ new Map();
    function registerComponent(location, componentType, name2) {
      var _a4;
      components2.set(location.absolutePointer, {
        used: ((_a4 = components2.get(location.absolutePointer)) === null || _a4 === void 0 ? void 0 : _a4.used) || false,
        componentType,
        name: name2
      });
    }
    return {
      ref: {
        leave(ref, { type: type2, resolve: resolve28, key: key2 }) {
          if (["Schema", "Header", "Parameter", "Response", "Example", "RequestBody"].includes(type2.name)) {
            const resolvedRef = resolve28(ref);
            if (!resolvedRef.location)
              return;
            const [fileLocation, localPointer] = resolvedRef.location.absolutePointer.split("#", 2);
            const componentLevelLocalPointer = localPointer.split("/").slice(0, 4).join("/");
            const pointer = `${fileLocation}#${componentLevelLocalPointer}`;
            components2.set(pointer, {
              used: true,
              name: key2.toString()
            });
          }
        }
      },
      Root: {
        leave(root, ctx) {
          const data = ctx.getVisitorData();
          data.removedCount = 0;
          components2.forEach((usageInfo) => {
            const { used, componentType, name: name2 } = usageInfo;
            if (!used && componentType && root.components) {
              const componentChild = root.components[componentType];
              delete componentChild[name2];
              data.removedCount++;
              if (utils_1.isEmptyObject(componentChild)) {
                delete root.components[componentType];
              }
            }
          });
          if (utils_1.isEmptyObject(root.components)) {
            delete root.components;
          }
        }
      },
      NamedSchemas: {
        Schema(schema2, { location, key: key2 }) {
          if (!schema2.allOf) {
            registerComponent(location, "schemas", key2.toString());
          }
        }
      },
      NamedParameters: {
        Parameter(_parameter, { location, key: key2 }) {
          registerComponent(location, "parameters", key2.toString());
        }
      },
      NamedResponses: {
        Response(_response, { location, key: key2 }) {
          registerComponent(location, "responses", key2.toString());
        }
      },
      NamedExamples: {
        Example(_example, { location, key: key2 }) {
          registerComponent(location, "examples", key2.toString());
        }
      },
      NamedRequestBodies: {
        RequestBody(_requestBody, { location, key: key2 }) {
          registerComponent(location, "requestBodies", key2.toString());
        }
      },
      NamedHeaders: {
        Header(_header, { location, key: key2 }) {
          registerComponent(location, "headers", key2.toString());
        }
      }
    };
  };
  removeUnusedComponents.RemoveUnusedComponents = RemoveUnusedComponents;
  return removeUnusedComponents;
}
var hasRequiredBundle;
function requireBundle() {
  if (hasRequiredBundle)
    return bundle;
  hasRequiredBundle = 1;
  (function(exports) {
    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve28) {
          resolve28(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve28, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve28(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTypeToComponent = exports.bundleDocument = exports.bundle = exports.OasVersion = void 0;
    const isEqual3 = requireLodash_isequal();
    const resolve_1 = requireResolve();
    const visitors_1 = requireVisitors();
    const types_12 = requireTypes();
    const walk_1 = requireWalk();
    const oas_types_1 = requireOasTypes();
    const ref_utils_1 = requireRefUtils();
    const rules_1 = requireRules();
    const no_unresolved_refs_1 = requireNoUnresolvedRefs();
    const utils_1 = requireUtils$1();
    const redocly_1 = requireRedocly();
    const remove_unused_components_1 = requireRemoveUnusedComponents$1();
    const remove_unused_components_2 = requireRemoveUnusedComponents();
    (function(OasVersion) {
      OasVersion["Version2"] = "oas2";
      OasVersion["Version3_0"] = "oas3_0";
      OasVersion["Version3_1"] = "oas3_1";
    })(exports.OasVersion || (exports.OasVersion = {}));
    function bundle2(opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const { ref, doc, externalRefResolver = new resolve_1.BaseResolver(opts.config.resolve), base = null } = opts;
        if (!(ref || doc)) {
          throw new Error("Document or reference is required.\n");
        }
        const document2 = doc !== void 0 ? doc : yield externalRefResolver.resolveDocument(base, ref, true);
        if (document2 instanceof Error) {
          throw document2;
        }
        return bundleDocument(Object.assign(Object.assign({ document: document2 }, opts), { config: opts.config.styleguide, externalRefResolver }));
      });
    }
    exports.bundle = bundle2;
    function bundleDocument(opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const { document: document2, config: config2, customTypes, externalRefResolver, dereference = false, skipRedoclyRegistryRefs = false, removeUnusedComponents: removeUnusedComponents2 = false, keepUrlRefs = false } = opts;
        const specVersion = oas_types_1.detectSpec(document2.parsed);
        const specMajorVersion = oas_types_1.getMajorSpecVersion(specVersion);
        const rules2 = config2.getRulesForOasVersion(specMajorVersion);
        const types2 = types_12.normalizeTypes(config2.extendTypes(customTypes !== null && customTypes !== void 0 ? customTypes : oas_types_1.getTypes(specVersion), specVersion), config2);
        const preprocessors = rules_1.initRules(rules2, config2, "preprocessors", specVersion);
        const decorators = rules_1.initRules(rules2, config2, "decorators", specVersion);
        const ctx = {
          problems: [],
          oasVersion: specVersion,
          refTypes: /* @__PURE__ */ new Map(),
          visitorsData: {}
        };
        if (removeUnusedComponents2) {
          decorators.push({
            severity: "error",
            ruleId: "remove-unused-components",
            visitor: specMajorVersion === oas_types_1.SpecMajorVersion.OAS2 ? remove_unused_components_1.RemoveUnusedComponents({}) : remove_unused_components_2.RemoveUnusedComponents({})
          });
        }
        let resolvedRefMap = yield resolve_1.resolveDocument({
          rootDocument: document2,
          rootType: types2.Root,
          externalRefResolver
        });
        if (preprocessors.length > 0) {
          walk_1.walkDocument({
            document: document2,
            rootType: types2.Root,
            normalizedVisitors: visitors_1.normalizeVisitors(preprocessors, types2),
            resolvedRefMap,
            ctx
          });
          resolvedRefMap = yield resolve_1.resolveDocument({
            rootDocument: document2,
            rootType: types2.Root,
            externalRefResolver
          });
        }
        const bundleVisitor = visitors_1.normalizeVisitors([
          {
            severity: "error",
            ruleId: "bundler",
            visitor: makeBundleVisitor(specMajorVersion, dereference, skipRedoclyRegistryRefs, document2, resolvedRefMap, keepUrlRefs)
          },
          ...decorators
        ], types2);
        walk_1.walkDocument({
          document: document2,
          rootType: types2.Root,
          normalizedVisitors: bundleVisitor,
          resolvedRefMap,
          ctx
        });
        return {
          bundle: document2,
          problems: ctx.problems.map((problem) => config2.addProblemToIgnore(problem)),
          fileDependencies: externalRefResolver.getFiles(),
          rootType: types2.Root,
          refTypes: ctx.refTypes,
          visitorsData: ctx.visitorsData
        };
      });
    }
    exports.bundleDocument = bundleDocument;
    function mapTypeToComponent(typeName, version2) {
      switch (version2) {
        case oas_types_1.SpecMajorVersion.OAS3:
          switch (typeName) {
            case "Schema":
              return "schemas";
            case "Parameter":
              return "parameters";
            case "Response":
              return "responses";
            case "Example":
              return "examples";
            case "RequestBody":
              return "requestBodies";
            case "Header":
              return "headers";
            case "SecuritySchema":
              return "securitySchemes";
            case "Link":
              return "links";
            case "Callback":
              return "callbacks";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.OAS2:
          switch (typeName) {
            case "Schema":
              return "definitions";
            case "Parameter":
              return "parameters";
            case "Response":
              return "responses";
            default:
              return null;
          }
        case oas_types_1.SpecMajorVersion.Async2:
          switch (typeName) {
            case "Schema":
              return "schemas";
            case "Parameter":
              return "parameters";
            default:
              return null;
          }
      }
    }
    exports.mapTypeToComponent = mapTypeToComponent;
    function makeBundleVisitor(version2, dereference, skipRedoclyRegistryRefs, rootDocument, resolvedRefMap, keepUrlRefs) {
      let components2;
      let rootLocation;
      const visitor = {
        ref: {
          leave(node2, ctx, resolved) {
            if (!resolved.location || resolved.node === void 0) {
              no_unresolved_refs_1.reportUnresolvedRef(resolved, ctx.report, ctx.location);
              return;
            }
            if (resolved.location.source === rootDocument.source && resolved.location.source === ctx.location.source && ctx.type.name !== "scalar" && !dereference) {
              return;
            }
            if (skipRedoclyRegistryRefs && redocly_1.isRedoclyRegistryURL(node2.$ref)) {
              return;
            }
            if (keepUrlRefs && ref_utils_1.isAbsoluteUrl(node2.$ref)) {
              return;
            }
            const componentType = mapTypeToComponent(ctx.type.name, version2);
            if (!componentType) {
              replaceRef(node2, resolved, ctx);
            } else {
              if (dereference) {
                saveComponent(componentType, resolved, ctx);
                replaceRef(node2, resolved, ctx);
              } else {
                node2.$ref = saveComponent(componentType, resolved, ctx);
                resolveBundledComponent(node2, resolved, ctx);
              }
            }
          }
        },
        Root: {
          enter(root, ctx) {
            rootLocation = ctx.location;
            if (version2 === oas_types_1.SpecMajorVersion.OAS3) {
              components2 = root.components = root.components || {};
            } else if (version2 === oas_types_1.SpecMajorVersion.OAS2) {
              components2 = root;
            }
          }
        }
      };
      if (version2 === oas_types_1.SpecMajorVersion.OAS3) {
        visitor.DiscriminatorMapping = {
          leave(mapping, ctx) {
            for (const name2 of Object.keys(mapping)) {
              const $ref = mapping[name2];
              const resolved = ctx.resolve({ $ref });
              if (!resolved.location || resolved.node === void 0) {
                no_unresolved_refs_1.reportUnresolvedRef(resolved, ctx.report, ctx.location.child(name2));
                return;
              }
              const componentType = mapTypeToComponent("Schema", version2);
              if (dereference) {
                saveComponent(componentType, resolved, ctx);
              } else {
                mapping[name2] = saveComponent(componentType, resolved, ctx);
              }
            }
          }
        };
      }
      function resolveBundledComponent(node2, resolved, ctx) {
        const newRefId = resolve_1.makeRefId(ctx.location.source.absoluteRef, node2.$ref);
        resolvedRefMap.set(newRefId, {
          document: rootDocument,
          isRemote: false,
          node: resolved.node,
          nodePointer: node2.$ref,
          resolved: true
        });
      }
      function replaceRef(ref, resolved, ctx) {
        if (!utils_1.isPlainObject(resolved.node)) {
          ctx.parent[ctx.key] = resolved.node;
        } else {
          delete ref.$ref;
          const obj = Object.assign({}, resolved.node, ref);
          Object.assign(ref, obj);
        }
      }
      function saveComponent(componentType, target, ctx) {
        components2[componentType] = components2[componentType] || {};
        const name2 = getComponentName(target, componentType, ctx);
        components2[componentType][name2] = target.node;
        if (version2 === oas_types_1.SpecMajorVersion.OAS3) {
          return `#/components/${componentType}/${name2}`;
        } else {
          return `#/${componentType}/${name2}`;
        }
      }
      function isEqualOrEqualRef(node2, target, ctx) {
        var _a4;
        if (ref_utils_1.isRef(node2) && ((_a4 = ctx.resolve(node2, rootLocation.absolutePointer).location) === null || _a4 === void 0 ? void 0 : _a4.absolutePointer) === target.location.absolutePointer) {
          return true;
        }
        return isEqual3(node2, target.node);
      }
      function getComponentName(target, componentType, ctx) {
        const [fileRef, pointer] = [target.location.source.absoluteRef, target.location.pointer];
        const componentsGroup = components2[componentType];
        let name2 = "";
        const refParts = pointer.slice(2).split("/").filter(utils_1.isTruthy);
        while (refParts.length > 0) {
          name2 = refParts.pop() + (name2 ? `-${name2}` : "");
          if (!componentsGroup || !componentsGroup[name2] || isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
            return name2;
          }
        }
        name2 = ref_utils_1.refBaseName(fileRef) + (name2 ? `_${name2}` : "");
        if (!componentsGroup[name2] || isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
          return name2;
        }
        const prevName = name2;
        let serialId = 2;
        while (componentsGroup[name2] && !isEqualOrEqualRef(componentsGroup[name2], target, ctx)) {
          name2 = `${prevName}-${serialId}`;
          serialId++;
        }
        if (!componentsGroup[name2]) {
          ctx.report({
            message: `Two schemas are referenced with the same name but different content. Renamed ${prevName} to ${name2}.`,
            location: ctx.location,
            forceSeverity: "warn"
          });
        }
        return name2;
      }
      return visitor;
    }
  })(bundle);
  return bundle;
}
var decko = {};
var hasRequiredDecko;
function requireDecko() {
  if (hasRequiredDecko)
    return decko;
  hasRequiredDecko = 1;
  (function(exports) {
    (function(global2, factory2) {
      {
        factory2(exports);
      }
    })(commonjsGlobal, function(exports2) {
      exports2.__esModule = true;
      var EMPTY = {};
      var HOP = Object.prototype.hasOwnProperty;
      var fns = { memoize: function memoize3(fn2) {
        var opt = arguments.length <= 1 || arguments[1] === void 0 ? EMPTY : arguments[1];
        var cache2 = opt.cache || {};
        return function() {
          for (var _len = arguments.length, a = Array(_len), _key = 0; _key < _len; _key++) {
            a[_key] = arguments[_key];
          }
          var k2 = String(a[0]);
          if (opt.caseSensitive === false)
            k2 = k2.toLowerCase();
          return HOP.call(cache2, k2) ? cache2[k2] : cache2[k2] = fn2.apply(this, a);
        };
      }, debounce: function debounce3(fn2, opts) {
        if (typeof opts === "function") {
          var p2 = fn2;
          fn2 = opts;
          opts = p2;
        }
        var delay2 = opts && opts.delay || opts || 0, args = void 0, context = void 0, timer = void 0;
        return function() {
          for (var _len2 = arguments.length, a = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            a[_key2] = arguments[_key2];
          }
          args = a;
          context = this;
          if (!timer)
            timer = setTimeout(function() {
              fn2.apply(context, args);
              args = context = timer = null;
            }, delay2);
        };
      }, bind: function bind4(target, key2, _ref3) {
        var fn2 = _ref3.value;
        return { configurable: true, get: function get4() {
          var value = fn2.bind(this);
          Object.defineProperty(this, key2, { value, configurable: true, writable: true });
          return value;
        } };
      } };
      var memoize2 = multiMethod(fns.memoize), debounce2 = multiMethod(fns.debounce), bind3 = multiMethod(function(f2, c2) {
        return f2.bind(c2);
      }, function() {
        return fns.bind;
      });
      exports2.memoize = memoize2;
      exports2.debounce = debounce2;
      exports2.bind = bind3;
      exports2["default"] = { memoize: memoize2, debounce: debounce2, bind: bind3 };
      function multiMethod(inner, deco) {
        deco = deco || inner.decorate || decorator(inner);
        var d2 = deco();
        return function() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          var l2 = args.length;
          return (l2 < 2 ? deco : l2 > 2 ? d2 : inner).apply(void 0, args);
        };
      }
      function decorator(fn2) {
        return function(opt) {
          return typeof opt === "function" ? fn2(opt) : function(target, key2, desc) {
            desc.value = fn2(desc.value, opt, target, key2, desc);
          };
        };
      }
    });
  })(decko);
  return decko;
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3)
    return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has3 = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE2(fn2, context, once3) {
      this.fn = fn2;
      this.context = context;
      this.once = once3 || false;
    }
    function addListener(emitter, event, fn2, context, once3) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE2(fn2, context || emitter, once3), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events = this._events) {
        if (has3.call(events, name2))
          names.push(prefix2 ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers2 = this._events[evt];
      if (!handlers2)
        return [];
      if (handlers2.fn)
        return [handlers2.fn];
      for (var i = 0, l2 = handlers2.length, ee2 = new Array(l2); i < l2; i++) {
        ee2[i] = handlers2[i].fn;
      }
      return ee2;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter.prototype.once = function once3(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn2, context, once3) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once3 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn2 || once3 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix2;
    EventEmitter.EventEmitter = EventEmitter;
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var foreach;
var hasRequiredForeach;
function requireForeach() {
  if (hasRequiredForeach)
    return foreach;
  hasRequiredForeach = 1;
  var hasOwn2 = Object.prototype.hasOwnProperty;
  var toString2 = Object.prototype.toString;
  foreach = function forEach(obj, fn2, ctx) {
    if (toString2.call(fn2) !== "[object Function]") {
      throw new TypeError("iterator must be a function");
    }
    var l2 = obj.length;
    if (l2 === +l2) {
      for (var i = 0; i < l2; i++) {
        fn2.call(ctx, obj[i], i, obj);
      }
    } else {
      for (var k2 in obj) {
        if (hasOwn2.call(obj, k2)) {
          fn2.call(ctx, obj[k2], k2, obj);
        }
      }
    }
  };
  return foreach;
}
var jsonPointer;
var hasRequiredJsonPointer;
function requireJsonPointer() {
  if (hasRequiredJsonPointer)
    return jsonPointer;
  hasRequiredJsonPointer = 1;
  var each = requireForeach();
  jsonPointer = api;
  function api(obj, pointer, value) {
    if (arguments.length === 3) {
      return api.set(obj, pointer, value);
    }
    if (arguments.length === 2) {
      return api.get(obj, pointer);
    }
    var wrapped = api.bind(api, obj);
    for (var name2 in api) {
      if (api.hasOwnProperty(name2)) {
        wrapped[name2] = api[name2].bind(wrapped, obj);
      }
    }
    return wrapped;
  }
  api.get = function get4(obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    for (var i = 0; i < refTokens.length; ++i) {
      var tok = refTokens[i];
      if (!(typeof obj == "object" && tok in obj)) {
        throw new Error("Invalid reference token: " + tok);
      }
      obj = obj[tok];
    }
    return obj;
  };
  api.set = function set5(obj, pointer, value) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer), nextTok = refTokens[0];
    if (refTokens.length === 0) {
      throw Error("Can not set the root object");
    }
    for (var i = 0; i < refTokens.length - 1; ++i) {
      var tok = refTokens[i];
      if (typeof tok !== "string" && typeof tok !== "number") {
        tok = String(tok);
      }
      if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
        continue;
      }
      if (tok === "-" && Array.isArray(obj)) {
        tok = obj.length;
      }
      nextTok = refTokens[i + 1];
      if (!(tok in obj)) {
        if (nextTok.match(/^(\d+|-)$/)) {
          obj[tok] = [];
        } else {
          obj[tok] = {};
        }
      }
      obj = obj[tok];
    }
    if (nextTok === "-" && Array.isArray(obj)) {
      nextTok = obj.length;
    }
    obj[nextTok] = value;
    return this;
  };
  api.remove = function(obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    var finalToken = refTokens[refTokens.length - 1];
    if (finalToken === void 0) {
      throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
    }
    var parent = api.get(obj, refTokens.slice(0, -1));
    if (Array.isArray(parent)) {
      var index2 = +finalToken;
      if (finalToken === "" && isNaN(index2)) {
        throw new Error('Invalid array index: "' + finalToken + '"');
      }
      Array.prototype.splice.call(parent, index2, 1);
    } else {
      delete parent[finalToken];
    }
  };
  api.dict = function dict(obj, descend) {
    var results = {};
    api.walk(obj, function(value, pointer) {
      results[pointer] = value;
    }, descend);
    return results;
  };
  api.walk = function walk2(obj, iterator, descend) {
    var refTokens = [];
    descend = descend || function(value) {
      var type2 = Object.prototype.toString.call(value);
      return type2 === "[object Object]" || type2 === "[object Array]";
    };
    (function next2(cur) {
      each(cur, function(value, key2) {
        refTokens.push(String(key2));
        if (descend(value)) {
          next2(value);
        } else {
          iterator(value, api.compile(refTokens));
        }
        refTokens.pop();
      });
    })(obj);
  };
  api.has = function has3(obj, pointer) {
    try {
      api.get(obj, pointer);
    } catch (e2) {
      return false;
    }
    return true;
  };
  api.escape = function escape2(str2) {
    return str2.toString().replace(/~/g, "~0").replace(/\//g, "~1");
  };
  api.unescape = function unescape2(str2) {
    return str2.replace(/~1/g, "/").replace(/~0/g, "~");
  };
  api.parse = function parse2(pointer) {
    if (pointer === "") {
      return [];
    }
    if (pointer.charAt(0) !== "/") {
      throw new Error("Invalid JSON pointer: " + pointer);
    }
    return pointer.substring(1).split(/\//).map(api.unescape);
  };
  api.compile = function compile2(refTokens) {
    if (refTokens.length === 0) {
      return "";
    }
    return "/" + refTokens.map(api.escape).join("/");
  };
  return jsonPointer;
}
var urlTemplate = { exports: {} };
var hasRequiredUrlTemplate;
function requireUrlTemplate() {
  if (hasRequiredUrlTemplate)
    return urlTemplate.exports;
  hasRequiredUrlTemplate = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2();
      }
    })(commonjsGlobal, function() {
      function UrlTemplate() {
      }
      UrlTemplate.prototype.encodeReserved = function(str2) {
        return str2.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
          if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
          }
          return part;
        }).join("");
      };
      UrlTemplate.prototype.encodeUnreserved = function(str2) {
        return encodeURIComponent(str2).replace(/[!'()*]/g, function(c2) {
          return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
        });
      };
      UrlTemplate.prototype.encodeValue = function(operator, value, key2) {
        value = operator === "+" || operator === "#" ? this.encodeReserved(value) : this.encodeUnreserved(value);
        if (key2) {
          return this.encodeUnreserved(key2) + "=" + value;
        } else {
          return value;
        }
      };
      UrlTemplate.prototype.isDefined = function(value) {
        return value !== void 0 && value !== null;
      };
      UrlTemplate.prototype.isKeyOperator = function(operator) {
        return operator === ";" || operator === "&" || operator === "?";
      };
      UrlTemplate.prototype.getValues = function(context, operator, key2, modifier) {
        var value = context[key2], result = [];
        if (this.isDefined(value) && value !== "") {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
              value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key2 : null));
          } else {
            if (modifier === "*") {
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  result.push(this.encodeValue(operator, value2, this.isKeyOperator(operator) ? key2 : null));
                }, this);
              } else {
                Object.keys(value).forEach(function(k2) {
                  if (this.isDefined(value[k2])) {
                    result.push(this.encodeValue(operator, value[k2], k2));
                  }
                }, this);
              }
            } else {
              var tmp = [];
              if (Array.isArray(value)) {
                value.filter(this.isDefined).forEach(function(value2) {
                  tmp.push(this.encodeValue(operator, value2));
                }, this);
              } else {
                Object.keys(value).forEach(function(k2) {
                  if (this.isDefined(value[k2])) {
                    tmp.push(this.encodeUnreserved(k2));
                    tmp.push(this.encodeValue(operator, value[k2].toString()));
                  }
                }, this);
              }
              if (this.isKeyOperator(operator)) {
                result.push(this.encodeUnreserved(key2) + "=" + tmp.join(","));
              } else if (tmp.length !== 0) {
                result.push(tmp.join(","));
              }
            }
          }
        } else {
          if (operator === ";") {
            if (this.isDefined(value)) {
              result.push(this.encodeUnreserved(key2));
            }
          } else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(this.encodeUnreserved(key2) + "=");
          } else if (value === "") {
            result.push("");
          }
        }
        return result;
      };
      UrlTemplate.prototype.parse = function(template2) {
        var that = this;
        var operators = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(context) {
            return template2.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
              if (expression) {
                var operator = null, values2 = [];
                if (operators.indexOf(expression.charAt(0)) !== -1) {
                  operator = expression.charAt(0);
                  expression = expression.substr(1);
                }
                expression.split(/,/g).forEach(function(variable) {
                  var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                  values2.push.apply(values2, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                });
                if (operator && operator !== "+") {
                  var separator = ",";
                  if (operator === "?") {
                    separator = "&";
                  } else if (operator !== "#") {
                    separator = operator;
                  }
                  return (values2.length !== 0 ? operator : "") + values2.join(separator);
                } else {
                  return values2.join(",");
                }
              } else {
                return that.encodeReserved(literal);
              }
            });
          }
        };
      };
      return new UrlTemplate();
    });
  })(urlTemplate);
  return urlTemplate.exports;
}
var prism = { exports: {} };
var hasRequiredPrism;
function requirePrism() {
  if (hasRequiredPrism)
    return prism.exports;
  hasRequiredPrism = 1;
  (function(module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism2 = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode2(tokens2) {
            if (tokens2 instanceof Token) {
              return new Token(tokens2.type, encode2(tokens2.content), tokens2.alias);
            } else if (Array.isArray(tokens2)) {
              return tokens2.map(encode2);
            } else {
              return tokens2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id2;
            switch (_2.util.type(o)) {
              case "Object":
                id2 = _2.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone;
                for (var key2 in o) {
                  if (o.hasOwnProperty(key2)) {
                    clone[key2] = deepClone(o[key2], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id2 = _2.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = [];
                visited[id2] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v2, i) {
                  clone[i] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m2 = lang.exec(element.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang2 = _2.util.clone(_2.languages[id2]);
            for (var key2 in redef) {
              lang2[key2] = redef[key2];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert2, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token2 in grammar) {
              if (grammar.hasOwnProperty(token2)) {
                if (token2 == before) {
                  for (var newToken in insert2) {
                    if (insert2.hasOwnProperty(newToken)) {
                      ret[newToken] = insert2[newToken];
                    }
                  }
                }
                if (!insert2.hasOwnProperty(token2)) {
                  ret[token2] = grammar[token2];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key2, value) {
              if (value === old && key2 != inside) {
                this[key2] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type2, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type2 || i);
                var property = o[i];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container2, async, callback) {
          var env2 = {
            callback,
            container: container2,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env2);
          env2.elements = Array.prototype.slice.apply(env2.container.querySelectorAll(env2.selector));
          _2.hooks.run("before-all-elements-highlight", env2);
          for (var i = 0, element; element = env2.elements[i++]; ) {
            _2.highlightElement(element, async === true, env2.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env2 = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env2.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env2);
            env2.element.innerHTML = env2.highlightedCode;
            _2.hooks.run("after-highlight", env2);
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
          }
          _2.hooks.run("before-sanity-check", env2);
          parent = env2.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env2.code) {
            _2.hooks.run("complete", env2);
            callback && callback.call(env2.element);
            return;
          }
          _2.hooks.run("before-highlight", env2);
          if (!env2.grammar) {
            insertHighlightedCode(_2.util.encode(env2.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env2.language,
              code: env2.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env2.code, env2.grammar, env2.language));
          }
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env2 = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env2);
          if (!env2.grammar) {
            throw new Error('The language "' + env2.language + '" has no grammar.');
          }
          env2.tokens = _2.tokenize(env2.code, env2.grammar);
          _2.hooks.run("after-tokenize", env2);
          return Token.stringify(_2.util.encode(env2.tokens), env2.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token2 in rest) {
              grammar[token2] = rest[token2];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray2(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _2.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env2) {
            var callbacks = _2.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env2);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type2, content, alias, matchedStr) {
        this.type = type2;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify16(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e2) {
            s += stringify16(e2, language);
          });
          return s;
        }
        var env2 = {
          type: o.type,
          content: stringify16(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env2.classes, aliases);
          } else {
            env2.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env2);
        var attributes = "";
        for (var name2 in env2.attributes) {
          attributes += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes + ">" + env2.content + "</" + env2.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match2 = pattern.exec(text);
        if (match2 && lookbehind && match2[1]) {
          var lookbehindLength = match2[1].length;
          match2.index += lookbehindLength;
          match2[0] = match2[0].slice(lookbehindLength);
        }
        return match2;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token2 in grammar) {
          if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
            continue;
          }
          var patterns2 = grammar[token2];
          patterns2 = Array.isArray(patterns2) ? patterns2 : [patterns2];
          for (var j = 0; j < patterns2.length; ++j) {
            if (rematch && rematch.cause == token2 + "," + j) {
              return;
            }
            var patternObj = patterns2[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str2 = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str2 instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match2;
              if (greedy) {
                match2 = matchPattern(pattern, pos, text, lookbehind);
                if (!match2 || match2.index >= text.length) {
                  break;
                }
                var from2 = match2.index;
                var to = match2.index + match2[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from2 >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p2 += k2.value.length;
                }
                removeCount--;
                str2 = text.slice(pos, p2);
                match2.index -= pos;
              } else {
                match2 = matchPattern(pattern, 0, str2, lookbehind);
                if (!match2) {
                  continue;
                }
              }
              var from2 = match2.index;
              var matchStr = match2[0];
              var before = str2.slice(0, from2);
              var after = str2.slice(from2 + matchStr.length);
              var reach = pos + str2.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token2 + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list2, node2, value) {
        var next2 = node2.next;
        var newNode = { value, prev: node2, next: next2 };
        node2.next = newNode;
        next2.prev = newNode;
        list2.length++;
        return newNode;
      }
      function removeRange(list2, node2, count2) {
        var next2 = node2.next;
        for (var i = 0; i < count2 && next2 !== list2.tail; i++) {
          next2 = next2.next;
        }
        node2.next = next2;
        next2.prev = node2;
        list2.length -= i;
      }
      function toArray2(list2) {
        var array2 = [];
        var node2 = list2.head.next;
        while (node2 !== list2.tail) {
          array2.push(node2.value);
          node2 = node2.next;
        }
        return array2;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    }(_self);
    if (module.exports) {
      module.exports = Prism2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env2) {
      if (env2.type === "entity") {
        env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string2.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string2,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading";
      var FAILURE_MESSAGE = function(status, message) {
        return " Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = " Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m2) {
          var start2 = Number(m2[1]);
          var comma2 = m2[2];
          var end2 = m2[3];
          if (!comma2) {
            return [start2, start2];
          }
          if (!end2) {
            return [start2, void 0];
          }
          return [start2, Number(end2)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env2) {
        env2.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env2) {
        var pre = (
          /** @type {HTMLPreElement} */
          env2.element
        );
        if (pre.matches(SELECTOR)) {
          env2.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env2.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start2 = range[0];
                var end2 = range[1] == null ? lines.length : range[1];
                if (start2 < 0) {
                  start2 += lines.length;
                }
                start2 = Math.max(0, Math.min(start2 - 1, lines.length));
                if (end2 < 0) {
                  end2 += lines.length;
                }
                end2 = Math.max(0, Math.min(end2, lines.length));
                text = lines.slice(start2, end2).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start2 + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container2) {
          var elements = (container2 || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  })(prism);
  return prism.exports;
}
var prismBash = {};
var hasRequiredPrismBash;
function requirePrismBash() {
  if (hasRequiredPrismBash)
    return prismBash;
  hasRequiredPrismBash = 1;
  (function(Prism2) {
    var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
    var commandAfterHeredoc = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: true,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    };
    var insideString = {
      "bash": commandAfterHeredoc,
      "environment": {
        pattern: RegExp("\\$" + envVars),
        alias: "constant"
      },
      "variable": [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: true,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            "variable": [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: true
              },
              /^\$\(\(/
            ],
            "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            "punctuation": /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: true,
          inside: {
            "variable": /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: true,
          inside: {
            "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            "punctuation": /[\[\]]/,
            "environment": {
              pattern: RegExp("(\\{)" + envVars),
              lookbehind: true,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    Prism2.languages.bash = {
      "shebang": {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      "comment": {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: true
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not foo {
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: true,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: true
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (= and +=).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          "environment": {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: true
      },
      // Highlight parameter names as variables
      "parameter": {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: true
      },
      "string": [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        },
        // Here-document with quotes around the tag
        //  No expansion (so no inside).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: true,
          greedy: true,
          inside: {
            "bash": commandAfterHeredoc
          }
        },
        // Normal string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: true,
          greedy: true
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: true,
          inside: {
            "entity": insideString.entity
          }
        }
      ],
      "environment": {
        pattern: RegExp("\\$?" + envVars),
        alias: "constant"
      },
      "variable": insideString.variable,
      "function": {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      "keyword": {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      "builtin": {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: true,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      "boolean": {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      "operator": {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      "number": {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: true
      }
    };
    commandAfterHeredoc.inside = Prism2.languages.bash;
    var toBeCopied = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ];
    var inside = insideString.variable[1].inside;
    for (var i = 0; i < toBeCopied.length; i++) {
      inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
    }
    Prism2.languages.sh = Prism2.languages.bash;
    Prism2.languages.shell = Prism2.languages.bash;
  })(Prism);
  return prismBash;
}
var prismC = {};
var hasRequiredPrismC;
function requirePrismC() {
  if (hasRequiredPrismC)
    return prismC;
  hasRequiredPrismC = 1;
  Prism.languages.c = Prism.languages.extend("clike", {
    "comment": {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    "string": {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: true
    },
    "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  });
  Prism.languages.insertBefore("c", "string", {
    "char": {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: true
    }
  });
  Prism.languages.insertBefore("c", "string", {
    "macro": {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: true,
      greedy: true,
      alias: "property",
      inside: {
        "string": [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: true
          },
          Prism.languages.c["string"]
        ],
        "char": Prism.languages.c["char"],
        "comment": Prism.languages.c["comment"],
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: true
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: true,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        "directive": {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: true,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        "punctuation": /##|\\(?=[\r\n])/,
        "expression": {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  });
  Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  });
  delete Prism.languages.c["boolean"];
  return prismC;
}
var prismClike = {};
var hasRequiredPrismClike;
function requirePrismClike() {
  if (hasRequiredPrismClike)
    return prismClike;
  hasRequiredPrismClike = 1;
  Prism.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
  return prismClike;
}
var prismCoffeescript = {};
var hasRequiredPrismCoffeescript;
function requirePrismCoffeescript() {
  if (hasRequiredPrismCoffeescript)
    return prismCoffeescript;
  hasRequiredPrismCoffeescript = 1;
  (function(Prism2) {
    var comment2 = /#(?!\{).+/;
    var interpolation = {
      pattern: /#\{[^}]+\}/,
      alias: "variable"
    };
    Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
      "comment": comment2,
      "string": [
        // Strings are multiline
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          greedy: true
        },
        {
          // Strings are multiline
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          greedy: true,
          inside: {
            "interpolation": interpolation
          }
        }
      ],
      "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
      "class-member": {
        pattern: /@(?!\d)\w+/,
        alias: "variable"
      }
    });
    Prism2.languages.insertBefore("coffeescript", "comment", {
      "multiline-comment": {
        pattern: /###[\s\S]+?###/,
        alias: "comment"
      },
      // Block regexp can contain comments and interpolation
      "block-regex": {
        pattern: /\/{3}[\s\S]*?\/{3}/,
        alias: "regex",
        inside: {
          "comment": comment2,
          "interpolation": interpolation
        }
      }
    });
    Prism2.languages.insertBefore("coffeescript", "string", {
      "inline-javascript": {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        inside: {
          "delimiter": {
            pattern: /^`|`$/,
            alias: "punctuation"
          },
          "script": {
            pattern: /[\s\S]+/,
            alias: "language-javascript",
            inside: Prism2.languages.javascript
          }
        }
      },
      // Block strings
      "multiline-string": [
        {
          pattern: /'''[\s\S]*?'''/,
          greedy: true,
          alias: "string"
        },
        {
          pattern: /"""[\s\S]*?"""/,
          greedy: true,
          alias: "string",
          inside: {
            interpolation
          }
        }
      ]
    });
    Prism2.languages.insertBefore("coffeescript", "keyword", {
      // Object property
      "property": /(?!\d)\w+(?=\s*:(?!:))/
    });
    delete Prism2.languages.coffeescript["template-string"];
    Prism2.languages.coffee = Prism2.languages.coffeescript;
  })(Prism);
  return prismCoffeescript;
}
var prismCpp = {};
var hasRequiredPrismCpp;
function requirePrismCpp() {
  if (hasRequiredPrismCpp)
    return prismCpp;
  hasRequiredPrismCpp = 1;
  (function(Prism2) {
    var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
    var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return keyword.source;
    });
    Prism2.languages.cpp = Prism2.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return keyword.source;
          })),
          lookbehind: true
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      "keyword": keyword,
      "number": {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: true
      },
      "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      "boolean": /\b(?:false|true)\b/
    });
    Prism2.languages.insertBefore("cpp", "string", {
      "module": {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return modName;
          }) + ")"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "string": /^[<"][\s\S]+/,
          "operator": /:/,
          "punctuation": /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: true
      }
    });
    Prism2.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          "function": /^\w+/,
          "generic": {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: Prism2.languages.cpp
          }
        }
      }
    });
    Prism2.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    Prism2.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: true,
        greedy: true,
        inside: Prism2.languages.extend("cpp", {})
      }
    });
    Prism2.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, Prism2.languages.cpp["base-clause"]);
  })(Prism);
  return prismCpp;
}
var prismCsharp = {};
var hasRequiredPrismCsharp;
function requirePrismCsharp() {
  if (hasRequiredPrismCsharp)
    return prismCsharp;
  hasRequiredPrismCsharp = 1;
  (function(Prism2) {
    function replace3(pattern, replacements) {
      return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
        return "(?:" + replacements[+index2] + ")";
      });
    }
    function re2(pattern, replacements, flags) {
      return RegExp(replace3(pattern, replacements), flags || "");
    }
    function nested(pattern, depthLog2) {
      for (var i = 0; i < depthLog2; i++) {
        pattern = pattern.replace(/<<self>>/g, function() {
          return "(?:" + pattern + ")";
        });
      }
      return pattern.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var keywordKinds = {
      // keywords which represent a return or variable type
      type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
      // keywords which are used to declare a type
      typeDeclaration: "class enum interface record struct",
      // contextual keywords
      // ("var" and "dynamic" are missing because they are used like types)
      contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
      // all other keywords
      other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function keywordsToPattern(words) {
      return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
    }
    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
    var keywords2 = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
    var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
    var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
    var name2 = /@?\b[A-Za-z_]\w*\b/.source;
    var genericName = replace3(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
    var identifier2 = replace3(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
    var array2 = /\[\s*(?:,\s*)*\]/.source;
    var typeExpressionWithoutTuple = replace3(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier2, array2]);
    var tupleElement = replace3(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array2]);
    var tuple = replace3(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
    var typeExpression = replace3(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier2, array2]);
    var typeInside = {
      "keyword": keywords2,
      "punctuation": /[<>()?,.:[\]]/
    };
    var character2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
    var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
    var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    Prism2.languages.csharp = Prism2.languages.extend("clike", {
      "string": [
        {
          pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
          lookbehind: true,
          greedy: true
        }
      ],
      "class-name": [
        {
          // Using static
          // using static System.Math;
          pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier2]),
          lookbehind: true,
          inside: typeInside
        },
        {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
          lookbehind: true,
          inside: typeInside
        },
        {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
          lookbehind: true
        },
        {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
          lookbehind: true,
          inside: typeInside
        },
        {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier2]),
          lookbehind: true,
          inside: typeInside
        },
        {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: re2(/(\bwhere\s+)<<0>>/.source, [name2]),
          lookbehind: true
        },
        {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
          lookbehind: true,
          inside: typeInside
        },
        {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: re2(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
          inside: typeInside
        }
      ],
      "keyword": keywords2,
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
      "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
      "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      "punctuation": /\?\.?|::|[{}[\];(),.:]/
    });
    Prism2.languages.insertBefore("csharp", "number", {
      "range": {
        pattern: /\.\./,
        alias: "operator"
      }
    });
    Prism2.languages.insertBefore("csharp", "punctuation", {
      "named-parameter": {
        pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
        lookbehind: true,
        alias: "punctuation"
      }
    });
    Prism2.languages.insertBefore("csharp", "class-name", {
      "namespace": {
        // namespace Foo.Bar {}
        // using Foo.Bar;
        pattern: re2(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      },
      "type-expression": {
        // default(Foo), typeof(Foo<Bar>), sizeof(int)
        pattern: re2(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
        lookbehind: true,
        alias: "class-name",
        inside: typeInside
      },
      "return-type": {
        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
        // int Foo => 0; int Foo { get; set } = 0;
        pattern: re2(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier2]),
        inside: typeInside,
        alias: "class-name"
      },
      "constructor-invocation": {
        // new List<Foo<Bar[]>> { }
        pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
        lookbehind: true,
        inside: typeInside,
        alias: "class-name"
      },
      /*'explicit-implementation': {
      	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
      	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
      	inside: classNameInside,
      	alias: 'class-name'
      },*/
      "generic-method": {
        // foo<Bar>()
        pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
        inside: {
          "function": re2(/^<<0>>/.source, [name2]),
          "generic": {
            pattern: RegExp(generic),
            alias: "class-name",
            inside: typeInside
          }
        }
      },
      "type-list": {
        // The list of types inherited or of generic constraints
        // class Foo<F> : Bar, IList<FooBar>
        // where F : Bar, IList<int>
        pattern: re2(
          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
          [typeDeclarationKeywords, genericName, name2, typeExpression, keywords2.source, nestedRound, /\bnew\s*\(\s*\)/.source]
        ),
        lookbehind: true,
        inside: {
          "record-arguments": {
            pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
            lookbehind: true,
            greedy: true,
            inside: Prism2.languages.csharp
          },
          "keyword": keywords2,
          "class-name": {
            pattern: RegExp(typeExpression),
            greedy: true,
            inside: typeInside
          },
          "punctuation": /[,()]/
        }
      },
      "preprocessor": {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: true,
        alias: "property",
        inside: {
          // highlight preprocessor directives as keywords
          "directive": {
            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
            lookbehind: true,
            alias: "keyword"
          }
        }
      }
    });
    var regularStringOrCharacter = regularString + "|" + character2;
    var regularStringCharacterOrComment = replace3(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
    var roundExpression = nested(replace3(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
    var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
    var attr = replace3(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier2, roundExpression]);
    Prism2.languages.insertBefore("csharp", "class-name", {
      "attribute": {
        // Attributes
        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
        pattern: re2(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
        lookbehind: true,
        greedy: true,
        inside: {
          "target": {
            pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
            inside: Prism2.languages.csharp
          },
          "class-name": {
            pattern: RegExp(identifier2),
            inside: {
              "punctuation": /\./
            }
          },
          "punctuation": /[:,]/
        }
      }
    });
    var formatString = /:[^}\r\n]+/.source;
    var mInterpolationRound = nested(replace3(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
    var mInterpolation = replace3(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
    var sInterpolationRound = nested(replace3(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
    var sInterpolation = replace3(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
    function createInterpolationInside(interpolation, interpolationRound) {
      return {
        "interpolation": {
          pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
          lookbehind: true,
          inside: {
            "format-string": {
              pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
              lookbehind: true,
              inside: {
                "punctuation": /^:/
              }
            },
            "punctuation": /^\{|\}$/,
            "expression": {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: Prism2.languages.csharp
            }
          }
        },
        "string": /[\s\S]+/
      };
    }
    Prism2.languages.insertBefore("csharp", "string", {
      "interpolation-string": [
        {
          pattern: re2(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
          lookbehind: true,
          greedy: true,
          inside: createInterpolationInside(mInterpolation, mInterpolationRound)
        },
        {
          pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
          lookbehind: true,
          greedy: true,
          inside: createInterpolationInside(sInterpolation, sInterpolationRound)
        }
      ],
      "char": {
        pattern: RegExp(character2),
        greedy: true
      }
    });
    Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
  })(Prism);
  return prismCsharp;
}
var prismGo = {};
var hasRequiredPrismGo;
function requirePrismGo() {
  if (hasRequiredPrismGo)
    return prismGo;
  hasRequiredPrismGo = 1;
  Prism.languages.go = Prism.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: true,
      greedy: true
    },
    "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    "boolean": /\b(?:_|false|iota|nil|true)\b/,
    "number": [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  });
  Prism.languages.insertBefore("go", "string", {
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: true
    }
  });
  delete Prism.languages.go["class-name"];
  return prismGo;
}
var prismHttp = {};
var hasRequiredPrismHttp;
function requirePrismHttp() {
  if (hasRequiredPrismHttp)
    return prismHttp;
  hasRequiredPrismHttp = 1;
  (function(Prism2) {
    function headerValueOf(name2) {
      return RegExp("(^(?:" + name2 + "):[ 	]*(?![ 	]))[^]+", "i");
    }
    Prism2.languages.http = {
      "request-line": {
        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
        inside: {
          // HTTP Method
          "method": {
            pattern: /^[A-Z]+\b/,
            alias: "property"
          },
          // Request Target e.g. http://example.com, /path/to/file
          "request-target": {
            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
            lookbehind: true,
            alias: "url",
            inside: Prism2.languages.uri
          },
          // HTTP Version
          "http-version": {
            pattern: /^(\s)HTTP\/[\d.]+/,
            lookbehind: true,
            alias: "property"
          }
        }
      },
      "response-status": {
        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
        inside: {
          // HTTP Version
          "http-version": {
            pattern: /^HTTP\/[\d.]+/,
            alias: "property"
          },
          // Status Code
          "status-code": {
            pattern: /^(\s)\d+(?=\s)/,
            lookbehind: true,
            alias: "number"
          },
          // Reason Phrase
          "reason-phrase": {
            pattern: /^(\s).+/,
            lookbehind: true,
            alias: "string"
          }
        }
      },
      "header": {
        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
        inside: {
          "header-value": [
            {
              pattern: headerValueOf(/Content-Security-Policy/.source),
              lookbehind: true,
              alias: ["csp", "languages-csp"],
              inside: Prism2.languages.csp
            },
            {
              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: true,
              alias: ["hpkp", "languages-hpkp"],
              inside: Prism2.languages.hpkp
            },
            {
              pattern: headerValueOf(/Strict-Transport-Security/.source),
              lookbehind: true,
              alias: ["hsts", "languages-hsts"],
              inside: Prism2.languages.hsts
            },
            {
              pattern: headerValueOf(/[^:]+/.source),
              lookbehind: true
            }
          ],
          "header-name": {
            pattern: /^[^:]+/,
            alias: "keyword"
          },
          "punctuation": /^:/
        }
      }
    };
    var langs = Prism2.languages;
    var httpLanguages = {
      "application/javascript": langs.javascript,
      "application/json": langs.json || langs.javascript,
      "application/xml": langs.xml,
      "text/xml": langs.xml,
      "text/html": langs.html,
      "text/css": langs.css,
      "text/plain": langs.plain
    };
    var suffixTypes = {
      "application/json": true,
      "application/xml": true
    };
    function getSuffixPattern(contentType2) {
      var suffix = contentType2.replace(/^[a-z]+\//, "");
      var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
      return "(?:" + contentType2 + "|" + suffixPattern + ")";
    }
    var options2;
    for (var contentType in httpLanguages) {
      if (httpLanguages[contentType]) {
        options2 = options2 || {};
        var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
        options2[contentType.replace(/\//g, "-")] = {
          pattern: RegExp(
            "(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source,
            "i"
          ),
          lookbehind: true,
          inside: httpLanguages[contentType]
        };
      }
    }
    if (options2) {
      Prism2.languages.insertBefore("http", "header", options2);
    }
  })(Prism);
  return prismHttp;
}
var prismJava = {};
var hasRequiredPrismJava;
function requirePrismJava() {
  if (hasRequiredPrismJava)
    return prismJava;
  hasRequiredPrismJava = 1;
  (function(Prism2) {
    var keywords2 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
    var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
    var className = {
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: true,
      inside: {
        "namespace": {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /\./
      }
    };
    Prism2.languages.java = Prism2.languages.extend("clike", {
      "string": {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: true,
        greedy: true
      },
      "class-name": [
        className,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: true,
          inside: className.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
          lookbehind: true,
          inside: className.inside
        }
      ],
      "keyword": keywords2,
      "function": [
        Prism2.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: true
        }
      ],
      "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      "operator": {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: true
      },
      "constant": /\b[A-Z][A-Z_\d]+\b/
    });
    Prism2.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: true,
        alias: "string"
      },
      "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: true
      }
    });
    Prism2.languages.insertBefore("java", "class-name", {
      "annotation": {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: true,
        alias: "punctuation"
      },
      "generics": {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": className,
          "keyword": keywords2,
          "punctuation": /[<>(),.:]/,
          "operator": /[?&|]/
        }
      },
      "import": [
        {
          pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: true,
          inside: {
            "namespace": className.inside.namespace,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: true,
          alias: "static",
          inside: {
            "namespace": className.inside.namespace,
            "static": /\b\w+$/,
            "punctuation": /\./,
            "operator": /\*/,
            "class-name": /\w+/
          }
        }
      ],
      "namespace": {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return keywords2.source;
          })
        ),
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      }
    });
  })(Prism);
  return prismJava;
}
var prismLua = {};
var hasRequiredPrismLua;
function requirePrismLua() {
  if (hasRequiredPrismLua)
    return prismLua;
  hasRequiredPrismLua = 1;
  Prism.languages.lua = {
    "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    "string": {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: true
    },
    "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    "function": /(?!\d)\w+(?=\s*(?:[({]))/,
    "operator": [
      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
      {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: true
      }
    ],
    "punctuation": /[\[\](){},;]|\.+|:+/
  };
  return prismLua;
}
var prismMarkupTemplating = {};
var hasRequiredPrismMarkupTemplating;
function requirePrismMarkupTemplating() {
  if (hasRequiredPrismMarkupTemplating)
    return prismMarkupTemplating;
  hasRequiredPrismMarkupTemplating = 1;
  (function(Prism2) {
    function getPlaceholder(language, index2) {
      return "___" + language.toUpperCase() + index2 + "___";
    }
    Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(env2, language, placeholderPattern, replaceFilter) {
          if (env2.language !== language) {
            return;
          }
          var tokenStack = env2.tokenStack = [];
          env2.code = env2.code.replace(placeholderPattern, function(match2) {
            if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
              return match2;
            }
            var i = tokenStack.length;
            var placeholder;
            while (env2.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
              ++i;
            }
            tokenStack[i] = match2;
            return placeholder;
          });
          env2.grammar = Prism2.languages.markup;
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(env2, language) {
          if (env2.language !== language || !env2.tokenStack) {
            return;
          }
          env2.grammar = Prism2.languages[language];
          var j = 0;
          var keys2 = Object.keys(env2.tokenStack);
          function walkTokens(tokens2) {
            for (var i = 0; i < tokens2.length; i++) {
              if (j >= keys2.length) {
                break;
              }
              var token2 = tokens2[i];
              if (typeof token2 === "string" || token2.content && typeof token2.content === "string") {
                var k2 = keys2[j];
                var t2 = env2.tokenStack[k2];
                var s = typeof token2 === "string" ? token2 : token2.content;
                var placeholder = getPlaceholder(language, k2);
                var index2 = s.indexOf(placeholder);
                if (index2 > -1) {
                  ++j;
                  var before = s.substring(0, index2);
                  var middle = new Prism2.Token(language, Prism2.tokenize(t2, env2.grammar), "language-" + language, t2);
                  var after = s.substring(index2 + placeholder.length);
                  var replacement = [];
                  if (before) {
                    replacement.push.apply(replacement, walkTokens([before]));
                  }
                  replacement.push(middle);
                  if (after) {
                    replacement.push.apply(replacement, walkTokens([after]));
                  }
                  if (typeof token2 === "string") {
                    tokens2.splice.apply(tokens2, [i, 1].concat(replacement));
                  } else {
                    token2.content = replacement;
                  }
                }
              } else if (token2.content) {
                walkTokens(token2.content);
              }
            }
            return tokens2;
          }
          walkTokens(env2.tokens);
        }
      }
    });
  })(Prism);
  return prismMarkupTemplating;
}
var prismMarkup = {};
var hasRequiredPrismMarkup;
function requirePrismMarkup() {
  if (hasRequiredPrismMarkup)
    return prismMarkup;
  hasRequiredPrismMarkup = 1;
  Prism.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
  Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
  Prism.hooks.add("wrap", function(env2) {
    if (env2.type === "entity") {
      env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;
  Prism.languages.xml = Prism.languages.extend("markup", {});
  Prism.languages.ssml = Prism.languages.xml;
  Prism.languages.atom = Prism.languages.xml;
  Prism.languages.rss = Prism.languages.xml;
  return prismMarkup;
}
var prismObjectivec = {};
var hasRequiredPrismObjectivec;
function requirePrismObjectivec() {
  if (hasRequiredPrismObjectivec)
    return prismObjectivec;
  hasRequiredPrismObjectivec = 1;
  Prism.languages.objectivec = Prism.languages.extend("c", {
    "string": {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  });
  delete Prism.languages.objectivec["class-name"];
  Prism.languages.objc = Prism.languages.objectivec;
  return prismObjectivec;
}
var prismPerl = {};
var hasRequiredPrismPerl;
function requirePrismPerl() {
  if (hasRequiredPrismPerl)
    return prismPerl;
  hasRequiredPrismPerl = 1;
  (function(Prism2) {
    var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    Prism2.languages.perl = {
      "comment": [
        {
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      // TODO Could be nice to handle Heredoc too.
      "string": [
        {
          pattern: RegExp(
            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              brackets
            ].join("|") + ")"
          ),
          greedy: true
        },
        // "...", `...`
        {
          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
          greedy: true
        },
        // '...'
        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
        {
          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
          greedy: true
        }
      ],
      "regex": [
        {
          pattern: RegExp(
            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              brackets
            ].join("|") + ")" + /[msixpodualngc]*/.source
          ),
          greedy: true
        },
        // The lookbehinds prevent -s from breaking
        {
          pattern: RegExp(
            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              brackets + /\s*/.source + brackets
            ].join("|") + ")" + /[msixpodualngcer]*/.source
          ),
          lookbehind: true,
          greedy: true
        },
        // /.../
        // The look-ahead tries to prevent two divisions on
        // the same line from being highlighted as regex.
        // This does not support multi-line regex.
        {
          pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
          greedy: true
        }
      ],
      // FIXME Not sure about the handling of ::, ', and #
      "variable": [
        // ${^POSTMATCH}
        /[&*$@%]\{\^[A-Z]+\}/,
        // $^V
        /[&*$@%]\^[A-Z_]/,
        // ${...}
        /[&*$@%]#?(?=\{)/,
        // $foo
        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
        // $1
        /[&*$@%]\d+/,
        // $_, @_, %!
        // The negative lookahead prevents from breaking the %= operator
        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
      ],
      "filehandle": {
        // <>, <FOO>, _
        pattern: /<(?![<=])\S*?>|\b_\b/,
        alias: "symbol"
      },
      "v-string": {
        // v1.2, 1.2.3
        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
        alias: "string"
      },
      "function": {
        pattern: /(\bsub[ \t]+)\w+/,
        lookbehind: true
      },
      "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
      "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
      "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
      "punctuation": /[{}[\];(),:]/
    };
  })(Prism);
  return prismPerl;
}
var prismPhp = {};
var hasRequiredPrismPhp;
function requirePrismPhp() {
  if (hasRequiredPrismPhp)
    return prismPhp;
  hasRequiredPrismPhp = 1;
  (function(Prism2) {
    var comment2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
    var constant = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: true,
        lookbehind: true
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ];
    var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
    var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
    var punctuation = /[{}\[\](),:;]/;
    Prism2.languages.php = {
      "delimiter": {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      "comment": comment2,
      "variable": /\$+(?:\w+\b|(?=\{))/,
      "package": {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: true,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: true,
        alias: "function"
      },
      "keyword": [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: true
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: true
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: true
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: true
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: true
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: true
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: true
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: true
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /\\/
          }
        }
      ],
      "constant": constant,
      "function": {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      "property": {
        pattern: /(->\s*)\w+/,
        lookbehind: true
      },
      "number": number2,
      "operator": operator,
      "punctuation": punctuation
    };
    var string_interpolation = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: true,
      inside: Prism2.languages.php
    };
    var string2 = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              "punctuation": /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              "punctuation": /^<<<"?|[";]$/
            }
          },
          "interpolation": string_interpolation
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: true
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: true
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: true,
        inside: {
          "interpolation": string_interpolation
        }
      }
    ];
    Prism2.languages.insertBefore("php", "variable", {
      "string": string2,
      "attribute": {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: true,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: true,
            // inside can appear subset of php
            inside: {
              "comment": comment2,
              "string": string2,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: true,
                  lookbehind: true
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: [
                    "class-name",
                    "class-name-fully-qualified"
                  ],
                  greedy: true,
                  lookbehind: true,
                  inside: {
                    "punctuation": /\\/
                  }
                }
              ],
              "constant": constant,
              "number": number2,
              "operator": operator,
              "punctuation": punctuation
            }
          },
          "delimiter": {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    });
    Prism2.hooks.add("before-tokenize", function(env2) {
      if (!/<\?/.test(env2.code)) {
        return;
      }
      var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
      Prism2.languages["markup-templating"].buildPlaceholders(env2, "php", phpPattern);
    });
    Prism2.hooks.add("after-tokenize", function(env2) {
      Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "php");
    });
  })(Prism);
  return prismPhp;
}
var prismPython = {};
var hasRequiredPrismPython;
function requirePrismPython() {
  if (hasRequiredPrismPython)
    return prismPython;
  hasRequiredPrismPython = 1;
  Prism.languages.python = {
    "comment": {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true,
      greedy: true
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: true,
      inside: {
        "interpolation": {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: true,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: true
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        "string": /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: true,
      alias: "string"
    },
    "string": {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: true
    },
    "function": {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: true
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: true
    },
    "decorator": {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: true,
      alias: ["annotation", "punctuation"],
      inside: {
        "punctuation": /\./
      }
    },
    "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    "boolean": /\b(?:False|None|True)\b/,
    "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    "punctuation": /[{}[\];(),.:]/
  };
  Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
  Prism.languages.py = Prism.languages.python;
  return prismPython;
}
var prismQ = {};
var hasRequiredPrismQ;
function requirePrismQ() {
  if (hasRequiredPrismQ)
    return prismQ;
  hasRequiredPrismQ = 1;
  Prism.languages.q = {
    "string": /"(?:\\.|[^"\\\r\n])*"/,
    "comment": [
      // From http://code.kx.com/wiki/Reference/Slash:
      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
      {
        pattern: /([\t )\]}])\/.*/,
        lookbehind: true,
        greedy: true
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
      {
        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
        lookbehind: true,
        greedy: true
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A \ on a line by itself with no preceding matching / will comment to end of file.
      {
        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
        greedy: true
      },
      {
        pattern: /^#!.+/m,
        greedy: true
      }
    ],
    "symbol": /`(?::\S+|[\w.]*)/,
    "datetime": {
      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
      alias: "number"
    },
    // The negative look-ahead prevents bad highlighting
    // of verbs 0: and 1:
    "number": /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
    "keyword": /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
    "adverb": {
      pattern: /['\/\\]:?|\beach\b/,
      alias: "function"
    },
    "verb": {
      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
      alias: "operator"
    },
    "punctuation": /[(){}\[\];.]/
  };
  return prismQ;
}
var prismRuby = {};
var hasRequiredPrismRuby;
function requirePrismRuby() {
  if (hasRequiredPrismRuby)
    return prismRuby;
  hasRequiredPrismRuby = 1;
  (function(Prism2) {
    Prism2.languages.ruby = Prism2.languages.extend("clike", {
      "comment": {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      "punctuation": /[(){}[\].,;]/
    });
    Prism2.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var interpolation = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: true,
      inside: {
        "content": {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: true,
          inside: Prism2.languages.ruby
        },
        "delimiter": {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete Prism2.languages.ruby.function;
    var percentExpression = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")";
    var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    Prism2.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "regex": /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "regex": /[\s\S]+/
          }
        }
      ],
      "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      "symbol": [
        {
          pattern: RegExp(/(^|[^:]):/.source + symbolName),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
          lookbehind: true,
          greedy: true
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: true,
        inside: {
          "function": /\b\w+$/,
          "keyword": /^self\b/,
          "class-name": /^\w+/,
          "punctuation": /\./
        }
      }
    });
    Prism2.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: true,
          inside: {
            "delimiter": {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                "symbol": /\b\w+/,
                "punctuation": /^<<[-~]?/
              }
            },
            "interpolation": interpolation,
            "string": /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: true,
          inside: {
            "delimiter": {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                "symbol": /\b\w+/,
                "punctuation": /^<<[-~]?'|'$/
              }
            },
            "string": /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + percentExpression),
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "command": {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: true,
          inside: {
            "interpolation": interpolation,
            "command": {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    });
    delete Prism2.languages.ruby.string;
    Prism2.languages.insertBefore("ruby", "number", {
      "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    });
    Prism2.languages.rb = Prism2.languages.ruby;
  })(Prism);
  return prismRuby;
}
var prismScala = {};
var hasRequiredPrismScala;
function requirePrismScala() {
  if (hasRequiredPrismScala)
    return prismScala;
  hasRequiredPrismScala = 1;
  Prism.languages.scala = Prism.languages.extend("java", {
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: true,
      alias: "string"
    },
    "string": {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "keyword": /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
    "number": /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
    "builtin": /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
    "symbol": /'[^\d\s\\]\w*/
  });
  Prism.languages.insertBefore("scala", "triple-quoted-string", {
    "string-interpolation": {
      pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
      greedy: true,
      inside: {
        "id": {
          pattern: /^\w+/,
          greedy: true,
          alias: "function"
        },
        "escape": {
          pattern: /\\\$"|\$[$"]/,
          greedy: true,
          alias: "symbol"
        },
        "interpolation": {
          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          greedy: true,
          inside: {
            "punctuation": /^\$\{?|\}$/,
            "expression": {
              pattern: /[\s\S]+/,
              inside: Prism.languages.scala
            }
          }
        },
        "string": /[\s\S]+/
      }
    }
  });
  delete Prism.languages.scala["class-name"];
  delete Prism.languages.scala["function"];
  delete Prism.languages.scala["constant"];
  return prismScala;
}
var prismSql = {};
var hasRequiredPrismSql;
function requirePrismSql() {
  if (hasRequiredPrismSql)
    return prismSql;
  hasRequiredPrismSql = 1;
  Prism.languages.sql = {
    "comment": {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    "variable": [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    "string": {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    "identifier": {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /^`|`$/
      }
    },
    "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
    "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    "punctuation": /[;[\]()`,.]/
  };
  return prismSql;
}
var prismSwift = {};
var hasRequiredPrismSwift;
function requirePrismSwift() {
  if (hasRequiredPrismSwift)
    return prismSwift;
  hasRequiredPrismSwift = 1;
  Prism.languages.swift = {
    "comment": {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: true,
      greedy: true
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          "punctuation": /\\(?=[\r\n])/,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "directive": {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        "boolean": /\b(?:false|true)\b/,
        "number": /\b\d+(?:\.\d+)*\b/,
        "operator": /!|&&|\|\||[<>]=?/,
        "punctuation": /[(),]/
      }
    },
    "literal": {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    "attribute": {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "label": {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: true,
      alias: "important"
    },
    "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    "boolean": /\b(?:false|true)\b/,
    "nil": {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    "omit": {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    "punctuation": /[{}[\]();,.:\\]/
  };
  Prism.languages.swift["string-literal"].forEach(function(rule) {
    rule.inside["interpolation"].inside = Prism.languages.swift;
  });
  return prismSwift;
}
var prismYaml = {};
var hasRequiredPrismYaml;
function requirePrismYaml() {
  if (hasRequiredPrismYaml)
    return prismYaml;
  hasRequiredPrismYaml = 1;
  (function(Prism2) {
    var anchorOrAlias = /[*&][^\s[\]{},]+/;
    var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
    var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
    var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    });
    var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function createValuePattern(value, flags) {
      flags = (flags || "").replace(/m/g, "") + "m";
      var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<value>>/g, function() {
        return value;
      });
      return RegExp(pattern, flags);
    }
    Prism2.languages.yaml = {
      "scalar": {
        pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
          return properties;
        })),
        lookbehind: true,
        alias: "string"
      },
      "comment": /#.*/,
      "key": {
        pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
          return properties;
        }).replace(/<<key>>/g, function() {
          return "(?:" + plainKey + "|" + string2 + ")";
        })),
        lookbehind: true,
        greedy: true,
        alias: "atrule"
      },
      "directive": {
        pattern: /(^[ \t]*)%.+/m,
        lookbehind: true,
        alias: "important"
      },
      "datetime": {
        pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
        lookbehind: true,
        alias: "number"
      },
      "boolean": {
        pattern: createValuePattern(/false|true/.source, "i"),
        lookbehind: true,
        alias: "important"
      },
      "null": {
        pattern: createValuePattern(/null|~/.source, "i"),
        lookbehind: true,
        alias: "important"
      },
      "string": {
        pattern: createValuePattern(string2),
        lookbehind: true,
        greedy: true
      },
      "number": {
        pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
        lookbehind: true
      },
      "tag": tag,
      "important": anchorOrAlias,
      "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
    };
    Prism2.languages.yml = Prism2.languages.yaml;
  })(Prism);
  return prismYaml;
}
var prismCsv = {};
var hasRequiredPrismCsv;
function requirePrismCsv() {
  if (hasRequiredPrismCsv)
    return prismCsv;
  hasRequiredPrismCsv = 1;
  Prism.languages.csv = {
    "value": /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
    "punctuation": /,/
  };
  return prismCsv;
}
var mark = { exports: {} };
/*!***************************************************
* mark.js v8.11.1
* https://markjs.io/
* Copyright (c) 20142018, Julian Khnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
var hasRequiredMark;
function requireMark() {
  if (hasRequiredMark)
    return mark.exports;
  hasRequiredMark = 1;
  (function(module, exports) {
    (function(global2, factory2) {
      module.exports = factory2();
    })(commonjsGlobal, function() {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      var DOMIterator = function() {
        function DOMIterator2(ctx) {
          var iframes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var exclude = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var iframesTimeout = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          classCallCheck(this, DOMIterator2);
          this.ctx = ctx;
          this.iframes = iframes;
          this.exclude = exclude;
          this.iframesTimeout = iframesTimeout;
        }
        createClass(DOMIterator2, [{
          key: "getContexts",
          value: function getContexts() {
            var ctx = void 0, filteredCtx = [];
            if (typeof this.ctx === "undefined" || !this.ctx) {
              ctx = [];
            } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {
              ctx = Array.prototype.slice.call(this.ctx);
            } else if (Array.isArray(this.ctx)) {
              ctx = this.ctx;
            } else if (typeof this.ctx === "string") {
              ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));
            } else {
              ctx = [this.ctx];
            }
            ctx.forEach(function(ctx2) {
              var isDescendant = filteredCtx.filter(function(contexts) {
                return contexts.contains(ctx2);
              }).length > 0;
              if (filteredCtx.indexOf(ctx2) === -1 && !isDescendant) {
                filteredCtx.push(ctx2);
              }
            });
            return filteredCtx;
          }
        }, {
          key: "getIframeContents",
          value: function getIframeContents(ifr, successFn) {
            var errorFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            };
            var doc = void 0;
            try {
              var ifrWin = ifr.contentWindow;
              doc = ifrWin.document;
              if (!ifrWin || !doc) {
                throw new Error("iframe inaccessible");
              }
            } catch (e2) {
              errorFn();
            }
            if (doc) {
              successFn(doc);
            }
          }
        }, {
          key: "isIframeBlank",
          value: function isIframeBlank(ifr) {
            var bl2 = "about:blank", src = ifr.getAttribute("src").trim(), href = ifr.contentWindow.location.href;
            return href === bl2 && src !== bl2 && src;
          }
        }, {
          key: "observeIframeLoad",
          value: function observeIframeLoad(ifr, successFn, errorFn) {
            var _this = this;
            var called = false, tout = null;
            var listener = function listener2() {
              if (called) {
                return;
              }
              called = true;
              clearTimeout(tout);
              try {
                if (!_this.isIframeBlank(ifr)) {
                  ifr.removeEventListener("load", listener2);
                  _this.getIframeContents(ifr, successFn, errorFn);
                }
              } catch (e2) {
                errorFn();
              }
            };
            ifr.addEventListener("load", listener);
            tout = setTimeout(listener, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function onIframeReady(ifr, successFn, errorFn) {
            try {
              if (ifr.contentWindow.document.readyState === "complete") {
                if (this.isIframeBlank(ifr)) {
                  this.observeIframeLoad(ifr, successFn, errorFn);
                } else {
                  this.getIframeContents(ifr, successFn, errorFn);
                }
              } else {
                this.observeIframeLoad(ifr, successFn, errorFn);
              }
            } catch (e2) {
              errorFn();
            }
          }
        }, {
          key: "waitForIframes",
          value: function waitForIframes(ctx, done) {
            var _this2 = this;
            var eachCalled = 0;
            this.forEachIframe(ctx, function() {
              return true;
            }, function(ifr) {
              eachCalled++;
              _this2.waitForIframes(ifr.querySelector("html"), function() {
                if (!--eachCalled) {
                  done();
                }
              });
            }, function(handled) {
              if (!handled) {
                done();
              }
            });
          }
        }, {
          key: "forEachIframe",
          value: function forEachIframe(ctx, filter2, each) {
            var _this3 = this;
            var end2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var ifr = ctx.querySelectorAll("iframe"), open = ifr.length, handled = 0;
            ifr = Array.prototype.slice.call(ifr);
            var checkEnd = function checkEnd2() {
              if (--open <= 0) {
                end2(handled);
              }
            };
            if (!open) {
              checkEnd();
            }
            ifr.forEach(function(ifr2) {
              if (DOMIterator2.matches(ifr2, _this3.exclude)) {
                checkEnd();
              } else {
                _this3.onIframeReady(ifr2, function(con) {
                  if (filter2(ifr2)) {
                    handled++;
                    each(con);
                  }
                  checkEnd();
                }, checkEnd);
              }
            });
          }
        }, {
          key: "createIterator",
          value: function createIterator(ctx, whatToShow, filter2) {
            return document.createNodeIterator(ctx, whatToShow, filter2, false);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function createInstanceOnIframe(contents) {
            return new DOMIterator2(contents.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function compareNodeIframe(node2, prevNode, ifr) {
            var compCurr = node2.compareDocumentPosition(ifr), prev2 = Node.DOCUMENT_POSITION_PRECEDING;
            if (compCurr & prev2) {
              if (prevNode !== null) {
                var compPrev = prevNode.compareDocumentPosition(ifr), after = Node.DOCUMENT_POSITION_FOLLOWING;
                if (compPrev & after) {
                  return true;
                }
              } else {
                return true;
              }
            }
            return false;
          }
        }, {
          key: "getIteratorNode",
          value: function getIteratorNode(itr) {
            var prevNode = itr.previousNode();
            var node2 = void 0;
            if (prevNode === null) {
              node2 = itr.nextNode();
            } else {
              node2 = itr.nextNode() && itr.nextNode();
            }
            return {
              prevNode,
              node: node2
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function checkIframeFilter(node2, prevNode, currIfr, ifr) {
            var key2 = false, handled = false;
            ifr.forEach(function(ifrDict, i) {
              if (ifrDict.val === currIfr) {
                key2 = i;
                handled = ifrDict.handled;
              }
            });
            if (this.compareNodeIframe(node2, prevNode, currIfr)) {
              if (key2 === false && !handled) {
                ifr.push({
                  val: currIfr,
                  handled: true
                });
              } else if (key2 !== false && !handled) {
                ifr[key2].handled = true;
              }
              return true;
            }
            if (key2 === false) {
              ifr.push({
                val: currIfr,
                handled: false
              });
            }
            return false;
          }
        }, {
          key: "handleOpenIframes",
          value: function handleOpenIframes(ifr, whatToShow, eCb, fCb) {
            var _this4 = this;
            ifr.forEach(function(ifrDict) {
              if (!ifrDict.handled) {
                _this4.getIframeContents(ifrDict.val, function(con) {
                  _this4.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);
                });
              }
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {
            var _this5 = this;
            var itr = this.createIterator(ctx, whatToShow, filterCb);
            var ifr = [], elements = [], node2 = void 0, prevNode = void 0, retrieveNodes = function retrieveNodes2() {
              var _getIteratorNode = _this5.getIteratorNode(itr);
              prevNode = _getIteratorNode.prevNode;
              node2 = _getIteratorNode.node;
              return node2;
            };
            while (retrieveNodes()) {
              if (this.iframes) {
                this.forEachIframe(ctx, function(currIfr) {
                  return _this5.checkIframeFilter(node2, prevNode, currIfr, ifr);
                }, function(con) {
                  _this5.createInstanceOnIframe(con).forEachNode(whatToShow, function(ifrNode) {
                    return elements.push(ifrNode);
                  }, filterCb);
                });
              }
              elements.push(node2);
            }
            elements.forEach(function(node3) {
              eachCb(node3);
            });
            if (this.iframes) {
              this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);
            }
            doneCb();
          }
        }, {
          key: "forEachNode",
          value: function forEachNode(whatToShow, each, filter2) {
            var _this6 = this;
            var done = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var contexts = this.getContexts();
            var open = contexts.length;
            if (!open) {
              done();
            }
            contexts.forEach(function(ctx) {
              var ready = function ready2() {
                _this6.iterateThroughNodes(whatToShow, ctx, each, filter2, function() {
                  if (--open <= 0) {
                    done();
                  }
                });
              };
              if (_this6.iframes) {
                _this6.waitForIframes(ctx, ready);
              } else {
                ready();
              }
            });
          }
        }], [{
          key: "matches",
          value: function matches2(element, selector) {
            var selectors = typeof selector === "string" ? [selector] : selector, fn2 = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;
            if (fn2) {
              var match2 = false;
              selectors.every(function(sel) {
                if (fn2.call(element, sel)) {
                  match2 = true;
                  return false;
                }
                return true;
              });
              return match2;
            } else {
              return false;
            }
          }
        }]);
        return DOMIterator2;
      }();
      var Mark$1 = function() {
        function Mark2(ctx) {
          classCallCheck(this, Mark2);
          this.ctx = ctx;
          this.ie = false;
          var ua2 = window.navigator.userAgent;
          if (ua2.indexOf("MSIE") > -1 || ua2.indexOf("Trident") > -1) {
            this.ie = true;
          }
        }
        createClass(Mark2, [{
          key: "log",
          value: function log(msg) {
            var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug";
            var log2 = this.opt.log;
            if (!this.opt.debug) {
              return;
            }
            if ((typeof log2 === "undefined" ? "undefined" : _typeof2(log2)) === "object" && typeof log2[level] === "function") {
              log2[level]("mark.js: " + msg);
            }
          }
        }, {
          key: "escapeStr",
          value: function escapeStr(str2) {
            return str2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function createRegExp(str2) {
            if (this.opt.wildcards !== "disabled") {
              str2 = this.setupWildcardsRegExp(str2);
            }
            str2 = this.escapeStr(str2);
            if (Object.keys(this.opt.synonyms).length) {
              str2 = this.createSynonymsRegExp(str2);
            }
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str2 = this.setupIgnoreJoinersRegExp(str2);
            }
            if (this.opt.diacritics) {
              str2 = this.createDiacriticsRegExp(str2);
            }
            str2 = this.createMergedBlanksRegExp(str2);
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str2 = this.createJoinersRegExp(str2);
            }
            if (this.opt.wildcards !== "disabled") {
              str2 = this.createWildcardsRegExp(str2);
            }
            str2 = this.createAccuracyRegExp(str2);
            return str2;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function createSynonymsRegExp(str2) {
            var syn = this.opt.synonyms, sens = this.opt.caseSensitive ? "" : "i", joinerPlaceholder = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var index2 in syn) {
              if (syn.hasOwnProperty(index2)) {
                var value = syn[index2], k1 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(index2) : this.escapeStr(index2), k2 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(value) : this.escapeStr(value);
                if (k1 !== "" && k2 !== "") {
                  str2 = str2.replace(new RegExp("(" + this.escapeStr(k1) + "|" + this.escapeStr(k2) + ")", "gm" + sens), joinerPlaceholder + ("(" + this.processSynomyms(k1) + "|") + (this.processSynomyms(k2) + ")") + joinerPlaceholder);
                }
              }
            }
            return str2;
          }
        }, {
          key: "processSynomyms",
          value: function processSynomyms(str2) {
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str2 = this.setupIgnoreJoinersRegExp(str2);
            }
            return str2;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function setupWildcardsRegExp(str2) {
            str2 = str2.replace(/(?:\\)*\?/g, function(val) {
              return val.charAt(0) === "\\" ? "?" : "";
            });
            return str2.replace(/(?:\\)*\*/g, function(val) {
              return val.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function createWildcardsRegExp(str2) {
            var spaces = this.opt.wildcards === "withSpaces";
            return str2.replace(/\u0001/g, spaces ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, spaces ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function setupIgnoreJoinersRegExp(str2) {
            return str2.replace(/[^(|)\\]/g, function(val, indx, original) {
              var nextChar = original.charAt(indx + 1);
              if (/[(|)\\]/.test(nextChar) || nextChar === "") {
                return val;
              } else {
                return val + "\0";
              }
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function createJoinersRegExp(str2) {
            var joiner = [];
            var ignorePunctuation = this.opt.ignorePunctuation;
            if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {
              joiner.push(this.escapeStr(ignorePunctuation.join("")));
            }
            if (this.opt.ignoreJoiners) {
              joiner.push("\\u00ad\\u200b\\u200c\\u200d");
            }
            return joiner.length ? str2.split(/\u0000+/).join("[" + joiner.join("") + "]*") : str2;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function createDiacriticsRegExp(str2) {
            var sens = this.opt.caseSensitive ? "" : "i", dct = this.opt.caseSensitive ? ["a", "A", "c", "C", "d", "D", "e", "E", "i", "I", "l", "L", "n", "N", "o", "O", "r", "R", "s", "S", "t", "T", "u", "U", "y", "Y", "z", "Z"] : ["aA", "cC", "dD", "eE", "iI", "lL", "nN", "oO", "rR", "sS", "tT", "uU", "yY", "zZ"];
            var handled = [];
            str2.split("").forEach(function(ch2) {
              dct.every(function(dct2) {
                if (dct2.indexOf(ch2) !== -1) {
                  if (handled.indexOf(dct2) > -1) {
                    return false;
                  }
                  str2 = str2.replace(new RegExp("[" + dct2 + "]", "gm" + sens), "[" + dct2 + "]");
                  handled.push(dct2);
                }
                return true;
              });
            });
            return str2;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function createMergedBlanksRegExp(str2) {
            return str2.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function createAccuracyRegExp(str2) {
            var _this = this;
            var chars = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
            var acc = this.opt.accuracy, val = typeof acc === "string" ? acc : acc.value, ls = typeof acc === "string" ? [] : acc.limiters, lsJoin = "";
            ls.forEach(function(limiter) {
              lsJoin += "|" + _this.escapeStr(limiter);
            });
            switch (val) {
              case "partially":
              default:
                return "()(" + str2 + ")";
              case "complementary":
                lsJoin = "\\s" + (lsJoin ? lsJoin : this.escapeStr(chars));
                return "()([^" + lsJoin + "]*" + str2 + "[^" + lsJoin + "]*)";
              case "exactly":
                return "(^|\\s" + lsJoin + ")(" + str2 + ")(?=$|\\s" + lsJoin + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function getSeparatedKeywords(sv) {
            var _this2 = this;
            var stack = [];
            sv.forEach(function(kw) {
              if (!_this2.opt.separateWordSearch) {
                if (kw.trim() && stack.indexOf(kw) === -1) {
                  stack.push(kw);
                }
              } else {
                kw.split(" ").forEach(function(kwSplitted) {
                  if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {
                    stack.push(kwSplitted);
                  }
                });
              }
            });
            return {
              "keywords": stack.sort(function(a, b2) {
                return b2.length - a.length;
              }),
              "length": stack.length
            };
          }
        }, {
          key: "isNumeric",
          value: function isNumeric2(value) {
            return Number(parseFloat(value)) == value;
          }
        }, {
          key: "checkRanges",
          value: function checkRanges(array2) {
            var _this3 = this;
            if (!Array.isArray(array2) || Object.prototype.toString.call(array2[0]) !== "[object Object]") {
              this.log("markRanges() will only accept an array of objects");
              this.opt.noMatch(array2);
              return [];
            }
            var stack = [];
            var last2 = 0;
            array2.sort(function(a, b2) {
              return a.start - b2.start;
            }).forEach(function(item) {
              var _callNoMatchOnInvalid = _this3.callNoMatchOnInvalidRanges(item, last2), start2 = _callNoMatchOnInvalid.start, end2 = _callNoMatchOnInvalid.end, valid = _callNoMatchOnInvalid.valid;
              if (valid) {
                item.start = start2;
                item.length = end2 - start2;
                stack.push(item);
                last2 = end2;
              }
            });
            return stack;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function callNoMatchOnInvalidRanges(range, last2) {
            var start2 = void 0, end2 = void 0, valid = false;
            if (range && typeof range.start !== "undefined") {
              start2 = parseInt(range.start, 10);
              end2 = start2 + parseInt(range.length, 10);
              if (this.isNumeric(range.start) && this.isNumeric(range.length) && end2 - last2 > 0 && end2 - start2 > 0) {
                valid = true;
              } else {
                this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(range)));
                this.opt.noMatch(range);
              }
            } else {
              this.log("Ignoring invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start: start2,
              end: end2,
              valid
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function checkWhitespaceRanges(range, originalLength, string2) {
            var end2 = void 0, valid = true, max2 = string2.length, offset2 = originalLength - max2, start2 = parseInt(range.start, 10) - offset2;
            start2 = start2 > max2 ? max2 : start2;
            end2 = start2 + parseInt(range.length, 10);
            if (end2 > max2) {
              end2 = max2;
              this.log("End range automatically set to the max value of " + max2);
            }
            if (start2 < 0 || end2 - start2 < 0 || start2 > max2 || end2 > max2) {
              valid = false;
              this.log("Invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            } else if (string2.substring(start2, end2).replace(/\s+/g, "") === "") {
              valid = false;
              this.log("Skipping whitespace only range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start: start2,
              end: end2,
              valid
            };
          }
        }, {
          key: "getTextNodes",
          value: function getTextNodes(cb2) {
            var _this4 = this;
            var val = "", nodes = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(node2) {
              nodes.push({
                start: val.length,
                end: (val += node2.textContent).length,
                node: node2
              });
            }, function(node2) {
              if (_this4.matchesExclude(node2.parentNode)) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, function() {
              cb2({
                value: val,
                nodes
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function matchesExclude(el2) {
            return DOMIterator.matches(el2, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function wrapRangeInTextNode(node2, start2, end2) {
            var hEl = !this.opt.element ? "mark" : this.opt.element, startNode = node2.splitText(start2), ret = startNode.splitText(end2 - start2);
            var repl = document.createElement(hEl);
            repl.setAttribute("data-markjs", "true");
            if (this.opt.className) {
              repl.setAttribute("class", this.opt.className);
            }
            repl.textContent = startNode.textContent;
            startNode.parentNode.replaceChild(repl, startNode);
            return ret;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function wrapRangeInMappedTextNode(dict, start2, end2, filterCb, eachCb) {
            var _this5 = this;
            dict.nodes.every(function(n2, i) {
              var sibl = dict.nodes[i + 1];
              if (typeof sibl === "undefined" || sibl.start > start2) {
                if (!filterCb(n2.node)) {
                  return false;
                }
                var s = start2 - n2.start, e2 = (end2 > n2.end ? n2.end : end2) - n2.start, startStr = dict.value.substr(0, n2.start), endStr = dict.value.substr(e2 + n2.start);
                n2.node = _this5.wrapRangeInTextNode(n2.node, s, e2);
                dict.value = startStr + endStr;
                dict.nodes.forEach(function(k2, j) {
                  if (j >= i) {
                    if (dict.nodes[j].start > 0 && j !== i) {
                      dict.nodes[j].start -= e2;
                    }
                    dict.nodes[j].end -= e2;
                  }
                });
                end2 -= e2;
                eachCb(n2.node.previousSibling, n2.start);
                if (end2 > n2.end) {
                  start2 = n2.end;
                } else {
                  return false;
                }
              }
              return true;
            });
          }
        }, {
          key: "wrapMatches",
          value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this6 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              dict.nodes.forEach(function(node2) {
                node2 = node2.node;
                var match2 = void 0;
                while ((match2 = regex.exec(node2.textContent)) !== null && match2[matchIdx] !== "") {
                  if (!filterCb(match2[matchIdx], node2)) {
                    continue;
                  }
                  var pos = match2.index;
                  if (matchIdx !== 0) {
                    for (var i = 1; i < matchIdx; i++) {
                      pos += match2[i].length;
                    }
                  }
                  node2 = _this6.wrapRangeInTextNode(node2, pos, pos + match2[matchIdx].length);
                  eachCb(node2.previousSibling);
                  regex.lastIndex = 0;
                }
              });
              endCb();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this7 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              var match2 = void 0;
              while ((match2 = regex.exec(dict.value)) !== null && match2[matchIdx] !== "") {
                var start2 = match2.index;
                if (matchIdx !== 0) {
                  for (var i = 1; i < matchIdx; i++) {
                    start2 += match2[i].length;
                  }
                }
                var end2 = start2 + match2[matchIdx].length;
                _this7.wrapRangeInMappedTextNode(dict, start2, end2, function(node2) {
                  return filterCb(match2[matchIdx], node2);
                }, function(node2, lastIndex) {
                  regex.lastIndex = lastIndex;
                  eachCb(node2);
                });
              }
              endCb();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {
            var _this8 = this;
            this.getTextNodes(function(dict) {
              var originalLength = dict.value.length;
              ranges.forEach(function(range, counter2) {
                var _checkWhitespaceRange = _this8.checkWhitespaceRanges(range, originalLength, dict.value), start2 = _checkWhitespaceRange.start, end2 = _checkWhitespaceRange.end, valid = _checkWhitespaceRange.valid;
                if (valid) {
                  _this8.wrapRangeInMappedTextNode(dict, start2, end2, function(node2) {
                    return filterCb(node2, range, dict.value.substring(start2, end2), counter2);
                  }, function(node2) {
                    eachCb(node2, range);
                  });
                }
              });
              endCb();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function unwrapMatches(node2) {
            var parent = node2.parentNode;
            var docFrag = document.createDocumentFragment();
            while (node2.firstChild) {
              docFrag.appendChild(node2.removeChild(node2.firstChild));
            }
            parent.replaceChild(docFrag, node2);
            if (!this.ie) {
              parent.normalize();
            } else {
              this.normalizeTextNode(parent);
            }
          }
        }, {
          key: "normalizeTextNode",
          value: function normalizeTextNode(node2) {
            if (!node2) {
              return;
            }
            if (node2.nodeType === 3) {
              while (node2.nextSibling && node2.nextSibling.nodeType === 3) {
                node2.nodeValue += node2.nextSibling.nodeValue;
                node2.parentNode.removeChild(node2.nextSibling);
              }
            } else {
              this.normalizeTextNode(node2.firstChild);
            }
            this.normalizeTextNode(node2.nextSibling);
          }
        }, {
          key: "markRegExp",
          value: function markRegExp(regexp, opt) {
            var _this9 = this;
            this.opt = opt;
            this.log('Searching with expression "' + regexp + '"');
            var totalMatches = 0, fn2 = "wrapMatches";
            var eachCb = function eachCb2(element) {
              totalMatches++;
              _this9.opt.each(element);
            };
            if (this.opt.acrossElements) {
              fn2 = "wrapMatchesAcrossElements";
            }
            this[fn2](regexp, this.opt.ignoreGroups, function(match2, node2) {
              return _this9.opt.filter(node2, match2, totalMatches);
            }, eachCb, function() {
              if (totalMatches === 0) {
                _this9.opt.noMatch(regexp);
              }
              _this9.opt.done(totalMatches);
            });
          }
        }, {
          key: "mark",
          value: function mark2(sv, opt) {
            var _this10 = this;
            this.opt = opt;
            var totalMatches = 0, fn2 = "wrapMatches";
            var _getSeparatedKeywords = this.getSeparatedKeywords(typeof sv === "string" ? [sv] : sv), kwArr = _getSeparatedKeywords.keywords, kwArrLen = _getSeparatedKeywords.length, sens = this.opt.caseSensitive ? "" : "i", handler = function handler2(kw) {
              var regex = new RegExp(_this10.createRegExp(kw), "gm" + sens), matches2 = 0;
              _this10.log('Searching with expression "' + regex + '"');
              _this10[fn2](regex, 1, function(term, node2) {
                return _this10.opt.filter(node2, kw, totalMatches, matches2);
              }, function(element) {
                matches2++;
                totalMatches++;
                _this10.opt.each(element);
              }, function() {
                if (matches2 === 0) {
                  _this10.opt.noMatch(kw);
                }
                if (kwArr[kwArrLen - 1] === kw) {
                  _this10.opt.done(totalMatches);
                } else {
                  handler2(kwArr[kwArr.indexOf(kw) + 1]);
                }
              });
            };
            if (this.opt.acrossElements) {
              fn2 = "wrapMatchesAcrossElements";
            }
            if (kwArrLen === 0) {
              this.opt.done(totalMatches);
            } else {
              handler(kwArr[0]);
            }
          }
        }, {
          key: "markRanges",
          value: function markRanges(rawRanges, opt) {
            var _this11 = this;
            this.opt = opt;
            var totalMatches = 0, ranges = this.checkRanges(rawRanges);
            if (ranges && ranges.length) {
              this.log("Starting to mark with the following ranges: " + JSON.stringify(ranges));
              this.wrapRangeFromIndex(ranges, function(node2, range, match2, counter2) {
                return _this11.opt.filter(node2, range, match2, counter2);
              }, function(element, range) {
                totalMatches++;
                _this11.opt.each(element, range);
              }, function() {
                _this11.opt.done(totalMatches);
              });
            } else {
              this.opt.done(totalMatches);
            }
          }
        }, {
          key: "unmark",
          value: function unmark(opt) {
            var _this12 = this;
            this.opt = opt;
            var sel = this.opt.element ? this.opt.element : "*";
            sel += "[data-markjs]";
            if (this.opt.className) {
              sel += "." + this.opt.className;
            }
            this.log('Removal selector "' + sel + '"');
            this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(node2) {
              _this12.unwrapMatches(node2);
            }, function(node2) {
              var matchesSel = DOMIterator.matches(node2, sel), matchesExclude = _this12.matchesExclude(node2);
              if (!matchesSel || matchesExclude) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function set$$1(val) {
            this._opt = _extends2({}, {
              "element": "",
              "className": "",
              "exclude": [],
              "iframes": false,
              "iframesTimeout": 5e3,
              "separateWordSearch": true,
              "diacritics": true,
              "synonyms": {},
              "accuracy": "partially",
              "acrossElements": false,
              "caseSensitive": false,
              "ignoreJoiners": false,
              "ignoreGroups": 0,
              "ignorePunctuation": [],
              "wildcards": "disabled",
              "each": function each() {
              },
              "noMatch": function noMatch() {
              },
              "filter": function filter2() {
                return true;
              },
              "done": function done() {
              },
              "debug": false,
              "log": window.console
            }, val);
          },
          get: function get$$1() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function get$$1() {
            return new DOMIterator(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]);
        return Mark2;
      }();
      function Mark(ctx) {
        var _this = this;
        var instance = new Mark$1(ctx);
        this.mark = function(sv, opt) {
          instance.mark(sv, opt);
          return _this;
        };
        this.markRegExp = function(sv, opt) {
          instance.markRegExp(sv, opt);
          return _this;
        };
        this.markRanges = function(sv, opt) {
          instance.markRanges(sv, opt);
          return _this;
        };
        this.unmark = function(opt) {
          instance.unmark(opt);
          return _this;
        };
        return this;
      }
      return Mark;
    });
  })(mark);
  return mark.exports;
}
function pad(number2) {
  if (number2 < 10) {
    return "0" + number2;
  }
  return number2;
}
function toRFCDateTime(date, omitTime, omitDate, milliseconds) {
  var res = omitDate ? "" : date.getUTCFullYear() + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate());
  if (!omitTime) {
    res += "T" + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (milliseconds ? "." + (date.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) : "") + "Z";
  }
  return res;
}
function ensureMinLength(sample2, min2) {
  if (min2 > sample2.length) {
    return sample2.repeat(Math.trunc(min2 / sample2.length) + 1).substring(0, min2);
  }
  return sample2;
}
function mergeDeep(...objects) {
  const isObject2 = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev2, obj) => {
    Object.keys(obj || {}).forEach((key2) => {
      const pVal = prev2[key2];
      const oVal = obj[key2];
      if (isObject2(pVal) && isObject2(oVal)) {
        prev2[key2] = mergeDeep(pVal, oVal);
      } else {
        prev2[key2] = oVal;
      }
    });
    return prev2;
  }, Array.isArray(objects[objects.length - 1]) ? [] : {});
}
function uuid$1(str2) {
  var hash2 = hashCode(str2);
  var random = jsf32(hash2, hash2, hash2, hash2);
  var uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    var r2 = random() * 16 % 16 | 0;
    return (c2 == "x" ? r2 : r2 & 3 | 8).toString(16);
  });
  return uuid2;
}
function getResultForCircular(type2) {
  return {
    value: type2 === "object" ? {} : type2 === "array" ? [] : void 0
  };
}
function popSchemaStack(seenSchemasStack2, context) {
  if (context)
    seenSchemasStack2.pop();
}
function hashCode(str2) {
  var hash2 = 0;
  if (str2.length == 0)
    return hash2;
  for (var i = 0; i < str2.length; i++) {
    var char2 = str2.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char2;
    hash2 = hash2 & hash2;
  }
  return hash2;
}
function jsf32(a, b2, c2, d2) {
  return function() {
    a |= 0;
    b2 |= 0;
    c2 |= 0;
    d2 |= 0;
    var t2 = a - (b2 << 27 | b2 >>> 5) | 0;
    a = b2 ^ (c2 << 17 | c2 >>> 15);
    b2 = c2 + d2 | 0;
    c2 = d2 + t2 | 0;
    d2 = a + t2 | 0;
    return (d2 >>> 0) / 4294967296;
  };
}
function allOfSample(into, children, options2, spec, context) {
  let res = traverse(into, options2, spec);
  const subSamples = [];
  for (let subSchema of children) {
    const { type: type2, readOnly, writeOnly, value } = traverse({ type: res.type, ...subSchema }, options2, spec, context);
    if (res.type && type2 && type2 !== res.type) {
      console.warn("allOf: schemas with different types can't be merged");
      res.type = type2;
    }
    res.type = res.type || type2;
    res.readOnly = res.readOnly || readOnly;
    res.writeOnly = res.writeOnly || writeOnly;
    if (value != null)
      subSamples.push(value);
  }
  if (res.type === "object") {
    res.value = mergeDeep(res.value || {}, ...subSamples.filter((sample2) => typeof sample2 === "object"));
    return res;
  } else {
    if (res.type === "array") {
      if (!options2.quiet)
        console.warn('OpenAPI Sampler: found allOf with "array" type. Result may be incorrect');
    }
    const lastSample = subSamples[subSamples.length - 1];
    res.value = lastSample != null ? lastSample : res.value;
    return res;
  }
}
const schemaKeywordTypes = {
  multipleOf: "number",
  maximum: "number",
  exclusiveMaximum: "number",
  minimum: "number",
  exclusiveMinimum: "number",
  maxLength: "string",
  minLength: "string",
  pattern: "string",
  items: "array",
  maxItems: "array",
  minItems: "array",
  uniqueItems: "array",
  additionalItems: "array",
  maxProperties: "object",
  minProperties: "object",
  required: "object",
  additionalProperties: "object",
  properties: "object",
  patternProperties: "object",
  dependencies: "object"
};
function inferType(schema2) {
  if (schema2.type !== void 0) {
    return Array.isArray(schema2.type) ? schema2.type.length === 0 ? null : schema2.type[0] : schema2.type;
  }
  const keywords2 = Object.keys(schemaKeywordTypes);
  for (var i = 0; i < keywords2.length; i++) {
    let keyword = keywords2[i];
    let type2 = schemaKeywordTypes[keyword];
    if (schema2[keyword] !== void 0) {
      return type2;
    }
  }
  return null;
}
var jsonPointerExports = requireJsonPointer();
const JsonPointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonPointerExports);
let $refCache = {};
let seenSchemasStack = [];
function clearCache() {
  $refCache = {};
  seenSchemasStack = [];
}
function inferExample(schema2) {
  let example;
  if (schema2.const !== void 0) {
    example = schema2.const;
  } else if (schema2.examples !== void 0 && schema2.examples.length) {
    example = schema2.examples[0];
  } else if (schema2.enum !== void 0 && schema2.enum.length) {
    example = schema2.enum[0];
  } else if (schema2.default !== void 0) {
    example = schema2.default;
  }
  return example;
}
function tryInferExample(schema2) {
  const example = inferExample(schema2);
  if (example !== void 0) {
    return {
      value: example,
      readOnly: schema2.readOnly,
      writeOnly: schema2.writeOnly,
      type: null
    };
  }
  return;
}
function traverse(schema2, options2, spec, context) {
  if (context) {
    if (seenSchemasStack.includes(schema2))
      return getResultForCircular(inferType(schema2));
    seenSchemasStack.push(schema2);
  }
  if (context && context.depth > options2.maxSampleDepth) {
    popSchemaStack(seenSchemasStack, context);
    return getResultForCircular(inferType(schema2));
  }
  if (schema2.$ref) {
    if (!spec) {
      throw new Error("Your schema contains $ref. You must provide full specification in the third parameter.");
    }
    let ref = decodeURIComponent(schema2.$ref);
    if (ref.startsWith("#")) {
      ref = ref.substring(1);
    }
    const referenced = JsonPointer.get(spec, ref);
    let result;
    if ($refCache[ref] !== true) {
      $refCache[ref] = true;
      result = traverse(referenced, options2, spec, context);
      $refCache[ref] = false;
    } else {
      const referencedType = inferType(referenced);
      result = getResultForCircular(referencedType);
    }
    popSchemaStack(seenSchemasStack, context);
    return result;
  }
  if (schema2.example !== void 0) {
    popSchemaStack(seenSchemasStack, context);
    return {
      value: schema2.example,
      readOnly: schema2.readOnly,
      writeOnly: schema2.writeOnly,
      type: schema2.type
    };
  }
  if (schema2.allOf !== void 0) {
    popSchemaStack(seenSchemasStack, context);
    return tryInferExample(schema2) || allOfSample(
      { ...schema2, allOf: void 0 },
      schema2.allOf,
      options2,
      spec,
      context
    );
  }
  if (schema2.oneOf && schema2.oneOf.length) {
    if (schema2.anyOf) {
      if (!options2.quiet)
        console.warn("oneOf and anyOf are not supported on the same level. Skipping anyOf");
    }
    popSchemaStack(seenSchemasStack, context);
    const firstOneOf = Object.assign({
      readOnly: schema2.readOnly,
      writeOnly: schema2.writeOnly
    }, schema2.oneOf[0]);
    return traverseOneOrAnyOf(schema2, firstOneOf);
  }
  if (schema2.anyOf && schema2.anyOf.length) {
    popSchemaStack(seenSchemasStack, context);
    const firstAnyOf = Object.assign({
      readOnly: schema2.readOnly,
      writeOnly: schema2.writeOnly
    }, schema2.anyOf[0]);
    return traverseOneOrAnyOf(schema2, firstAnyOf);
  }
  if (schema2.if && schema2.then) {
    popSchemaStack(seenSchemasStack, context);
    const { if: ifSchema, then, ...rest } = schema2;
    return traverse(mergeDeep(rest, ifSchema, then), options2, spec, context);
  }
  let example = inferExample(schema2);
  let type2 = null;
  if (example === void 0) {
    example = null;
    type2 = schema2.type;
    if (Array.isArray(type2) && schema2.type.length > 0) {
      type2 = schema2.type[0];
    }
    if (!type2) {
      type2 = inferType(schema2);
    }
    let sampler = _samplers[type2];
    if (sampler) {
      example = sampler(schema2, options2, spec, context);
    }
  }
  popSchemaStack(seenSchemasStack, context);
  return {
    value: example,
    readOnly: schema2.readOnly,
    writeOnly: schema2.writeOnly,
    type: type2
  };
  function traverseOneOrAnyOf(schema3, selectedSubSchema) {
    const inferred = tryInferExample(schema3);
    if (inferred !== void 0) {
      return inferred;
    }
    const localExample = traverse({ ...schema3, oneOf: void 0, anyOf: void 0 }, options2, spec, context);
    const subSchemaExample = traverse(selectedSubSchema, options2, spec, context);
    if (typeof localExample.value === "object" && typeof subSchemaExample.value === "object") {
      const mergedExample = mergeDeep(localExample.value, subSchemaExample.value);
      return { ...subSchemaExample, value: mergedExample };
    }
    return subSchemaExample;
  }
}
function sampleArray(schema2, options2 = {}, spec, context) {
  const depth = context && context.depth || 1;
  let arrayLength = Math.min(schema2.maxItems != void 0 ? schema2.maxItems : Infinity, schema2.minItems || 1);
  const items = schema2.prefixItems || schema2.items || schema2.contains;
  if (Array.isArray(items)) {
    arrayLength = Math.max(arrayLength, items.length);
  }
  let itemSchemaGetter = (itemNumber) => {
    if (Array.isArray(items)) {
      return items[itemNumber] || {};
    }
    return items || {};
  };
  let res = [];
  if (!items)
    return res;
  for (let i = 0; i < arrayLength; i++) {
    let itemSchema = itemSchemaGetter(i);
    let { value: sample2 } = traverse(itemSchema, options2, spec, { depth: depth + 1 });
    res.push(sample2);
  }
  return res;
}
function sampleBoolean(schema2) {
  return true;
}
function sampleNumber(schema2) {
  let res = 0;
  if (typeof schema2.exclusiveMinimum === "boolean" || typeof schema2.exclusiveMaximum === "boolean") {
    if (schema2.maximum && schema2.minimum) {
      res = schema2.exclusiveMinimum ? Math.floor(schema2.minimum) + 1 : schema2.minimum;
      if (schema2.exclusiveMaximum && res >= schema2.maximum || !schema2.exclusiveMaximum && res > schema2.maximum) {
        res = (schema2.maximum + schema2.minimum) / 2;
      }
      return res;
    }
    if (schema2.minimum) {
      if (schema2.exclusiveMinimum) {
        return Math.floor(schema2.minimum) + 1;
      } else {
        return schema2.minimum;
      }
    }
    if (schema2.maximum) {
      if (schema2.exclusiveMaximum) {
        return schema2.maximum > 0 ? 0 : Math.floor(schema2.maximum) - 1;
      } else {
        return schema2.maximum > 0 ? 0 : schema2.maximum;
      }
    }
  } else {
    if (schema2.minimum) {
      return schema2.minimum;
    }
    if (schema2.exclusiveMinimum) {
      res = Math.floor(schema2.exclusiveMinimum) + 1;
      if (res === schema2.exclusiveMaximum) {
        res = (res + Math.floor(schema2.exclusiveMaximum) - 1) / 2;
      }
    } else if (schema2.exclusiveMaximum) {
      res = Math.floor(schema2.exclusiveMaximum) - 1;
    } else if (schema2.maximum) {
      res = schema2.maximum;
    }
  }
  return res;
}
function sampleObject(schema2, options2 = {}, spec, context) {
  let res = {};
  const depth = context && context.depth || 1;
  if (schema2 && typeof schema2.properties === "object") {
    let requiredKeys = Array.isArray(schema2.required) ? schema2.required : [];
    let requiredKeyDict = requiredKeys.reduce((dict, key2) => {
      dict[key2] = true;
      return dict;
    }, {});
    Object.keys(schema2.properties).forEach((propertyName) => {
      if (options2.skipNonRequired && !requiredKeyDict.hasOwnProperty(propertyName)) {
        return;
      }
      const sample2 = traverse(schema2.properties[propertyName], options2, spec, { propertyName, depth: depth + 1 });
      if (options2.skipReadOnly && sample2.readOnly) {
        return;
      }
      if (options2.skipWriteOnly && sample2.writeOnly) {
        return;
      }
      res[propertyName] = sample2.value;
    });
  }
  if (schema2 && typeof schema2.additionalProperties === "object") {
    const propertyName = schema2.additionalProperties["x-additionalPropertiesName"] || "property";
    res[`${String(propertyName)}1`] = traverse(schema2.additionalProperties, options2, spec, { depth: depth + 1 }).value;
    res[`${String(propertyName)}2`] = traverse(schema2.additionalProperties, options2, spec, { depth: depth + 1 }).value;
  }
  return res;
}
const passwordSymbols = "qwerty!@#$%^123456";
function emailSample() {
  return "user@example.com";
}
function idnEmailSample() {
  return "@.";
}
function passwordSample(min2, max2) {
  let res = "pa$$word";
  if (min2 > res.length) {
    res += "_";
    res += ensureMinLength(passwordSymbols, min2 - res.length).substring(0, min2 - res.length);
  }
  return res;
}
function commonDateTimeSample({ min: min2, max: max2, omitTime, omitDate }) {
  let res = toRFCDateTime(/* @__PURE__ */ new Date("2019-08-24T14:15:22.123Z"), omitTime, omitDate, false);
  if (res.length < min2) {
    console.warn(`Using minLength = ${min2} is incorrect with format "date-time"`);
  }
  if (max2 && res.length > max2) {
    console.warn(`Using maxLength = ${max2} is incorrect with format "date-time"`);
  }
  return res;
}
function dateTimeSample(min2, max2) {
  return commonDateTimeSample({ min: min2, max: max2, omitTime: false, omitDate: false });
}
function dateSample(min2, max2) {
  return commonDateTimeSample({ min: min2, max: max2, omitTime: true, omitDate: false });
}
function timeSample(min2, max2) {
  return commonDateTimeSample({ min: min2, max: max2, omitTime: false, omitDate: true }).slice(1);
}
function defaultSample(min2, max2) {
  let res = ensureMinLength("string", min2);
  if (max2 && res.length > max2) {
    res = res.substring(0, max2);
  }
  return res;
}
function ipv4Sample() {
  return "192.168.0.1";
}
function ipv6Sample() {
  return "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
}
function hostnameSample() {
  return "example.com";
}
function idnHostnameSample() {
  return ".";
}
function uriSample() {
  return "http://example.com";
}
function uriReferenceSample() {
  return "../dictionary";
}
function uriTemplateSample() {
  return "http://example.com/{endpoint}";
}
function iriSample() {
  return "http://example.com/entity/1";
}
function iriReferenceSample() {
  return "/entity/1";
}
function uuidSample(_min, _max, propertyName) {
  return uuid$1(propertyName || "id");
}
function jsonPointerSample() {
  return "/json/pointer";
}
function relativeJsonPointerSample() {
  return "1/relative/json/pointer";
}
function regexSample() {
  return "/regex/";
}
const stringFormats = {
  "email": emailSample,
  "idn-email": idnEmailSample,
  // https://tools.ietf.org/html/rfc6531#section-3.3
  "password": passwordSample,
  "date-time": dateTimeSample,
  "date": dateSample,
  "time": timeSample,
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  "ipv4": ipv4Sample,
  "ipv6": ipv6Sample,
  "hostname": hostnameSample,
  "idn-hostname": idnHostnameSample,
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  "iri": iriSample,
  // https://tools.ietf.org/html/rfc3987
  "iri-reference": iriReferenceSample,
  "uri": uriSample,
  "uri-reference": uriReferenceSample,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-template": uriTemplateSample,
  "uuid": uuidSample,
  "default": defaultSample,
  "json-pointer": jsonPointerSample,
  "relative-json-pointer": relativeJsonPointerSample,
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  "regex": regexSample
};
function sampleString(schema2, options2, spec, context) {
  let format2 = schema2.format || "default";
  let sampler = stringFormats[format2] || defaultSample;
  let propertyName = context && context.propertyName;
  return sampler(schema2.minLength | 0, schema2.maxLength, propertyName);
}
var _samplers = {};
const defaults = {
  skipReadOnly: false,
  maxSampleDepth: 15
};
function sample(schema2, options2, spec) {
  let opts = Object.assign({}, defaults, options2);
  clearCache();
  return traverse(schema2, opts, spec).value;
}
function _registerSampler(type2, sampler) {
  _samplers[type2] = sampler;
}
_registerSampler("array", sampleArray);
_registerSampler("boolean", sampleBoolean);
_registerSampler("integer", sampleNumber);
_registerSampler("number", sampleNumber);
_registerSampler("object", sampleObject);
_registerSampler("string", sampleString);
const openapiSampler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _registerSampler,
  _samplers,
  inferType,
  sample
}, Symbol.toStringTag, { value: "Module" }));
const require$$42 = /* @__PURE__ */ getAugmentedNamespace(openapiSampler);
function makeTypeChecker(tabsRole) {
  return function(element) {
    return !!element.type && element.type.tabsRole === tabsRole;
  };
}
var isTab = makeTypeChecker("Tab");
var isTabList = makeTypeChecker("TabList");
var isTabPanel = makeTypeChecker("TabPanel");
function _extends$6() {
  _extends$6 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function isTabChild(child) {
  return isTab(child) || isTabList(child) || isTabPanel(child);
}
function deepMap(children, callback) {
  return reactExports.Children.map(children, function(child) {
    if (child === null)
      return null;
    if (isTabChild(child)) {
      return callback(child);
    }
    if (child.props && child.props.children && typeof child.props.children === "object") {
      return /* @__PURE__ */ reactExports.cloneElement(child, _extends$6({}, child.props, {
        children: deepMap(child.props.children, callback)
      }));
    }
    return child;
  });
}
function deepForEach(children, callback) {
  return reactExports.Children.forEach(children, function(child) {
    if (child === null)
      return;
    if (isTab(child) || isTabPanel(child)) {
      callback(child);
    } else if (child.props && child.props.children && typeof child.props.children === "object") {
      if (isTabList(child))
        callback(child);
      deepForEach(child.props.children, callback);
    }
  });
}
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var count = 0;
function uuid() {
  return "react-tabs-" + count++;
}
function reset() {
  count = 0;
}
function getTabsCount(children) {
  var tabCount = 0;
  deepForEach(children, function(child) {
    if (isTab(child))
      tabCount++;
  });
  return tabCount;
}
var _excluded$c = ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName", "environment", "disableUpDownKeys"];
function _extends$5() {
  _extends$5 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function isNode$2(node2) {
  return node2 && "getAttribute" in node2;
}
function isTabNode(node2) {
  return isNode$2(node2) && node2.getAttribute("data-rttab");
}
function isTabDisabled(node2) {
  return isNode$2(node2) && node2.getAttribute("aria-disabled") === "true";
}
var canUseActiveElement;
function determineCanUseActiveElement(environment) {
  var env2 = environment || (typeof window !== "undefined" ? window : void 0);
  try {
    canUseActiveElement = !!(typeof env2 !== "undefined" && env2.document && env2.document.activeElement);
  } catch (e2) {
    canUseActiveElement = false;
  }
}
var defaultProps$5 = {
  className: "react-tabs",
  focus: false
};
var UncontrolledTabs = function UncontrolledTabs2(props) {
  var tabNodes = reactExports.useRef([]);
  var tabIds = reactExports.useRef([]);
  var panelIds = reactExports.useRef([]);
  var _ref3 = reactExports.useRef();
  function setSelected(index2, event) {
    if (index2 < 0 || index2 >= getTabsCount$1())
      return;
    var onSelect = props.onSelect, selectedIndex = props.selectedIndex;
    onSelect(index2, selectedIndex, event);
  }
  function getNextTab(index2) {
    var count2 = getTabsCount$1();
    for (var i = index2 + 1; i < count2; i++) {
      if (!isTabDisabled(getTab(i))) {
        return i;
      }
    }
    for (var _i = 0; _i < index2; _i++) {
      if (!isTabDisabled(getTab(_i))) {
        return _i;
      }
    }
    return index2;
  }
  function getPrevTab(index2) {
    var i = index2;
    while (i--) {
      if (!isTabDisabled(getTab(i))) {
        return i;
      }
    }
    i = getTabsCount$1();
    while (i-- > index2) {
      if (!isTabDisabled(getTab(i))) {
        return i;
      }
    }
    return index2;
  }
  function getFirstTab() {
    var count2 = getTabsCount$1();
    for (var i = 0; i < count2; i++) {
      if (!isTabDisabled(getTab(i))) {
        return i;
      }
    }
    return null;
  }
  function getLastTab() {
    var i = getTabsCount$1();
    while (i--) {
      if (!isTabDisabled(getTab(i))) {
        return i;
      }
    }
    return null;
  }
  function getTabsCount$1() {
    var children = props.children;
    return getTabsCount(children);
  }
  function getTab(index2) {
    return tabNodes.current["tabs-" + index2];
  }
  function getChildren() {
    var index2 = 0;
    var children = props.children, disabledTabClassName = props.disabledTabClassName, focus = props.focus, forceRenderTabPanel = props.forceRenderTabPanel, selectedIndex = props.selectedIndex, selectedTabClassName = props.selectedTabClassName, selectedTabPanelClassName = props.selectedTabPanelClassName, environment = props.environment;
    tabIds.current = tabIds.current || [];
    panelIds.current = panelIds.current || [];
    var diff = tabIds.current.length - getTabsCount$1();
    while (diff++ < 0) {
      tabIds.current.push(uuid());
      panelIds.current.push(uuid());
    }
    return deepMap(children, function(child) {
      var result = child;
      if (isTabList(child)) {
        var listIndex = 0;
        var wasTabFocused = false;
        if (canUseActiveElement == null) {
          determineCanUseActiveElement(environment);
        }
        var env2 = environment || (typeof window !== "undefined" ? window : void 0);
        if (canUseActiveElement && env2) {
          wasTabFocused = React.Children.toArray(child.props.children).filter(isTab).some(function(tab, i) {
            return env2.document.activeElement === getTab(i);
          });
        }
        result = /* @__PURE__ */ reactExports.cloneElement(child, {
          children: deepMap(child.props.children, function(tab) {
            var key2 = "tabs-" + listIndex;
            var selected = selectedIndex === listIndex;
            var props2 = {
              tabRef: function tabRef(node2) {
                tabNodes.current[key2] = node2;
              },
              id: tabIds.current[listIndex],
              panelId: panelIds.current[listIndex],
              selected,
              focus: selected && (focus || wasTabFocused)
            };
            if (selectedTabClassName)
              props2.selectedClassName = selectedTabClassName;
            if (disabledTabClassName)
              props2.disabledClassName = disabledTabClassName;
            listIndex++;
            return /* @__PURE__ */ reactExports.cloneElement(tab, props2);
          })
        });
      } else if (isTabPanel(child)) {
        var _props = {
          id: panelIds.current[index2],
          tabId: tabIds.current[index2],
          selected: selectedIndex === index2
        };
        if (forceRenderTabPanel)
          _props.forceRender = forceRenderTabPanel;
        if (selectedTabPanelClassName)
          _props.selectedClassName = selectedTabPanelClassName;
        index2++;
        result = /* @__PURE__ */ reactExports.cloneElement(child, _props);
      }
      return result;
    });
  }
  function handleKeyDown(e2) {
    var direction2 = props.direction, disableUpDownKeys = props.disableUpDownKeys;
    if (isTabFromContainer(e2.target)) {
      var index2 = props.selectedIndex;
      var preventDefault = false;
      var useSelectedIndex = false;
      if (e2.code === "Space" || e2.keyCode === 32 || e2.code === "Enter" || e2.keyCode === 13) {
        preventDefault = true;
        useSelectedIndex = false;
        handleClick(e2);
      }
      if (e2.code === "ArrowLeft" || e2.keyCode === 37 || !disableUpDownKeys && (e2.keyCode === 38 || e2.code === "ArrowUp")) {
        if (direction2 === "rtl") {
          index2 = getNextTab(index2);
        } else {
          index2 = getPrevTab(index2);
        }
        preventDefault = true;
        useSelectedIndex = true;
      } else if (e2.code === "ArrowRight" || e2.keyCode === 39 || !disableUpDownKeys && (e2.keyCode === 40 || e2.code === "ArrowDown")) {
        if (direction2 === "rtl") {
          index2 = getPrevTab(index2);
        } else {
          index2 = getNextTab(index2);
        }
        preventDefault = true;
        useSelectedIndex = true;
      } else if (e2.keyCode === 35 || e2.code === "End") {
        index2 = getLastTab();
        preventDefault = true;
        useSelectedIndex = true;
      } else if (e2.keyCode === 36 || e2.code === "Home") {
        index2 = getFirstTab();
        preventDefault = true;
        useSelectedIndex = true;
      }
      if (preventDefault) {
        e2.preventDefault();
      }
      if (useSelectedIndex) {
        setSelected(index2, e2);
      }
    }
  }
  function handleClick(e2) {
    var node2 = e2.target;
    do {
      if (isTabFromContainer(node2)) {
        if (isTabDisabled(node2)) {
          return;
        }
        var index2 = [].slice.call(node2.parentNode.children).filter(isTabNode).indexOf(node2);
        setSelected(index2, e2);
        return;
      }
    } while ((node2 = node2.parentNode) != null);
  }
  function isTabFromContainer(node2) {
    if (!isTabNode(node2)) {
      return false;
    }
    var nodeAncestor = node2.parentElement;
    do {
      if (nodeAncestor === _ref3.current)
        return true;
      if (nodeAncestor.getAttribute("data-rttabs"))
        break;
      nodeAncestor = nodeAncestor.parentElement;
    } while (nodeAncestor);
    return false;
  }
  props.children;
  var className = props.className;
  props.disabledTabClassName;
  var domRef = props.domRef;
  props.focus;
  props.forceRenderTabPanel;
  props.onSelect;
  props.selectedIndex;
  props.selectedTabClassName;
  props.selectedTabPanelClassName;
  props.environment;
  props.disableUpDownKeys;
  var attributes = _objectWithoutPropertiesLoose$4(props, _excluded$c);
  return /* @__PURE__ */ React.createElement("div", _extends$5({}, attributes, {
    className: clsx(className),
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: function ref(node2) {
      _ref3.current = node2;
      if (domRef)
        domRef(node2);
    },
    "data-rttabs": true
  }), getChildren());
};
UncontrolledTabs.defaultProps = defaultProps$5;
UncontrolledTabs.propTypes = {};
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var MODE_CONTROLLED = 0;
var MODE_UNCONTROLLED = 1;
var defaultProps$4 = {
  defaultFocus: false,
  focusTabOnClick: true,
  forceRenderTabPanel: false,
  selectedIndex: null,
  defaultIndex: null,
  environment: null,
  disableUpDownKeys: false
};
var getModeFromProps = function getModeFromProps2(props) {
  return props.selectedIndex === null ? MODE_UNCONTROLLED : MODE_CONTROLLED;
};
var Tabs = function Tabs2(props) {
  var children = props.children, defaultFocus = props.defaultFocus, defaultIndex = props.defaultIndex, focusTabOnClick = props.focusTabOnClick, onSelect = props.onSelect;
  var _useState = reactExports.useState(defaultFocus), focus = _useState[0], setFocus = _useState[1];
  var _useState2 = reactExports.useState(getModeFromProps(props)), mode2 = _useState2[0];
  var _useState3 = reactExports.useState(mode2 === MODE_UNCONTROLLED ? defaultIndex || 0 : null), selectedIndex = _useState3[0], setSelectedIndex = _useState3[1];
  reactExports.useEffect(function() {
    setFocus(false);
  }, []);
  if (mode2 === MODE_UNCONTROLLED) {
    var tabsCount = getTabsCount(children);
    reactExports.useEffect(function() {
      if (selectedIndex != null) {
        var maxTabIndex = Math.max(0, tabsCount - 1);
        setSelectedIndex(Math.min(selectedIndex, maxTabIndex));
      }
    }, [tabsCount]);
  }
  var handleSelected = function handleSelected2(index2, last2, event) {
    if (typeof onSelect === "function") {
      if (onSelect(index2, last2, event) === false)
        return;
    }
    if (focusTabOnClick) {
      setFocus(true);
    }
    if (mode2 === MODE_UNCONTROLLED) {
      setSelectedIndex(index2);
    }
  };
  var subProps = _extends$4({}, props);
  subProps.focus = focus;
  subProps.onSelect = handleSelected;
  if (selectedIndex != null) {
    subProps.selectedIndex = selectedIndex;
  }
  delete subProps.defaultFocus;
  delete subProps.defaultIndex;
  delete subProps.focusTabOnClick;
  return /* @__PURE__ */ React.createElement(UncontrolledTabs, subProps, children);
};
Tabs.propTypes = {};
Tabs.defaultProps = defaultProps$4;
Tabs.tabsRole = "Tabs";
var _excluded$b = ["children", "className"];
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var defaultProps$3 = {
  className: "react-tabs__tab-list"
};
var TabList = function TabList2(props) {
  var children = props.children, className = props.className, attributes = _objectWithoutPropertiesLoose$3(props, _excluded$b);
  return /* @__PURE__ */ React.createElement("ul", _extends$3({}, attributes, {
    className: clsx(className),
    role: "tablist"
  }), children);
};
TabList.tabsRole = "TabList";
TabList.propTypes = {};
TabList.defaultProps = defaultProps$3;
var _excluded$a = ["children", "className", "disabled", "disabledClassName", "focus", "id", "panelId", "selected", "selectedClassName", "tabIndex", "tabRef"];
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var DEFAULT_CLASS$1 = "react-tabs__tab";
var DEFAULT_PROPS = {
  className: DEFAULT_CLASS$1,
  disabledClassName: DEFAULT_CLASS$1 + "--disabled",
  focus: false,
  id: null,
  panelId: null,
  selected: false,
  selectedClassName: DEFAULT_CLASS$1 + "--selected"
};
var Tab = function Tab2(props) {
  var _cx;
  var nodeRef = reactExports.useRef();
  var children = props.children, className = props.className, disabled = props.disabled, disabledClassName = props.disabledClassName, focus = props.focus, id2 = props.id, panelId = props.panelId, selected = props.selected, selectedClassName = props.selectedClassName, tabIndex = props.tabIndex, tabRef = props.tabRef, attributes = _objectWithoutPropertiesLoose$2(props, _excluded$a);
  reactExports.useEffect(function() {
    if (selected && focus) {
      nodeRef.current.focus();
    }
  }, [selected, focus]);
  return /* @__PURE__ */ React.createElement("li", _extends$2({}, attributes, {
    className: clsx(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
    ref: function ref(node2) {
      nodeRef.current = node2;
      if (tabRef)
        tabRef(node2);
    },
    role: "tab",
    id: id2,
    "aria-selected": selected ? "true" : "false",
    "aria-disabled": disabled ? "true" : "false",
    "aria-controls": panelId,
    tabIndex: tabIndex || (selected ? "0" : null),
    "data-rttab": true
  }), children);
};
Tab.propTypes = {};
Tab.tabsRole = "Tab";
Tab.defaultProps = DEFAULT_PROPS;
var _excluded$9 = ["children", "className", "forceRender", "id", "selected", "selectedClassName", "tabId"];
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var DEFAULT_CLASS = "react-tabs__tab-panel";
var defaultProps$2 = {
  className: DEFAULT_CLASS,
  forceRender: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};
var TabPanel = function TabPanel2(props) {
  var _cx;
  var children = props.children, className = props.className, forceRender = props.forceRender, id2 = props.id, selected = props.selected, selectedClassName = props.selectedClassName, tabId = props.tabId, attributes = _objectWithoutPropertiesLoose$1(props, _excluded$9);
  return /* @__PURE__ */ React.createElement("div", _extends$1({}, attributes, {
    className: clsx(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
    role: "tabpanel",
    id: id2,
    "aria-labelledby": tabId
  }), forceRender || selected ? children : null);
};
TabPanel.tabsRole = "TabPanel";
TabPanel.propTypes = {};
TabPanel.defaultProps = defaultProps$2;
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tab,
  TabList,
  TabPanel,
  Tabs,
  resetIdCounter: reset
}, Symbol.toStringTag, { value: "Module" }));
const require$$43 = /* @__PURE__ */ getAugmentedNamespace(esm);
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function get$2(element) {
  return getComputedStyle(element);
}
function set$2(element, obj) {
  for (var key2 in obj) {
    var val = obj[key2];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key2] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches$1(element, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query);
}
function remove$2(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(
    element.children,
    function(child) {
      return matches$1(child, selector);
    }
  );
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(x2) {
      return "ps__thumb-" + x2;
    },
    rail: function(x2) {
      return "ps__rail-" + x2;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(x2) {
      return "ps--active-" + x2;
    },
    scrolling: function(x2) {
      return "ps--scrolling-" + x2;
    }
  }
};
var scrollingClassTimeout = { x: null, y: null };
function addScrollingClass(i, x2) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x2);
  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x2]);
  } else {
    classList.add(className);
  }
}
function removeScrollingClass(i, x2) {
  scrollingClassTimeout[x2] = setTimeout(
    function() {
      return i.isAlive && i.element.classList.remove(cls.state.scrolling(x2));
    },
    i.settings.scrollingThreshold
  );
}
function setScrollingClassInstantly(i, x2) {
  addScrollingClass(i, x2);
  removeScrollingClass(i, x2);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors = { isEmpty: { configurable: true } };
EventElement.prototype.bind = function bind(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name2 in this.handlers) {
    this.unbind(name2);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(
    function(key2) {
      return this$1$1.handlers[key2].length === 0;
    }
  );
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee2 = this.eventElements.filter(function(ee3) {
    return ee3.element === element;
  })[0];
  if (!ee2) {
    ee2 = new EventElement(element);
    this.eventElements.push(ee2);
  }
  return ee2;
};
EventManager.prototype.bind = function bind2(element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  ee2.unbind(eventName, handler);
  if (ee2.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e2) {
    return e2.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once2(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  var onceHandler = function(evt) {
    ee2.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee2.bind(eventName, onceHandler);
};
function createEvent(name2) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name2);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name2, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  } else if (axis === "left") {
    fields = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
}
function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y2 = ref[3];
  var up = ref[4];
  var down = ref[5];
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var element = i.element;
  i.reach[y2] = null;
  if (element[scrollTop] < 1) {
    i.reach[y2] = "start";
  }
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y2] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y2));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i, y2);
    }
  }
  if (i.reach[y2] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i.reach[y2]));
  }
}
function toInt$1(x2) {
  return parseInt(x2, 10) || 0;
}
function isEditable(el2) {
  return matches$1(el2, "input,[contenteditable]") || matches$1(el2, "select,[contenteditable]") || matches$1(el2, "textarea,[contenteditable]") || matches$1(el2, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles2 = get$2(element);
  return toInt$1(styles2.width) + toInt$1(styles2.paddingLeft) + toInt$1(styles2.paddingRight) + toInt$1(styles2.borderLeftWidth) + toInt$1(styles2.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i.containerWidth = Math.round(rect.width);
  i.containerHeight = Math.round(rect.height);
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;
  if (!element.contains(i.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(
      function(el2) {
        return remove$2(el2);
      }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(
      function(el2) {
        return remove$2(el2);
      }
    );
    element.appendChild(i.scrollbarYRail);
  }
  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt$1(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt$1(
      (i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }
  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt$1(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt$1(
      roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }
  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }
  updateCss(element, i);
  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set$2(i.scrollbarXRail, xRailOffset);
  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set$2(i.scrollbarYRail, yRailOffset);
  set$2(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set$2(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}
function clickRail(i) {
  i.element;
  i.event.bind(i.scrollbarY, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, "mousedown", function(e2) {
    var positionTop = e2.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction2 = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction2 * i.containerHeight;
    updateGeometry(i);
    e2.stopPropagation();
  });
  i.event.bind(i.scrollbarX, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, "mousedown", function(e2) {
    var positionLeft = e2.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction2 = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction2 * i.containerWidth;
    updateGeometry(i);
    e2.stopPropagation();
  });
}
function dragThumb(i) {
  bindMouseScrollHandler(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
  bindMouseScrollHandler(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function bindMouseScrollHandler(i, ref) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y2 = ref[7];
  var scrollbarYRail = ref[8];
  var element = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e2) {
    if (e2.touches && e2.touches[0]) {
      e2[pageY] = e2.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy * (e2[pageY] - startingMousePageY);
    addScrollingClass(i, y2);
    updateGeometry(i);
    e2.stopPropagation();
    if (e2.type.startsWith("touch") && e2.changedTouches.length > 1) {
      e2.preventDefault();
    }
  }
  function mouseUpHandler() {
    removeScrollingClass(i, y2);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e2, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e2.touches) {
      e2[pageY] = e2.touches[0].pageY;
    }
    startingMousePageY = e2[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
    if (!touchMode) {
      i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
      i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
      e2.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i[scrollbarYRail].classList.add(cls.state.clicking);
    e2.stopPropagation();
  }
  i.event.bind(i[scrollbarY], "mousedown", function(e2) {
    bindMoves(e2);
  });
  i.event.bind(i[scrollbarY], "touchstart", function(e2) {
    bindMoves(e2, true);
  });
}
function keyboard(i) {
  var element = i.element;
  var elementHovered = function() {
    return matches$1(element, ":hover");
  };
  var scrollbarFocused = function() {
    return matches$1(i.scrollbarX, ":focus") || matches$1(i.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }
  i.event.bind(i.ownerDocument, "keydown", function(e2) {
    if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e2.which) {
      case 37:
        if (e2.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e2.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e2.metaKey) {
          deltaY = i.contentHeight;
        } else if (e2.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e2.metaKey) {
          deltaX = i.contentWidth;
        } else if (e2.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e2.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e2.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e2.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33:
        deltaY = i.containerHeight;
        break;
      case 34:
        deltaY = -i.containerHeight;
        break;
      case 36:
        deltaY = i.contentHeight;
        break;
      case 35:
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }
    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e2.preventDefault();
    }
  });
}
function wheel(i) {
  var element = i.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e2) {
    var deltaX = e2.deltaX;
    var deltaY = -1 * e2.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e2.wheelDeltaX / 6;
      deltaY = e2.wheelDeltaY / 6;
    }
    if (e2.deltaMode && e2.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e2.wheelDelta;
    }
    if (e2.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get$2(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e2) {
    var ref = getDeltaFromEvent(e2);
    var deltaX = ref[0];
    var deltaY = ref[1];
    if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e2.ctrlKey) {
      e2.stopPropagation();
      e2.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (magnitudeY > magnitudeX) {
      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e2) {
    if (e2.targetTouches) {
      return e2.targetTouches[0];
    } else {
      return e2;
    }
  }
  function shouldHandle(e2) {
    if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
      return false;
    }
    if (e2.targetTouches && e2.targetTouches.length === 1) {
      return true;
    }
    if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e2) {
    if (!shouldHandle(e2)) {
      return;
    }
    var touch2 = getTouch(e2);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = (/* @__PURE__ */ new Date()).getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get$2(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function touchMove(e2) {
    if (shouldHandle(e2)) {
      var touch2 = getTouch(e2);
      var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (shouldPrevent(differenceX, differenceY)) {
        e2.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        if (!i.element) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i.event.bind(element, "touchstart", touchStart);
    i.event.bind(element, "touchmove", touchMove);
    i.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, "pointerdown", touchStart);
      i.event.bind(element, "pointermove", touchMove);
      i.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, "MSPointerDown", touchStart);
      i.event.bind(element, "MSPointerMove", touchMove);
      i.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0)
    userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key2 in userSettings) {
    this.settings[key2] = userSettings[key2];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function() {
    return element.classList.add(cls.state.focus);
  };
  var blur2 = function() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get$2(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur2);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get$2(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt$1(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt$1(railXStyle.borderLeftWidth) + toInt$1(railXStyle.borderRightWidth);
  set$2(this.scrollbarXRail, { display: "block" });
  this.railXMarginWidth = toInt$1(railXStyle.marginLeft) + toInt$1(railXStyle.marginRight);
  set$2(this.scrollbarXRail, { display: "" });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur2);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get$2(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt$1(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt$1(railYStyle.borderTopWidth) + toInt$1(railYStyle.borderBottomWidth);
  set$2(this.scrollbarYRail, { display: "block" });
  this.railYMarginHeight = toInt$1(railYStyle.marginTop) + toInt$1(railYStyle.marginBottom);
  set$2(this.scrollbarYRail, { display: "" });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e2) {
    return this$1$1.onScroll(e2);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update() {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set$2(this.scrollbarXRail, { display: "block" });
  set$2(this.scrollbarYRail, { display: "block" });
  this.railXMarginWidth = toInt$1(get$2(this.scrollbarXRail).marginLeft) + toInt$1(get$2(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt$1(get$2(this.scrollbarYRail).marginTop) + toInt$1(get$2(this.scrollbarYRail).marginBottom);
  set$2(this.scrollbarXRail, { display: "none" });
  set$2(this.scrollbarYRail, { display: "none" });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true);
  processScrollDiff(this, "left", 0, false, true);
  set$2(this.scrollbarXRail, { display: "" });
  set$2(this.scrollbarYRail, { display: "" });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  );
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove$2(this.scrollbarX);
  remove$2(this.scrollbarY);
  remove$2(this.scrollbarXRail);
  remove$2(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name2) {
    return !name2.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const perfectScrollbar_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PerfectScrollbar
}, Symbol.toStringTag, { value: "Module" }));
const require$$44 = /* @__PURE__ */ getAugmentedNamespace(perfectScrollbar_esm);
var purify = { exports: {} };
/*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */
var hasRequiredPurify;
function requirePurify() {
  if (hasRequiredPurify)
    return purify.exports;
  hasRequiredPurify = 1;
  (function(module, exports) {
    (function(global2, factory2) {
      module.exports = factory2();
    })(commonjsGlobal, function() {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof2(obj);
      }
      function _setPrototypeOf2(o, p2) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf2(o, p2);
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct2(Parent, args, Class) {
        if (_isNativeReflectConstruct2()) {
          _construct2 = Reflect.construct;
        } else {
          _construct2 = function _construct3(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf2(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct2.apply(null, arguments);
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n2 = Object.prototype.toString.call(o).slice(8, -1);
        if (n2 === "Object" && o.constructor)
          n2 = o.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray2(o, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze, seal = Object.seal, create = Object.create;
      var _ref3 = typeof Reflect !== "undefined" && Reflect, apply = _ref3.apply, construct = _ref3.construct;
      if (!apply) {
        apply = function apply2(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!construct) {
        construct = function construct2(Func, args) {
          return _construct2(Func, _toConsumableArray2(args));
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return construct(func, args);
        };
      }
      function addToSet(set5, array2, transformCaseFunc) {
        var _transformCaseFunc;
        transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set5, null);
        }
        var l2 = array2.length;
        while (l2--) {
          var element = array2[l2];
          if (typeof element === "string") {
            var lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
              if (!isFrozen(array2)) {
                array2[l2] = lcElement;
              }
              element = lcElement;
            }
          }
          set5[element] = true;
        }
        return set5;
      }
      function clone(object2) {
        var newObject = create(null);
        var property;
        for (property in object2) {
          if (apply(hasOwnProperty2, object2, [property]) === true) {
            newObject[property] = object2[property];
          }
        }
        return newObject;
      }
      function lookupGetter(object2, prop) {
        while (object2 !== null) {
          var desc = getOwnPropertyDescriptor(object2, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object2 = getPrototypeOf(object2);
        }
        function fallbackValue(element) {
          console.warn("fallback value for", element);
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text = freeze(["#text"]);
      var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
      var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var getGlobal2 = function getGlobal3() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
        if (_typeof2(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        var suffix = null;
        var ATTR_NAME = "data-tt-policy-suffix";
        if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document2.currentScript.getAttribute(ATTR_NAME);
        }
        var policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html2) {
              return html2;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_2) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      function createDOMPurify() {
        var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal2();
        var DOMPurify = function DOMPurify2(root) {
          return createDOMPurify(root);
        };
        DOMPurify.version = "2.4.7";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== 9) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        var originalDocument = window2.document;
        var document2 = window2.document;
        var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node3 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
        var ElementPrototype = Element2.prototype;
        var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
        var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        var getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          var template2 = document2.createElement("template");
          if (template2.content && template2.content.ownerDocument) {
            document2 = template2.content.ownerDocument;
          }
        }
        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
        var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};
        try {
          documentMode = clone(document2).documentMode ? document2.documentMode : {};
        } catch (_2) {
        }
        var hooks = {};
        DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray2(html$1), _toConsumableArray2(svg$1), _toConsumableArray2(svgFilters), _toConsumableArray2(mathMl$1), _toConsumableArray2(text)));
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray2(html), _toConsumableArray2(svg), _toConsumableArray2(mathMl), _toConsumableArray2(xml)));
        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        var FORBID_TAGS = null;
        var FORBID_ATTR = null;
        var ALLOW_ARIA_ATTR = true;
        var ALLOW_DATA_ATTR = true;
        var ALLOW_UNKNOWN_PROTOCOLS = false;
        var ALLOW_SELF_CLOSE_IN_ATTR = true;
        var SAFE_FOR_TEMPLATES = false;
        var WHOLE_DOCUMENT = false;
        var SET_CONFIG = false;
        var FORCE_BODY = false;
        var RETURN_DOM = false;
        var RETURN_DOM_FRAGMENT = false;
        var RETURN_TRUSTED_TYPE = false;
        var SANITIZE_DOM = true;
        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        var KEEP_CONTENT = true;
        var IN_PLACE = false;
        var USE_PROFILES = {};
        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        var transformCaseFunc;
        var CONFIG = null;
        var formElement = document2.createElement("form");
        var isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        var _parseConfig = function _parseConfig2(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || _typeof2(cfg) !== "object") {
            cfg = {};
          }
          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
            clone(DEFAULT_URI_SAFE_ATTRIBUTES),
            // eslint-disable-line indent
            cfg.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
            clone(DEFAULT_DATA_URI_TAGS),
            // eslint-disable-line indent
            cfg.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray2(text));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        var _checkValidNamespace = function _checkValidNamespace2(element) {
          var parent = getParentNode2(element);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }
          if (element.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          }
          return false;
        };
        var _forceRemove = function _forceRemove2(node2) {
          arrayPush(DOMPurify.removed, {
            element: node2
          });
          try {
            node2.parentNode.removeChild(node2);
          } catch (_2) {
            try {
              node2.outerHTML = emptyHTML;
            } catch (_3) {
              node2.remove();
            }
          }
        };
        var _removeAttribute = function _removeAttribute2(name2, node2) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node2.getAttributeNode(name2),
              from: node2
            });
          } catch (_2) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node2
            });
          }
          node2.removeAttribute(name2);
          if (name2 === "is" && !ALLOWED_ATTR[name2]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node2);
              } catch (_2) {
              }
            } else {
              try {
                node2.setAttribute(name2, "");
              } catch (_2) {
              }
            }
          }
        };
        var _initDocument = function _initDocument2(dirty) {
          var doc;
          var leadingWhitespace;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            var matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches2 && matches2[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_2) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_2) {
            }
          }
          var body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        var _createIterator = function _createIterator2(root) {
          return createNodeIterator.call(
            root.ownerDocument || root,
            root,
            // eslint-disable-next-line no-bitwise
            NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT,
            null,
            false
          );
        };
        var _isClobbered = function _isClobbered2(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
        };
        var _isNode = function _isNode2(object2) {
          return _typeof2(Node3) === "object" ? object2 instanceof Node3 : object2 && _typeof2(object2) === "object" && typeof object2.nodeType === "number" && typeof object2.nodeName === "string";
        };
        var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }
          arrayForEach(hooks[entryPoint], function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        var _sanitizeElements = function _sanitizeElements2(currentNode) {
          var content;
          _executeHook("beforeSanitizeElements", currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);
            return true;
          }
          var tagName = transformCaseFunc(currentNode.nodeName);
          _executeHook("uponSanitizeElement", currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                return false;
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode2(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                var childCount = childNodes.length;
                for (var i = childCount - 1; i >= 0; --i) {
                  parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, " ");
            content = stringReplace(content, ERB_EXPR$1, " ");
            content = stringReplace(content, TMPLIT_EXPR$1, " ");
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          _executeHook("afterSanitizeElements", currentNode, null);
          return false;
        };
        var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
            ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
            ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
            )
              ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName])
            ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
            ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if (value) {
            return false;
          } else
            ;
          return true;
        };
        var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
          return tagName.indexOf("-") > 0;
        };
        var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          var attr;
          var value;
          var lcName;
          var l2;
          _executeHook("beforeSanitizeAttributes", currentNode, null);
          var attributes = currentNode.attributes;
          if (!attributes) {
            return;
          }
          var hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l2 = attributes.length;
          while (l2--) {
            attr = attributes[l2];
            var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
            value = name2 === "value" ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name2);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            _removeAttribute(name2, currentNode);
            if (!hookEvent.keepAttr) {
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name2, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, " ");
              value = stringReplace(value, ERB_EXPR$1, " ");
              value = stringReplace(value, TMPLIT_EXPR$1, " ");
            }
            var lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name2, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (trustedTypesPolicy && _typeof2(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI)
                ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name2, value);
              } else {
                currentNode.setAttribute(name2, value);
              }
              arrayPop(DOMPurify.removed);
            } catch (_2) {
            }
          }
          _executeHook("afterSanitizeAttributes", currentNode, null);
        };
        var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          var shadowNode;
          var shadowIterator = _createIterator(fragment);
          _executeHook("beforeSanitizeShadowDOM", fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHook("uponSanitizeShadowNode", shadowNode, null);
            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
            _sanitizeAttributes(shadowNode);
          }
          _executeHook("afterSanitizeShadowDOM", fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            if (_typeof2(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
              if (typeof dirty === "string") {
                return window2.toStaticHTML(dirty);
              }
              if (_isNode(dirty)) {
                return window2.toStaticHTML(dirty.outerHTML);
              }
            }
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node3) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            if (_sanitizeElements(currentNode)) {
              continue;
            }
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            _sanitizeAttributes(currentNode);
            oldNode = currentNode;
          }
          oldNode = null;
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function(cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag, attr, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint) {
          if (hooks[entryPoint]) {
            return arrayPop(hooks[entryPoint]);
          }
        };
        DOMPurify.removeHooks = function(entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };
        DOMPurify.removeAllHooks = function() {
          hooks = {};
        };
        return DOMPurify;
      }
      var purify2 = createDOMPurify();
      return purify2;
    });
  })(purify);
  return purify.exports;
}
if (!reactExports.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
  }
  configure({ reactionScheduler: reactionScheduler3 });
}
function printDebugValue(v2) {
  return getDependencyTree(v2);
}
var REGISTRY_FINALIZE_AFTER = 1e4;
var REGISTRY_SWEEP_INTERVAL = 1e4;
var TimerBasedFinalizationRegistry = (
  /** @class */
  function() {
    function TimerBasedFinalizationRegistry2(finalize) {
      var _this = this;
      Object.defineProperty(this, "finalize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: finalize
      });
      Object.defineProperty(this, "registrations", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "sweepTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "sweep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function(maxAge) {
          if (maxAge === void 0) {
            maxAge = REGISTRY_FINALIZE_AFTER;
          }
          clearTimeout(_this.sweepTimeout);
          _this.sweepTimeout = void 0;
          var now2 = Date.now();
          _this.registrations.forEach(function(registration, token2) {
            if (now2 - registration.registeredAt >= maxAge) {
              _this.finalize(registration.value);
              _this.registrations.delete(token2);
            }
          });
          if (_this.registrations.size > 0) {
            _this.scheduleSweep();
          }
        }
      });
      Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function() {
          _this.sweep(0);
        }
      });
    }
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(target, value, token2) {
        this.registrations.set(token2, {
          value,
          registeredAt: Date.now()
        });
        this.scheduleSweep();
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(token2) {
        this.registrations.delete(token2);
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.sweepTimeout === void 0) {
          this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
        }
      }
    });
    return TimerBasedFinalizationRegistry2;
  }()
);
var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;
var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
  var _a4;
  (_a4 = adm.reaction) === null || _a4 === void 0 ? void 0 : _a4.dispose();
  adm.reaction = null;
});
var globalIsUsingStaticRendering = false;
function enableStaticRendering(enable) {
  globalIsUsingStaticRendering = enable;
}
function isUsingStaticRendering() {
  return globalIsUsingStaticRendering;
}
var __read$1 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function observerComponentNameFor(baseComponentName) {
  return "observer".concat(baseComponentName);
}
var ObjectToBeRetainedByReact = (
  /** @class */
  function() {
    function ObjectToBeRetainedByReact2() {
    }
    return ObjectToBeRetainedByReact2;
  }()
);
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver$1(fn2, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  if (isUsingStaticRendering()) {
    return fn2();
  }
  var _a4 = __read$1(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a4[0];
  var _b3 = __read$1(React.useState(), 2), setState = _b3[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var admRef = React.useRef(null);
  if (!admRef.current) {
    admRef.current = {
      reaction: null,
      mounted: false,
      changedBeforeMount: false
    };
  }
  var adm = admRef.current;
  if (!adm.reaction) {
    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (adm.mounted) {
        forceUpdate();
      } else {
        adm.changedBeforeMount = true;
      }
    });
    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
  }
  React.useDebugValue(adm.reaction, printDebugValue);
  React.useEffect(function() {
    observerFinalizationRegistry.unregister(adm);
    adm.mounted = true;
    if (adm.reaction) {
      if (adm.changedBeforeMount) {
        adm.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        forceUpdate();
      });
      forceUpdate();
    }
    return function() {
      adm.reaction.dispose();
      adm.reaction = null;
      adm.mounted = false;
      adm.changedBeforeMount = false;
    };
  }, []);
  var rendering;
  var exception2;
  adm.reaction.track(function() {
    try {
      rendering = fn2();
    } catch (e2) {
      exception2 = e2;
    }
  });
  if (exception2) {
    throw exception2;
  }
  return rendering;
}
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof reactExports.forwardRef === "function" && reactExports.forwardRef(function(props) {
  return null;
})["$$typeof"];
var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof reactExports.memo === "function" && reactExports.memo(function(props) {
  return null;
})["$$typeof"];
function observer$1(baseComponent, options2) {
  var _a4;
  if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  }
  if (isUsingStaticRendering()) {
    return baseComponent;
  }
  var useForwardRef = (_a4 = options2 === null || options2 === void 0 ? void 0 : options2.forwardRef) !== null && _a4 !== void 0 ? _a4 : false;
  var render = baseComponent;
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render = baseComponent["render"];
    if (typeof render !== "function") {
      throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    }
  }
  var observerComponent = function(props, ref) {
    return useObserver$1(function() {
      return render(props, ref);
    }, baseComponentName);
  };
  if (baseComponentName !== "") {
    observerComponent.displayName = baseComponentName;
  }
  if (baseComponent.contextTypes) {
    observerComponent.contextTypes = baseComponent.contextTypes;
  }
  if (useForwardRef) {
    observerComponent = reactExports.forwardRef(observerComponent);
  }
  observerComponent = reactExports.memo(observerComponent);
  copyStaticProperties$1(baseComponent, observerComponent);
  return observerComponent;
}
var hoistBlackList$1 = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: true
};
function copyStaticProperties$1(base, target) {
  Object.keys(base).forEach(function(key2) {
    if (!hoistBlackList$1[key2]) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(base, key2));
    }
  });
}
function ObserverComponent(_a4) {
  var children = _a4.children, render = _a4.render;
  var component = children || render;
  if (typeof component !== "function") {
    return null;
  }
  return useObserver$1(component);
}
ObserverComponent.displayName = "Observer";
function useLocalObservable(initializer, annotations) {
  return reactExports.useState(function() {
    return observable(initializer(), annotations, { autoBind: true });
  })[0];
}
var __read = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function useAsObservableSource(current) {
  var _a4 = __read(reactExports.useState(function() {
    return observable(current, {}, { deep: false });
  }), 1), res = _a4[0];
  runInAction(function() {
    Object.assign(res, current);
  });
  return res;
}
function useLocalStore(initializer, current) {
  var source = current && useAsObservableSource(current);
  return reactExports.useState(function() {
    return observable(initializer(source), void 0, { autoBind: true });
  })[0];
}
var _a;
observerBatching(reactDomExports.unstable_batchedUpdates);
(_a = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a !== void 0 ? _a : function() {
};
function useObserver(fn2, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  return useObserver$1(fn2, baseComponentName);
}
function useStaticRendering(enable) {
  enableStaticRendering(enable);
}
var symbolId = 0;
function createSymbol(name2) {
  if (typeof Symbol === "function") {
    return Symbol(name2);
  }
  var symbol = "__$mobx-react " + name2 + " (" + symbolId + ")";
  symbolId++;
  return symbol;
}
var createdSymbols = {};
function newSymbol(name2) {
  if (!createdSymbols[name2]) {
    createdSymbols[name2] = createSymbol(name2);
  }
  return createdSymbols[name2];
}
function shallowEqual2(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
var hoistBlackList = {
  $$typeof: 1,
  render: 1,
  compare: 1,
  type: 1,
  childContextTypes: 1,
  contextType: 1,
  contextTypes: 1,
  defaultProps: 1,
  getDefaultProps: 1,
  getDerivedStateFromError: 1,
  getDerivedStateFromProps: 1,
  mixins: 1,
  displayName: 1,
  propTypes: 1
};
function copyStaticProperties(base, target) {
  var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));
  Object.getOwnPropertyNames(base).forEach(function(key2) {
    if (!hoistBlackList[key2] && protoProps.indexOf(key2) === -1) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(base, key2));
    }
  });
}
function setHiddenProp(target, prop, value) {
  if (!Object.hasOwnProperty.call(target, prop)) {
    Object.defineProperty(target, prop, {
      enumerable: false,
      configurable: true,
      writable: true,
      value
    });
  } else {
    target[prop] = value;
  }
}
var mobxMixins = /* @__PURE__ */ newSymbol("patchMixins");
var mobxPatchedDefinition = /* @__PURE__ */ newSymbol("patchedDefinition");
function getMixins(target, methodName) {
  var mixins = target[mobxMixins] = target[mobxMixins] || {};
  var methodMixins = mixins[methodName] = mixins[methodName] || {};
  methodMixins.locks = methodMixins.locks || 0;
  methodMixins.methods = methodMixins.methods || [];
  return methodMixins;
}
function wrapper$4(realMethod, mixins) {
  var _this = this;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  mixins.locks++;
  try {
    var retVal;
    if (realMethod !== void 0 && realMethod !== null) {
      retVal = realMethod.apply(this, args);
    }
    return retVal;
  } finally {
    mixins.locks--;
    if (mixins.locks === 0) {
      mixins.methods.forEach(function(mx) {
        mx.apply(_this, args);
      });
    }
  }
}
function wrapFunction(realMethod, mixins) {
  var fn2 = function fn3() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    wrapper$4.call.apply(wrapper$4, [this, realMethod, mixins].concat(args));
  };
  return fn2;
}
function patch(target, methodName, mixinMethod) {
  var mixins = getMixins(target, methodName);
  if (mixins.methods.indexOf(mixinMethod) < 0) {
    mixins.methods.push(mixinMethod);
  }
  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
    return;
  }
  var originalMethod = target[methodName];
  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : void 0, mixins, originalMethod);
  Object.defineProperty(target, methodName, newDefinition);
}
function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
  var _ref3;
  var wrappedFunc = wrapFunction(originalMethod, mixins);
  return _ref3 = {}, _ref3[mobxPatchedDefinition] = true, _ref3.get = function get4() {
    return wrappedFunc;
  }, _ref3.set = function set5(value) {
    if (this === target) {
      wrappedFunc = wrapFunction(value, mixins);
    } else {
      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
      Object.defineProperty(this, methodName, newDefinition);
    }
  }, _ref3.configurable = true, _ref3.enumerable = enumerable, _ref3;
}
var mobxAdminProperty = $mobx || "$mobx";
var mobxObserverProperty = /* @__PURE__ */ newSymbol("isMobXReactObserver");
var mobxIsUnmounted = /* @__PURE__ */ newSymbol("isUnmounted");
var skipRenderKey = /* @__PURE__ */ newSymbol("skipRender");
var isForcingUpdateKey = /* @__PURE__ */ newSymbol("isForcingUpdate");
function makeClassComponentObserver(componentClass) {
  var target = componentClass.prototype;
  if (componentClass[mobxObserverProperty]) {
    var displayName = getDisplayName(target);
    console.warn("The provided component class (" + displayName + ")\n                has already been declared as an observer component.");
  } else {
    componentClass[mobxObserverProperty] = true;
  }
  if (target.componentWillReact) {
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  }
  if (componentClass["__proto__"] !== reactExports.PureComponent) {
    if (!target.shouldComponentUpdate) {
      target.shouldComponentUpdate = observerSCU;
    } else if (target.shouldComponentUpdate !== observerSCU) {
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
    }
  }
  makeObservableProp(target, "props");
  makeObservableProp(target, "state");
  if (componentClass.contextType) {
    makeObservableProp(target, "context");
  }
  var originalRender = target.render;
  if (typeof originalRender !== "function") {
    var _displayName = getDisplayName(target);
    throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  target.render = function() {
    this.render = isUsingStaticRendering() ? originalRender : createReactiveRender.call(this, originalRender);
    return this.render();
  };
  patch(target, "componentDidMount", function() {
    this[mobxIsUnmounted] = false;
    if (!this.render[mobxAdminProperty]) {
      reactExports.Component.prototype.forceUpdate.call(this);
    }
  });
  patch(target, "componentWillUnmount", function() {
    if (isUsingStaticRendering()) {
      return;
    }
    var reaction2 = this.render[mobxAdminProperty];
    if (reaction2) {
      reaction2.dispose();
      this.render[mobxAdminProperty] = null;
    } else {
      var _displayName2 = getDisplayName(this);
      console.warn("The reactive render of an observer class component (" + _displayName2 + ")\n                was overridden after MobX attached. This may result in a memory leak if the\n                overridden reactive render was not properly disposed.");
    }
    this[mobxIsUnmounted] = true;
  });
  return componentClass;
}
function getDisplayName(comp) {
  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || "<component>";
}
function createReactiveRender(originalRender) {
  var _this = this;
  setHiddenProp(this, skipRenderKey, false);
  setHiddenProp(this, isForcingUpdateKey, false);
  var initialName = getDisplayName(this);
  var boundOriginalRender = originalRender.bind(this);
  var isRenderingPending = false;
  var createReaction = function createReaction2() {
    var reaction2 = new Reaction(initialName + ".render()", function() {
      if (!isRenderingPending) {
        isRenderingPending = true;
        if (_this[mobxIsUnmounted] !== true) {
          var hasError = true;
          try {
            setHiddenProp(_this, isForcingUpdateKey, true);
            if (!_this[skipRenderKey]) {
              reactExports.Component.prototype.forceUpdate.call(_this);
            }
            hasError = false;
          } finally {
            setHiddenProp(_this, isForcingUpdateKey, false);
            if (hasError) {
              reaction2.dispose();
              _this.render[mobxAdminProperty] = null;
            }
          }
        }
      }
    });
    reaction2["reactComponent"] = _this;
    return reaction2;
  };
  function reactiveRender() {
    var _reactiveRender$mobxA;
    isRenderingPending = false;
    var reaction2 = (_reactiveRender$mobxA = reactiveRender[mobxAdminProperty]) != null ? _reactiveRender$mobxA : reactiveRender[mobxAdminProperty] = createReaction();
    var exception2 = void 0;
    var rendering = void 0;
    reaction2.track(function() {
      try {
        rendering = allowStateChanges(false, boundOriginalRender);
      } catch (e2) {
        exception2 = e2;
      }
    });
    if (exception2) {
      throw exception2;
    }
    return rendering;
  }
  return reactiveRender;
}
function observerSCU(nextProps, nextState) {
  if (isUsingStaticRendering()) {
    console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
  }
  if (this.state !== nextState) {
    return true;
  }
  return !shallowEqual2(this.props, nextProps);
}
function makeObservableProp(target, propName) {
  var valueHolderKey = newSymbol("reactProp_" + propName + "_valueHolder");
  var atomHolderKey = newSymbol("reactProp_" + propName + "_atomHolder");
  function getAtom2() {
    if (!this[atomHolderKey]) {
      setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
    }
    return this[atomHolderKey];
  }
  Object.defineProperty(target, propName, {
    configurable: true,
    enumerable: true,
    get: function get4() {
      var prevReadState = false;
      if (allowStateReadsStart && allowStateReadsEnd) {
        prevReadState = allowStateReadsStart(true);
      }
      getAtom2.call(this).reportObserved();
      if (allowStateReadsStart && allowStateReadsEnd) {
        allowStateReadsEnd(prevReadState);
      }
      return this[valueHolderKey];
    },
    set: function set5(v2) {
      if (!this[isForcingUpdateKey] && !shallowEqual2(this[valueHolderKey], v2)) {
        setHiddenProp(this, valueHolderKey, v2);
        setHiddenProp(this, skipRenderKey, true);
        getAtom2.call(this).reportChanged();
        setHiddenProp(this, skipRenderKey, false);
      } else {
        setHiddenProp(this, valueHolderKey, v2);
      }
    }
  });
}
function observer(component) {
  if (component["isMobxInjector"] === true) {
    console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`");
  }
  if (Object.prototype.isPrototypeOf.call(reactExports.Component, component) || Object.prototype.isPrototypeOf.call(reactExports.PureComponent, component)) {
    return makeClassComponentObserver(component);
  } else {
    return observer$1(component);
  }
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var _excluded$8 = ["children"];
var MobXProviderContext = /* @__PURE__ */ React.createContext({});
function Provider(props) {
  var children = props.children, stores = _objectWithoutPropertiesLoose(props, _excluded$8);
  var parentValue = React.useContext(MobXProviderContext);
  var mutableProviderRef = React.useRef(_extends({}, parentValue, stores));
  var value = mutableProviderRef.current;
  return React.createElement(MobXProviderContext.Provider, {
    value
  }, children);
}
Provider.displayName = "MobXProvider";
function createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {
  var Injector = React.forwardRef(function(props, ref) {
    var newProps = _extends({}, props);
    var context = React.useContext(MobXProviderContext);
    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});
    if (ref) {
      newProps.ref = ref;
    }
    return React.createElement(component, newProps);
  });
  if (makeReactive)
    Injector = observer(Injector);
  Injector["isMobxInjector"] = true;
  copyStaticProperties(component, Injector);
  Injector["wrappedComponent"] = component;
  Injector.displayName = getInjectName(component, injectNames);
  return Injector;
}
function getInjectName(component, injectNames) {
  var displayName;
  var componentName = component.displayName || component.name || component.constructor && component.constructor.name || "Component";
  if (injectNames)
    displayName = "inject-with-" + injectNames + "(" + componentName + ")";
  else
    displayName = "inject(" + componentName + ")";
  return displayName;
}
function grabStoresByName(storeNames) {
  return function(baseStores, nextProps) {
    storeNames.forEach(function(storeName) {
      if (storeName in nextProps)
        return;
      if (!(storeName in baseStores))
        throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
      nextProps[storeName] = baseStores[storeName];
    });
    return nextProps;
  };
}
function inject() {
  for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {
    storeNames[_key] = arguments[_key];
  }
  if (typeof arguments[0] === "function") {
    var grabStoresFn = arguments[0];
    return function(componentClass) {
      return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);
    };
  } else {
    return function(componentClass) {
      return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join("-"), false);
    };
  }
}
var protoStoreKey = /* @__PURE__ */ newSymbol("disposeOnUnmountProto");
var instStoreKey = /* @__PURE__ */ newSymbol("disposeOnUnmountInst");
function runDisposersOnWillUnmount() {
  var _this = this;
  [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function(propKeyOrFunction) {
    var prop = typeof propKeyOrFunction === "string" ? _this[propKeyOrFunction] : propKeyOrFunction;
    if (prop !== void 0 && prop !== null) {
      if (Array.isArray(prop))
        prop.map(function(f2) {
          return f2();
        });
      else
        prop();
    }
  });
}
function disposeOnUnmount(target, propertyKeyOrFunction) {
  if (Array.isArray(propertyKeyOrFunction)) {
    return propertyKeyOrFunction.map(function(fn2) {
      return disposeOnUnmount(target, fn2);
    });
  }
  var c2 = Object.getPrototypeOf(target).constructor;
  var c22 = Object.getPrototypeOf(target.constructor);
  var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));
  if (!(c2 === React.Component || c2 === React.PureComponent || c22 === React.Component || c22 === React.PureComponent || c3 === React.Component || c3 === React.PureComponent)) {
    throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
  }
  if (typeof propertyKeyOrFunction !== "string" && typeof propertyKeyOrFunction !== "function" && !Array.isArray(propertyKeyOrFunction)) {
    throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
  }
  var isDecorator = typeof propertyKeyOrFunction === "string";
  var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];
  var store3 = isDecorator ? (
    // decorators are added to the prototype store
    target[protoStoreKey] || (target[protoStoreKey] = [])
  ) : (
    // functions are added to the instance store
    target[instStoreKey] || (target[instStoreKey] = [])
  );
  store3.push(propertyKeyOrFunction);
  if (!componentWasAlreadyModified) {
    patch(target, "componentWillUnmount", runDisposersOnWillUnmount);
  }
  if (typeof propertyKeyOrFunction !== "string") {
    return propertyKeyOrFunction;
  }
}
function createChainableTypeChecker(validator2) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      rest[_key - 6] = arguments[_key];
    }
    return untracked(function() {
      componentName = componentName || "<<anonymous>>";
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        if (isRequired) {
          var actual = props[propName] === null ? "null" : "undefined";
          return new Error("The " + location + " `" + propFullName + "` is marked as required in `" + componentName + "`, but its value is `" + actual + "`.");
        }
        return null;
      } else {
        return validator2.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));
      }
    });
  }
  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
}
function isSymbol(propType, propValue) {
  if (propType === "symbol") {
    return true;
  }
  if (propValue["@@toStringTag"] === "Symbol") {
    return true;
  }
  if (typeof Symbol === "function" && propValue instanceof Symbol) {
    return true;
  }
  return false;
}
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return "array";
  }
  if (propValue instanceof RegExp) {
    return "object";
  }
  if (isSymbol(propType, propValue)) {
    return "symbol";
  }
  return propType;
}
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === "object") {
    if (propValue instanceof Date) {
      return "date";
    } else if (propValue instanceof RegExp) {
      return "regexp";
    }
  }
  return propType;
}
function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
  return createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
    return untracked(function() {
      if (allowNativeType) {
        if (getPropType(props[propName]) === mobxType.toLowerCase())
          return null;
      }
      var mobxChecker;
      switch (mobxType) {
        case "Array":
          mobxChecker = isObservableArray;
          break;
        case "Object":
          mobxChecker = isObservableObject;
          break;
        case "Map":
          mobxChecker = isObservableMap;
          break;
        default:
          throw new Error("Unexpected mobxType: " + mobxType);
      }
      var propValue = props[propName];
      if (!mobxChecker(propValue)) {
        var preciseType = getPreciseType(propValue);
        var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
      }
      return null;
    });
  });
}
function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
  return createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      rest[_key2 - 5] = arguments[_key2];
    }
    return untracked(function() {
      if (typeof typeChecker !== "function") {
        return new Error("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation.");
      } else {
        var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName, location, propFullName);
        if (error instanceof Error)
          return error;
        var propValue = props[propName];
        for (var i = 0; i < propValue.length; i++) {
          error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + "[" + i + "]"].concat(rest));
          if (error instanceof Error)
            return error;
        }
        return null;
      }
    });
  });
}
var observableArray = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Array");
var observableArrayOf = /* @__PURE__ */ createObservableArrayOfTypeChecker.bind(null, false);
var observableMap = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Map");
var observableObject = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Object");
var arrayOrObservableArray = /* @__PURE__ */ createObservableTypeCheckerCreator(true, "Array");
var arrayOrObservableArrayOf = /* @__PURE__ */ createObservableArrayOfTypeChecker.bind(null, true);
var objectOrObservableObject = /* @__PURE__ */ createObservableTypeCheckerCreator(true, "Object");
var PropTypes = {
  observableArray,
  observableArrayOf,
  observableMap,
  observableObject,
  arrayOrObservableArray,
  arrayOrObservableArrayOf,
  objectOrObservableObject
};
if (!reactExports.Component)
  throw new Error("mobx-react requires React to be available");
if (!observable)
  throw new Error("mobx-react requires mobx to be available");
const mobxreact_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MobXProviderContext,
  Observer: ObserverComponent,
  PropTypes,
  Provider,
  disposeOnUnmount,
  enableStaticRendering,
  inject,
  isUsingStaticRendering,
  observer,
  observerBatching,
  useAsObservableSource,
  useLocalObservable,
  useLocalStore,
  useObserver,
  useStaticRendering
}, Symbol.toStringTag, { value: "Module" }));
const require$$46 = /* @__PURE__ */ getAugmentedNamespace(mobxreact_esm);
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames)
    return classnames.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes2 = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes2.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes2.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes2.push(arg.toString());
              continue;
            }
            for (var key2 in arg) {
              if (hasOwn2.call(arg, key2) && arg[key2]) {
                classes2.push(key2);
              }
            }
          }
        }
        return classes2.join(" ");
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  return classnames.exports;
}
/*! For license information please see redoc.browser.lib.js.LICENSE.txt */
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    return function() {
      var e2 = { 260: function(e3, t3, r3) {
        var n3 = r3(15), o = r3.n(n3), i = r3(645), s = r3.n(i)()(o());
        s.push([e3.id, ".ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0;position:absolute}.ps__rail-y{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0;position:absolute}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{display:block;background-color:transparent}.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y,.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y{opacity:.6}.ps .ps__rail-x:hover,.ps .ps__rail-y:hover,.ps .ps__rail-x:focus,.ps .ps__rail-y:focus,.ps .ps__rail-x.ps--clicking,.ps .ps__rail-y.ps--clicking{background-color:#eee;opacity:.9}.ps__thumb-x{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px;position:absolute}.ps__thumb-y{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px;right:2px;position:absolute}.ps__rail-x:hover>.ps__thumb-x,.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x.ps--clicking .ps__thumb-x{background-color:#999;height:11px}.ps__rail-y:hover>.ps__thumb-y,.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y.ps--clicking .ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style: none){.ps{overflow:auto!important}}@media screen and (-ms-high-contrast: active),(-ms-high-contrast: none){.ps{overflow:auto!important}}\n", "", { version: 3, sources: ["webpack://./node_modules/perfect-scrollbar/css/perfect-scrollbar.css"], names: [], mappings: "AAGA,IACE,yBAAA,CACA,oBAAA,CACA,uBAAA,CACA,iBAAA,CACA,qBAAA,CAMF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,WAAA,CAEA,QAAA,CAEA,iBAAA,CAGF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,UAAA,CAEA,OAAA,CAEA,iBAAA,CAGF,oDAEE,aAAA,CACA,4BAAA,CAGF,oJAME,UAAA,CAGF,kJAME,qBAAA,CACA,UAAA,CAMF,aACE,qBAAA,CAnEF,iBAAA,CAqEE,6DAAA,CACA,qEAAA,CACA,UAAA,CAEA,UAAA,CAEA,iBAAA,CAGF,aACE,qBAAA,CA/EF,iBAAA,CAiFE,4DAAA,CACA,oEAAA,CACA,SAAA,CAEA,SAAA,CAEA,iBAAA,CAGF,oGAGE,qBAAA,CACA,WAAA,CAGF,oGAGE,qBAAA,CACA,UAAA,CAIF,qCACE,IACE,uBAAA,CAAA,CAIJ,wEACE,IACE,uBAAA,CAAA", sourcesContent: ["/*\n * Container style\n */\n.ps {\n  overflow: hidden !important;\n  overflow-anchor: none;\n  -ms-overflow-style: none;\n  touch-action: auto;\n  -ms-touch-action: auto;\n}\n\n/*\n * Scrollbar rail styles\n */\n.ps__rail-x {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  height: 15px;\n  /* there must be 'bottom' or 'top' for ps__rail-x */\n  bottom: 0px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-y {\n  display: none;\n  opacity: 0;\n  transition: background-color .2s linear, opacity .2s linear;\n  -webkit-transition: background-color .2s linear, opacity .2s linear;\n  width: 15px;\n  /* there must be 'right' or 'left' for ps__rail-y */\n  right: 0;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps--active-x > .ps__rail-x,\n.ps--active-y > .ps__rail-y {\n  display: block;\n  background-color: transparent;\n}\n\n.ps:hover > .ps__rail-x,\n.ps:hover > .ps__rail-y,\n.ps--focus > .ps__rail-x,\n.ps--focus > .ps__rail-y,\n.ps--scrolling-x > .ps__rail-x,\n.ps--scrolling-y > .ps__rail-y {\n  opacity: 0.6;\n}\n\n.ps .ps__rail-x:hover,\n.ps .ps__rail-y:hover,\n.ps .ps__rail-x:focus,\n.ps .ps__rail-y:focus,\n.ps .ps__rail-x.ps--clicking,\n.ps .ps__rail-y.ps--clicking {\n  background-color: #eee;\n  opacity: 0.9;\n}\n\n/*\n * Scrollbar thumb styles\n */\n.ps__thumb-x {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, height .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, height .2s ease-in-out;\n  height: 6px;\n  /* there must be 'bottom' for ps__thumb-x */\n  bottom: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__thumb-y {\n  background-color: #aaa;\n  border-radius: 6px;\n  transition: background-color .2s linear, width .2s ease-in-out;\n  -webkit-transition: background-color .2s linear, width .2s ease-in-out;\n  width: 6px;\n  /* there must be 'right' for ps__thumb-y */\n  right: 2px;\n  /* please don't change 'position' */\n  position: absolute;\n}\n\n.ps__rail-x:hover > .ps__thumb-x,\n.ps__rail-x:focus > .ps__thumb-x,\n.ps__rail-x.ps--clicking .ps__thumb-x {\n  background-color: #999;\n  height: 11px;\n}\n\n.ps__rail-y:hover > .ps__thumb-y,\n.ps__rail-y:focus > .ps__thumb-y,\n.ps__rail-y.ps--clicking .ps__thumb-y {\n  background-color: #999;\n  width: 11px;\n}\n\n/* MS supports */\n@supports (-ms-overflow-style: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n\n@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {\n  .ps {\n    overflow: auto !important;\n  }\n}\n"], sourceRoot: "" }]), t3.Z = s;
      }, 645: function(e3) {
        e3.exports = function(e4) {
          var t3 = [];
          return t3.toString = function() {
            return this.map(function(t4) {
              var r3 = e4(t4);
              return t4[2] ? "@media ".concat(t4[2], " {").concat(r3, "}") : r3;
            }).join("");
          }, t3.i = function(e5, r3, n3) {
            "string" == typeof e5 && (e5 = [[null, e5, ""]]);
            var o = {};
            if (n3)
              for (var i = 0; i < this.length; i++) {
                var s = this[i][0];
                null != s && (o[s] = true);
              }
            for (var a = 0; a < e5.length; a++) {
              var l2 = [].concat(e5[a]);
              n3 && o[l2[0]] || (r3 && (l2[2] ? l2[2] = "".concat(r3, " and ").concat(l2[2]) : l2[2] = r3), t3.push(l2));
            }
          }, t3;
        };
      }, 15: function(e3) {
        function t3(e4, t4) {
          (null == t4 || t4 > e4.length) && (t4 = e4.length);
          for (var r3 = 0, n3 = new Array(t4); r3 < t4; r3++)
            n3[r3] = e4[r3];
          return n3;
        }
        e3.exports = function(e4) {
          var r3, n3, o = (n3 = 4, function(e5) {
            if (Array.isArray(e5))
              return e5;
          }(r3 = e4) || function(e5, t4) {
            var r4 = e5 && ("undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"]);
            if (null != r4) {
              var n4, o2, i2 = [], s2 = true, a2 = false;
              try {
                for (r4 = r4.call(e5); !(s2 = (n4 = r4.next()).done) && (i2.push(n4.value), !t4 || i2.length !== t4); s2 = true)
                  ;
              } catch (e6) {
                a2 = true, o2 = e6;
              } finally {
                try {
                  s2 || null == r4.return || r4.return();
                } finally {
                  if (a2)
                    throw o2;
                }
              }
              return i2;
            }
          }(r3, n3) || function(e5, r4) {
            if (e5) {
              if ("string" == typeof e5)
                return t3(e5, r4);
              var n4 = Object.prototype.toString.call(e5).slice(8, -1);
              return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? t3(e5, r4) : void 0;
            }
          }(r3, n3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }()), i = o[1], s = o[3];
          if ("function" == typeof btoa) {
            var a = btoa(unescape(encodeURIComponent(JSON.stringify(s)))), l2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a), c2 = "/*# ".concat(l2, " */"), p2 = s.sources.map(function(e5) {
              return "/*# sourceURL=".concat(s.sourceRoot || "").concat(e5, " */");
            });
            return [i].concat(p2).concat([c2]).join("\n");
          }
          return [i].join("\n");
        };
      }, 825: function(e3) {
        e3.exports = {};
      }, 388: function(e3, t3, r3) {
        r3.d(t3, { ZP: function() {
          return i;
        } });
        var n3 = requireLunr(), o = (e4, t4, r4) => new Promise((n4, o2) => {
          var i2 = (e5) => {
            try {
              a2(r4.next(e5));
            } catch (e6) {
              o2(e6);
            }
          }, s2 = (e5) => {
            try {
              a2(r4.throw(e5));
            } catch (e6) {
              o2(e6);
            }
          }, a2 = (e5) => e5.done ? n4(e5.value) : Promise.resolve(e5.value).then(i2, s2);
          a2((r4 = r4.apply(e4, t4)).next());
        });
        class i {
          constructor() {
            this.add = d2, this.done = h2, this.search = b2, this.toJS = m2, this.load = g2, this.dispose = y2, this.fromExternalJS = f2;
          }
        }
        let s, a, l2, c2 = [];
        function p2() {
          s = new n3.Builder(), s.field("title"), s.field("description"), s.ref("ref"), s.pipeline.add(n3.trimmer, n3.stopWordFilter, n3.stemmer), l2 = new Promise((e4) => {
            a = e4;
          });
        }
        n3.tokenizer.separator = /\s+/, p2();
        const u2 = (e4) => {
          const t4 = n3.trimmer(new n3.Token(e4, {}));
          return "*" + n3.stemmer(t4) + "*";
        };
        function d2(e4, t4, r4) {
          const n4 = c2.push(r4) - 1, o2 = { title: e4.toLowerCase(), description: t4.toLowerCase(), ref: n4 };
          s.add(o2);
        }
        function h2() {
          return o(this, null, function* () {
            a(s.build());
          });
        }
        function m2() {
          return o(this, null, function* () {
            return { store: c2, index: (yield l2).toJSON() };
          });
        }
        function f2(e4, t4) {
          return o(this, null, function* () {
            try {
              if (importScripts(e4), !self[t4])
                throw new Error("Broken index file format");
              g2(self[t4]);
            } catch (e5) {
              console.error("Failed to load search index: " + e5.message);
            }
          });
        }
        function g2(e4) {
          return o(this, null, function* () {
            c2 = e4.store, a(n3.Index.load(e4.index));
          });
        }
        function y2() {
          return o(this, null, function* () {
            c2 = [], p2();
          });
        }
        function b2(e4, t4 = 0) {
          return o(this, null, function* () {
            if (0 === e4.trim().length)
              return [];
            let r4 = (yield l2).query((t5) => {
              e4.trim().toLowerCase().split(/\s+/).forEach((e5) => {
                if (1 === e5.length)
                  return;
                const r5 = u2(e5);
                t5.term(r5, {});
              });
            });
            return t4 > 0 && (r4 = r4.slice(0, t4)), r4.map((e5) => ({ meta: c2[e5.ref], score: e5.score }));
          });
        }
      }, 342: function(e3, t3, r3) {
        const n3 = r3(376), o = {}.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
        function i(e4, t4) {
          function r4(e5, t5) {
            return n3.stringify(e5) === n3.stringify(Object.assign({}, e5, t5));
          }
          return r4(e4, t4) && r4(t4, e4);
        }
        function s(e4) {
          let t4 = (e4 = e4.replace("[]", "Array")).split("/");
          return t4[0] = t4[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_"), t4.join("/");
        }
        String.prototype.toCamelCase = function() {
          return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(e4, t4) {
            return t4.toUpperCase();
          });
        }, e3.exports = { colour: o, uniqueOnly: function(e4, t4, r4) {
          return r4.indexOf(e4) === t4;
        }, hasDuplicates: function(e4) {
          return new Set(e4).size !== e4.length;
        }, allSame: function(e4) {
          return new Set(e4).size <= 1;
        }, distinctArray: function(e4) {
          return e4.length === function(e5) {
            let t4 = [];
            for (let r4 of e5)
              t4.find(function(e6, t5, n4) {
                return i(e6, r4);
              }) || t4.push(r4);
            return t4;
          }(e4).length;
        }, firstDupe: function(e4) {
          return e4.find(function(t4, r4, n4) {
            return e4.indexOf(t4) < r4;
          });
        }, hash: function(e4) {
          let t4, r4 = 0;
          if (0 === e4.length)
            return r4;
          for (let n4 = 0; n4 < e4.length; n4++)
            t4 = e4.charCodeAt(n4), r4 = (r4 << 5) - r4 + t4, r4 |= 0;
          return r4;
        }, parameterTypeProperties: ["format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "minLength", "maxLength", "multipleOf", "minItems", "maxItems", "uniqueItems", "minProperties", "maxProperties", "additionalProperties", "pattern", "enum", "default"], arrayProperties: ["items", "minItems", "maxItems", "uniqueItems"], httpMethods: ["get", "post", "put", "delete", "patch", "head", "options", "trace"], sanitise: s, sanitiseAll: function(e4) {
          return s(e4.split("/").join("_"));
        } };
      }, 856: function(e3, t3, r3) {
        const n3 = r3(825), o = r3(470), i = r3(416), s = r3(416), a = r3(66), l2 = r3(53).jptr, c2 = r3(401).recurse, p2 = r3(683).clone, u2 = r3(593).dereference, d2 = r3(592).isRef, h2 = r3(342);
        function m2(e4, t4, r4, n4, o2, s2) {
          let a2 = s2.externalRefs[r4 + n4].paths[0], u3 = i.parse(o2), m3 = {}, f3 = 1;
          for (; f3; )
            f3 = 0, c2(e4, { identityDetection: true }, function(e5, r5, n5) {
              if (d2(e5, r5)) {
                if (e5[r5].startsWith("#"))
                  if (m3[e5[r5]] || e5.$fixed) {
                    if (!e5.$fixed) {
                      let t5 = (a2 + "/" + m3[e5[r5]]).split("/#/").join("/");
                      n5.parent[n5.pkey] = { $ref: t5, "x-miro": e5[r5], $fixed: true }, s2.verbose > 1 && console.warn("Replacing with", t5), f3++;
                    }
                  } else {
                    let o3 = p2(l2(t4, e5[r5]));
                    if (s2.verbose > 1 && console.warn((false === o3 ? h2.colour.red : h2.colour.green) + "Fragment resolution", e5[r5], h2.colour.normal), false === o3) {
                      if (n5.parent[n5.pkey] = {}, s2.fatal) {
                        let t5 = new Error("Fragment $ref resolution failed " + e5[r5]);
                        if (!s2.promise)
                          throw t5;
                        s2.promise.reject(t5);
                      }
                    } else
                      f3++, n5.parent[n5.pkey] = o3, m3[e5[r5]] = n5.path.replace("/%24ref", "");
                  }
                else if (u3.protocol) {
                  let t5 = i.resolve(o2, e5[r5]).toString();
                  s2.verbose > 1 && console.warn(h2.colour.yellow + "Rewriting external url ref", e5[r5], "as", t5, h2.colour.normal), e5["x-miro"] = e5[r5], s2.externalRefs[e5[r5]] && (s2.externalRefs[t5] || (s2.externalRefs[t5] = s2.externalRefs[e5[r5]]), s2.externalRefs[t5].failed = s2.externalRefs[e5[r5]].failed), e5[r5] = t5;
                } else if (!e5["x-miro"]) {
                  let t5 = i.resolve(o2, e5[r5]).toString(), n6 = false;
                  s2.externalRefs[e5[r5]] && (n6 = s2.externalRefs[e5[r5]].failed), n6 || (s2.verbose > 1 && console.warn(h2.colour.yellow + "Rewriting external ref", e5[r5], "as", t5, h2.colour.normal), e5["x-miro"] = e5[r5], e5[r5] = t5);
                }
              }
            });
          return c2(e4, {}, function(e5, t5, r5) {
            d2(e5, t5) && void 0 !== e5.$fixed && delete e5.$fixed;
          }), s2.verbose > 1 && console.warn("Finished fragment resolution"), e4;
        }
        function f2(e4, t4) {
          if (!t4.filters || !t4.filters.length)
            return e4;
          for (let r4 of t4.filters)
            e4 = r4(e4, t4);
          return e4;
        }
        function g2(e4, t4, r4, s2) {
          var c3 = i.parse(r4.source), u3 = r4.source.split("\\").join("/").split("/");
          u3.pop() || u3.pop();
          let d3 = "", h3 = t4.split("#");
          h3.length > 1 && (d3 = "#" + h3[1], t4 = h3[0]), u3 = u3.join("/");
          let g3 = (y3 = i.parse(t4).protocol, b3 = c3.protocol, y3 && y3.length > 2 ? y3 : b3 && b3.length > 2 ? b3 : "file:");
          var y3, b3;
          let x3;
          if (x3 = "file:" === g3 ? o.resolve(u3 ? u3 + "/" : "", t4) : i.resolve(u3 ? u3 + "/" : "", t4), r4.cache[x3]) {
            r4.verbose && console.warn("CACHED", x3, d3);
            let e5 = p2(r4.cache[x3]), n4 = r4.externalRef = e5;
            if (d3 && (n4 = l2(n4, d3), false === n4 && (n4 = {}, r4.fatal))) {
              let e6 = new Error("Cached $ref resolution failed " + x3 + d3);
              if (!r4.promise)
                throw e6;
              r4.promise.reject(e6);
            }
            return n4 = m2(n4, e5, t4, d3, x3, r4), n4 = f2(n4, r4), s2(p2(n4), x3, r4), Promise.resolve(n4);
          }
          if (r4.verbose && console.warn("GET", x3, d3), r4.handlers && r4.handlers[g3])
            return r4.handlers[g3](u3, t4, d3, r4).then(function(e5) {
              return r4.externalRef = e5, e5 = f2(e5, r4), r4.cache[x3] = e5, s2(e5, x3, r4), e5;
            }).catch(function(e5) {
              throw r4.verbose && console.warn(e5), e5;
            });
          if (g3 && g3.startsWith("http")) {
            const e5 = Object.assign({}, r4.fetchOptions, { agent: r4.agent });
            return r4.fetch(x3, e5).then(function(e6) {
              if (200 !== e6.status) {
                if (r4.ignoreIOErrors)
                  return r4.verbose && console.warn("FAILED", t4), r4.externalRefs[t4].failed = true, '{"$ref":"' + t4 + '"}';
                throw new Error(`Received status code ${e6.status}: ${x3}`);
              }
              return e6.text();
            }).then(function(e6) {
              try {
                let n4 = a.parse(e6, { schema: "core", prettyErrors: true });
                if (e6 = r4.externalRef = n4, r4.cache[x3] = p2(e6), d3 && false === (e6 = l2(e6, d3)) && (e6 = {}, r4.fatal)) {
                  let e7 = new Error("Remote $ref resolution failed " + x3 + d3);
                  if (!r4.promise)
                    throw e7;
                  r4.promise.reject(e7);
                }
                e6 = f2(e6 = m2(e6, n4, t4, d3, x3, r4), r4);
              } catch (e7) {
                if (r4.verbose && console.warn(e7), !r4.promise || !r4.fatal)
                  throw e7;
                r4.promise.reject(e7);
              }
              return s2(e6, x3, r4), e6;
            }).catch(function(e6) {
              if (r4.verbose && console.warn(e6), r4.cache[x3] = {}, !r4.promise || !r4.fatal)
                throw e6;
              r4.promise.reject(e6);
            });
          }
          {
            const e5 = '{"$ref":"' + t4 + '"}';
            return function(e6, t5, r5, o2, i2) {
              return new Promise(function(s3, a2) {
                n3.readFile(e6, t5, function(e7, t6) {
                  e7 ? r5.ignoreIOErrors && i2 ? (r5.verbose && console.warn("FAILED", o2), r5.externalRefs[o2].failed = true, s3(i2)) : a2(e7) : s3(t6);
                });
              });
            }(x3, r4.encoding || "utf8", r4, t4, e5).then(function(e6) {
              try {
                let n4 = a.parse(e6, { schema: "core", prettyErrors: true });
                if (e6 = r4.externalRef = n4, r4.cache[x3] = p2(e6), d3 && false === (e6 = l2(e6, d3)) && (e6 = {}, r4.fatal)) {
                  let e7 = new Error("File $ref resolution failed " + x3 + d3);
                  if (!r4.promise)
                    throw e7;
                  r4.promise.reject(e7);
                }
                e6 = f2(e6 = m2(e6, n4, t4, d3, x3, r4), r4);
              } catch (e7) {
                if (r4.verbose && console.warn(e7), !r4.promise || !r4.fatal)
                  throw e7;
                r4.promise.reject(e7);
              }
              return s2(e6, x3, r4), e6;
            }).catch(function(e6) {
              if (r4.verbose && console.warn(e6), !r4.promise || !r4.fatal)
                throw e6;
              r4.promise.reject(e6);
            });
          }
        }
        function y2(e4) {
          return new Promise(function(t4, r4) {
            (function(e5) {
              return new Promise(function(t5, r5) {
                function n5(t6, r6, n6) {
                  if (t6[r6] && d2(t6[r6], "$ref")) {
                    let i2 = t6[r6].$ref;
                    if (!i2.startsWith("#")) {
                      let s2 = "";
                      if (!o2[i2]) {
                        let t7 = Object.keys(o2).find(function(e6, t8, r7) {
                          return i2.startsWith(e6 + "/");
                        });
                        t7 && (e5.verbose && console.warn("Found potential subschema at", t7), s2 = "/" + (i2.split("#")[1] || "").replace(t7.split("#")[1] || ""), s2 = s2.split("/undefined").join(""), i2 = t7);
                      }
                      if (o2[i2] || (o2[i2] = { resolved: false, paths: [], extras: {}, description: t6[r6].description }), o2[i2].resolved)
                        if (o2[i2].failed)
                          ;
                        else if (e5.rewriteRefs) {
                          let n7 = o2[i2].resolvedAt;
                          e5.verbose > 1 && console.warn("Rewriting ref", i2, n7), t6[r6]["x-miro"] = i2, t6[r6].$ref = n7 + s2;
                        } else
                          t6[r6] = p2(o2[i2].data);
                      else
                        o2[i2].paths.push(n6.path), o2[i2].extras[n6.path] = s2;
                    }
                  }
                }
                let o2 = e5.externalRefs;
                if (e5.resolver.depth > 0 && e5.source === e5.resolver.base)
                  return t5(o2);
                c2(e5.openapi.definitions, { identityDetection: true, path: "#/definitions" }, n5), c2(e5.openapi.components, { identityDetection: true, path: "#/components" }, n5), c2(e5.openapi, { identityDetection: true }, n5), t5(o2);
              });
            })(e4).then(function(t5) {
              for (let r5 in t5)
                if (!t5[r5].resolved) {
                  let n5 = e4.resolver.depth;
                  n5 > 0 && n5++, e4.resolver.actions[n5].push(function() {
                    return g2(e4.openapi, r5, e4, function(e5, n6, o2) {
                      if (!t5[r5].resolved) {
                        let i3 = {};
                        i3.context = t5[r5], i3.$ref = r5, i3.original = p2(e5), i3.updated = e5, i3.source = n6, o2.externals.push(i3), t5[r5].resolved = true;
                      }
                      let i2 = Object.assign({}, o2, { source: "", resolver: { actions: o2.resolver.actions, depth: o2.resolver.actions.length - 1, base: o2.resolver.base } });
                      o2.patch && t5[r5].description && !e5.description && "object" == typeof e5 && (e5.description = t5[r5].description), t5[r5].data = e5;
                      let s2 = (a2 = t5[r5].paths, [...new Set(a2)]);
                      var a2;
                      s2 = s2.sort(function(e6, t6) {
                        const r6 = e6.startsWith("#/components/") || e6.startsWith("#/definitions/"), n7 = t6.startsWith("#/components/") || t6.startsWith("#/definitions/");
                        return r6 && !n7 ? -1 : n7 && !r6 ? 1 : 0;
                      });
                      for (let n7 of s2)
                        if (t5[r5].resolvedAt && n7 !== t5[r5].resolvedAt && n7.indexOf("x-ms-examples/") < 0)
                          o2.verbose > 1 && console.warn("Creating pointer to data at", n7), l2(o2.openapi, n7, { $ref: t5[r5].resolvedAt + t5[r5].extras[n7], "x-miro": r5 + t5[r5].extras[n7] });
                        else {
                          t5[r5].resolvedAt ? o2.verbose > 1 && console.warn("Avoiding circular reference") : (t5[r5].resolvedAt = n7, o2.verbose > 1 && console.warn("Creating initial clone of data at", n7));
                          let i3 = p2(e5);
                          l2(o2.openapi, n7, i3);
                        }
                      0 === o2.resolver.actions[i2.resolver.depth].length && o2.resolver.actions[i2.resolver.depth].push(function() {
                        return y2(i2);
                      });
                    });
                  });
                }
            }).catch(function(t5) {
              e4.verbose && console.warn(t5), r4(t5);
            });
            let n4 = { options: e4 };
            n4.actions = e4.resolver.actions[e4.resolver.depth], t4(n4);
          });
        }
        function b2(e4, t4, r4) {
          e4.resolver.actions.push([]), y2(e4).then(function(n4) {
            var o2;
            (o2 = n4.actions, o2.reduce((e5, t5) => e5.then((e6) => t5().then(Array.prototype.concat.bind(e6))), Promise.resolve([]))).then(function() {
              if (e4.resolver.depth >= e4.resolver.actions.length)
                return console.warn("Ran off the end of resolver actions"), t4(true);
              e4.resolver.depth++, e4.resolver.actions[e4.resolver.depth].length ? setTimeout(function() {
                b2(n4.options, t4, r4);
              }, 0) : (e4.verbose > 1 && console.warn(h2.colour.yellow + "Finished external resolution!", h2.colour.normal), e4.resolveInternal && (e4.verbose > 1 && console.warn(h2.colour.yellow + "Starting internal resolution!", h2.colour.normal), e4.openapi = u2(e4.openapi, e4.original, { verbose: e4.verbose - 1 }), e4.verbose > 1 && console.warn(h2.colour.yellow + "Finished internal resolution!", h2.colour.normal)), c2(e4.openapi, {}, function(t5, r5, n5) {
                d2(t5, r5) && (e4.preserveMiro || delete t5["x-miro"]);
              }), t4(e4));
            }).catch(function(t5) {
              e4.verbose && console.warn(t5), r4(t5);
            });
          }).catch(function(t5) {
            e4.verbose && console.warn(t5), r4(t5);
          });
        }
        function x2(e4) {
          if (e4.cache || (e4.cache = {}), e4.fetch || (e4.fetch = s), e4.source) {
            let t4 = i.parse(e4.source);
            (!t4.protocol || t4.protocol.length <= 2) && (e4.source = o.resolve(e4.source));
          }
          e4.externals = [], e4.externalRefs = {}, e4.rewriteRefs = true, e4.resolver = {}, e4.resolver.depth = 0, e4.resolver.base = e4.source, e4.resolver.actions = [[]];
        }
        e3.exports = { optionalResolve: function(e4) {
          return x2(e4), new Promise(function(t4, r4) {
            e4.resolve ? b2(e4, t4, r4) : t4(e4);
          });
        }, resolve: function(e4, t4, r4) {
          return r4 || (r4 = {}), r4.openapi = e4, r4.source = t4, r4.resolve = true, x2(r4), new Promise(function(e5, t5) {
            b2(r4, e5, t5);
          });
        } };
      }, 804: function(e3) {
        function t3() {
          return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: true, combine: false, allowRefSiblings: false };
        }
        e3.exports = { getDefaultState: t3, walkSchema: function e4(r3, n3, o, i) {
          if (void 0 === o.depth && (o = t3()), null == r3)
            return r3;
          if (void 0 !== r3.$ref) {
            let e5 = { $ref: r3.$ref };
            return o.allowRefSiblings && r3.description && (e5.description = r3.description), i(e5, n3, o), e5;
          }
          if (o.combine && (r3.allOf && Array.isArray(r3.allOf) && 1 === r3.allOf.length && delete (r3 = Object.assign({}, r3.allOf[0], r3)).allOf, r3.anyOf && Array.isArray(r3.anyOf) && 1 === r3.anyOf.length && delete (r3 = Object.assign({}, r3.anyOf[0], r3)).anyOf, r3.oneOf && Array.isArray(r3.oneOf) && 1 === r3.oneOf.length && delete (r3 = Object.assign({}, r3.oneOf[0], r3)).oneOf), i(r3, n3, o), o.seen.has(r3))
            return r3;
          if ("object" == typeof r3 && null !== r3 && o.seen.set(r3, true), o.top = false, o.depth++, void 0 !== r3.items && (o.property = "items", e4(r3.items, r3, o, i)), r3.additionalItems && "object" == typeof r3.additionalItems && (o.property = "additionalItems", e4(r3.additionalItems, r3, o, i)), r3.additionalProperties && "object" == typeof r3.additionalProperties && (o.property = "additionalProperties", e4(r3.additionalProperties, r3, o, i)), r3.properties)
            for (let t4 in r3.properties) {
              let n4 = r3.properties[t4];
              o.property = "properties/" + t4, e4(n4, r3, o, i);
            }
          if (r3.patternProperties)
            for (let t4 in r3.patternProperties) {
              let n4 = r3.patternProperties[t4];
              o.property = "patternProperties/" + t4, e4(n4, r3, o, i);
            }
          if (r3.allOf)
            for (let t4 in r3.allOf) {
              let n4 = r3.allOf[t4];
              o.property = "allOf/" + t4, e4(n4, r3, o, i);
            }
          if (r3.anyOf)
            for (let t4 in r3.anyOf) {
              let n4 = r3.anyOf[t4];
              o.property = "anyOf/" + t4, e4(n4, r3, o, i);
            }
          if (r3.oneOf)
            for (let t4 in r3.oneOf) {
              let n4 = r3.oneOf[t4];
              o.property = "oneOf/" + t4, e4(n4, r3, o, i);
            }
          return r3.not && (o.property = "not", e4(r3.not, r3, o, i)), o.depth--, r3;
        } };
      }, 470: function(e3) {
        function t3(e4) {
          if ("string" != typeof e4)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e4));
        }
        function r3(e4, t4) {
          for (var r4, n4 = "", o = 0, i = -1, s = 0, a = 0; a <= e4.length; ++a) {
            if (a < e4.length)
              r4 = e4.charCodeAt(a);
            else {
              if (47 === r4)
                break;
              r4 = 47;
            }
            if (47 === r4) {
              if (i === a - 1 || 1 === s)
                ;
              else if (i !== a - 1 && 2 === s) {
                if (n4.length < 2 || 2 !== o || 46 !== n4.charCodeAt(n4.length - 1) || 46 !== n4.charCodeAt(n4.length - 2)) {
                  if (n4.length > 2) {
                    var l2 = n4.lastIndexOf("/");
                    if (l2 !== n4.length - 1) {
                      -1 === l2 ? (n4 = "", o = 0) : o = (n4 = n4.slice(0, l2)).length - 1 - n4.lastIndexOf("/"), i = a, s = 0;
                      continue;
                    }
                  } else if (2 === n4.length || 1 === n4.length) {
                    n4 = "", o = 0, i = a, s = 0;
                    continue;
                  }
                }
                t4 && (n4.length > 0 ? n4 += "/.." : n4 = "..", o = 2);
              } else
                n4.length > 0 ? n4 += "/" + e4.slice(i + 1, a) : n4 = e4.slice(i + 1, a), o = a - i - 1;
              i = a, s = 0;
            } else
              46 === r4 && -1 !== s ? ++s : s = -1;
          }
          return n4;
        }
        var n3 = { resolve: function() {
          for (var e4, n4 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var s;
            i >= 0 ? s = arguments[i] : (void 0 === e4 && (e4 = process.cwd()), s = e4), t3(s), 0 !== s.length && (n4 = s + "/" + n4, o = 47 === s.charCodeAt(0));
          }
          return n4 = r3(n4, !o), o ? n4.length > 0 ? "/" + n4 : "/" : n4.length > 0 ? n4 : ".";
        }, normalize: function(e4) {
          if (t3(e4), 0 === e4.length)
            return ".";
          var n4 = 47 === e4.charCodeAt(0), o = 47 === e4.charCodeAt(e4.length - 1);
          return 0 !== (e4 = r3(e4, !n4)).length || n4 || (e4 = "."), e4.length > 0 && o && (e4 += "/"), n4 ? "/" + e4 : e4;
        }, isAbsolute: function(e4) {
          return t3(e4), e4.length > 0 && 47 === e4.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var e4, r4 = 0; r4 < arguments.length; ++r4) {
            var o = arguments[r4];
            t3(o), o.length > 0 && (void 0 === e4 ? e4 = o : e4 += "/" + o);
          }
          return void 0 === e4 ? "." : n3.normalize(e4);
        }, relative: function(e4, r4) {
          if (t3(e4), t3(r4), e4 === r4)
            return "";
          if ((e4 = n3.resolve(e4)) === (r4 = n3.resolve(r4)))
            return "";
          for (var o = 1; o < e4.length && 47 === e4.charCodeAt(o); ++o)
            ;
          for (var i = e4.length, s = i - o, a = 1; a < r4.length && 47 === r4.charCodeAt(a); ++a)
            ;
          for (var l2 = r4.length - a, c2 = s < l2 ? s : l2, p2 = -1, u2 = 0; u2 <= c2; ++u2) {
            if (u2 === c2) {
              if (l2 > c2) {
                if (47 === r4.charCodeAt(a + u2))
                  return r4.slice(a + u2 + 1);
                if (0 === u2)
                  return r4.slice(a + u2);
              } else
                s > c2 && (47 === e4.charCodeAt(o + u2) ? p2 = u2 : 0 === u2 && (p2 = 0));
              break;
            }
            var d2 = e4.charCodeAt(o + u2);
            if (d2 !== r4.charCodeAt(a + u2))
              break;
            47 === d2 && (p2 = u2);
          }
          var h2 = "";
          for (u2 = o + p2 + 1; u2 <= i; ++u2)
            u2 !== i && 47 !== e4.charCodeAt(u2) || (0 === h2.length ? h2 += ".." : h2 += "/..");
          return h2.length > 0 ? h2 + r4.slice(a + p2) : (a += p2, 47 === r4.charCodeAt(a) && ++a, r4.slice(a));
        }, _makeLong: function(e4) {
          return e4;
        }, dirname: function(e4) {
          if (t3(e4), 0 === e4.length)
            return ".";
          for (var r4 = e4.charCodeAt(0), n4 = 47 === r4, o = -1, i = true, s = e4.length - 1; s >= 1; --s)
            if (47 === (r4 = e4.charCodeAt(s))) {
              if (!i) {
                o = s;
                break;
              }
            } else
              i = false;
          return -1 === o ? n4 ? "/" : "." : n4 && 1 === o ? "//" : e4.slice(0, o);
        }, basename: function(e4, r4) {
          if (void 0 !== r4 && "string" != typeof r4)
            throw new TypeError('"ext" argument must be a string');
          t3(e4);
          var n4, o = 0, i = -1, s = true;
          if (void 0 !== r4 && r4.length > 0 && r4.length <= e4.length) {
            if (r4.length === e4.length && r4 === e4)
              return "";
            var a = r4.length - 1, l2 = -1;
            for (n4 = e4.length - 1; n4 >= 0; --n4) {
              var c2 = e4.charCodeAt(n4);
              if (47 === c2) {
                if (!s) {
                  o = n4 + 1;
                  break;
                }
              } else
                -1 === l2 && (s = false, l2 = n4 + 1), a >= 0 && (c2 === r4.charCodeAt(a) ? -1 == --a && (i = n4) : (a = -1, i = l2));
            }
            return o === i ? i = l2 : -1 === i && (i = e4.length), e4.slice(o, i);
          }
          for (n4 = e4.length - 1; n4 >= 0; --n4)
            if (47 === e4.charCodeAt(n4)) {
              if (!s) {
                o = n4 + 1;
                break;
              }
            } else
              -1 === i && (s = false, i = n4 + 1);
          return -1 === i ? "" : e4.slice(o, i);
        }, extname: function(e4) {
          t3(e4);
          for (var r4 = -1, n4 = 0, o = -1, i = true, s = 0, a = e4.length - 1; a >= 0; --a) {
            var l2 = e4.charCodeAt(a);
            if (47 !== l2)
              -1 === o && (i = false, o = a + 1), 46 === l2 ? -1 === r4 ? r4 = a : 1 !== s && (s = 1) : -1 !== r4 && (s = -1);
            else if (!i) {
              n4 = a + 1;
              break;
            }
          }
          return -1 === r4 || -1 === o || 0 === s || 1 === s && r4 === o - 1 && r4 === n4 + 1 ? "" : e4.slice(r4, o);
        }, format: function(e4) {
          if (null === e4 || "object" != typeof e4)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e4);
          return function(e5, t4) {
            var r4 = t4.dir || t4.root, n4 = t4.base || (t4.name || "") + (t4.ext || "");
            return r4 ? r4 === t4.root ? r4 + n4 : r4 + "/" + n4 : n4;
          }(0, e4);
        }, parse: function(e4) {
          t3(e4);
          var r4 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === e4.length)
            return r4;
          var n4, o = e4.charCodeAt(0), i = 47 === o;
          i ? (r4.root = "/", n4 = 1) : n4 = 0;
          for (var s = -1, a = 0, l2 = -1, c2 = true, p2 = e4.length - 1, u2 = 0; p2 >= n4; --p2)
            if (47 !== (o = e4.charCodeAt(p2)))
              -1 === l2 && (c2 = false, l2 = p2 + 1), 46 === o ? -1 === s ? s = p2 : 1 !== u2 && (u2 = 1) : -1 !== s && (u2 = -1);
            else if (!c2) {
              a = p2 + 1;
              break;
            }
          return -1 === s || -1 === l2 || 0 === u2 || 1 === u2 && s === l2 - 1 && s === a + 1 ? -1 !== l2 && (r4.base = r4.name = 0 === a && i ? e4.slice(1, l2) : e4.slice(a, l2)) : (0 === a && i ? (r4.name = e4.slice(1, s), r4.base = e4.slice(1, l2)) : (r4.name = e4.slice(a, s), r4.base = e4.slice(a, l2)), r4.ext = e4.slice(s, l2)), a > 0 ? r4.dir = e4.slice(0, a - 1) : i && (r4.dir = "/"), r4;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n3.posix = n3, e3.exports = n3;
      }, 683: function(e3) {
        e3.exports = { nop: function(e4) {
          return e4;
        }, clone: function(e4) {
          return JSON.parse(JSON.stringify(e4));
        }, shallowClone: function(e4) {
          let t3 = {};
          for (let r3 in e4)
            e4.hasOwnProperty(r3) && (t3[r3] = e4[r3]);
          return t3;
        }, deepClone: function e4(t3) {
          let r3 = Array.isArray(t3) ? [] : {};
          for (let n3 in t3)
            (t3.hasOwnProperty(n3) || Array.isArray(t3)) && (r3[n3] = "object" == typeof t3[n3] ? e4(t3[n3]) : t3[n3]);
          return r3;
        }, fastClone: function(e4) {
          return Object.assign({}, e4);
        }, circularClone: function e4(t3, r3) {
          if (r3 || (r3 = /* @__PURE__ */ new WeakMap()), Object(t3) !== t3 || t3 instanceof Function)
            return t3;
          if (r3.has(t3))
            return r3.get(t3);
          try {
            var n3 = new t3.constructor();
          } catch (e5) {
            n3 = Object.create(Object.getPrototypeOf(t3));
          }
          return r3.set(t3, n3), Object.assign(n3, ...Object.keys(t3).map((n4) => ({ [n4]: e4(t3[n4], r3) })));
        } };
      }, 593: function(e3, t3, r3) {
        const n3 = r3(401).recurse, o = r3(683).shallowClone, i = r3(53).jptr, s = r3(592).isRef;
        e3.exports = { dereference: function e4(t4, r4, a) {
          a || (a = {}), a.cache || (a.cache = {}), a.state || (a.state = {}), a.state.identityDetection = true, a.depth = a.depth ? a.depth + 1 : 1;
          let l2 = a.depth > 1 ? t4 : o(t4), c2 = { data: l2 }, p2 = a.depth > 1 ? r4 : o(r4);
          a.master || (a.master = l2);
          let u2 = function(e5) {
            return e5 && e5.verbose ? { warn: function() {
              var e6 = Array.prototype.slice.call(arguments);
              console.warn.apply(console, e6);
            } } : { warn: function() {
            } };
          }(a), d2 = 1;
          for (; d2 > 0; )
            d2 = 0, n3(c2, a.state, function(t5, r5, n4) {
              if (s(t5, r5)) {
                let o2 = t5[r5];
                if (d2++, a.cache[o2]) {
                  let e5 = a.cache[o2];
                  if (e5.resolved)
                    u2.warn("Patching %s for %s", o2, e5.path), n4.parent[n4.pkey] = e5.data, a.$ref && "object" == typeof n4.parent[n4.pkey] && (n4.parent[n4.pkey][a.$ref] = o2);
                  else {
                    if (o2 === e5.path)
                      throw new Error(`Tight circle at ${e5.path}`);
                    u2.warn("Unresolved ref"), n4.parent[n4.pkey] = i(e5.source, e5.path), false === n4.parent[n4.pkey] && (n4.parent[n4.pkey] = i(e5.source, e5.key)), a.$ref && "object" == typeof n4.parent[n4.pkey] && (n4.parent[a.$ref] = o2);
                  }
                } else {
                  let t6 = {};
                  t6.path = n4.path.split("/$ref")[0], t6.key = o2, u2.warn("Dereffing %s at %s", o2, t6.path), t6.source = p2, t6.data = i(t6.source, t6.key), false === t6.data && (t6.data = i(a.master, t6.key), t6.source = a.master), false === t6.data && u2.warn("Missing $ref target", t6.key), a.cache[o2] = t6, t6.data = n4.parent[n4.pkey] = e4(i(t6.source, t6.key), t6.source, a), a.$ref && "object" == typeof n4.parent[n4.pkey] && (n4.parent[n4.pkey][a.$ref] = o2), t6.resolved = true;
                }
              }
            });
          return c2.data;
        } };
      }, 592: function(e3) {
        e3.exports = { isRef: function(e4, t3) {
          return "$ref" === t3 && !!e4 && "string" == typeof e4[t3];
        } };
      }, 53: function(e3) {
        function t3(e4) {
          return e4.replace(/\~1/g, "/").replace(/~0/g, "~");
        }
        e3.exports = { jptr: function(e4, r3, n3) {
          if (void 0 === e4)
            return false;
          if (!r3 || "string" != typeof r3 || "#" === r3)
            return void 0 !== n3 ? n3 : e4;
          if (r3.indexOf("#") >= 0) {
            let e5 = r3.split("#");
            if (e5[0])
              return false;
            r3 = e5[1], r3 = decodeURIComponent(r3.slice(1).split("+").join(" "));
          }
          r3.startsWith("/") && (r3 = r3.slice(1));
          let o = r3.split("/");
          for (let r4 = 0; r4 < o.length; r4++) {
            o[r4] = t3(o[r4]);
            let i = void 0 !== n3 && r4 == o.length - 1, s = parseInt(o[r4], 10);
            if (!Array.isArray(e4) || isNaN(s) || s.toString() !== o[r4] ? s = Array.isArray(e4) && "-" === o[r4] ? -2 : -1 : o[r4] = r4 > 0 ? o[r4 - 1] : "", -1 != s || e4 && e4.hasOwnProperty(o[r4]))
              if (s >= 0)
                i && (e4[s] = n3), e4 = e4[s];
              else {
                if (-2 === s)
                  return i ? (Array.isArray(e4) && e4.push(n3), n3) : void 0;
                i && (e4[o[r4]] = n3), e4 = e4[o[r4]];
              }
            else {
              if (void 0 === n3 || "object" != typeof e4 || Array.isArray(e4))
                return false;
              e4[o[r4]] = i ? n3 : "0" === o[r4 + 1] || "-" === o[r4 + 1] ? [] : {}, e4 = e4[o[r4]];
            }
          }
          return e4;
        }, jpescape: function(e4) {
          return e4.replace(/\~/g, "~0").replace(/\//g, "~1");
        }, jpunescape: t3 };
      }, 401: function(e3, t3, r3) {
        const n3 = r3(53).jpescape;
        e3.exports = { recurse: function e4(t4, r4, o) {
          if (r4 || (r4 = { depth: 0 }), r4.depth || (r4 = Object.assign({}, { path: "#", depth: 0, pkey: "", parent: {}, payload: {}, seen: /* @__PURE__ */ new WeakMap(), identity: false, identityDetection: false }, r4)), "object" != typeof t4)
            return;
          let i = r4.path;
          for (let s in t4) {
            if (r4.key = s, r4.path = r4.path + "/" + encodeURIComponent(n3(s)), r4.identityPath = r4.seen.get(t4[s]), r4.identity = void 0 !== r4.identityPath, t4.hasOwnProperty(s) && o(t4, s, r4), "object" == typeof t4[s] && !r4.identity) {
              r4.identityDetection && !Array.isArray(t4[s]) && null !== t4[s] && r4.seen.set(t4[s], r4.path);
              let n4 = {};
              n4.parent = t4, n4.path = r4.path, n4.depth = r4.depth ? r4.depth + 1 : 1, n4.pkey = s, n4.payload = r4.payload, n4.seen = r4.seen, n4.identity = false, n4.identityDetection = r4.identityDetection, e4(t4[s], n4, o);
            }
            r4.path = i;
          }
        } };
      }, 232: function(e3, t3, r3) {
        r3.r(t3);
        var n3 = r3(379), o = r3.n(n3), i = r3(795), s = r3.n(i), a = r3(569), l2 = r3.n(a), c2 = r3(565), p2 = r3.n(c2), u2 = r3(216), d2 = r3.n(u2), h2 = r3(589), m2 = r3.n(h2), f2 = r3(260), g2 = {};
        g2.styleTagTransform = m2(), g2.setAttributes = p2(), g2.insert = l2().bind(null, "head"), g2.domAPI = s(), g2.insertStyleElement = d2(), o()(f2.Z, g2), t3.default = f2.Z && f2.Z.locals ? f2.Z.locals : void 0;
      }, 379: function(e3) {
        var t3 = [];
        function r3(e4) {
          for (var r4 = -1, n4 = 0; n4 < t3.length; n4++)
            if (t3[n4].identifier === e4) {
              r4 = n4;
              break;
            }
          return r4;
        }
        function n3(e4, n4) {
          for (var i = {}, s = [], a = 0; a < e4.length; a++) {
            var l2 = e4[a], c2 = n4.base ? l2[0] + n4.base : l2[0], p2 = i[c2] || 0, u2 = "".concat(c2, " ").concat(p2);
            i[c2] = p2 + 1;
            var d2 = r3(u2), h2 = { css: l2[1], media: l2[2], sourceMap: l2[3], supports: l2[4], layer: l2[5] };
            if (-1 !== d2)
              t3[d2].references++, t3[d2].updater(h2);
            else {
              var m2 = o(h2, n4);
              n4.byIndex = a, t3.splice(a, 0, { identifier: u2, updater: m2, references: 1 });
            }
            s.push(u2);
          }
          return s;
        }
        function o(e4, t4) {
          var r4 = t4.domAPI(t4);
          return r4.update(e4), function(t5) {
            if (t5) {
              if (t5.css === e4.css && t5.media === e4.media && t5.sourceMap === e4.sourceMap && t5.supports === e4.supports && t5.layer === e4.layer)
                return;
              r4.update(e4 = t5);
            } else
              r4.remove();
          };
        }
        e3.exports = function(e4, o2) {
          var i = n3(e4 = e4 || [], o2 = o2 || {});
          return function(e5) {
            e5 = e5 || [];
            for (var s = 0; s < i.length; s++) {
              var a = r3(i[s]);
              t3[a].references--;
            }
            for (var l2 = n3(e5, o2), c2 = 0; c2 < i.length; c2++) {
              var p2 = r3(i[c2]);
              0 === t3[p2].references && (t3[p2].updater(), t3.splice(p2, 1));
            }
            i = l2;
          };
        };
      }, 569: function(e3) {
        var t3 = {};
        e3.exports = function(e4, r3) {
          var n3 = function(e5) {
            if (void 0 === t3[e5]) {
              var r4 = document.querySelector(e5);
              if (window.HTMLIFrameElement && r4 instanceof window.HTMLIFrameElement)
                try {
                  r4 = r4.contentDocument.head;
                } catch (e6) {
                  r4 = null;
                }
              t3[e5] = r4;
            }
            return t3[e5];
          }(e4);
          if (!n3)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          n3.appendChild(r3);
        };
      }, 216: function(e3) {
        e3.exports = function(e4) {
          var t3 = document.createElement("style");
          return e4.setAttributes(t3, e4.attributes), e4.insert(t3, e4.options), t3;
        };
      }, 565: function(e3, t3, r3) {
        e3.exports = function(e4) {
          var t4 = r3.nc;
          t4 && e4.setAttribute("nonce", t4);
        };
      }, 795: function(e3) {
        e3.exports = function(e4) {
          var t3 = e4.insertStyleElement(e4);
          return { update: function(r3) {
            !function(e5, t4, r4) {
              var n3 = "";
              r4.supports && (n3 += "@supports (".concat(r4.supports, ") {")), r4.media && (n3 += "@media ".concat(r4.media, " {"));
              var o = void 0 !== r4.layer;
              o && (n3 += "@layer".concat(r4.layer.length > 0 ? " ".concat(r4.layer) : "", " {")), n3 += r4.css, o && (n3 += "}"), r4.media && (n3 += "}"), r4.supports && (n3 += "}");
              var i = r4.sourceMap;
              i && "undefined" != typeof btoa && (n3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i)))), " */")), t4.styleTagTransform(n3, e5, t4.options);
            }(t3, e4, r3);
          }, remove: function() {
            !function(e5) {
              if (null === e5.parentNode)
                return false;
              e5.parentNode.removeChild(e5);
            }(t3);
          } };
        };
      }, 589: function(e3) {
        e3.exports = function(e4, t3) {
          if (t3.styleSheet)
            t3.styleSheet.cssText = e4;
          else {
            for (; t3.firstChild; )
              t3.removeChild(t3.firstChild);
            t3.appendChild(document.createTextNode(e4));
          }
        };
      }, 925: function(e3, t3, r3) {
        const n3 = r3(825), o = r3(416), i = (r3(470), r3(766)), s = r3(416), a = r3(66), l2 = r3(53), c2 = l2.jptr, p2 = r3(592).isRef, u2 = r3(683).clone, d2 = r3(683).circularClone, h2 = r3(401).recurse, m2 = r3(856), f2 = r3(804), g2 = r3(342), y2 = r3(711).statusCodes, b2 = r3(109).i8, x2 = "3.0.0";
        let v2;
        class w2 extends Error {
          constructor(e4) {
            super(e4), this.name = "S2OError";
          }
        }
        function k2(e4, t4) {
          let r4 = new w2(e4);
          if (r4.options = t4, !t4.promise)
            throw r4;
          t4.promise.reject(r4);
        }
        function O2(e4, t4, r4) {
          r4.warnOnly ? t4[r4.warnProperty || "x-s2o-warning"] = e4 : k2(e4, r4);
        }
        function E2(e4, t4) {
          f2.walkSchema(e4, {}, {}, function(e5, r4, n4) {
            !function(e6, t5) {
              if (e6["x-required"] && Array.isArray(e6["x-required"]) && (e6.required || (e6.required = []), e6.required = e6.required.concat(e6["x-required"]), delete e6["x-required"]), e6["x-anyOf"] && (e6.anyOf = e6["x-anyOf"], delete e6["x-anyOf"]), e6["x-oneOf"] && (e6.oneOf = e6["x-oneOf"], delete e6["x-oneOf"]), e6["x-not"] && (e6.not = e6["x-not"], delete e6["x-not"]), "boolean" == typeof e6["x-nullable"] && (e6.nullable = e6["x-nullable"], delete e6["x-nullable"]), "object" == typeof e6["x-discriminator"] && "string" == typeof e6["x-discriminator"].propertyName) {
                e6.discriminator = e6["x-discriminator"], delete e6["x-discriminator"];
                for (let t6 in e6.discriminator.mapping) {
                  let r5 = e6.discriminator.mapping[t6];
                  r5.startsWith("#/definitions/") && (e6.discriminator.mapping[t6] = r5.replace("#/definitions/", "#/components/schemas/"));
                }
              }
            }(e5), function(e6, t5, r5) {
              if (e6.nullable && r5.patches++, e6.discriminator && "string" == typeof e6.discriminator && (e6.discriminator = { propertyName: e6.discriminator }), e6.items && Array.isArray(e6.items) && (0 === e6.items.length ? e6.items = {} : 1 === e6.items.length ? e6.items = e6.items[0] : e6.items = { anyOf: e6.items }), e6.type && Array.isArray(e6.type))
                if (r5.patch) {
                  if (r5.patches++, 0 === e6.type.length)
                    delete e6.type;
                  else {
                    e6.oneOf || (e6.oneOf = []);
                    for (let t6 of e6.type) {
                      let r6 = {};
                      if ("null" === t6)
                        e6.nullable = true;
                      else {
                        r6.type = t6;
                        for (let t7 of g2.arrayProperties)
                          void 0 !== e6.prop && (r6[t7] = e6[t7], delete e6[t7]);
                      }
                      r6.type && e6.oneOf.push(r6);
                    }
                    delete e6.type, 0 === e6.oneOf.length ? delete e6.oneOf : e6.oneOf.length < 2 && (e6.type = e6.oneOf[0].type, Object.keys(e6.oneOf[0]).length > 1 && O2("Lost properties from oneOf", e6, r5), delete e6.oneOf);
                  }
                  e6.type && Array.isArray(e6.type) && 1 === e6.type.length && (e6.type = e6.type[0]);
                } else
                  k2("(Patchable) schema type must not be an array", r5);
              e6.type && "null" === e6.type && (delete e6.type, e6.nullable = true), "array" !== e6.type || e6.items || (e6.items = {}), "file" === e6.type && (e6.type = "string", e6.format = "binary"), "boolean" == typeof e6.required && (e6.required && e6.name && (void 0 === t5.required && (t5.required = []), Array.isArray(t5.required) && t5.required.push(e6.name)), delete e6.required), e6.xml && "string" == typeof e6.xml.namespace && (e6.xml.namespace || delete e6.xml.namespace), void 0 !== e6.allowEmptyValue && (r5.patches++, delete e6.allowEmptyValue);
            }(e5, r4, t4);
          });
        }
        function j(e4, t4, r4) {
          let n4 = r4.payload.options;
          if (p2(e4, t4)) {
            if (e4[t4].startsWith("#/components/"))
              ;
            else if ("#/consumes" === e4[t4])
              delete e4[t4], r4.parent[r4.pkey] = u2(n4.openapi.consumes);
            else if ("#/produces" === e4[t4])
              delete e4[t4], r4.parent[r4.pkey] = u2(n4.openapi.produces);
            else if (e4[t4].startsWith("#/definitions/")) {
              let r5 = e4[t4].replace("#/definitions/", "").split("/");
              const o3 = l2.jpunescape(r5[0]);
              let i2 = v2.schemas[decodeURIComponent(o3)];
              i2 ? r5[0] = i2 : O2("Could not resolve reference " + e4[t4], e4, n4), e4[t4] = "#/components/schemas/" + r5.join("/");
            } else if (e4[t4].startsWith("#/parameters/"))
              e4[t4] = "#/components/parameters/" + g2.sanitise(e4[t4].replace("#/parameters/", ""));
            else if (e4[t4].startsWith("#/responses/"))
              e4[t4] = "#/components/responses/" + g2.sanitise(e4[t4].replace("#/responses/", ""));
            else if (e4[t4].startsWith("#")) {
              let r5 = u2(l2.jptr(n4.openapi, e4[t4]));
              if (false === r5)
                O2("direct $ref not found " + e4[t4], e4, n4);
              else if (n4.refmap[e4[t4]])
                e4[t4] = n4.refmap[e4[t4]];
              else {
                let i2 = e4[t4];
                i2 = i2.replace("/properties/headers/", ""), i2 = i2.replace("/properties/responses/", ""), i2 = i2.replace("/properties/parameters/", ""), i2 = i2.replace("/properties/schemas/", "");
                let s2 = "schemas", a2 = i2.lastIndexOf("/schema");
                if (s2 = i2.indexOf("/headers/") > a2 ? "headers" : i2.indexOf("/responses/") > a2 ? "responses" : i2.indexOf("/example") > a2 ? "examples" : i2.indexOf("/x-") > a2 ? "extensions" : i2.indexOf("/parameters/") > a2 ? "parameters" : "schemas", "schemas" === s2 && E2(r5, n4), "responses" !== s2 && "extensions" !== s2) {
                  let i3 = s2.substr(0, s2.length - 1);
                  "parameter" === i3 && r5.name && r5.name === g2.sanitise(r5.name) && (i3 = encodeURIComponent(r5.name));
                  let a3 = 1;
                  for (e4["x-miro"] && (o2 = (o2 = e4["x-miro"]).indexOf("#") >= 0 ? o2.split("#")[1].split("/").pop() : o2.split("/").pop().split(".")[0], i3 = encodeURIComponent(g2.sanitise(o2)), a3 = ""); l2.jptr(n4.openapi, "#/components/" + s2 + "/" + i3 + a3); )
                    a3 = "" === a3 ? 2 : ++a3;
                  let c3 = "#/components/" + s2 + "/" + i3 + a3, p3 = "";
                  "examples" === s2 && (r5 = { value: r5 }, p3 = "/value"), l2.jptr(n4.openapi, c3, r5), n4.refmap[e4[t4]] = c3 + p3, e4[t4] = c3 + p3;
                }
              }
            }
            if (delete e4["x-miro"], Object.keys(e4).length > 1) {
              const o3 = e4[t4], i2 = r4.path.indexOf("/schema") >= 0;
              "preserve" === n4.refSiblings || (i2 && "allOf" === n4.refSiblings ? (delete e4.$ref, r4.parent[r4.pkey] = { allOf: [{ $ref: o3 }, e4] }) : r4.parent[r4.pkey] = { $ref: o3 });
            }
          }
          var o2;
          if ("x-ms-odata" === t4 && "string" == typeof e4[t4] && e4[t4].startsWith("#/")) {
            let r5 = e4[t4].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/"), o3 = v2.schemas[decodeURIComponent(r5[0])];
            o3 ? r5[0] = o3 : O2("Could not resolve reference " + e4[t4], e4, n4), e4[t4] = "#/components/schemas/" + r5.join("/");
          }
        }
        function $2(e4) {
          for (let t4 in e4)
            for (let r4 in e4[t4]) {
              let n4 = g2.sanitise(r4);
              r4 !== n4 && (e4[t4][n4] = e4[t4][r4], delete e4[t4][r4]);
            }
        }
        function S2(e4, t4) {
          if ("basic" === e4.type && (e4.type = "http", e4.scheme = "basic"), "oauth2" === e4.type) {
            let r4 = {}, n4 = e4.flow;
            "application" === e4.flow && (n4 = "clientCredentials"), "accessCode" === e4.flow && (n4 = "authorizationCode"), void 0 !== e4.authorizationUrl && (r4.authorizationUrl = e4.authorizationUrl.split("?")[0].trim() || "/"), "string" == typeof e4.tokenUrl && (r4.tokenUrl = e4.tokenUrl.split("?")[0].trim() || "/"), r4.scopes = e4.scopes || {}, e4.flows = {}, e4.flows[n4] = r4, delete e4.flow, delete e4.authorizationUrl, delete e4.tokenUrl, delete e4.scopes, void 0 !== e4.name && (t4.patch ? (t4.patches++, delete e4.name) : k2("(Patchable) oauth2 securitySchemes should not have name property", t4));
          }
        }
        function C2(e4) {
          return e4 && !e4["x-s2o-delete"];
        }
        function P2(e4, t4) {
          if (e4.$ref)
            e4.$ref = e4.$ref.replace("#/responses/", "#/components/responses/");
          else {
            e4.type && !e4.schema && (e4.schema = {}), e4.type && (e4.schema.type = e4.type), e4.items && "array" !== e4.items.type && (e4.items.collectionFormat !== e4.collectionFormat && O2("Nested collectionFormats are not supported", e4, t4), delete e4.items.collectionFormat), "array" === e4.type ? ("ssv" === e4.collectionFormat ? O2("collectionFormat:ssv is no longer supported for headers", e4, t4) : "pipes" === e4.collectionFormat ? O2("collectionFormat:pipes is no longer supported for headers", e4, t4) : "multi" === e4.collectionFormat ? e4.explode = true : "tsv" === e4.collectionFormat ? (O2("collectionFormat:tsv is no longer supported", e4, t4), e4["x-collectionFormat"] = "tsv") : e4.style = "simple", delete e4.collectionFormat) : e4.collectionFormat && (t4.patch ? (t4.patches++, delete e4.collectionFormat) : k2("(Patchable) collectionFormat is only applicable to header.type array", t4)), delete e4.type;
            for (let t5 of g2.parameterTypeProperties)
              void 0 !== e4[t5] && (e4.schema[t5] = e4[t5], delete e4[t5]);
            for (let t5 of g2.arrayProperties)
              void 0 !== e4[t5] && (e4.schema[t5] = e4[t5], delete e4[t5]);
          }
        }
        function A2(e4, t4) {
          if (e4.$ref.indexOf("#/parameters/") >= 0) {
            let t5 = e4.$ref.split("#/parameters/");
            e4.$ref = t5[0] + "#/components/parameters/" + g2.sanitise(t5[1]);
          }
          e4.$ref.indexOf("#/definitions/") >= 0 && O2("Definition used as parameter", e4, t4);
        }
        function I2(e4, t4, r4, n4, o2, i2, s2) {
          let a2, l3 = {}, p3 = true;
          if (t4 && t4.consumes && "string" == typeof t4.consumes) {
            if (!s2.patch)
              return k2("(Patchable) operation.consumes must be an array", s2);
            s2.patches++, t4.consumes = [t4.consumes];
          }
          Array.isArray(i2.consumes) || delete i2.consumes;
          let d3 = ((t4 ? t4.consumes : null) || i2.consumes || []).filter(g2.uniqueOnly);
          if (e4 && e4.$ref && "string" == typeof e4.$ref) {
            A2(e4, s2);
            let t5 = decodeURIComponent(e4.$ref.replace("#/components/parameters/", "")), r5 = false, n5 = i2.components.parameters[t5];
            if (n5 && !n5["x-s2o-delete"] || !e4.$ref.startsWith("#/") || (e4["x-s2o-delete"] = true, r5 = true), r5) {
              let t6 = e4.$ref, r6 = c2(i2, e4.$ref);
              !r6 && t6.startsWith("#/") ? O2("Could not resolve reference " + t6, e4, s2) : r6 && (e4 = r6);
            }
          }
          if (e4 && (e4.name || e4.in)) {
            "boolean" == typeof e4["x-deprecated"] && (e4.deprecated = e4["x-deprecated"], delete e4["x-deprecated"]), void 0 !== e4["x-example"] && (e4.example = e4["x-example"], delete e4["x-example"]), "body" === e4.in || e4.type || (s2.patch ? (s2.patches++, e4.type = "string") : k2("(Patchable) parameter.type is mandatory for non-body parameters", s2)), e4.type && "object" == typeof e4.type && e4.type.$ref && (e4.type = c2(i2, e4.type.$ref)), "file" === e4.type && (e4["x-s2o-originalType"] = e4.type, a2 = e4.type), e4.description && "object" == typeof e4.description && e4.description.$ref && (e4.description = c2(i2, e4.description.$ref)), null === e4.description && delete e4.description;
            let t5 = e4.collectionFormat;
            if ("array" !== e4.type || t5 || (t5 = "csv"), t5 && ("array" !== e4.type && (s2.patch ? (s2.patches++, delete e4.collectionFormat) : k2("(Patchable) collectionFormat is only applicable to param.type array", s2)), "csv" !== t5 || "query" !== e4.in && "cookie" !== e4.in || (e4.style = "form", e4.explode = false), "csv" !== t5 || "path" !== e4.in && "header" !== e4.in || (e4.style = "simple"), "ssv" === t5 && ("query" === e4.in ? e4.style = "spaceDelimited" : O2("collectionFormat:ssv is no longer supported except for in:query parameters", e4, s2)), "pipes" === t5 && ("query" === e4.in ? e4.style = "pipeDelimited" : O2("collectionFormat:pipes is no longer supported except for in:query parameters", e4, s2)), "multi" === t5 && (e4.explode = true), "tsv" === t5 && (O2("collectionFormat:tsv is no longer supported", e4, s2), e4["x-collectionFormat"] = "tsv"), delete e4.collectionFormat), e4.type && "body" !== e4.type && "formData" !== e4.in)
              if (e4.items && e4.schema)
                O2("parameter has array,items and schema", e4, s2);
              else {
                e4.schema && s2.patches++, e4.schema && "object" == typeof e4.schema || (e4.schema = {}), e4.schema.type = e4.type, e4.items && (e4.schema.items = e4.items, delete e4.items, h2(e4.schema.items, null, function(r5, n5, o3) {
                  "collectionFormat" === n5 && "string" == typeof r5[n5] && (t5 && r5[n5] !== t5 && O2("Nested collectionFormats are not supported", e4, s2), delete r5[n5]);
                }));
                for (let t6 of g2.parameterTypeProperties)
                  void 0 !== e4[t6] && (e4.schema[t6] = e4[t6]), delete e4[t6];
              }
            e4.schema && E2(e4.schema, s2), e4["x-ms-skip-url-encoding"] && "query" === e4.in && (e4.allowReserved = true, delete e4["x-ms-skip-url-encoding"]);
          }
          if (e4 && "formData" === e4.in) {
            p3 = false, l3.content = {};
            let t5 = "application/x-www-form-urlencoded";
            if (d3.length && d3.indexOf("multipart/form-data") >= 0 && (t5 = "multipart/form-data"), l3.content[t5] = {}, e4.schema)
              l3.content[t5].schema = e4.schema, e4.schema.$ref && (l3["x-s2o-name"] = decodeURIComponent(e4.schema.$ref.replace("#/components/schemas/", "")));
            else {
              l3.content[t5].schema = {}, l3.content[t5].schema.type = "object", l3.content[t5].schema.properties = {}, l3.content[t5].schema.properties[e4.name] = {};
              let r5 = l3.content[t5].schema, n5 = l3.content[t5].schema.properties[e4.name];
              e4.description && (n5.description = e4.description), e4.example && (n5.example = e4.example), e4.type && (n5.type = e4.type);
              for (let t6 of g2.parameterTypeProperties)
                void 0 !== e4[t6] && (n5[t6] = e4[t6]);
              true === e4.required && (r5.required || (r5.required = []), r5.required.push(e4.name), l3.required = true), void 0 !== e4.default && (n5.default = e4.default), n5.properties && (n5.properties = e4.properties), e4.allOf && (n5.allOf = e4.allOf), "array" === e4.type && e4.items && (n5.items = e4.items, n5.items.collectionFormat && delete n5.items.collectionFormat), "file" !== a2 && "file" !== e4["x-s2o-originalType"] || (n5.type = "string", n5.format = "binary"), T2(e4, n5);
            }
          } else
            e4 && "file" === e4.type && (e4.required && (l3.required = e4.required), l3.content = {}, l3.content["application/octet-stream"] = {}, l3.content["application/octet-stream"].schema = {}, l3.content["application/octet-stream"].schema.type = "string", l3.content["application/octet-stream"].schema.format = "binary", T2(e4, l3));
          if (e4 && "body" === e4.in) {
            l3.content = {}, e4.name && (l3["x-s2o-name"] = (t4 && t4.operationId ? g2.sanitiseAll(t4.operationId) : "") + ("_" + e4.name).toCamelCase()), e4.description && (l3.description = e4.description), e4.required && (l3.required = e4.required), t4 && s2.rbname && e4.name && (t4[s2.rbname] = e4.name), e4.schema && e4.schema.$ref ? l3["x-s2o-name"] = decodeURIComponent(e4.schema.$ref.replace("#/components/schemas/", "")) : e4.schema && "array" === e4.schema.type && e4.schema.items && e4.schema.items.$ref && (l3["x-s2o-name"] = decodeURIComponent(e4.schema.items.$ref.replace("#/components/schemas/", "")) + "Array"), d3.length || d3.push("application/json");
            for (let t5 of d3)
              l3.content[t5] = {}, l3.content[t5].schema = u2(e4.schema || {}), E2(l3.content[t5].schema, s2);
            T2(e4, l3);
          }
          if (Object.keys(l3).length > 0 && (e4["x-s2o-delete"] = true, t4) && (t4.requestBody && p3 ? (t4.requestBody["x-s2o-overloaded"] = true, O2("Operation " + (t4.operationId || o2) + " has multiple requestBodies", t4, s2)) : (t4.requestBody || (t4 = r4[n4] = function(e5, t5) {
            let r5 = {};
            for (let n5 of Object.keys(e5))
              r5[n5] = e5[n5], "parameters" === n5 && (r5.requestBody = {}, t5.rbname && (r5[t5.rbname] = ""));
            return r5.requestBody = {}, r5;
          }(t4, s2)), t4.requestBody.content && t4.requestBody.content["multipart/form-data"] && t4.requestBody.content["multipart/form-data"].schema && t4.requestBody.content["multipart/form-data"].schema.properties && l3.content["multipart/form-data"] && l3.content["multipart/form-data"].schema && l3.content["multipart/form-data"].schema.properties ? (t4.requestBody.content["multipart/form-data"].schema.properties = Object.assign(t4.requestBody.content["multipart/form-data"].schema.properties, l3.content["multipart/form-data"].schema.properties), t4.requestBody.content["multipart/form-data"].schema.required = (t4.requestBody.content["multipart/form-data"].schema.required || []).concat(l3.content["multipart/form-data"].schema.required || []), t4.requestBody.content["multipart/form-data"].schema.required.length || delete t4.requestBody.content["multipart/form-data"].schema.required) : t4.requestBody.content && t4.requestBody.content["application/x-www-form-urlencoded"] && t4.requestBody.content["application/x-www-form-urlencoded"].schema && t4.requestBody.content["application/x-www-form-urlencoded"].schema.properties && l3.content["application/x-www-form-urlencoded"] && l3.content["application/x-www-form-urlencoded"].schema && l3.content["application/x-www-form-urlencoded"].schema.properties ? (t4.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(t4.requestBody.content["application/x-www-form-urlencoded"].schema.properties, l3.content["application/x-www-form-urlencoded"].schema.properties), t4.requestBody.content["application/x-www-form-urlencoded"].schema.required = (t4.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(l3.content["application/x-www-form-urlencoded"].schema.required || []), t4.requestBody.content["application/x-www-form-urlencoded"].schema.required.length || delete t4.requestBody.content["application/x-www-form-urlencoded"].schema.required) : (t4.requestBody = Object.assign(t4.requestBody, l3), t4.requestBody["x-s2o-name"] || (t4.requestBody.schema && t4.requestBody.schema.$ref ? t4.requestBody["x-s2o-name"] = decodeURIComponent(t4.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("") : t4.operationId && (t4.requestBody["x-s2o-name"] = g2.sanitiseAll(t4.operationId)))))), e4 && !e4["x-s2o-delete"]) {
            delete e4.type;
            for (let t5 of g2.parameterTypeProperties)
              delete e4[t5];
            "path" !== e4.in || void 0 !== e4.required && true === e4.required || (s2.patch ? (s2.patches++, e4.required = true) : k2("(Patchable) path parameters must be required:true [" + e4.name + " in " + o2 + "]", s2));
          }
          return t4;
        }
        function T2(e4, t4) {
          for (let r4 in e4)
            r4.startsWith("x-") && !r4.startsWith("x-s2o") && (t4[r4] = e4[r4]);
        }
        function _2(e4, t4, r4, n4, o2) {
          if (!e4)
            return false;
          if (e4.$ref && "string" == typeof e4.$ref)
            e4.$ref.indexOf("#/definitions/") >= 0 ? O2("definition used as response: " + e4.$ref, e4, o2) : e4.$ref.startsWith("#/responses/") && (e4.$ref = "#/components/responses/" + g2.sanitise(decodeURIComponent(e4.$ref.replace("#/responses/", ""))));
          else {
            if ((void 0 === e4.description || null === e4.description || "" === e4.description && o2.patch) && (o2.patch ? "object" != typeof e4 || Array.isArray(e4) || (o2.patches++, e4.description = y2[e4] || "") : k2("(Patchable) response.description is mandatory", o2)), void 0 !== e4.schema) {
              if (E2(e4.schema, o2), e4.schema.$ref && "string" == typeof e4.schema.$ref && e4.schema.$ref.startsWith("#/responses/") && (e4.schema.$ref = "#/components/responses/" + g2.sanitise(decodeURIComponent(e4.schema.$ref.replace("#/responses/", "")))), r4 && r4.produces && "string" == typeof r4.produces) {
                if (!o2.patch)
                  return k2("(Patchable) operation.produces must be an array", o2);
                o2.patches++, r4.produces = [r4.produces];
              }
              n4.produces && !Array.isArray(n4.produces) && delete n4.produces;
              let t5 = ((r4 ? r4.produces : null) || n4.produces || []).filter(g2.uniqueOnly);
              t5.length || t5.push("*/*"), e4.content = {};
              for (let r5 of t5) {
                if (e4.content[r5] = {}, e4.content[r5].schema = u2(e4.schema), e4.examples && e4.examples[r5]) {
                  let t6 = {};
                  t6.value = e4.examples[r5], e4.content[r5].examples = {}, e4.content[r5].examples.response = t6, delete e4.examples[r5];
                }
                "file" === e4.content[r5].schema.type && (e4.content[r5].schema = { type: "string", format: "binary" });
              }
              delete e4.schema;
            }
            for (let t5 in e4.examples)
              e4.content || (e4.content = {}), e4.content[t5] || (e4.content[t5] = {}), e4.content[t5].examples = {}, e4.content[t5].examples.response = {}, e4.content[t5].examples.response.value = e4.examples[t5];
            if (delete e4.examples, e4.headers)
              for (let t5 in e4.headers)
                "status code" === t5.toLowerCase() ? o2.patch ? (o2.patches++, delete e4.headers[t5]) : k2('(Patchable) "Status Code" is not a valid header', o2) : P2(e4.headers[t5], o2);
          }
        }
        function R2(e4, t4, r4, n4, i2) {
          for (let s2 in e4) {
            let a2 = e4[s2];
            a2 && a2["x-trace"] && "object" == typeof a2["x-trace"] && (a2.trace = a2["x-trace"], delete a2["x-trace"]), a2 && a2["x-summary"] && "string" == typeof a2["x-summary"] && (a2.summary = a2["x-summary"], delete a2["x-summary"]), a2 && a2["x-description"] && "string" == typeof a2["x-description"] && (a2.description = a2["x-description"], delete a2["x-description"]), a2 && a2["x-servers"] && Array.isArray(a2["x-servers"]) && (a2.servers = a2["x-servers"], delete a2["x-servers"]);
            for (let e5 in a2)
              if (g2.httpMethods.indexOf(e5) >= 0 || "x-amazon-apigateway-any-method" === e5) {
                let p3 = a2[e5];
                if (p3 && p3.parameters && Array.isArray(p3.parameters)) {
                  if (a2.parameters)
                    for (let t5 of a2.parameters)
                      "string" == typeof t5.$ref && (A2(t5, r4), t5 = c2(i2, t5.$ref)), p3.parameters.find(function(e6, r5, n5) {
                        return e6.name === t5.name && e6.in === t5.in;
                      }) || "formData" !== t5.in && "body" !== t5.in && "file" !== t5.type || (p3 = I2(t5, p3, a2, e5, s2, i2, r4), r4.rbname && "" === p3[r4.rbname] && delete p3[r4.rbname]);
                  for (let t5 of p3.parameters)
                    p3 = I2(t5, p3, a2, e5, e5 + ":" + s2, i2, r4);
                  r4.rbname && "" === p3[r4.rbname] && delete p3[r4.rbname], r4.debug || p3.parameters && (p3.parameters = p3.parameters.filter(C2));
                }
                if (p3 && p3.security && $2(p3.security), "object" == typeof p3) {
                  if (!p3.responses) {
                    let e6 = { description: "Default response" };
                    p3.responses = { default: e6 };
                  }
                  for (let e6 in p3.responses)
                    _2(p3.responses[e6], 0, p3, i2, r4);
                }
                if (p3 && p3["x-servers"] && Array.isArray(p3["x-servers"]))
                  p3.servers = p3["x-servers"], delete p3["x-servers"];
                else if (p3 && p3.schemes && p3.schemes.length) {
                  for (let e6 of p3.schemes)
                    if ((!i2.schemes || i2.schemes.indexOf(e6) < 0) && (p3.servers || (p3.servers = []), Array.isArray(i2.servers)))
                      for (let t5 of i2.servers) {
                        let r5 = u2(t5), n5 = o.parse(r5.url);
                        n5.protocol = e6, r5.url = n5.format(), p3.servers.push(r5);
                      }
                }
                if (r4.debug && (p3["x-s2o-consumes"] = p3.consumes || [], p3["x-s2o-produces"] = p3.produces || []), p3) {
                  if (delete p3.consumes, delete p3.produces, delete p3.schemes, p3["x-ms-examples"]) {
                    for (let e6 in p3["x-ms-examples"]) {
                      let t5 = p3["x-ms-examples"][e6], r5 = g2.sanitiseAll(e6);
                      if (t5.parameters)
                        for (let r6 in t5.parameters) {
                          let n5 = t5.parameters[r6];
                          for (let t6 of (p3.parameters || []).concat(a2.parameters || []))
                            t6.$ref && (t6 = l2.jptr(i2, t6.$ref)), t6.name !== r6 || t6.example || (t6.examples || (t6.examples = {}), t6.examples[e6] = { value: n5 });
                        }
                      if (t5.responses)
                        for (let n5 in t5.responses) {
                          if (t5.responses[n5].headers)
                            for (let e7 in t5.responses[n5].headers) {
                              let r6 = t5.responses[n5].headers[e7];
                              for (let t6 in p3.responses[n5].headers)
                                t6 === e7 && (p3.responses[n5].headers[t6].example = r6);
                            }
                          if (t5.responses[n5].body && (i2.components.examples[r5] = { value: u2(t5.responses[n5].body) }, p3.responses[n5] && p3.responses[n5].content))
                            for (let t6 in p3.responses[n5].content) {
                              let o2 = p3.responses[n5].content[t6];
                              o2.examples || (o2.examples = {}), o2.examples[e6] = { $ref: "#/components/examples/" + r5 };
                            }
                        }
                    }
                    delete p3["x-ms-examples"];
                  }
                  if (p3.parameters && 0 === p3.parameters.length && delete p3.parameters, p3.requestBody) {
                    let r5 = p3.operationId ? g2.sanitiseAll(p3.operationId) : g2.sanitiseAll(e5 + s2).toCamelCase(), o2 = g2.sanitise(p3.requestBody["x-s2o-name"] || r5 || "");
                    delete p3.requestBody["x-s2o-name"];
                    let i3 = JSON.stringify(p3.requestBody), a3 = g2.hash(i3);
                    if (!n4[a3]) {
                      let e6 = {};
                      e6.name = o2, e6.body = p3.requestBody, e6.refs = [], n4[a3] = e6;
                    }
                    let c3 = "#/" + t4 + "/" + encodeURIComponent(l2.jpescape(s2)) + "/" + e5 + "/requestBody";
                    n4[a3].refs.push(c3);
                  }
                }
              }
            if (a2 && a2.parameters) {
              for (let e5 in a2.parameters)
                I2(a2.parameters[e5], null, a2, null, s2, i2, r4);
              !r4.debug && Array.isArray(a2.parameters) && (a2.parameters = a2.parameters.filter(C2));
            }
          }
        }
        function L2(e4) {
          return e4 && e4.url && "string" == typeof e4.url ? (e4.url = e4.url.split("{{").join("{"), e4.url = e4.url.split("}}").join("}"), e4.url.replace(/\{(.+?)\}/g, function(t4, r4) {
            e4.variables || (e4.variables = {}), e4.variables[r4] = { default: "unknown" };
          }), e4) : e4;
        }
        function D2(e4, t4, r4) {
          if (void 0 === e4.info || null === e4.info) {
            if (!t4.patch)
              return r4(new w2("(Patchable) info object is mandatory"));
            t4.patches++, e4.info = { version: "", title: "" };
          }
          if ("object" != typeof e4.info || Array.isArray(e4.info))
            return r4(new w2("info must be an object"));
          if (void 0 === e4.info.title || null === e4.info.title) {
            if (!t4.patch)
              return r4(new w2("(Patchable) info.title cannot be null"));
            t4.patches++, e4.info.title = "";
          }
          if (void 0 === e4.info.version || null === e4.info.version) {
            if (!t4.patch)
              return r4(new w2("(Patchable) info.version cannot be null"));
            t4.patches++, e4.info.version = "";
          }
          if ("string" != typeof e4.info.version) {
            if (!t4.patch)
              return r4(new w2("(Patchable) info.version must be a string"));
            t4.patches++, e4.info.version = e4.info.version.toString();
          }
          if (void 0 !== e4.info.logo) {
            if (!t4.patch)
              return r4(new w2("(Patchable) info should not have logo property"));
            t4.patches++, e4.info["x-logo"] = e4.info.logo, delete e4.info.logo;
          }
          if (void 0 !== e4.info.termsOfService) {
            if (null === e4.info.termsOfService) {
              if (!t4.patch)
                return r4(new w2("(Patchable) info.termsOfService cannot be null"));
              t4.patches++, e4.info.termsOfService = "";
            }
            try {
              new URL(e4.info.termsOfService);
            } catch (n4) {
              if (!t4.patch)
                return r4(new w2("(Patchable) info.termsOfService must be a URL"));
              t4.patches++, delete e4.info.termsOfService;
            }
          }
        }
        function z2(e4, t4, r4) {
          if (void 0 === e4.paths) {
            if (!t4.patch)
              return r4(new w2("(Patchable) paths object is mandatory"));
            t4.patches++, e4.paths = {};
          }
        }
        function N2(e4, t4, r4) {
          return i(r4, new Promise(function(r5, n4) {
            if (e4 || (e4 = {}), t4.original = e4, t4.text || (t4.text = a.stringify(e4)), t4.externals = [], t4.externalRefs = {}, t4.rewriteRefs = true, t4.preserveMiro = true, t4.promise = {}, t4.promise.resolve = r5, t4.promise.reject = n4, t4.patches = 0, t4.cache || (t4.cache = {}), t4.source && (t4.cache[t4.source] = t4.original), function(e5, t5) {
              const r6 = /* @__PURE__ */ new WeakSet();
              h2(e5, { identityDetection: true }, function(e6, n5, o3) {
                "object" == typeof e6[n5] && null !== e6[n5] && (r6.has(e6[n5]) ? t5.anchors ? e6[n5] = u2(e6[n5]) : k2("YAML anchor or merge key at " + o3.path, t5) : r6.add(e6[n5]));
              });
            }(e4, t4), e4.openapi && "string" == typeof e4.openapi && e4.openapi.startsWith("3."))
              return t4.openapi = d2(e4), D2(t4.openapi, t4, n4), z2(t4.openapi, t4, n4), void m2.optionalResolve(t4).then(function() {
                return t4.direct ? r5(t4.openapi) : r5(t4);
              }).catch(function(e5) {
                console.warn(e5), n4(e5);
              });
            if (!e4.swagger || "2.0" != e4.swagger)
              return n4(new w2("Unsupported swagger/OpenAPI version: " + (e4.openapi ? e4.openapi : e4.swagger)));
            let o2 = t4.openapi = {};
            if (o2.openapi = "string" == typeof t4.targetVersion && t4.targetVersion.startsWith("3.") ? t4.targetVersion : x2, t4.origin) {
              o2["x-origin"] || (o2["x-origin"] = []);
              let r6 = {};
              r6.url = t4.source || t4.origin, r6.format = "swagger", r6.version = e4.swagger, r6.converter = {}, r6.converter.url = "https://github.com/mermade/oas-kit", r6.converter.version = b2, o2["x-origin"].push(r6);
            }
            if (o2 = Object.assign(o2, d2(e4)), delete o2.swagger, h2(o2, {}, function(e5, t5, r6) {
              null === e5[t5] && !t5.startsWith("x-") && "default" !== t5 && r6.path.indexOf("/example") < 0 && delete e5[t5];
            }), e4.host)
              for (let t5 of Array.isArray(e4.schemes) ? e4.schemes : [""]) {
                let r6 = {}, n5 = (e4.basePath || "").replace(/\/$/, "");
                r6.url = (t5 ? t5 + ":" : "") + "//" + e4.host + n5, L2(r6), o2.servers || (o2.servers = []), o2.servers.push(r6);
              }
            else if (e4.basePath) {
              let t5 = {};
              t5.url = e4.basePath, L2(t5), o2.servers || (o2.servers = []), o2.servers.push(t5);
            }
            if (delete o2.host, delete o2.basePath, o2["x-servers"] && Array.isArray(o2["x-servers"]) && (o2.servers = o2["x-servers"], delete o2["x-servers"]), e4["x-ms-parameterized-host"]) {
              let t5 = e4["x-ms-parameterized-host"], r6 = {};
              r6.url = t5.hostTemplate + (e4.basePath ? e4.basePath : ""), r6.variables = {};
              const n5 = r6.url.match(/\{\w+\}/g);
              for (let e5 in t5.parameters) {
                let i2 = t5.parameters[e5];
                i2.$ref && (i2 = u2(c2(o2, i2.$ref))), e5.startsWith("x-") || (delete i2.required, delete i2.type, delete i2.in, void 0 === i2.default && (i2.enum ? i2.default = i2.enum[0] : i2.default = "none"), i2.name || (i2.name = n5[e5].replace("{", "").replace("}", "")), r6.variables[i2.name] = i2, delete i2.name);
              }
              o2.servers || (o2.servers = []), false === t5.useSchemePrefix ? o2.servers.push(r6) : e4.schemes.forEach((e5) => {
                o2.servers.push(Object.assign({}, r6, { url: e5 + "://" + r6.url }));
              }), delete o2["x-ms-parameterized-host"];
            }
            D2(o2, t4, n4), z2(o2, t4, n4), "string" == typeof o2.consumes && (o2.consumes = [o2.consumes]), "string" == typeof o2.produces && (o2.produces = [o2.produces]), o2.components = {}, o2["x-callbacks"] && (o2.components.callbacks = o2["x-callbacks"], delete o2["x-callbacks"]), o2.components.examples = {}, o2.components.headers = {}, o2["x-links"] && (o2.components.links = o2["x-links"], delete o2["x-links"]), o2.components.parameters = o2.parameters || {}, o2.components.responses = o2.responses || {}, o2.components.requestBodies = {}, o2.components.securitySchemes = o2.securityDefinitions || {}, o2.components.schemas = o2.definitions || {}, delete o2.definitions, delete o2.responses, delete o2.parameters, delete o2.securityDefinitions, m2.optionalResolve(t4).then(function() {
              (function(e5, t5) {
                let r6 = {};
                v2 = { schemas: {} }, e5.security && $2(e5.security);
                for (let r7 in e5.components.securitySchemes) {
                  let n6 = g2.sanitise(r7);
                  r7 !== n6 && (e5.components.securitySchemes[n6] && k2("Duplicate sanitised securityScheme name " + n6, t5), e5.components.securitySchemes[n6] = e5.components.securitySchemes[r7], delete e5.components.securitySchemes[r7]), S2(e5.components.securitySchemes[n6], t5);
                }
                for (let r7 in e5.components.schemas) {
                  let n6 = g2.sanitiseAll(r7), o3 = "";
                  if (r7 !== n6) {
                    for (; e5.components.schemas[n6 + o3]; )
                      o3 = o3 ? ++o3 : 2;
                    e5.components.schemas[n6 + o3] = e5.components.schemas[r7], delete e5.components.schemas[r7];
                  }
                  v2.schemas[r7] = n6 + o3, E2(e5.components.schemas[n6 + o3], t5);
                }
                t5.refmap = {}, h2(e5, { payload: { options: t5 } }, j), function(e6, t6) {
                  for (let r7 in t6.refmap)
                    l2.jptr(e6, r7, { $ref: t6.refmap[r7] });
                }(e5, t5);
                for (let r7 in e5.components.parameters) {
                  let n6 = g2.sanitise(r7);
                  r7 !== n6 && (e5.components.parameters[n6] && k2("Duplicate sanitised parameter name " + n6, t5), e5.components.parameters[n6] = e5.components.parameters[r7], delete e5.components.parameters[r7]), I2(e5.components.parameters[n6], null, null, null, n6, e5, t5);
                }
                for (let r7 in e5.components.responses) {
                  let n6 = g2.sanitise(r7);
                  r7 !== n6 && (e5.components.responses[n6] && k2("Duplicate sanitised response name " + n6, t5), e5.components.responses[n6] = e5.components.responses[r7], delete e5.components.responses[r7]);
                  let o3 = e5.components.responses[n6];
                  if (_2(o3, 0, null, e5, t5), o3.headers)
                    for (let e6 in o3.headers)
                      "status code" === e6.toLowerCase() ? t5.patch ? (t5.patches++, delete o3.headers[e6]) : k2('(Patchable) "Status Code" is not a valid header', t5) : P2(o3.headers[e6], t5);
                }
                for (let t6 in e5.components.requestBodies) {
                  let n6 = e5.components.requestBodies[t6], o3 = JSON.stringify(n6), i2 = g2.hash(o3), s2 = {};
                  s2.name = t6, s2.body = n6, s2.refs = [], r6[i2] = s2;
                }
                if (R2(e5.paths, "paths", t5, r6, e5), e5["x-ms-paths"] && R2(e5["x-ms-paths"], "x-ms-paths", t5, r6, e5), !t5.debug)
                  for (let t6 in e5.components.parameters)
                    e5.components.parameters[t6]["x-s2o-delete"] && delete e5.components.parameters[t6];
                t5.debug && (e5["x-s2o-consumes"] = e5.consumes || [], e5["x-s2o-produces"] = e5.produces || []), delete e5.consumes, delete e5.produces, delete e5.schemes;
                let n5 = [];
                if (e5.components.requestBodies = {}, !t5.resolveInternal) {
                  let t6 = 1;
                  for (let o3 in r6) {
                    let i2 = r6[o3];
                    if (i2.refs.length > 1) {
                      let r7 = "";
                      for (i2.name || (i2.name = "requestBody", r7 = t6++); n5.indexOf(i2.name + r7) >= 0; )
                        r7 = r7 ? ++r7 : 2;
                      i2.name = i2.name + r7, n5.push(i2.name), e5.components.requestBodies[i2.name] = u2(i2.body);
                      for (let t7 in i2.refs) {
                        let r8 = {};
                        r8.$ref = "#/components/requestBodies/" + i2.name, l2.jptr(e5, i2.refs[t7], r8);
                      }
                    }
                  }
                }
                e5.components.responses && 0 === Object.keys(e5.components.responses).length && delete e5.components.responses, e5.components.parameters && 0 === Object.keys(e5.components.parameters).length && delete e5.components.parameters, e5.components.examples && 0 === Object.keys(e5.components.examples).length && delete e5.components.examples, e5.components.requestBodies && 0 === Object.keys(e5.components.requestBodies).length && delete e5.components.requestBodies, e5.components.securitySchemes && 0 === Object.keys(e5.components.securitySchemes).length && delete e5.components.securitySchemes, e5.components.headers && 0 === Object.keys(e5.components.headers).length && delete e5.components.headers, e5.components.schemas && 0 === Object.keys(e5.components.schemas).length && delete e5.components.schemas, e5.components && 0 === Object.keys(e5.components).length && delete e5.components;
              })(t4.openapi, t4), t4.direct ? r5(t4.openapi) : r5(t4);
            }).catch(function(e5) {
              console.warn(e5), n4(e5);
            });
          }));
        }
        function M2(e4, t4, r4) {
          return i(r4, new Promise(function(r5, n4) {
            let o2 = null, i2 = null;
            try {
              o2 = JSON.parse(e4), t4.text = JSON.stringify(o2, null, 2);
            } catch (r6) {
              i2 = r6;
              try {
                o2 = a.parse(e4, { schema: "core", prettyErrors: true }), t4.sourceYaml = true, t4.text = e4;
              } catch (e5) {
                i2 = e5;
              }
            }
            o2 ? N2(o2, t4).then((e5) => r5(e5)).catch((e5) => n4(e5)) : n4(new w2(i2 ? i2.message : "Could not parse string"));
          }));
        }
        e3.exports = { S2OError: w2, targetVersion: x2, convert: N2, convertObj: N2, convertUrl: function(e4, t4, r4) {
          return i(r4, new Promise(function(r5, n4) {
            t4.origin = true, t4.source || (t4.source = e4), t4.verbose && console.warn("GET " + e4), t4.fetch || (t4.fetch = s);
            const o2 = Object.assign({}, t4.fetchOptions, { agent: t4.agent });
            t4.fetch(e4, o2).then(function(t5) {
              if (200 !== t5.status)
                throw new w2(`Received status code ${t5.status}: ${e4}`);
              return t5.text();
            }).then(function(e5) {
              M2(e5, t4).then((e6) => r5(e6)).catch((e6) => n4(e6));
            }).catch(function(e5) {
              n4(e5);
            });
          }));
        }, convertStr: M2, convertFile: function(e4, t4, r4) {
          return i(r4, new Promise(function(r5, o2) {
            n3.readFile(e4, t4.encoding || "utf8", function(n4, i2) {
              n4 ? o2(n4) : (t4.sourceFile = e4, M2(i2, t4).then((e5) => r5(e5)).catch((e5) => o2(e5)));
            });
          }));
        }, convertStream: function(e4, t4, r4) {
          return i(r4, new Promise(function(r5, n4) {
            let o2 = "";
            e4.on("data", function(e5) {
              o2 += e5;
            }).on("end", function() {
              M2(o2, t4).then((e5) => r5(e5)).catch((e5) => n4(e5));
            });
          }));
        } };
      }, 711: function(e3, t3, r3) {
        const n3 = r3(177);
        e3.exports = { statusCodes: Object.assign({}, { default: "Default response", "1XX": "Informational", 103: "Early hints", "2XX": "Successful", "3XX": "Redirection", "4XX": "Client Error", "5XX": "Server Error", "7XX": "Developer Error" }, n3.STATUS_CODES) };
      }, 595: function(e3, t3, r3) {
        var n3 = r3(314), o = ["add", "done", "toJS", "fromExternalJS", "load", "dispose", "search", "Worker"];
        e3.exports = function() {
          var e4 = new Worker(URL.createObjectURL(new Blob([`/*! For license information please see 756674defce81e90acea.worker.js.LICENSE.txt */
!function(){var e={336:function(e,t,r){var n,i;!function(){var s,o,a,u,l,c,h,d,f,p,y,m,g,x,v,w,Q,k,S,E,L,P,b,T,O,I,R,F,C,N,j=function(e){var t=new j.Builder;return t.pipeline.add(j.trimmer,j.stopWordFilter,j.stemmer),t.searchPipeline.add(j.stemmer),e.call(t,t),t.build()};j.version="2.3.9",j.utils={},j.utils.warn=(s=this,function(e){s.console&&console.warn&&console.warn(e)}),j.utils.asString=function(e){return null==e?"":e.toString()},j.utils.clone=function(e){if(null==e)return e;for(var t=Object.create(null),r=Object.keys(e),n=0;n<r.length;n++){var i=r[n],s=e[i];if(Array.isArray(s))t[i]=s.slice();else{if("string"!=typeof s&&"number"!=typeof s&&"boolean"!=typeof s)throw new TypeError("clone is not deep and does not support nested objects");t[i]=s}}return t},j.FieldRef=function(e,t,r){this.docRef=e,this.fieldName=t,this._stringValue=r},j.FieldRef.joiner="/",j.FieldRef.fromString=function(e){var t=e.indexOf(j.FieldRef.joiner);if(-1===t)throw"malformed field ref string";var r=e.slice(0,t),n=e.slice(t+1);return new j.FieldRef(n,r,e)},j.FieldRef.prototype.toString=function(){return null==this._stringValue&&(this._stringValue=this.fieldName+j.FieldRef.joiner+this.docRef),this._stringValue},j.Set=function(e){if(this.elements=Object.create(null),e){this.length=e.length;for(var t=0;t<this.length;t++)this.elements[e[t]]=!0}else this.length=0},j.Set.complete={intersect:function(e){return e},union:function(){return this},contains:function(){return!0}},j.Set.empty={intersect:function(){return this},union:function(e){return e},contains:function(){return!1}},j.Set.prototype.contains=function(e){return!!this.elements[e]},j.Set.prototype.intersect=function(e){var t,r,n,i=[];if(e===j.Set.complete)return this;if(e===j.Set.empty)return e;this.length<e.length?(t=this,r=e):(t=e,r=this),n=Object.keys(t.elements);for(var s=0;s<n.length;s++){var o=n[s];o in r.elements&&i.push(o)}return new j.Set(i)},j.Set.prototype.union=function(e){return e===j.Set.complete?j.Set.complete:e===j.Set.empty?this:new j.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))},j.idf=function(e,t){var r=0;for(var n in e)"_index"!=n&&(r+=Object.keys(e[n]).length);var i=(t-r+.5)/(r+.5);return Math.log(1+Math.abs(i))},j.Token=function(e,t){this.str=e||"",this.metadata=t||{}},j.Token.prototype.toString=function(){return this.str},j.Token.prototype.update=function(e){return this.str=e(this.str,this.metadata),this},j.Token.prototype.clone=function(e){return e=e||function(e){return e},new j.Token(e(this.str,this.metadata),this.metadata)},j.tokenizer=function(e,t){if(null==e||null==e)return[];if(Array.isArray(e))return e.map((function(e){return new j.Token(j.utils.asString(e).toLowerCase(),j.utils.clone(t))}));for(var r=e.toString().toLowerCase(),n=r.length,i=[],s=0,o=0;s<=n;s++){var a=s-o;if(r.charAt(s).match(j.tokenizer.separator)||s==n){if(a>0){var u=j.utils.clone(t)||{};u.position=[o,a],u.index=i.length,i.push(new j.Token(r.slice(o,s),u))}o=s+1}}return i},j.tokenizer.separator=/[\\s\\-]+/,j.Pipeline=function(){this._stack=[]},j.Pipeline.registeredFunctions=Object.create(null),j.Pipeline.registerFunction=function(e,t){t in this.registeredFunctions&&j.utils.warn("Overwriting existing registered function: "+t),e.label=t,j.Pipeline.registeredFunctions[e.label]=e},j.Pipeline.warnIfFunctionNotRegistered=function(e){e.label&&e.label in this.registeredFunctions||j.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\\n",e)},j.Pipeline.load=function(e){var t=new j.Pipeline;return e.forEach((function(e){var r=j.Pipeline.registeredFunctions[e];if(!r)throw new Error("Cannot load unregistered function: "+e);t.add(r)})),t},j.Pipeline.prototype.add=function(){Array.prototype.slice.call(arguments).forEach((function(e){j.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)}),this)},j.Pipeline.prototype.after=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");r+=1,this._stack.splice(r,0,t)},j.Pipeline.prototype.before=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");this._stack.splice(r,0,t)},j.Pipeline.prototype.remove=function(e){var t=this._stack.indexOf(e);-1!=t&&this._stack.splice(t,1)},j.Pipeline.prototype.run=function(e){for(var t=this._stack.length,r=0;r<t;r++){for(var n=this._stack[r],i=[],s=0;s<e.length;s++){var o=n(e[s],s,e);if(null!=o&&""!==o)if(Array.isArray(o))for(var a=0;a<o.length;a++)i.push(o[a]);else i.push(o)}e=i}return e},j.Pipeline.prototype.runString=function(e,t){var r=new j.Token(e,t);return this.run([r]).map((function(e){return e.toString()}))},j.Pipeline.prototype.reset=function(){this._stack=[]},j.Pipeline.prototype.toJSON=function(){return this._stack.map((function(e){return j.Pipeline.warnIfFunctionNotRegistered(e),e.label}))},j.Vector=function(e){this._magnitude=0,this.elements=e||[]},j.Vector.prototype.positionForIndex=function(e){if(0==this.elements.length)return 0;for(var t=0,r=this.elements.length/2,n=r-t,i=Math.floor(n/2),s=this.elements[2*i];n>1&&(s<e&&(t=i),s>e&&(r=i),s!=e);)n=r-t,i=t+Math.floor(n/2),s=this.elements[2*i];return s==e||s>e?2*i:s<e?2*(i+1):void 0},j.Vector.prototype.insert=function(e,t){this.upsert(e,t,(function(){throw"duplicate index"}))},j.Vector.prototype.upsert=function(e,t,r){this._magnitude=0;var n=this.positionForIndex(e);this.elements[n]==e?this.elements[n+1]=r(this.elements[n+1],t):this.elements.splice(n,0,e,t)},j.Vector.prototype.magnitude=function(){if(this._magnitude)return this._magnitude;for(var e=0,t=this.elements.length,r=1;r<t;r+=2){var n=this.elements[r];e+=n*n}return this._magnitude=Math.sqrt(e)},j.Vector.prototype.dot=function(e){for(var t=0,r=this.elements,n=e.elements,i=r.length,s=n.length,o=0,a=0,u=0,l=0;u<i&&l<s;)(o=r[u])<(a=n[l])?u+=2:o>a?l+=2:o==a&&(t+=r[u+1]*n[l+1],u+=2,l+=2);return t},j.Vector.prototype.similarity=function(e){return this.dot(e)/this.magnitude()||0},j.Vector.prototype.toArray=function(){for(var e=new Array(this.elements.length/2),t=1,r=0;t<this.elements.length;t+=2,r++)e[r]=this.elements[t];return e},j.Vector.prototype.toJSON=function(){return this.elements},j.stemmer=(o={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},a={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},h="^("+(l="[^aeiou][^aeiouy]*")+")?"+(c=(u="[aeiouy]")+"[aeiou]*")+l+"("+c+")?$",d="^("+l+")?"+c+l+c+l,f="^("+l+")?"+u,p=new RegExp("^("+l+")?"+c+l),y=new RegExp(d),m=new RegExp(h),g=new RegExp(f),x=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,w=/^(.+?)eed$/,Q=/^(.+?)(ed|ing)$/,k=/.$/,S=/(at|bl|iz)$/,E=new RegExp("([^aeiouylsz])\\\\1$"),L=new RegExp("^"+l+u+"[^aeiouwxy]$"),P=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,T=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,O=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,I=/^(.+?)(s|t)(ion)$/,R=/^(.+?)e$/,F=/ll$/,C=new RegExp("^"+l+u+"[^aeiouwxy]$"),N=function(e){var t,r,n,i,s,u,l;if(e.length<3)return e;if("y"==(n=e.substr(0,1))&&(e=n.toUpperCase()+e.substr(1)),s=v,(i=x).test(e)?e=e.replace(i,"$1$2"):s.test(e)&&(e=e.replace(s,"$1$2")),s=Q,(i=w).test(e)){var c=i.exec(e);(i=p).test(c[1])&&(i=k,e=e.replace(i,""))}else s.test(e)&&(t=(c=s.exec(e))[1],(s=g).test(t)&&(u=E,l=L,(s=S).test(e=t)?e+="e":u.test(e)?(i=k,e=e.replace(i,"")):l.test(e)&&(e+="e")));return(i=P).test(e)&&(e=(t=(c=i.exec(e))[1])+"i"),(i=b).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+o[r])),(i=T).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+a[r])),s=I,(i=O).test(e)?(t=(c=i.exec(e))[1],(i=y).test(t)&&(e=t)):s.test(e)&&(t=(c=s.exec(e))[1]+c[2],(s=y).test(t)&&(e=t)),(i=R).test(e)&&(t=(c=i.exec(e))[1],s=m,u=C,((i=y).test(t)||s.test(t)&&!u.test(t))&&(e=t)),s=y,(i=F).test(e)&&s.test(e)&&(i=k,e=e.replace(i,"")),"y"==n&&(e=n.toLowerCase()+e.substr(1)),e},function(e){return e.update(N)}),j.Pipeline.registerFunction(j.stemmer,"stemmer"),j.generateStopWordFilter=function(e){var t=e.reduce((function(e,t){return e[t]=t,e}),{});return function(e){if(e&&t[e.toString()]!==e.toString())return e}},j.stopWordFilter=j.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),j.Pipeline.registerFunction(j.stopWordFilter,"stopWordFilter"),j.trimmer=function(e){return e.update((function(e){return e.replace(/^\\W+/,"").replace(/\\W+$/,"")}))},j.Pipeline.registerFunction(j.trimmer,"trimmer"),j.TokenSet=function(){this.final=!1,this.edges={},this.id=j.TokenSet._nextId,j.TokenSet._nextId+=1},j.TokenSet._nextId=1,j.TokenSet.fromArray=function(e){for(var t=new j.TokenSet.Builder,r=0,n=e.length;r<n;r++)t.insert(e[r]);return t.finish(),t.root},j.TokenSet.fromClause=function(e){return"editDistance"in e?j.TokenSet.fromFuzzyString(e.term,e.editDistance):j.TokenSet.fromString(e.term)},j.TokenSet.fromFuzzyString=function(e,t){for(var r=new j.TokenSet,n=[{node:r,editsRemaining:t,str:e}];n.length;){var i=n.pop();if(i.str.length>0){var s,o=i.str.charAt(0);o in i.node.edges?s=i.node.edges[o]:(s=new j.TokenSet,i.node.edges[o]=s),1==i.str.length&&(s.final=!0),n.push({node:s,editsRemaining:i.editsRemaining,str:i.str.slice(1)})}if(0!=i.editsRemaining){if("*"in i.node.edges)var a=i.node.edges["*"];else a=new j.TokenSet,i.node.edges["*"]=a;if(0==i.str.length&&(a.final=!0),n.push({node:a,editsRemaining:i.editsRemaining-1,str:i.str}),i.str.length>1&&n.push({node:i.node,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)}),1==i.str.length&&(i.node.final=!0),i.str.length>=1){if("*"in i.node.edges)var u=i.node.edges["*"];else u=new j.TokenSet,i.node.edges["*"]=u;1==i.str.length&&(u.final=!0),n.push({node:u,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)})}if(i.str.length>1){var l,c=i.str.charAt(0),h=i.str.charAt(1);h in i.node.edges?l=i.node.edges[h]:(l=new j.TokenSet,i.node.edges[h]=l),1==i.str.length&&(l.final=!0),n.push({node:l,editsRemaining:i.editsRemaining-1,str:c+i.str.slice(2)})}}}return r},j.TokenSet.fromString=function(e){for(var t=new j.TokenSet,r=t,n=0,i=e.length;n<i;n++){var s=e[n],o=n==i-1;if("*"==s)t.edges[s]=t,t.final=o;else{var a=new j.TokenSet;a.final=o,t.edges[s]=a,t=a}}return r},j.TokenSet.prototype.toArray=function(){for(var e=[],t=[{prefix:"",node:this}];t.length;){var r=t.pop(),n=Object.keys(r.node.edges),i=n.length;r.node.final&&(r.prefix.charAt(0),e.push(r.prefix));for(var s=0;s<i;s++){var o=n[s];t.push({prefix:r.prefix.concat(o),node:r.node.edges[o]})}}return e},j.TokenSet.prototype.toString=function(){if(this._str)return this._str;for(var e=this.final?"1":"0",t=Object.keys(this.edges).sort(),r=t.length,n=0;n<r;n++){var i=t[n];e=e+i+this.edges[i].id}return e},j.TokenSet.prototype.intersect=function(e){for(var t=new j.TokenSet,r=void 0,n=[{qNode:e,output:t,node:this}];n.length;){r=n.pop();for(var i=Object.keys(r.qNode.edges),s=i.length,o=Object.keys(r.node.edges),a=o.length,u=0;u<s;u++)for(var l=i[u],c=0;c<a;c++){var h=o[c];if(h==l||"*"==l){var d=r.node.edges[h],f=r.qNode.edges[l],p=d.final&&f.final,y=void 0;h in r.output.edges?(y=r.output.edges[h]).final=y.final||p:((y=new j.TokenSet).final=p,r.output.edges[h]=y),n.push({qNode:f,output:y,node:d})}}}return t},j.TokenSet.Builder=function(){this.previousWord="",this.root=new j.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}},j.TokenSet.Builder.prototype.insert=function(e){var t,r=0;if(e<this.previousWord)throw new Error("Out of order word insertion");for(var n=0;n<e.length&&n<this.previousWord.length&&e[n]==this.previousWord[n];n++)r++;for(this.minimize(r),t=0==this.uncheckedNodes.length?this.root:this.uncheckedNodes[this.uncheckedNodes.length-1].child,n=r;n<e.length;n++){var i=new j.TokenSet,s=e[n];t.edges[s]=i,this.uncheckedNodes.push({parent:t,char:s,child:i}),t=i}t.final=!0,this.previousWord=e},j.TokenSet.Builder.prototype.finish=function(){this.minimize(0)},j.TokenSet.Builder.prototype.minimize=function(e){for(var t=this.uncheckedNodes.length-1;t>=e;t--){var r=this.uncheckedNodes[t],n=r.child.toString();n in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[n]:(r.child._str=n,this.minimizedNodes[n]=r.child),this.uncheckedNodes.pop()}},j.Index=function(e){this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline},j.Index.prototype.search=function(e){return this.query((function(t){new j.QueryParser(e,t).parse()}))},j.Index.prototype.query=function(e){for(var t=new j.Query(this.fields),r=Object.create(null),n=Object.create(null),i=Object.create(null),s=Object.create(null),o=Object.create(null),a=0;a<this.fields.length;a++)n[this.fields[a]]=new j.Vector;for(e.call(t,t),a=0;a<t.clauses.length;a++){var u,l=t.clauses[a],c=j.Set.empty;u=l.usePipeline?this.pipeline.runString(l.term,{fields:l.fields}):[l.term];for(var h=0;h<u.length;h++){var d=u[h];l.term=d;var f=j.TokenSet.fromClause(l),p=this.tokenSet.intersect(f).toArray();if(0===p.length&&l.presence===j.Query.presence.REQUIRED){for(var y=0;y<l.fields.length;y++)s[R=l.fields[y]]=j.Set.empty;break}for(var m=0;m<p.length;m++){var g=p[m],x=this.invertedIndex[g],v=x._index;for(y=0;y<l.fields.length;y++){var w=x[R=l.fields[y]],Q=Object.keys(w),k=g+"/"+R,S=new j.Set(Q);if(l.presence==j.Query.presence.REQUIRED&&(c=c.union(S),void 0===s[R]&&(s[R]=j.Set.complete)),l.presence!=j.Query.presence.PROHIBITED){if(n[R].upsert(v,l.boost,(function(e,t){return e+t})),!i[k]){for(var E=0;E<Q.length;E++){var L,P=Q[E],b=new j.FieldRef(P,R),T=w[P];void 0===(L=r[b])?r[b]=new j.MatchData(g,R,T):L.add(g,R,T)}i[k]=!0}}else void 0===o[R]&&(o[R]=j.Set.empty),o[R]=o[R].union(S)}}}if(l.presence===j.Query.presence.REQUIRED)for(y=0;y<l.fields.length;y++)s[R=l.fields[y]]=s[R].intersect(c)}var O=j.Set.complete,I=j.Set.empty;for(a=0;a<this.fields.length;a++){var R;s[R=this.fields[a]]&&(O=O.intersect(s[R])),o[R]&&(I=I.union(o[R]))}var F=Object.keys(r),C=[],N=Object.create(null);if(t.isNegated())for(F=Object.keys(this.fieldVectors),a=0;a<F.length;a++){b=F[a];var _=j.FieldRef.fromString(b);r[b]=new j.MatchData}for(a=0;a<F.length;a++){var D=(_=j.FieldRef.fromString(F[a])).docRef;if(O.contains(D)&&!I.contains(D)){var A,B=this.fieldVectors[_],z=n[_.fieldName].similarity(B);if(void 0!==(A=N[D]))A.score+=z,A.matchData.combine(r[_]);else{var V={ref:D,score:z,matchData:r[_]};N[D]=V,C.push(V)}}}return C.sort((function(e,t){return t.score-e.score}))},j.Index.prototype.toJSON=function(){var e=Object.keys(this.invertedIndex).sort().map((function(e){return[e,this.invertedIndex[e]]}),this),t=Object.keys(this.fieldVectors).map((function(e){return[e,this.fieldVectors[e].toJSON()]}),this);return{version:j.version,fields:this.fields,fieldVectors:t,invertedIndex:e,pipeline:this.pipeline.toJSON()}},j.Index.load=function(e){var t={},r={},n=e.fieldVectors,i=Object.create(null),s=e.invertedIndex,o=new j.TokenSet.Builder,a=j.Pipeline.load(e.pipeline);e.version!=j.version&&j.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+j.version+"' does not match serialized index '"+e.version+"'");for(var u=0;u<n.length;u++){var l=(h=n[u])[0],c=h[1];r[l]=new j.Vector(c)}for(u=0;u<s.length;u++){var h,d=(h=s[u])[0],f=h[1];o.insert(d),i[d]=f}return o.finish(),t.fields=e.fields,t.fieldVectors=r,t.invertedIndex=i,t.tokenSet=o.root,t.pipeline=a,new j.Index(t)},j.Builder=function(){this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=j.tokenizer,this.pipeline=new j.Pipeline,this.searchPipeline=new j.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]},j.Builder.prototype.ref=function(e){this._ref=e},j.Builder.prototype.field=function(e,t){if(/\\//.test(e))throw new RangeError("Field '"+e+"' contains illegal character '/'");this._fields[e]=t||{}},j.Builder.prototype.b=function(e){this._b=e<0?0:e>1?1:e},j.Builder.prototype.k1=function(e){this._k1=e},j.Builder.prototype.add=function(e,t){var r=e[this._ref],n=Object.keys(this._fields);this._documents[r]=t||{},this.documentCount+=1;for(var i=0;i<n.length;i++){var s=n[i],o=this._fields[s].extractor,a=o?o(e):e[s],u=this.tokenizer(a,{fields:[s]}),l=this.pipeline.run(u),c=new j.FieldRef(r,s),h=Object.create(null);this.fieldTermFrequencies[c]=h,this.fieldLengths[c]=0,this.fieldLengths[c]+=l.length;for(var d=0;d<l.length;d++){var f=l[d];if(null==h[f]&&(h[f]=0),h[f]+=1,null==this.invertedIndex[f]){var p=Object.create(null);p._index=this.termIndex,this.termIndex+=1;for(var y=0;y<n.length;y++)p[n[y]]=Object.create(null);this.invertedIndex[f]=p}null==this.invertedIndex[f][s][r]&&(this.invertedIndex[f][s][r]=Object.create(null));for(var m=0;m<this.metadataWhitelist.length;m++){var g=this.metadataWhitelist[m],x=f.metadata[g];null==this.invertedIndex[f][s][r][g]&&(this.invertedIndex[f][s][r][g]=[]),this.invertedIndex[f][s][r][g].push(x)}}}},j.Builder.prototype.calculateAverageFieldLengths=function(){for(var e=Object.keys(this.fieldLengths),t=e.length,r={},n={},i=0;i<t;i++){var s=j.FieldRef.fromString(e[i]),o=s.fieldName;n[o]||(n[o]=0),n[o]+=1,r[o]||(r[o]=0),r[o]+=this.fieldLengths[s]}var a=Object.keys(this._fields);for(i=0;i<a.length;i++){var u=a[i];r[u]=r[u]/n[u]}this.averageFieldLength=r},j.Builder.prototype.createFieldVectors=function(){for(var e={},t=Object.keys(this.fieldTermFrequencies),r=t.length,n=Object.create(null),i=0;i<r;i++){for(var s=j.FieldRef.fromString(t[i]),o=s.fieldName,a=this.fieldLengths[s],u=new j.Vector,l=this.fieldTermFrequencies[s],c=Object.keys(l),h=c.length,d=this._fields[o].boost||1,f=this._documents[s.docRef].boost||1,p=0;p<h;p++){var y,m,g,x=c[p],v=l[x],w=this.invertedIndex[x]._index;void 0===n[x]?(y=j.idf(this.invertedIndex[x],this.documentCount),n[x]=y):y=n[x],m=y*((this._k1+1)*v)/(this._k1*(1-this._b+this._b*(a/this.averageFieldLength[o]))+v),m*=d,m*=f,g=Math.round(1e3*m)/1e3,u.insert(w,g)}e[s]=u}this.fieldVectors=e},j.Builder.prototype.createTokenSet=function(){this.tokenSet=j.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())},j.Builder.prototype.build=function(){return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new j.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})},j.Builder.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},j.MatchData=function(e,t,r){for(var n=Object.create(null),i=Object.keys(r||{}),s=0;s<i.length;s++){var o=i[s];n[o]=r[o].slice()}this.metadata=Object.create(null),void 0!==e&&(this.metadata[e]=Object.create(null),this.metadata[e][t]=n)},j.MatchData.prototype.combine=function(e){for(var t=Object.keys(e.metadata),r=0;r<t.length;r++){var n=t[r],i=Object.keys(e.metadata[n]);null==this.metadata[n]&&(this.metadata[n]=Object.create(null));for(var s=0;s<i.length;s++){var o=i[s],a=Object.keys(e.metadata[n][o]);null==this.metadata[n][o]&&(this.metadata[n][o]=Object.create(null));for(var u=0;u<a.length;u++){var l=a[u];null==this.metadata[n][o][l]?this.metadata[n][o][l]=e.metadata[n][o][l]:this.metadata[n][o][l]=this.metadata[n][o][l].concat(e.metadata[n][o][l])}}}},j.MatchData.prototype.add=function(e,t,r){if(!(e in this.metadata))return this.metadata[e]=Object.create(null),void(this.metadata[e][t]=r);if(t in this.metadata[e])for(var n=Object.keys(r),i=0;i<n.length;i++){var s=n[i];s in this.metadata[e][t]?this.metadata[e][t][s]=this.metadata[e][t][s].concat(r[s]):this.metadata[e][t][s]=r[s]}else this.metadata[e][t]=r},j.Query=function(e){this.clauses=[],this.allFields=e},j.Query.wildcard=new String("*"),j.Query.wildcard.NONE=0,j.Query.wildcard.LEADING=1,j.Query.wildcard.TRAILING=2,j.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},j.Query.prototype.clause=function(e){return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=j.Query.wildcard.NONE),e.wildcard&j.Query.wildcard.LEADING&&e.term.charAt(0)!=j.Query.wildcard&&(e.term="*"+e.term),e.wildcard&j.Query.wildcard.TRAILING&&e.term.slice(-1)!=j.Query.wildcard&&(e.term=e.term+"*"),"presence"in e||(e.presence=j.Query.presence.OPTIONAL),this.clauses.push(e),this},j.Query.prototype.isNegated=function(){for(var e=0;e<this.clauses.length;e++)if(this.clauses[e].presence!=j.Query.presence.PROHIBITED)return!1;return!0},j.Query.prototype.term=function(e,t){if(Array.isArray(e))return e.forEach((function(e){this.term(e,j.utils.clone(t))}),this),this;var r=t||{};return r.term=e.toString(),this.clause(r),this},j.QueryParseError=function(e,t,r){this.name="QueryParseError",this.message=e,this.start=t,this.end=r},j.QueryParseError.prototype=new Error,j.QueryLexer=function(e){this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]},j.QueryLexer.prototype.run=function(){for(var e=j.QueryLexer.lexText;e;)e=e(this)},j.QueryLexer.prototype.sliceString=function(){for(var e=[],t=this.start,r=this.pos,n=0;n<this.escapeCharPositions.length;n++)r=this.escapeCharPositions[n],e.push(this.str.slice(t,r)),t=r+1;return e.push(this.str.slice(t,this.pos)),this.escapeCharPositions.length=0,e.join("")},j.QueryLexer.prototype.emit=function(e){this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos},j.QueryLexer.prototype.escapeCharacter=function(){this.escapeCharPositions.push(this.pos-1),this.pos+=1},j.QueryLexer.prototype.next=function(){if(this.pos>=this.length)return j.QueryLexer.EOS;var e=this.str.charAt(this.pos);return this.pos+=1,e},j.QueryLexer.prototype.width=function(){return this.pos-this.start},j.QueryLexer.prototype.ignore=function(){this.start==this.pos&&(this.pos+=1),this.start=this.pos},j.QueryLexer.prototype.backup=function(){this.pos-=1},j.QueryLexer.prototype.acceptDigitRun=function(){var e,t;do{t=(e=this.next()).charCodeAt(0)}while(t>47&&t<58);e!=j.QueryLexer.EOS&&this.backup()},j.QueryLexer.prototype.more=function(){return this.pos<this.length},j.QueryLexer.EOS="EOS",j.QueryLexer.FIELD="FIELD",j.QueryLexer.TERM="TERM",j.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",j.QueryLexer.BOOST="BOOST",j.QueryLexer.PRESENCE="PRESENCE",j.QueryLexer.lexField=function(e){return e.backup(),e.emit(j.QueryLexer.FIELD),e.ignore(),j.QueryLexer.lexText},j.QueryLexer.lexTerm=function(e){if(e.width()>1&&(e.backup(),e.emit(j.QueryLexer.TERM)),e.ignore(),e.more())return j.QueryLexer.lexText},j.QueryLexer.lexEditDistance=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.EDIT_DISTANCE),j.QueryLexer.lexText},j.QueryLexer.lexBoost=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.BOOST),j.QueryLexer.lexText},j.QueryLexer.lexEOS=function(e){e.width()>0&&e.emit(j.QueryLexer.TERM)},j.QueryLexer.termSeparator=j.tokenizer.separator,j.QueryLexer.lexText=function(e){for(;;){var t=e.next();if(t==j.QueryLexer.EOS)return j.QueryLexer.lexEOS;if(92!=t.charCodeAt(0)){if(":"==t)return j.QueryLexer.lexField;if("~"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexEditDistance;if("^"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexBoost;if("+"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if("-"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if(t.match(j.QueryLexer.termSeparator))return j.QueryLexer.lexTerm}else e.escapeCharacter()}},j.QueryParser=function(e,t){this.lexer=new j.QueryLexer(e),this.query=t,this.currentClause={},this.lexemeIdx=0},j.QueryParser.prototype.parse=function(){this.lexer.run(),this.lexemes=this.lexer.lexemes;for(var e=j.QueryParser.parseClause;e;)e=e(this);return this.query},j.QueryParser.prototype.peekLexeme=function(){return this.lexemes[this.lexemeIdx]},j.QueryParser.prototype.consumeLexeme=function(){var e=this.peekLexeme();return this.lexemeIdx+=1,e},j.QueryParser.prototype.nextClause=function(){var e=this.currentClause;this.query.clause(e),this.currentClause={}},j.QueryParser.parseClause=function(e){var t=e.peekLexeme();if(null!=t)switch(t.type){case j.QueryLexer.PRESENCE:return j.QueryParser.parsePresence;case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:var r="expected either a field or a term, found "+t.type;throw t.str.length>=1&&(r+=" with value '"+t.str+"'"),new j.QueryParseError(r,t.start,t.end)}},j.QueryParser.parsePresence=function(e){var t=e.consumeLexeme();if(null!=t){switch(t.str){case"-":e.currentClause.presence=j.Query.presence.PROHIBITED;break;case"+":e.currentClause.presence=j.Query.presence.REQUIRED;break;default:var r="unrecognised presence operator'"+t.str+"'";throw new j.QueryParseError(r,t.start,t.end)}var n=e.peekLexeme();if(null==n)throw r="expecting term or field, found nothing",new j.QueryParseError(r,t.start,t.end);switch(n.type){case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:throw r="expecting term or field, found '"+n.type+"'",new j.QueryParseError(r,n.start,n.end)}}},j.QueryParser.parseField=function(e){var t=e.consumeLexeme();if(null!=t){if(-1==e.query.allFields.indexOf(t.str)){var r=e.query.allFields.map((function(e){return"'"+e+"'"})).join(", "),n="unrecognised field '"+t.str+"', possible fields: "+r;throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.fields=[t.str];var i=e.peekLexeme();if(null==i)throw n="expecting term, found nothing",new j.QueryParseError(n,t.start,t.end);if(i.type===j.QueryLexer.TERM)return j.QueryParser.parseTerm;throw n="expecting term, found '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}},j.QueryParser.parseTerm=function(e){var t=e.consumeLexeme();if(null!=t){e.currentClause.term=t.str.toLowerCase(),-1!=t.str.indexOf("*")&&(e.currentClause.usePipeline=!1);var r=e.peekLexeme();if(null!=r)switch(r.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:var n="Unexpected lexeme type '"+r.type+"'";throw new j.QueryParseError(n,r.start,r.end)}else e.nextClause()}},j.QueryParser.parseEditDistance=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="edit distance must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.editDistance=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},j.QueryParser.parseBoost=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="boost must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.boost=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},void 0===(i="function"==typeof(n=function(){return j})?n.call(t,r,t,e):n)||(e.exports=i)}()}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,{a:t}),t},r.d=function(e,t){for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};var n={};!function(){"use strict";r.d(n,{add:function(){return c},dispose:function(){return y},done:function(){return h},fromExternalJS:function(){return f},load:function(){return p},search:function(){return m},toJS:function(){return d}});var e=r(336),t=(e,t,r)=>new Promise(((n,i)=>{var s=e=>{try{a(r.next(e))}catch(e){i(e)}},o=e=>{try{a(r.throw(e))}catch(e){i(e)}},a=e=>e.done?n(e.value):Promise.resolve(e.value).then(s,o);a((r=r.apply(e,t)).next())}));let i,s,o,a=[];function u(){i=new e.Builder,i.field("title"),i.field("description"),i.ref("ref"),i.pipeline.add(e.trimmer,e.stopWordFilter,e.stemmer),o=new Promise((e=>{s=e}))}e.tokenizer.separator=/\\s+/,u();const l=t=>{const r=e.trimmer(new e.Token(t,{}));return"*"+e.stemmer(r)+"*"};function c(e,t,r){const n=a.push(r)-1,s={title:e.toLowerCase(),description:t.toLowerCase(),ref:n};i.add(s)}function h(){return t(this,null,(function*(){s(i.build())}))}function d(){return t(this,null,(function*(){return{store:a,index:(yield o).toJSON()}}))}function f(e,r){return t(this,null,(function*(){try{if(importScripts(e),!self[r])throw new Error("Broken index file format");p(self[r])}catch(e){console.error("Failed to load search index: "+e.message)}}))}function p(r){return t(this,null,(function*(){a=r.store,s(e.Index.load(r.index))}))}function y(){return t(this,null,(function*(){a=[],u()}))}function m(e,r=0){return t(this,null,(function*(){if(0===e.trim().length)return[];let t=(yield o).query((t=>{e.trim().toLowerCase().split(/\\s+/).forEach((e=>{if(1===e.length)return;const r=l(e);t.term(r,{})}))}));return r>0&&(t=t.slice(0,r)),t.map((e=>({meta:a[e.ref],score:e.score})))}))}addEventListener("message",(function(e){var t,r=e.data,i=r.type,s=r.method,o=r.id,a=r.params;"RPC"===i&&s&&((t=n[s])?Promise.resolve().then((function(){return t.apply(n,a)})):Promise.reject("No such method")).then((function(e){postMessage({type:"RPC",id:o,result:e})})).catch((function(e){var t={message:e};e.stack&&(t.message=e.message,t.stack=e.stack,t.name=e.name),postMessage({type:"RPC",id:o,error:t})}))})),postMessage({type:"RPC",method:"ready"})}()}();
//# sourceMappingURL=756674defce81e90acea.worker.js.map`])), { name: "[fullhash].worker.js" });
          return n3(e4, o), e4;
        };
      }, 314: function(e3) {
        e3.exports = function(e4, t3) {
          var r3 = 0, n3 = {};
          e4.addEventListener("message", function(t4) {
            var r4 = t4.data;
            if ("RPC" === r4.type)
              if (r4.id) {
                var o = n3[r4.id];
                o && (delete n3[r4.id], r4.error ? o[1](Object.assign(Error(r4.error.message), r4.error)) : o[0](r4.result));
              } else {
                var i = document.createEvent("Event");
                i.initEvent(r4.method, false, false), i.data = r4.params, e4.dispatchEvent(i);
              }
          }), t3.forEach(function(t4) {
            e4[t4] = function() {
              var o = arguments;
              return new Promise(function(i, s) {
                var a = ++r3;
                n3[a] = [i, s], e4.postMessage({ type: "RPC", id: a, method: t4, params: [].slice.call(o) });
              });
            };
          });
        };
      }, 766: function(e3) {
        e3.exports = requireMaybe();
      }, 376: function(e3) {
        e3.exports = requireFastSafeStringify();
      }, 322: function(e3) {
        e3.exports = requireStickyfill();
      }, 66: function(e3) {
        e3.exports = requireBrowser();
      }, 416: function(e3) {
        e3.exports = void 0;
      }, 177: function() {
      }, 109: function(e3) {
        e3.exports = { i8: "7.0.6" };
      } }, t2 = {};
      function r2(n3) {
        var o = t2[n3];
        if (void 0 !== o)
          return o.exports;
        var i = t2[n3] = { id: n3, exports: {} };
        return e2[n3](i, i.exports, r2), i.exports;
      }
      r2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return r2.d(t3, { a: t3 }), t3;
      }, r2.d = function(e3, t3) {
        for (var n3 in t3)
          r2.o(t3, n3) && !r2.o(e3, n3) && Object.defineProperty(e3, n3, { enumerable: true, get: t3[n3] });
      }, r2.g = function() {
        if ("object" == typeof globalThis)
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e3) {
          if ("object" == typeof window)
            return window;
        }
      }(), r2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, r2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, r2.nc = void 0;
      var n2 = {};
      return function() {
        r2.r(n2), r2.d(n2, { AUTH_TYPES: function() {
          return ac2;
        }, ApiContentWrap: function() {
          return rd2;
        }, ApiInfo: function() {
          return bc2;
        }, ApiInfoModel: function() {
          return Vr;
        }, ApiLogo: function() {
          return kc2;
        }, AppStore: function() {
          return uc2;
        }, ArraySchema: function() {
          return ml2;
        }, BackgroundStub: function() {
          return nd2;
        }, BodyContent: function() {
          return dp;
        }, COMPONENT_REGEXP: function() {
          return Br;
        }, CallbackModel: function() {
          return dn;
        }, ClipboardService: function() {
          return Bs;
        }, ContentItem: function() {
          return $u;
        }, ContentItems: function() {
          return ju;
        }, DiscriminatorDropdown: function() {
          return rl2;
        }, Dropdown: function() {
          return us;
        }, DropdownLabel: function() {
          return aa2;
        }, DropdownOrLabel: function() {
          return vs;
        }, DropdownWrapper: function() {
          return la2;
        }, ErrorBoundary: function() {
          return ne2;
        }, Example: function() {
          return oa2;
        }, ExampleModel: function() {
          return Bn;
        }, ExternalExample: function() {
          return ia2;
        }, FieldModel: function() {
          return Hn;
        }, GROUP_DEPTH: function() {
          return Yo;
        }, GroupModel: function() {
          return Mo;
        }, HistoryService: function() {
          return Ut;
        }, IS_BROWSER: function() {
          return s;
        }, InvertedSimpleDropdown: function() {
          return ca2;
        }, JsonPointer: function() {
          return Oe2;
        }, JsonViewer: function() {
          return Ks;
        }, LEGACY_REGEXP: function() {
          return qr;
        }, Loading: function() {
          return ae2;
        }, MDX_COMPONENT_REGEXP: function() {
          return Fr;
        }, Markdown: function() {
          return Rs;
        }, MarkdownRenderer: function() {
          return Ur;
        }, MarkerService: function() {
          return Ht;
        }, MediaContentModel: function() {
          return Kn;
        }, MediaTypeModel: function() {
          return Yn;
        }, MediaTypesSwitch: function() {
          return tp;
        }, MenuBuilder: function() {
          return Zo;
        }, MenuItem: function() {
          return zu;
        }, MenuItemLabel: function() {
          return zc2;
        }, MenuItemLi: function() {
          return Lc2;
        }, MenuItemTitle: function() {
          return Nc2;
        }, MenuItemUl: function() {
          return Rc2;
        }, MenuItems: function() {
          return Uu;
        }, MenuStore: function() {
          return ti2;
        }, MiddlePanel: function() {
          return ai2;
        }, MimeLabel: function() {
          return sa2;
        }, NoSampleLabel: function() {
          return pa2;
        }, OLD_SECURITY_DEFINITIONS_JSX_NAME: function() {
          return ht;
        }, ObjectSchema: function() {
          return nl2;
        }, OneOfButton: function() {
          return El;
        }, OneOfSchema: function() {
          return jl2;
        }, OpenAPIParser: function() {
          return jn;
        }, Operation: function() {
          return yu;
        }, OperationBadge: function() {
          return Tc2;
        }, OperationItem: function() {
          return Pu;
        }, OperationMenuItemContent: function() {
          return Nu;
        }, OperationModel: function() {
          return yo;
        }, OptionsConsumer: function() {
          return ue2;
        }, OptionsContext: function() {
          return ce2;
        }, OptionsProvider: function() {
          return pe2;
        }, Parameters: function() {
          return pp;
        }, PayloadSamples: function() {
          return Yp;
        }, Redoc: function() {
          return dd2;
        }, RedocAttribution: function() {
          return Mc2;
        }, RedocNormalizedOptions: function() {
          return W2;
        }, RedocStandalone: function() {
          return xd2;
        }, RedocWrap: function() {
          return td2;
        }, RequestBodyModel: function() {
          return eo;
        }, ResponseDetails: function() {
          return Sp;
        }, ResponseHeaders: function() {
          return wp;
        }, ResponseModel: function() {
          return po;
        }, ResponseSamples: function() {
          return lu;
        }, ResponseTitle: function() {
          return gp;
        }, ResponseView: function() {
          return Cp;
        }, ResponsesList: function() {
          return Ap;
        }, RightPanel: function() {
          return ci2;
        }, Row: function() {
          return ui2;
        }, SCHEMA_DEFINITION_JSX_NAME: function() {
          return mt;
        }, SECTION_ATTR: function() {
          return ei2;
        }, SECURITY_DEFINITIONS_JSX_NAME: function() {
          return dt;
        }, SECURITY_SCHEMES_SECTION_PREFIX: function() {
          return ft;
        }, Schema: function() {
          return Dl;
        }, SchemaDefinition: function() {
          return Ul;
        }, SchemaModel: function() {
          return Nn;
        }, ScrollService: function() {
          return ii2;
        }, SearchBox: function() {
          return ud2;
        }, SearchStore: function() {
          return si2;
        }, Section: function() {
          return li2;
        }, SectionItem: function() {
          return Cu;
        }, SecurityDefs: function() {
          return lc2;
        }, SecuritySchemeModel: function() {
          return So;
        }, SecuritySchemesModel: function() {
          return Co;
        }, SideMenu: function() {
          return Vu;
        }, SideNavStyleEnum: function() {
          return R2;
        }, SimpleDropdown: function() {
          return ds;
        }, SourceCode: function() {
          return ea2;
        }, SourceCodeWithCopy: function() {
          return ta2;
        }, SpecStore: function() {
          return Lo;
        }, StickyResponsiveSidebar: function() {
          return ed2;
        }, StoreBuilder: function() {
          return ki2;
        }, StoreConsumer: function() {
          return wi2;
        }, StoreContext: function() {
          return xi2;
        }, StoreProvider: function() {
          return vi2;
        }, StyledMarkdownBlock: function() {
          return Os;
        }, ThemeProvider: function() {
          return X2;
        }, Throttle: function() {
          return $t;
        }, alphabeticallyByProp: function() {
          return qt;
        }, appendToMdHeading: function() {
          return y2;
        }, argValueToBoolean: function() {
          return Q2;
        }, buildComponentComment: function() {
          return Qr;
        }, concatRefStacks: function() {
          return En;
        }, convertSwagger2OpenAPI: function() {
          return be2;
        }, createGlobalStyle: function() {
          return Z2;
        }, createStore: function() {
          return pc2;
        }, css: function() {
          return Y2;
        }, debugTime: function() {
          return St;
        }, debugTimeEnd: function() {
          return Ct;
        }, detectType: function() {
          return Be2;
        }, escapeHTMLAttrChars: function() {
          return C2;
        }, expandDefaultServerVariables: function() {
          return pt2;
        }, extensionsHook: function() {
          return te2;
        }, extractExtensions: function() {
          return xt;
        }, flattenByProp: function() {
          return m2;
        }, getBasePath: function() {
          return E2;
        }, getContentWithLegacyExamples: function() {
          return wt;
        }, getDefinitionName: function() {
          return rt2;
        }, getOperationSummary: function() {
          return qe2;
        }, getSerializedValue: function() {
          return Xe2;
        }, getStatusCodeType: function() {
          return ze2;
        }, highlight: function() {
          return jt;
        }, history: function() {
          return Wt;
        }, html2Str: function() {
          return l2;
        }, humanizeConstraints: function() {
          return it2;
        }, humanizeNumberRange: function() {
          return ot2;
        }, isAbsoluteUrl: function() {
          return k2;
        }, isArray: function() {
          return A2;
        }, isBoolean: function() {
          return I2;
        }, isFormUrlEncoded: function() {
          return We2;
        }, isJsonLike: function() {
          return Ue2;
        }, isNamedDefinition: function() {
          return tt2;
        }, isNumeric: function() {
          return g2;
        }, isObject: function() {
          return x2;
        }, isOperationName: function() {
          return Me2;
        }, isPayloadSample: function() {
          return fo;
        }, isPrimitiveType: function() {
          return Qe2;
        }, isRedocExtension: function() {
          return bt;
        }, isStatusCode: function() {
          return De2;
        }, keyframes: function() {
          return G2;
        }, langFromMime: function() {
          return Ke2;
        }, loadAndBundleSpec: function() {
          return ye2;
        }, mapLang: function() {
          return Et;
        }, mapValues: function() {
          return h2;
        }, mapWithLast: function() {
          return d2;
        }, media: function() {
          return K2;
        }, memoize: function() {
          return Mt;
        }, menuItemDepth: function() {
          return Dc2;
        }, mergeObjects: function() {
          return b2;
        }, mergeParams: function() {
          return lt2;
        }, mergeSimilarMediaTypes: function() {
          return ct2;
        }, normalizeServers: function() {
          return ut2;
        }, pluralizeType: function() {
          return vt;
        }, pushRef: function() {
          return On;
        }, querySelector: function() {
          return a;
        }, removeQueryStringAndHash: function() {
          return $2;
        }, resolveUrl: function() {
          return O2;
        }, safeSlugify: function() {
          return w2;
        }, scrollIntoViewIfNeeded: function() {
          return c2;
        }, serializeParameterValue: function() {
          return Ge2;
        }, serializeParameterValueWithMime: function() {
          return Ze2;
        }, setSecuritySchemePrefix: function() {
          return gt;
        }, shortenHTTPVerb: function() {
          return yt;
        }, sortByField: function() {
          return at2;
        }, sortByRequired: function() {
          return st2;
        }, stripTrailingSlash: function() {
          return f2;
        }, styled: function() {
          return ee2;
        }, titleize: function() {
          return j;
        }, unescapeHTMLChars: function() {
          return P2;
        }, urlFormEncodePayload: function() {
          return Ye2;
        }, useStore: function() {
          return Oi2;
        } });
        var e3 = reactExports, t3 = require$$6;
        const o = { spacing: { unit: 5, sectionHorizontal: ({ spacing: e4 }) => 8 * e4.unit, sectionVertical: ({ spacing: e4 }) => 8 * e4.unit }, breakpoints: { small: "50rem", medium: "75rem", large: "105rem" }, colors: { tonalOffset: 0.2, primary: { main: "#32329f", light: ({ colors: e4 }) => (0, t3.lighten)(e4.tonalOffset, e4.primary.main), dark: ({ colors: e4 }) => (0, t3.darken)(e4.tonalOffset, e4.primary.main), contrastText: ({ colors: e4 }) => (0, t3.readableColor)(e4.primary.main) }, success: { main: "#1d8127", light: ({ colors: e4 }) => (0, t3.lighten)(2 * e4.tonalOffset, e4.success.main), dark: ({ colors: e4 }) => (0, t3.darken)(e4.tonalOffset, e4.success.main), contrastText: ({ colors: e4 }) => (0, t3.readableColor)(e4.success.main) }, warning: { main: "#ffa500", light: ({ colors: e4 }) => (0, t3.lighten)(e4.tonalOffset, e4.warning.main), dark: ({ colors: e4 }) => (0, t3.darken)(e4.tonalOffset, e4.warning.main), contrastText: "#ffffff" }, error: { main: "#d41f1c", light: ({ colors: e4 }) => (0, t3.lighten)(e4.tonalOffset, e4.error.main), dark: ({ colors: e4 }) => (0, t3.darken)(e4.tonalOffset, e4.error.main), contrastText: ({ colors: e4 }) => (0, t3.readableColor)(e4.error.main) }, gray: { 50: "#FAFAFA", 100: "#F5F5F5" }, text: { primary: "#333333", secondary: ({ colors: e4 }) => (0, t3.lighten)(e4.tonalOffset, e4.text.primary) }, border: { dark: "rgba(0,0,0, 0.1)", light: "#ffffff" }, responses: { success: { color: ({ colors: e4 }) => e4.success.main, backgroundColor: ({ colors: e4 }) => (0, t3.transparentize)(0.93, e4.success.main), tabTextColor: ({ colors: e4 }) => e4.responses.success.color }, error: { color: ({ colors: e4 }) => e4.error.main, backgroundColor: ({ colors: e4 }) => (0, t3.transparentize)(0.93, e4.error.main), tabTextColor: ({ colors: e4 }) => e4.responses.error.color }, redirect: { color: ({ colors: e4 }) => e4.warning.main, backgroundColor: ({ colors: e4 }) => (0, t3.transparentize)(0.9, e4.responses.redirect.color), tabTextColor: ({ colors: e4 }) => e4.responses.redirect.color }, info: { color: "#87ceeb", backgroundColor: ({ colors: e4 }) => (0, t3.transparentize)(0.9, e4.responses.info.color), tabTextColor: ({ colors: e4 }) => e4.responses.info.color } }, http: { get: "#2F8132", post: "#186FAF", put: "#95507c", options: "#947014", patch: "#bf581d", delete: "#cc3333", basic: "#707070", link: "#07818F", head: "#A23DAD" } }, schema: { linesColor: (e4) => (0, t3.lighten)(e4.colors.tonalOffset, (0, t3.desaturate)(e4.colors.tonalOffset, e4.colors.primary.main)), defaultDetailsWidth: "75%", typeNameColor: (e4) => e4.colors.text.secondary, typeTitleColor: (e4) => e4.schema.typeNameColor, requireLabelColor: (e4) => e4.colors.error.main, labelsTextSize: "0.9em", nestingSpacing: "1em", nestedBackground: "#fafafa", arrow: { size: "1.1em", color: (e4) => e4.colors.text.secondary } }, typography: { fontSize: "14px", lineHeight: "1.5em", fontWeightRegular: "400", fontWeightBold: "600", fontWeightLight: "300", fontFamily: "Roboto, sans-serif", smoothing: "antialiased", optimizeSpeed: true, headings: { fontFamily: "Montserrat, sans-serif", fontWeight: "400", lineHeight: "1.6em" }, code: { fontSize: "13px", fontFamily: "Courier, monospace", lineHeight: ({ typography: e4 }) => e4.lineHeight, fontWeight: ({ typography: e4 }) => e4.fontWeightRegular, color: "#e53935", backgroundColor: "rgba(38, 50, 56, 0.05)", wrap: false }, links: { color: ({ colors: e4 }) => e4.primary.main, visited: ({ typography: e4 }) => e4.links.color, hover: ({ typography: e4 }) => (0, t3.lighten)(0.2, e4.links.color), textDecoration: "auto", hoverTextDecoration: "auto" } }, sidebar: { width: "260px", backgroundColor: "#fafafa", textColor: "#333333", activeTextColor: (e4) => e4.sidebar.textColor !== o.sidebar.textColor ? e4.sidebar.textColor : e4.colors.primary.main, groupItems: { activeBackgroundColor: (e4) => (0, t3.darken)(0.1, e4.sidebar.backgroundColor), activeTextColor: (e4) => e4.sidebar.activeTextColor, textTransform: "uppercase" }, level1Items: { activeBackgroundColor: (e4) => (0, t3.darken)(0.05, e4.sidebar.backgroundColor), activeTextColor: (e4) => e4.sidebar.activeTextColor, textTransform: "none" }, arrow: { size: "1.5em", color: (e4) => e4.sidebar.textColor } }, logo: { maxHeight: ({ sidebar: e4 }) => e4.width, maxWidth: ({ sidebar: e4 }) => e4.width, gutter: "2px" }, rightPanel: { backgroundColor: "#263238", width: "40%", textColor: "#ffffff", servers: { overlay: { backgroundColor: "#fafafa", textColor: "#263238" }, url: { backgroundColor: "#fff" } } }, codeBlock: { backgroundColor: ({ rightPanel: e4 }) => (0, t3.darken)(0.1, e4.backgroundColor) }, fab: { backgroundColor: "#f2f2f2", color: "#0065FB" } };
        var i = o;
        const s = "undefined" != typeof window && "HTMLElement" in window;
        function a(e4) {
          return "undefined" != typeof document ? document.querySelector(e4) : null;
        }
        function l2(e4) {
          return e4.split(/<[^>]+>/).map((e5) => e5.trim()).filter((e5) => e5.length > 0).join(" ");
        }
        function c2(e4, t4 = true) {
          const r3 = e4.parentNode;
          if (!r3)
            return;
          const n3 = window.getComputedStyle(r3, void 0), o2 = parseInt(n3.getPropertyValue("border-top-width"), 10), i2 = parseInt(n3.getPropertyValue("border-left-width"), 10), s2 = e4.offsetTop - r3.offsetTop < r3.scrollTop, a2 = e4.offsetTop - r3.offsetTop + e4.clientHeight - o2 > r3.scrollTop + r3.clientHeight, l3 = e4.offsetLeft - r3.offsetLeft < r3.scrollLeft, c3 = e4.offsetLeft - r3.offsetLeft + e4.clientWidth - i2 > r3.scrollLeft + r3.clientWidth, p3 = s2 && !a2;
          (s2 || a2) && t4 && (r3.scrollTop = e4.offsetTop - r3.offsetTop - r3.clientHeight / 2 - o2 + e4.clientHeight / 2), (l3 || c3) && t4 && (r3.scrollLeft = e4.offsetLeft - r3.offsetLeft - r3.clientWidth / 2 - i2 + e4.clientWidth / 2), (s2 || a2 || l3 || c3) && !t4 && e4.scrollIntoView(p3);
        }
        var p2 = requireSlugify(), u2 = r2.n(p2);
        function d2(e4, t4) {
          const r3 = [];
          for (let n3 = 0; n3 < e4.length - 1; n3++)
            r3.push(t4(e4[n3], false));
          return 0 !== e4.length && r3.push(t4(e4[e4.length - 1], true)), r3;
        }
        function h2(e4, t4) {
          const r3 = {};
          for (const n3 in e4)
            e4.hasOwnProperty(n3) && (r3[n3] = t4(e4[n3], n3, e4));
          return r3;
        }
        function m2(e4, t4) {
          const r3 = [], n3 = (e5) => {
            for (const o2 of e5)
              r3.push(o2), o2[t4] && n3(o2[t4]);
          };
          return n3(e4), r3;
        }
        function f2(e4) {
          return e4.endsWith("/") ? e4.substring(0, e4.length - 1) : e4;
        }
        function g2(e4) {
          return !isNaN(parseFloat(e4)) && isFinite(e4);
        }
        function y2(e4, t4, r3) {
          const n3 = new RegExp(`(^|\\n)#\\s?${t4}\\s*\\n`, "i"), o2 = new RegExp(`((\\n|^)#\\s*${t4}\\s*(\\n|$)(?:.|\\n)*?)(\\n#|$)`, "i");
          if (n3.test(e4))
            return e4.replace(o2, `$1

${r3}
$4`);
          {
            const n4 = "" === e4 || e4.endsWith("\n\n") ? "" : e4.endsWith("\n") ? "\n" : "\n\n";
            return `${e4}${n4}# ${t4}

${r3}`;
          }
        }
        const b2 = (e4, ...t4) => {
          if (!t4.length)
            return e4;
          const r3 = t4.shift();
          return void 0 === r3 ? e4 : (v2(e4) && v2(r3) && Object.keys(r3).forEach((t5) => {
            v2(r3[t5]) ? (e4[t5] || (e4[t5] = {}), b2(e4[t5], r3[t5])) : e4[t5] = r3[t5];
          }), b2(e4, ...t4));
        }, x2 = (e4) => null !== e4 && "object" == typeof e4, v2 = (e4) => x2(e4) && !A2(e4);
        function w2(e4) {
          return u2()(e4) || e4.toString().toLowerCase().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/\--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
        }
        function k2(e4) {
          return /(?:^[a-z][a-z0-9+.-]*:|\/\/)/i.test(e4);
        }
        function O2(e4, t4) {
          let r3;
          if (t4.startsWith("//"))
            try {
              r3 = `${new URL(e4).protocol || "https:"}${t4}`;
            } catch (e5) {
              r3 = `https:${t4}`;
            }
          else if (k2(t4))
            r3 = t4;
          else if (t4.startsWith("/"))
            try {
              const n3 = new URL(e4);
              n3.pathname = t4, r3 = n3.href;
            } catch (e5) {
              r3 = t4;
            }
          else
            r3 = f2(e4) + "/" + t4;
          return f2(r3);
        }
        function E2(e4) {
          try {
            return S2(e4).pathname;
          } catch (t4) {
            return e4;
          }
        }
        function j(e4) {
          return e4.charAt(0).toUpperCase() + e4.slice(1);
        }
        function $2(e4) {
          try {
            const t4 = S2(e4);
            return t4.search = "", t4.hash = "", t4.toString();
          } catch (t4) {
            return e4;
          }
        }
        function S2(e4) {
          return "undefined" == typeof URL ? new (r2(416)).URL(e4) : new URL(e4);
        }
        function C2(e4) {
          return e4.replace(/["\\]/g, "\\$&");
        }
        function P2(e4) {
          return e4.replace(/&#(\d+);/g, (e5, t4) => String.fromCharCode(parseInt(t4, 10))).replace(/&amp;/g, "&").replace(/&quot;/g, '"');
        }
        function A2(e4) {
          return Array.isArray(e4);
        }
        function I2(e4) {
          return "boolean" == typeof e4;
        }
        const T2 = { enum: "Enum", enumSingleValue: "Value", enumArray: "Items", default: "Default", deprecated: "Deprecated", example: "Example", examples: "Examples", recursive: "Recursive", arrayOf: "Array of ", webhook: "Event", const: "Value", noResultsFound: "No results found", download: "Download", downloadSpecification: "Download OpenAPI specification", responses: "Responses", callbackResponses: "Callback responses", requestSamples: "Request samples", responseSamples: "Response samples" };
        function _2(e4, t4) {
          const r3 = T2[e4];
          return void 0 !== t4 ? r3[t4] : r3;
        }
        var R2 = ((e4) => (e4.SummaryOnly = "summary-only", e4.PathOnly = "path-only", e4.IdOnly = "id-only", e4))(R2 || {}), L2 = Object.defineProperty, D2 = Object.defineProperties, z2 = Object.getOwnPropertyDescriptors, N2 = Object.getOwnPropertySymbols, M2 = Object.prototype.hasOwnProperty, q2 = Object.prototype.propertyIsEnumerable, F2 = (e4, t4, r3) => t4 in e4 ? L2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, B2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            M2.call(t4, r3) && F2(e4, r3, t4[r3]);
          if (N2)
            for (var r3 of N2(t4))
              q2.call(t4, r3) && F2(e4, r3, t4[r3]);
          return e4;
        };
        function Q2(e4, t4) {
          return void 0 === e4 ? t4 || false : "string" == typeof e4 ? "false" !== e4 : e4;
        }
        function U2(e4) {
          return "string" == typeof e4 ? parseInt(e4, 10) : "number" == typeof e4 ? e4 : void 0;
        }
        class W2 {
          static normalizeExpandResponses(e4) {
            if ("all" === e4)
              return "all";
            if ("string" == typeof e4) {
              const t4 = {};
              return e4.split(",").forEach((e5) => {
                t4[e5.trim()] = true;
              }), t4;
            }
            return void 0 !== e4 && console.warn(`expandResponses must be a string but received value "${e4}" of type ${typeof e4}`), {};
          }
          static normalizeHideHostname(e4) {
            return !!e4;
          }
          static normalizeScrollYOffset(e4) {
            if ("string" == typeof e4 && !g2(e4)) {
              const t4 = a(e4);
              t4 || console.warn("scrollYOffset value is a selector to non-existing element. Using offset 0 by default");
              const r3 = t4 && t4.getBoundingClientRect().bottom || 0;
              return () => r3;
            }
            return "number" == typeof e4 || g2(e4) ? () => "number" == typeof e4 ? e4 : parseFloat(e4) : "function" == typeof e4 ? () => {
              const t4 = e4();
              return "number" != typeof t4 && console.warn(`scrollYOffset should return number but returned value "${t4}" of type ${typeof t4}`), t4;
            } : (void 0 !== e4 && console.warn("Wrong value for scrollYOffset ReDoc option: should be string, number or function"), () => 0);
          }
          static normalizeShowExtensions(e4) {
            if (void 0 === e4)
              return false;
            if ("" === e4)
              return true;
            if ("string" != typeof e4)
              return e4;
            switch (e4) {
              case "true":
                return true;
              case "false":
                return false;
              default:
                return e4.split(",").map((e5) => e5.trim());
            }
          }
          static normalizeSideNavStyle(e4) {
            const t4 = R2.SummaryOnly;
            if ("string" != typeof e4)
              return t4;
            switch (e4) {
              case t4:
                return e4;
              case R2.PathOnly:
                return R2.PathOnly;
              case R2.IdOnly:
                return R2.IdOnly;
              default:
                return t4;
            }
          }
          static normalizePayloadSampleIdx(e4) {
            return "number" == typeof e4 ? Math.max(0, e4) : "string" == typeof e4 && isFinite(e4) ? parseInt(e4, 10) : 0;
          }
          static normalizeJsonSampleExpandLevel(e4) {
            return "all" === e4 ? 1 / 0 : isNaN(Number(e4)) ? 2 : Math.ceil(Number(e4));
          }
          static normalizeGeneratedPayloadSamplesMaxDepth(e4) {
            return isNaN(Number(e4)) ? 10 : Math.max(0, Number(e4));
          }
          constructor(e4, t4 = {}) {
            var r3, n3, o2, s2, a2;
            const l3 = (e4 = B2(B2({}, t4), e4)).theme && e4.theme.extensionsHook;
            var c3, p3;
            (null == (r3 = e4.theme) ? void 0 : r3.menu) && !(null == (n3 = e4.theme) ? void 0 : n3.sidebar) && (console.warn('Theme setting "menu" is deprecated. Rename to "sidebar"'), e4.theme.sidebar = e4.theme.menu), (null == (o2 = e4.theme) ? void 0 : o2.codeSample) && !(null == (s2 = e4.theme) ? void 0 : s2.codeBlock) && (console.warn('Theme setting "codeSample" is deprecated. Rename to "codeBlock"'), e4.theme.codeBlock = e4.theme.codeSample), this.theme = function(e5) {
              const t5 = {};
              let r4 = 0;
              const n4 = (o3, i2) => {
                Object.keys(o3).forEach((s3) => {
                  const a3 = (i2 ? i2 + "." : "") + s3, l4 = o3[s3];
                  "function" == typeof l4 ? Object.defineProperty(o3, s3, { get() {
                    if (!t5[a3]) {
                      if (r4++, r4 > 1e3)
                        throw new Error(`Theme probably contains circular dependency at ${a3}: ${l4.toString()}`);
                      t5[a3] = l4(e5);
                    }
                    return t5[a3];
                  }, enumerable: true }) : "object" == typeof l4 && n4(l4, a3);
                });
              };
              return n4(e5, ""), JSON.parse(JSON.stringify(e5));
            }(b2({}, i, (c3 = B2({}, e4.theme), D2(c3, z2({ extensionsHook: void 0 }))))), this.theme.extensionsHook = l3, p3 = e4.labels, Object.assign(T2, p3), this.scrollYOffset = W2.normalizeScrollYOffset(e4.scrollYOffset), this.hideHostname = W2.normalizeHideHostname(e4.hideHostname), this.expandResponses = W2.normalizeExpandResponses(e4.expandResponses), this.requiredPropsFirst = Q2(e4.requiredPropsFirst), this.sortPropsAlphabetically = Q2(e4.sortPropsAlphabetically), this.sortEnumValuesAlphabetically = Q2(e4.sortEnumValuesAlphabetically), this.sortOperationsAlphabetically = Q2(e4.sortOperationsAlphabetically), this.sortTagsAlphabetically = Q2(e4.sortTagsAlphabetically), this.nativeScrollbars = Q2(e4.nativeScrollbars), this.pathInMiddlePanel = Q2(e4.pathInMiddlePanel), this.untrustedSpec = Q2(e4.untrustedSpec), this.hideDownloadButton = Q2(e4.hideDownloadButton), this.downloadFileName = e4.downloadFileName, this.downloadDefinitionUrl = e4.downloadDefinitionUrl, this.disableSearch = Q2(e4.disableSearch), this.onlyRequiredInSamples = Q2(e4.onlyRequiredInSamples), this.showExtensions = W2.normalizeShowExtensions(e4.showExtensions), this.sideNavStyle = W2.normalizeSideNavStyle(e4.sideNavStyle), this.hideSingleRequestSampleTab = Q2(e4.hideSingleRequestSampleTab), this.hideRequestPayloadSample = Q2(e4.hideRequestPayloadSample), this.menuToggle = Q2(e4.menuToggle, true), this.jsonSampleExpandLevel = W2.normalizeJsonSampleExpandLevel(e4.jsonSampleExpandLevel), this.enumSkipQuotes = Q2(e4.enumSkipQuotes), this.hideSchemaTitles = Q2(e4.hideSchemaTitles), this.simpleOneOfTypeLabel = Q2(e4.simpleOneOfTypeLabel), this.payloadSampleIdx = W2.normalizePayloadSampleIdx(e4.payloadSampleIdx), this.expandSingleSchemaField = Q2(e4.expandSingleSchemaField), this.schemaExpansionLevel = function(e5, t5 = 0) {
              return "all" === e5 ? 1 / 0 : U2(e5) || t5;
            }(e4.schemaExpansionLevel), this.showObjectSchemaExamples = Q2(e4.showObjectSchemaExamples), this.showSecuritySchemeType = Q2(e4.showSecuritySchemeType), this.hideSecuritySection = Q2(e4.hideSecuritySection), this.unstable_ignoreMimeParameters = Q2(e4.unstable_ignoreMimeParameters), this.allowedMdComponents = e4.allowedMdComponents || {}, this.expandDefaultServerVariables = Q2(e4.expandDefaultServerVariables), this.maxDisplayedEnumValues = U2(e4.maxDisplayedEnumValues);
            const u3 = A2(e4.ignoreNamedSchemas) ? e4.ignoreNamedSchemas : null == (a2 = e4.ignoreNamedSchemas) ? void 0 : a2.split(",").map((e5) => e5.trim());
            this.ignoreNamedSchemas = new Set(u3), this.hideSchemaPattern = Q2(e4.hideSchemaPattern), this.generatedPayloadSamplesMaxDepth = W2.normalizeGeneratedPayloadSamplesMaxDepth(e4.generatedPayloadSamplesMaxDepth), this.nonce = e4.nonce, this.hideFab = Q2(e4.hideFab), this.minCharacterLengthToInitSearch = U2(e4.minCharacterLengthToInitSearch) || 3, this.showWebhookVerb = Q2(e4.showWebhookVerb);
          }
        }
        var V2 = require$$8, H2 = r2.n(V2);
        const { default: J2, css: Y2, createGlobalStyle: Z2, keyframes: G2, ThemeProvider: X2 } = V2, K2 = { lessThan(e4, t4, r3) {
          return (...n3) => Y2`
      @media ${t4 ? "print, " : ""} screen and (max-width: ${(t5) => t5.theme.breakpoints[e4]}) ${r3 || ""} {
        ${Y2(...n3)};
      }
    `;
        }, greaterThan(e4) {
          return (...t4) => Y2`
      @media (min-width: ${(t5) => t5.theme.breakpoints[e4]}) {
        ${Y2(...t4)};
      }
    `;
        }, between(e4, t4) {
          return (...r3) => Y2`
      @media (min-width: ${(t5) => t5.theme.breakpoints[e4]}) and (max-width: ${(e5) => e5.theme.breakpoints[t4]}) {
        ${Y2(...r3)};
      }
    `;
        } };
        var ee2 = J2;
        function te2(e4) {
          return (t4) => {
            if (t4.theme.extensionsHook)
              return t4.theme.extensionsHook(e4, t4);
          };
        }
        const re2 = ee2.div`
  padding: 20px;
  color: red;
`;
        class ne2 extends e3.Component {
          constructor(e4) {
            super(e4), this.state = { error: void 0 };
          }
          componentDidCatch(e4) {
            return this.setState({ error: e4 }), false;
          }
          render() {
            return this.state.error ? e3.createElement(re2, null, e3.createElement("h1", null, "Something went wrong..."), e3.createElement("small", null, " ", this.state.error.message, " "), e3.createElement("p", null, e3.createElement("details", null, e3.createElement("summary", null, "Stack trace"), e3.createElement("pre", null, this.state.error.stack))), e3.createElement("small", null, " ReDoc Version: ", "2.1.3"), " ", e3.createElement("br", null), e3.createElement("small", null, " Commit: ", "b2d8e0f")) : e3.createElement(e3.Fragment, null, e3.Children.only(this.props.children));
          }
        }
        const oe2 = G2`
  0% {
    transform: rotate(0deg); }
  100% {
    transform: rotate(360deg);
  }
`, ie2 = ee2((t4) => e3.createElement("svg", { className: t4.className, version: "1.1", width: "512", height: "512", viewBox: "0 0 512 512" }, e3.createElement("path", { d: "M275.682 147.999c0 10.864-8.837 19.661-19.682 19.661v0c-10.875 0-19.681-8.796-19.681-19.661v-96.635c0-10.885 8.806-19.661 19.681-19.661v0c10.844 0 19.682 8.776 19.682 19.661v96.635z" }), e3.createElement("path", { d: "M275.682 460.615c0 10.865-8.837 19.682-19.682 19.682v0c-10.875 0-19.681-8.817-19.681-19.682v-96.604c0-10.885 8.806-19.681 19.681-19.681v0c10.844 0 19.682 8.796 19.682 19.682v96.604z" }), e3.createElement("path", { d: "M147.978 236.339c10.885 0 19.681 8.755 19.681 19.641v0c0 10.885-8.796 19.702-19.681 19.702h-96.624c-10.864 0-19.661-8.817-19.661-19.702v0c0-10.885 8.796-19.641 19.661-19.641h96.624z" }), e3.createElement("path", { d: "M460.615 236.339c10.865 0 19.682 8.755 19.682 19.641v0c0 10.885-8.817 19.702-19.682 19.702h-96.584c-10.885 0-19.722-8.817-19.722-19.702v0c0-10.885 8.837-19.641 19.722-19.641h96.584z" }), e3.createElement("path", { d: "M193.546 165.703c7.69 7.66 7.68 20.142 0 27.822v0c-7.701 7.701-20.162 7.701-27.853 0.020l-68.311-68.322c-7.68-7.701-7.68-20.142 0-27.863v0c7.68-7.68 20.121-7.68 27.822 0l68.342 68.342z" }), e3.createElement("path", { d: "M414.597 386.775c7.7 7.68 7.7 20.163 0.021 27.863v0c-7.7 7.659-20.142 7.659-27.843-0.062l-68.311-68.26c-7.68-7.7-7.68-20.204 0-27.863v0c7.68-7.7 20.163-7.7 27.842 0l68.291 68.322z" }), e3.createElement("path", { d: "M165.694 318.464c7.69-7.7 20.153-7.7 27.853 0v0c7.68 7.659 7.69 20.163 0 27.863l-68.342 68.322c-7.67 7.659-20.142 7.659-27.822-0.062v0c-7.68-7.68-7.68-20.122 0-27.801l68.311-68.322z" }), e3.createElement("path", { d: "M386.775 97.362c7.7-7.68 20.142-7.68 27.822 0v0c7.7 7.68 7.7 20.183 0.021 27.863l-68.322 68.311c-7.68 7.68-20.163 7.68-27.843-0.020v0c-7.68-7.68-7.68-20.162 0-27.822l68.322-68.332z" })))`
  animation: 2s ${oe2} linear infinite;
  width: 50px;
  height: 50px;
  content: '';
  display: inline-block;
  margin-left: -25px;

  path {
    fill: ${(e4) => e4.color};
  }
`, se2 = ee2.div`
  font-family: helvetica, sans;
  width: 100%;
  text-align: center;
  font-size: 25px;
  margin: 30px 0 20px 0;
  color: ${(e4) => e4.color};
`;
        class ae2 extends e3.PureComponent {
          render() {
            return e3.createElement("div", { style: { textAlign: "center" } }, e3.createElement(se2, { color: this.props.color }, "Loading ..."), e3.createElement(ie2, { color: this.props.color }));
          }
        }
        var le2 = requirePropTypes();
        const ce2 = e3.createContext(new W2({})), pe2 = ce2.Provider, ue2 = ce2.Consumer;
        var de2 = require$$10, he2 = requireBundle(), me2 = requireConfig(), fe2 = r2(925), ge2 = (e4, t4, r3) => new Promise((n3, o2) => {
          var i2 = (e5) => {
            try {
              a2(r3.next(e5));
            } catch (e6) {
              o2(e6);
            }
          }, s2 = (e5) => {
            try {
              a2(r3.throw(e5));
            } catch (e6) {
              o2(e6);
            }
          }, a2 = (e5) => e5.done ? n3(e5.value) : Promise.resolve(e5.value).then(i2, s2);
          a2((r3 = r3.apply(e4, t4)).next());
        });
        function ye2(e4) {
          return ge2(this, null, function* () {
            const t4 = new me2.Config({}), n3 = { config: t4, base: s ? window.location.href : process.cwd() };
            s && (t4.resolve.http.customFetch = r2.g.fetch), "object" == typeof e4 && null !== e4 ? n3.doc = { source: { absoluteRef: "" }, parsed: e4 } : n3.ref = e4;
            const { bundle: { parsed: o2 } } = yield (0, he2.bundle)(n3);
            return void 0 !== o2.swagger ? be2(o2) : o2;
          });
        }
        function be2(e4) {
          return console.warn("[ReDoc Compatibility mode]: Converting OpenAPI 2.0 to OpenAPI 3.0"), new Promise((t4, r3) => (0, fe2.convertObj)(e4, { patch: true, warnOnly: true, text: "{}", anchors: true }, (e5, n3) => {
            if (e5)
              return r3(e5);
            t4(n3 && n3.openapi);
          }));
        }
        var xe2 = requireDecko(), ve2 = requireEventemitter3(), we2 = requireJsonPointer();
        const ke2 = we2.parse;
        class Oe2 {
          static baseName(e4, t4 = 1) {
            const r3 = Oe2.parse(e4);
            return r3[r3.length - t4];
          }
          static dirName(e4, t4 = 1) {
            const r3 = Oe2.parse(e4);
            return we2.compile(r3.slice(0, r3.length - t4));
          }
          static relative(e4, t4) {
            const r3 = Oe2.parse(e4);
            return Oe2.parse(t4).slice(r3.length);
          }
          static parse(e4) {
            let t4 = e4;
            return "#" === t4.charAt(0) && (t4 = t4.substring(1)), ke2(t4);
          }
          static join(e4, t4) {
            const r3 = Oe2.parse(e4).concat(t4);
            return we2.compile(r3);
          }
          static get(e4, t4) {
            return we2.get(e4, t4);
          }
          static compile(e4) {
            return we2.compile(e4);
          }
          static escape(e4) {
            return we2.escape(e4);
          }
        }
        we2.parse = Oe2.parse, Object.assign(Oe2, we2);
        var Ee2 = r2(470), je2 = requireUrlTemplate(), $e2 = Object.defineProperty, Se2 = Object.defineProperties, Ce2 = Object.getOwnPropertyDescriptors, Pe2 = Object.getOwnPropertySymbols, Ae2 = Object.prototype.hasOwnProperty, Ie2 = Object.prototype.propertyIsEnumerable, Te2 = (e4, t4, r3) => t4 in e4 ? $e2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, _e2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Ae2.call(t4, r3) && Te2(e4, r3, t4[r3]);
          if (Pe2)
            for (var r3 of Pe2(t4))
              Ie2.call(t4, r3) && Te2(e4, r3, t4[r3]);
          return e4;
        }, Re2 = (e4, t4) => Se2(e4, Ce2(t4));
        function Le2(e4) {
          return "string" == typeof e4 && /\dxx/i.test(e4);
        }
        function De2(e4) {
          return "default" === e4 || g2(e4) || Le2(e4);
        }
        function ze2(e4, t4 = false) {
          if ("default" === e4)
            return t4 ? "error" : "success";
          let r3 = "string" == typeof e4 ? parseInt(e4, 10) : e4;
          if (Le2(e4) && (r3 *= 100), r3 < 100 || r3 > 599)
            throw new Error("invalid HTTP code");
          let n3 = "success";
          return r3 >= 300 && r3 < 400 ? n3 = "redirect" : r3 >= 400 ? n3 = "error" : r3 < 200 && (n3 = "info"), n3;
        }
        const Ne2 = { get: true, post: true, put: true, head: true, patch: true, delete: true, options: true, $ref: true };
        function Me2(e4) {
          return e4 in Ne2;
        }
        function qe2(e4) {
          return e4.summary || e4.operationId || e4.description && e4.description.substring(0, 50) || e4.pathName || "<no summary>";
        }
        const Fe2 = { multipleOf: "number", maximum: "number", exclusiveMaximum: "number", minimum: "number", exclusiveMinimum: "number", maxLength: "string", minLength: "string", pattern: "string", contentEncoding: "string", contentMediaType: "string", items: "array", maxItems: "array", minItems: "array", uniqueItems: "array", maxProperties: "object", minProperties: "object", required: "object", additionalProperties: "object", unevaluatedProperties: "object", properties: "object", patternProperties: "object" };
        function Be2(e4) {
          if (void 0 !== e4.type && !A2(e4.type))
            return e4.type;
          const t4 = Object.keys(Fe2);
          for (const r3 of t4) {
            const t5 = Fe2[r3];
            if (void 0 !== e4[r3])
              return t5;
          }
          return "any";
        }
        function Qe2(e4, t4 = e4.type) {
          if (e4["x-circular-ref"])
            return true;
          if (void 0 !== e4.oneOf || void 0 !== e4.anyOf)
            return false;
          if (e4.if && e4.then || e4.if && e4.else)
            return false;
          let r3 = true;
          const n3 = A2(t4);
          return ("object" === t4 || n3 && (null == t4 ? void 0 : t4.includes("object"))) && (r3 = void 0 !== e4.properties ? 0 === Object.keys(e4.properties).length : void 0 === e4.additionalProperties && void 0 === e4.unevaluatedProperties && void 0 === e4.patternProperties), !A2(e4.items) && !A2(e4.prefixItems) && (void 0 !== e4.items && !I2(e4.items) && ("array" === t4 || n3 && (null == t4 ? void 0 : t4.includes("array"))) && (r3 = Qe2(e4.items, e4.items.type)), r3);
        }
        function Ue2(e4) {
          return -1 !== e4.search(/json/i);
        }
        function We2(e4) {
          return "application/x-www-form-urlencoded" === e4;
        }
        function Ve2(e4, t4, r3) {
          return A2(e4) ? e4.map((e5) => e5.toString()).join(r3) : "object" == typeof e4 ? Object.keys(e4).map((t5) => `${t5}${r3}${e4[t5]}`).join(r3) : t4 + "=" + e4.toString();
        }
        function He2(e4, t4) {
          return A2(e4) ? (console.warn("deepObject style cannot be used with array value:" + e4.toString()), "") : "object" == typeof e4 ? Object.keys(e4).map((r3) => `${t4}[${r3}]=${e4[r3]}`).join("&") : (console.warn("deepObject style cannot be used with non-object value:" + e4.toString()), "");
        }
        function Je2(e4, t4, r3) {
          const n3 = "__redoc_param_name__", o2 = t4 ? "*" : "";
          return je2.parse(`{?${n3}${o2}}`).expand({ [n3]: r3 }).substring(1).replace(/__redoc_param_name__/g, e4);
        }
        function Ye2(e4, t4 = {}) {
          if (A2(e4))
            throw new Error("Payload must have fields: " + e4.toString());
          return Object.keys(e4).map((r3) => {
            const n3 = e4[r3], { style: o2 = "form", explode: i2 = true } = t4[r3] || {};
            switch (o2) {
              case "form":
                return Je2(r3, i2, n3);
              case "spaceDelimited":
                return Ve2(n3, r3, "%20");
              case "pipeDelimited":
                return Ve2(n3, r3, "|");
              case "deepObject":
                return He2(n3, r3);
              default:
                return console.warn("Incorrect or unsupported encoding style: " + o2), "";
            }
          }).join("&");
        }
        function Ze2(e4, t4) {
          return Ue2(t4) ? JSON.stringify(e4) : (console.warn(`Parameter serialization as ${t4} is not supported`), "");
        }
        function Ge2(e4, t4) {
          const { name: r3, style: n3, explode: o2 = false, serializationMime: i2 } = e4;
          if (i2)
            switch (e4.in) {
              case "path":
              case "header":
                return Ze2(t4, i2);
              case "cookie":
              case "query":
                return `${r3}=${Ze2(t4, i2)}`;
              default:
                return console.warn("Unexpected parameter location: " + e4.in), "";
            }
          if (!n3)
            return console.warn(`Missing style attribute or content for parameter ${r3}`), "";
          switch (e4.in) {
            case "path":
              return function(e5, t5, r4, n4) {
                const o3 = r4 ? "*" : "";
                let i3 = "";
                "label" === t5 ? i3 = "." : "matrix" === t5 && (i3 = ";");
                const s2 = "__redoc_param_name__";
                return je2.parse(`{${i3}${s2}${o3}}`).expand({ [s2]: n4 }).replace(/__redoc_param_name__/g, e5);
              }(r3, n3, o2, t4);
            case "query":
              return function(e5, t5, r4, n4) {
                switch (t5) {
                  case "form":
                    return Je2(e5, r4, n4);
                  case "spaceDelimited":
                    return A2(n4) ? r4 ? Je2(e5, r4, n4) : `${e5}=${n4.join("%20")}` : (console.warn("The style spaceDelimited is only applicable to arrays"), "");
                  case "pipeDelimited":
                    return A2(n4) ? r4 ? Je2(e5, r4, n4) : `${e5}=${n4.join("|")}` : (console.warn("The style pipeDelimited is only applicable to arrays"), "");
                  case "deepObject":
                    return !r4 || A2(n4) || "object" != typeof n4 ? (console.warn("The style deepObject is only applicable for objects with explode=true"), "") : He2(n4, e5);
                  default:
                    return console.warn("Unexpected style for query: " + t5), "";
                }
              }(r3, n3, o2, t4);
            case "header":
              return function(e5, t5, r4) {
                if ("simple" === e5) {
                  const e6 = t5 ? "*" : "", n4 = "__redoc_param_name__", o3 = je2.parse(`{${n4}${e6}}`);
                  return decodeURIComponent(o3.expand({ [n4]: r4 }));
                }
                return console.warn("Unexpected style for header: " + e5), "";
              }(n3, o2, t4);
            case "cookie":
              return function(e5, t5, r4, n4) {
                return "form" === t5 ? Je2(e5, r4, n4) : (console.warn("Unexpected style for cookie: " + t5), "");
              }(r3, n3, o2, t4);
            default:
              return console.warn("Unexpected parameter location: " + e4.in), "";
          }
        }
        function Xe2(e4, t4) {
          return e4.in ? decodeURIComponent(Ge2(e4, t4)) : String(t4);
        }
        function Ke2(e4) {
          return -1 !== e4.search(/xml/i) ? "xml" : -1 !== e4.search(/csv/i) ? "csv" : -1 !== e4.search(/plain/i) ? "tex" : "clike";
        }
        const et2 = /^#\/components\/(schemas|pathItems)\/([^/]+)$/;
        function tt2(e4) {
          return et2.test(e4 || "");
        }
        function rt2(e4) {
          var t4;
          const [r3] = (null == (t4 = null == e4 ? void 0 : e4.match(et2)) ? void 0 : t4.reverse()) || [];
          return r3;
        }
        function nt2(e4, t4, r3) {
          let n3;
          return void 0 !== t4 && void 0 !== r3 ? n3 = t4 === r3 ? `= ${t4} ${e4}` : `[ ${t4} .. ${r3} ] ${e4}` : void 0 !== r3 ? n3 = `<= ${r3} ${e4}` : void 0 !== t4 && (n3 = 1 === t4 ? "non-empty" : `>= ${t4} ${e4}`), n3;
        }
        function ot2(e4) {
          var t4, r3;
          const n3 = "number" == typeof e4.exclusiveMinimum ? Math.min(e4.exclusiveMinimum, null != (t4 = e4.minimum) ? t4 : 1 / 0) : e4.minimum, o2 = "number" == typeof e4.exclusiveMaximum ? Math.max(e4.exclusiveMaximum, null != (r3 = e4.maximum) ? r3 : -1 / 0) : e4.maximum, i2 = "number" == typeof e4.exclusiveMinimum || e4.exclusiveMinimum, s2 = "number" == typeof e4.exclusiveMaximum || e4.exclusiveMaximum;
          return void 0 !== n3 && void 0 !== o2 ? `${i2 ? "( " : "[ "}${n3} .. ${o2}${s2 ? " )" : " ]"}` : void 0 !== o2 ? `${s2 ? "< " : "<= "}${o2}` : void 0 !== n3 ? `${i2 ? "> " : ">= "}${n3}` : void 0;
        }
        function it2(e4) {
          const t4 = [], r3 = nt2("characters", e4.minLength, e4.maxLength);
          void 0 !== r3 && t4.push(r3);
          const n3 = nt2("items", e4.minItems, e4.maxItems);
          void 0 !== n3 && t4.push(n3);
          const o2 = nt2("properties", e4.minProperties, e4.maxProperties);
          void 0 !== o2 && t4.push(o2);
          const i2 = function(e5) {
            if (void 0 === e5)
              return;
            const t5 = e5.toString(10);
            return /^0\.0*1$/.test(t5) ? `decimal places <= ${t5.split(".")[1].length}` : `multiple of ${t5}`;
          }(e4.multipleOf);
          void 0 !== i2 && t4.push(i2);
          const s2 = ot2(e4);
          return void 0 !== s2 && t4.push(s2), e4.uniqueItems && t4.push("unique"), t4;
        }
        function st2(e4, t4 = []) {
          const r3 = [], n3 = [], o2 = [];
          return e4.forEach((e5) => {
            e5.required ? t4.includes(e5.name) ? n3.push(e5) : o2.push(e5) : r3.push(e5);
          }), n3.sort((e5, r4) => t4.indexOf(e5.name) - t4.indexOf(r4.name)), [...n3, ...o2, ...r3];
        }
        function at2(e4, t4) {
          return [...e4].sort((e5, r3) => e5[t4].localeCompare(r3[t4]));
        }
        function lt2(e4, t4 = [], r3 = []) {
          const n3 = {};
          return r3.forEach((t5) => {
            ({ resolved: t5 } = e4.deref(t5)), n3[t5.name + "_" + t5.in] = true;
          }), (t4 = t4.filter((t5) => ({ resolved: t5 } = e4.deref(t5), !n3[t5.name + "_" + t5.in]))).concat(r3);
        }
        function ct2(e4) {
          const t4 = {};
          return Object.keys(e4).forEach((r3) => {
            const n3 = e4[r3], o2 = r3.split(";")[0].trim();
            t4[o2] ? t4[o2] = _e2(_e2({}, t4[o2]), n3) : t4[o2] = n3;
          }), t4;
        }
        function pt2(e4, t4 = {}) {
          return e4.replace(/(?:{)([\w-.]+)(?:})/g, (e5, r3) => t4[r3] && t4[r3].default || e5);
        }
        function ut2(e4, t4) {
          const r3 = void 0 === e4 ? $2((() => {
            if (!s)
              return "";
            const e5 = window.location.href;
            return e5.endsWith(".html") ? (0, Ee2.dirname)(e5) : e5;
          })()) : (0, Ee2.dirname)(e4);
          return 0 === t4.length && (t4 = [{ url: "/" }]), t4.map((e5) => {
            return Re2(_e2({}, e5), { url: (t5 = e5.url, O2(r3, t5)), description: e5.description || "" });
            var t5;
          });
        }
        const dt = "SecurityDefinitions", ht = "security-definitions", mt = "SchemaDefinition";
        let ft = "section/Authentication/";
        function gt(e4) {
          ft = e4;
        }
        const yt = (e4) => ({ delete: "del", options: "opts" })[e4] || e4;
        function bt(e4) {
          return e4 in { "x-circular-ref": true, "x-parentRefs": true, "x-refsStack": true, "x-code-samples": true, "x-codeSamples": true, "x-displayName": true, "x-examples": true, "x-ignoredHeaderParameters": true, "x-logo": true, "x-nullable": true, "x-servers": true, "x-tagGroups": true, "x-traitTag": true, "x-additionalPropertiesName": true, "x-explicitMappingOnly": true };
        }
        function xt(e4, t4) {
          return Object.keys(e4).filter((e5) => true === t4 ? e5.startsWith("x-") && !bt(e5) : e5.startsWith("x-") && t4.indexOf(e5) > -1).reduce((t5, r3) => (t5[r3] = e4[r3], t5), {});
        }
        function vt(e4) {
          return e4.split(" or ").map((e5) => e5.replace(/^(string|object|number|integer|array|boolean)s?( ?.*)/, "$1s$2")).join(" or ");
        }
        function wt(e4) {
          let t4 = e4.content;
          const r3 = e4["x-examples"], n3 = e4["x-example"];
          if (r3) {
            t4 = _e2({}, t4);
            for (const e5 of Object.keys(r3)) {
              const n4 = r3[e5];
              t4[e5] = Re2(_e2({}, t4[e5]), { examples: n4 });
            }
          } else if (n3) {
            t4 = _e2({}, t4);
            for (const e5 of Object.keys(n3)) {
              const r4 = n3[e5];
              t4[e5] = Re2(_e2({}, t4[e5]), { example: r4 });
            }
          }
          return t4;
        }
        var kt = requirePrism();
        requirePrismBash(), requirePrismC(), requirePrismClike(), requirePrismCoffeescript(), requirePrismCpp(), requirePrismCsharp(), requirePrismGo(), requirePrismHttp(), requirePrismJava(), requirePrismLua(), requirePrismMarkupTemplating(), requirePrismMarkup(), requirePrismObjectivec(), requirePrismPerl(), requirePrismPhp(), requirePrismPython(), requirePrismQ(), requirePrismRuby(), requirePrismScala(), requirePrismSql(), requirePrismSwift(), requirePrismYaml(), requirePrismCsv();
        const Ot = "clike";
        function Et(e4) {
          return { json: "js", "c++": "cpp", "c#": "csharp", "objective-c": "objectivec", shell: "bash", viml: "vim" }[e4] || Ot;
        }
        function jt(e4, t4 = Ot) {
          t4 = t4.toLowerCase();
          let r3 = kt.languages[t4];
          return r3 || (r3 = kt.languages[Et(t4)]), kt.highlight(e4.toString(), r3, t4);
        }
        function $t(e4) {
          return (t4, r3, n3) => {
            n3.value = function(e5, t5) {
              let r4, n4, o2, i2 = null, s2 = 0;
              const a2 = () => {
                s2 = (/* @__PURE__ */ new Date()).getTime(), i2 = null, o2 = e5.apply(r4, n4), i2 || (r4 = n4 = null);
              };
              return function() {
                const l3 = (/* @__PURE__ */ new Date()).getTime(), c3 = t5 - (l3 - s2);
                return r4 = this, n4 = arguments, c3 <= 0 || c3 > t5 ? (i2 && (clearTimeout(i2), i2 = null), s2 = l3, o2 = e5.apply(r4, n4), i2 || (r4 = n4 = null)) : i2 || (i2 = setTimeout(a2, c3)), o2;
              };
            }(n3.value, e4);
          };
        }
        function St(e4) {
        }
        function Ct(e4) {
        }
        kt.languages.insertBefore("javascript", "string", { "property string": { pattern: /([{,]\s*)"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i, lookbehind: true } }, void 0), kt.languages.insertBefore("javascript", "punctuation", { property: { pattern: /([{,]\s*)[a-z]\w*(?=\s*:)/i, lookbehind: true } }, void 0);
        var Pt = Object.defineProperty, At = Object.defineProperties, It = Object.getOwnPropertyDescriptors, Tt = Object.getOwnPropertySymbols, _t = Object.prototype.hasOwnProperty, Rt = Object.prototype.propertyIsEnumerable, Lt = (e4, t4, r3) => t4 in e4 ? Pt(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Dt = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            _t.call(t4, r3) && Lt(e4, r3, t4[r3]);
          if (Tt)
            for (var r3 of Tt(t4))
              Rt.call(t4, r3) && Lt(e4, r3, t4[r3]);
          return e4;
        }, zt = (e4, t4) => At(e4, It(t4));
        const Nt = {};
        function Mt(e4, t4, r3) {
          if ("function" == typeof r3.value)
            return function(e5, t5, r4) {
              if (!r4.value || r4.value.length > 0)
                throw new Error("@memoize decorator can only be applied to methods of zero arguments");
              const n3 = `_memoized_${t5}`, o2 = r4.value;
              return e5[n3] = Nt, zt(Dt({}, r4), { value() {
                return this[n3] === Nt && (this[n3] = o2.call(this)), this[n3];
              } });
            }(e4, t4, r3);
          if ("function" == typeof r3.get)
            return function(e5, t5, r4) {
              const n3 = `_memoized_${t5}`, o2 = r4.get;
              return e5[n3] = Nt, zt(Dt({}, r4), { get() {
                return this[n3] === Nt && (this[n3] = o2.call(this)), this[n3];
              } });
            }(e4, t4, r3);
          throw new Error("@memoize decorator can be applied to methods or getters, got " + String(r3.value) + " instead");
        }
        function qt(e4) {
          let t4 = 1;
          return "-" === e4[0] && (t4 = -1, e4 = e4.substr(1)), (r3, n3) => -1 == t4 ? n3[e4].localeCompare(r3[e4]) : r3[e4].localeCompare(n3[e4]);
        }
        var Ft = Object.defineProperty, Bt = Object.getOwnPropertyDescriptor;
        const Qt = "hashchange";
        class Ut {
          constructor() {
            this.emit = () => {
              this._emiter.emit(Qt, this.currentId);
            }, this._emiter = new ve2.EventEmitter(), this.bind();
          }
          get currentId() {
            return s ? decodeURIComponent(window.location.hash.substring(1)) : "";
          }
          linkForId(e4) {
            return e4 ? "#" + e4 : "";
          }
          subscribe(e4) {
            const t4 = this._emiter.addListener(Qt, e4);
            return () => t4.removeListener(Qt, e4);
          }
          bind() {
            s && window.addEventListener("hashchange", this.emit, false);
          }
          dispose() {
            s && window.removeEventListener("hashchange", this.emit);
          }
          replace(e4, t4 = false) {
            s && null != e4 && e4 !== this.currentId && (t4 ? window.history.replaceState(null, "", window.location.href.split("#")[0] + this.linkForId(e4)) : (window.history.pushState(null, "", window.location.href.split("#")[0] + this.linkForId(e4)), this.emit()));
          }
        }
        ((e4, t4, r3, n3) => {
          for (var o2, i2 = Bt(t4, r3), s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(t4, r3, i2) || i2);
          i2 && Ft(t4, r3, i2);
        })([xe2.bind, xe2.debounce], Ut.prototype, "replace");
        const Wt = new Ut();
        var Vt = requireMark();
        class Ht {
          constructor() {
            this.map = /* @__PURE__ */ new Map(), this.prevTerm = "";
          }
          add(e4) {
            this.map.set(e4, new Vt(e4));
          }
          delete(e4) {
            this.map.delete(e4);
          }
          addOnly(e4) {
            this.map.forEach((t4, r3) => {
              -1 === e4.indexOf(r3) && (t4.unmark(), this.map.delete(r3));
            });
            for (const t4 of e4)
              this.map.has(t4) || this.map.set(t4, new Vt(t4));
          }
          clearAll() {
            this.unmark(), this.map.clear();
          }
          mark(e4) {
            (e4 || this.prevTerm) && (this.map.forEach((t4) => {
              t4.unmark(), t4.mark(e4 || this.prevTerm);
            }), this.prevTerm = e4 || this.prevTerm);
          }
          unmark() {
            this.map.forEach((e4) => e4.unmark()), this.prevTerm = "";
          }
        }
        let Jt = { baseUrl: null, breaks: false, extensions: null, gfm: true, headerIds: true, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: true, pedantic: false, renderer: null, sanitize: false, sanitizer: null, silent: false, smartLists: false, smartypants: false, tokenizer: null, walkTokens: null, xhtml: false };
        const Yt = /[&<>"']/, Zt = /[&<>"']/g, Gt = /[<>"']|&(?!#?\w+;)/, Xt = /[<>"']|&(?!#?\w+;)/g, Kt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, er = (e4) => Kt[e4];
        function tr(e4, t4) {
          if (t4) {
            if (Yt.test(e4))
              return e4.replace(Zt, er);
          } else if (Gt.test(e4))
            return e4.replace(Xt, er);
          return e4;
        }
        const rr = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
        function nr(e4) {
          return e4.replace(rr, (e5, t4) => "colon" === (t4 = t4.toLowerCase()) ? ":" : "#" === t4.charAt(0) ? "x" === t4.charAt(1) ? String.fromCharCode(parseInt(t4.substring(2), 16)) : String.fromCharCode(+t4.substring(1)) : "");
        }
        const or = /(^|[^\[])\^/g;
        function ir(e4, t4) {
          e4 = "string" == typeof e4 ? e4 : e4.source, t4 = t4 || "";
          const r3 = { replace: (t5, n3) => (n3 = (n3 = n3.source || n3).replace(or, "$1"), e4 = e4.replace(t5, n3), r3), getRegex: () => new RegExp(e4, t4) };
          return r3;
        }
        const sr = /[^\w:]/g, ar = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
        function lr(e4, t4, r3) {
          if (e4) {
            let e5;
            try {
              e5 = decodeURIComponent(nr(r3)).replace(sr, "").toLowerCase();
            } catch (e6) {
              return null;
            }
            if (0 === e5.indexOf("javascript:") || 0 === e5.indexOf("vbscript:") || 0 === e5.indexOf("data:"))
              return null;
          }
          t4 && !ar.test(r3) && (r3 = function(e5, t5) {
            cr[" " + e5] || (pr.test(e5) ? cr[" " + e5] = e5 + "/" : cr[" " + e5] = gr(e5, "/", true));
            const r4 = -1 === (e5 = cr[" " + e5]).indexOf(":");
            return "//" === t5.substring(0, 2) ? r4 ? t5 : e5.replace(ur, "$1") + t5 : "/" === t5.charAt(0) ? r4 ? t5 : e5.replace(dr, "$1") + t5 : e5 + t5;
          }(t4, r3));
          try {
            r3 = encodeURI(r3).replace(/%25/g, "%");
          } catch (e5) {
            return null;
          }
          return r3;
        }
        const cr = {}, pr = /^[^:]+:\/*[^/]*$/, ur = /^([^:]+:)[\s\S]*$/, dr = /^([^:]+:\/*[^/]*)[\s\S]*$/, hr = { exec: function() {
        } };
        function mr(e4) {
          let t4, r3, n3 = 1;
          for (; n3 < arguments.length; n3++)
            for (r3 in t4 = arguments[n3], t4)
              Object.prototype.hasOwnProperty.call(t4, r3) && (e4[r3] = t4[r3]);
          return e4;
        }
        function fr(e4, t4) {
          const r3 = e4.replace(/\|/g, (e5, t5, r4) => {
            let n4 = false, o2 = t5;
            for (; --o2 >= 0 && "\\" === r4[o2]; )
              n4 = !n4;
            return n4 ? "|" : " |";
          }).split(/ \|/);
          let n3 = 0;
          if (r3[0].trim() || r3.shift(), r3.length > 0 && !r3[r3.length - 1].trim() && r3.pop(), r3.length > t4)
            r3.splice(t4);
          else
            for (; r3.length < t4; )
              r3.push("");
          for (; n3 < r3.length; n3++)
            r3[n3] = r3[n3].trim().replace(/\\\|/g, "|");
          return r3;
        }
        function gr(e4, t4, r3) {
          const n3 = e4.length;
          if (0 === n3)
            return "";
          let o2 = 0;
          for (; o2 < n3; ) {
            const i2 = e4.charAt(n3 - o2 - 1);
            if (i2 !== t4 || r3) {
              if (i2 === t4 || !r3)
                break;
              o2++;
            } else
              o2++;
          }
          return e4.slice(0, n3 - o2);
        }
        function yr(e4) {
          e4 && e4.sanitize && !e4.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
        }
        function br(e4, t4) {
          if (t4 < 1)
            return "";
          let r3 = "";
          for (; t4 > 1; )
            1 & t4 && (r3 += e4), t4 >>= 1, e4 += e4;
          return r3 + e4;
        }
        function xr(e4, t4, r3, n3) {
          const o2 = t4.href, i2 = t4.title ? tr(t4.title) : null, s2 = e4[1].replace(/\\([\[\]])/g, "$1");
          if ("!" !== e4[0].charAt(0)) {
            n3.state.inLink = true;
            const e5 = { type: "link", raw: r3, href: o2, title: i2, text: s2, tokens: n3.inlineTokens(s2, []) };
            return n3.state.inLink = false, e5;
          }
          return { type: "image", raw: r3, href: o2, title: i2, text: tr(s2) };
        }
        class vr {
          constructor(e4) {
            this.options = e4 || Jt;
          }
          space(e4) {
            const t4 = this.rules.block.newline.exec(e4);
            if (t4 && t4[0].length > 0)
              return { type: "space", raw: t4[0] };
          }
          code(e4) {
            const t4 = this.rules.block.code.exec(e4);
            if (t4) {
              const e5 = t4[0].replace(/^ {1,4}/gm, "");
              return { type: "code", raw: t4[0], codeBlockStyle: "indented", text: this.options.pedantic ? e5 : gr(e5, "\n") };
            }
          }
          fences(e4) {
            const t4 = this.rules.block.fences.exec(e4);
            if (t4) {
              const e5 = t4[0], r3 = function(e6, t5) {
                const r4 = e6.match(/^(\s+)(?:```)/);
                if (null === r4)
                  return t5;
                const n3 = r4[1];
                return t5.split("\n").map((e7) => {
                  const t6 = e7.match(/^\s+/);
                  if (null === t6)
                    return e7;
                  const [r5] = t6;
                  return r5.length >= n3.length ? e7.slice(n3.length) : e7;
                }).join("\n");
              }(e5, t4[3] || "");
              return { type: "code", raw: e5, lang: t4[2] ? t4[2].trim() : t4[2], text: r3 };
            }
          }
          heading(e4) {
            const t4 = this.rules.block.heading.exec(e4);
            if (t4) {
              let e5 = t4[2].trim();
              if (/#$/.test(e5)) {
                const t5 = gr(e5, "#");
                this.options.pedantic ? e5 = t5.trim() : t5 && !/ $/.test(t5) || (e5 = t5.trim());
              }
              const r3 = { type: "heading", raw: t4[0], depth: t4[1].length, text: e5, tokens: [] };
              return this.lexer.inline(r3.text, r3.tokens), r3;
            }
          }
          hr(e4) {
            const t4 = this.rules.block.hr.exec(e4);
            if (t4)
              return { type: "hr", raw: t4[0] };
          }
          blockquote(e4) {
            const t4 = this.rules.block.blockquote.exec(e4);
            if (t4) {
              const e5 = t4[0].replace(/^ *>[ \t]?/gm, "");
              return { type: "blockquote", raw: t4[0], tokens: this.lexer.blockTokens(e5, []), text: e5 };
            }
          }
          list(e4) {
            let t4 = this.rules.block.list.exec(e4);
            if (t4) {
              let r3, n3, o2, i2, s2, a2, l3, c3, p3, u3, d3, h3, m3 = t4[1].trim();
              const f3 = m3.length > 1, g3 = { type: "list", raw: "", ordered: f3, start: f3 ? +m3.slice(0, -1) : "", loose: false, items: [] };
              m3 = f3 ? `\\d{1,9}\\${m3.slice(-1)}` : `\\${m3}`, this.options.pedantic && (m3 = f3 ? m3 : "[*+-]");
              const y3 = new RegExp(`^( {0,3}${m3})((?:[	 ][^\\n]*)?(?:\\n|$))`);
              for (; e4 && (h3 = false, t4 = y3.exec(e4)) && !this.rules.block.hr.test(e4); ) {
                if (r3 = t4[0], e4 = e4.substring(r3.length), c3 = t4[2].split("\n", 1)[0], p3 = e4.split("\n", 1)[0], this.options.pedantic ? (i2 = 2, d3 = c3.trimLeft()) : (i2 = t4[2].search(/[^ ]/), i2 = i2 > 4 ? 1 : i2, d3 = c3.slice(i2), i2 += t4[1].length), a2 = false, !c3 && /^ *$/.test(p3) && (r3 += p3 + "\n", e4 = e4.substring(p3.length + 1), h3 = true), !h3) {
                  const t5 = new RegExp(`^ {0,${Math.min(3, i2 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))`), n4 = new RegExp(`^ {0,${Math.min(3, i2 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                  for (; e4 && (u3 = e4.split("\n", 1)[0], c3 = u3, this.options.pedantic && (c3 = c3.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !t5.test(c3)) && !n4.test(e4); ) {
                    if (c3.search(/[^ ]/) >= i2 || !c3.trim())
                      d3 += "\n" + c3.slice(i2);
                    else {
                      if (a2)
                        break;
                      d3 += "\n" + c3;
                    }
                    a2 || c3.trim() || (a2 = true), r3 += u3 + "\n", e4 = e4.substring(u3.length + 1);
                  }
                }
                g3.loose || (l3 ? g3.loose = true : /\n *\n *$/.test(r3) && (l3 = true)), this.options.gfm && (n3 = /^\[[ xX]\] /.exec(d3), n3 && (o2 = "[ ] " !== n3[0], d3 = d3.replace(/^\[[ xX]\] +/, ""))), g3.items.push({ type: "list_item", raw: r3, task: !!n3, checked: o2, loose: false, text: d3 }), g3.raw += r3;
              }
              g3.items[g3.items.length - 1].raw = r3.trimRight(), g3.items[g3.items.length - 1].text = d3.trimRight(), g3.raw = g3.raw.trimRight();
              const b3 = g3.items.length;
              for (s2 = 0; s2 < b3; s2++) {
                this.lexer.state.top = false, g3.items[s2].tokens = this.lexer.blockTokens(g3.items[s2].text, []);
                const e5 = g3.items[s2].tokens.filter((e6) => "space" === e6.type), t5 = e5.every((e6) => {
                  const t6 = e6.raw.split("");
                  let r4 = 0;
                  for (const e7 of t6)
                    if ("\n" === e7 && (r4 += 1), r4 > 1)
                      return true;
                  return false;
                });
                !g3.loose && e5.length && t5 && (g3.loose = true, g3.items[s2].loose = true);
              }
              return g3;
            }
          }
          html(e4) {
            const t4 = this.rules.block.html.exec(e4);
            if (t4) {
              const e5 = { type: "html", raw: t4[0], pre: !this.options.sanitizer && ("pre" === t4[1] || "script" === t4[1] || "style" === t4[1]), text: t4[0] };
              return this.options.sanitize && (e5.type = "paragraph", e5.text = this.options.sanitizer ? this.options.sanitizer(t4[0]) : tr(t4[0]), e5.tokens = [], this.lexer.inline(e5.text, e5.tokens)), e5;
            }
          }
          def(e4) {
            const t4 = this.rules.block.def.exec(e4);
            if (t4)
              return t4[3] && (t4[3] = t4[3].substring(1, t4[3].length - 1)), { type: "def", tag: t4[1].toLowerCase().replace(/\s+/g, " "), raw: t4[0], href: t4[2], title: t4[3] };
          }
          table(e4) {
            const t4 = this.rules.block.table.exec(e4);
            if (t4) {
              const e5 = { type: "table", header: fr(t4[1]).map((e6) => ({ text: e6 })), align: t4[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: t4[3] && t4[3].trim() ? t4[3].replace(/\n[ \t]*$/, "").split("\n") : [] };
              if (e5.header.length === e5.align.length) {
                e5.raw = t4[0];
                let r3, n3, o2, i2, s2 = e5.align.length;
                for (r3 = 0; r3 < s2; r3++)
                  /^ *-+: *$/.test(e5.align[r3]) ? e5.align[r3] = "right" : /^ *:-+: *$/.test(e5.align[r3]) ? e5.align[r3] = "center" : /^ *:-+ *$/.test(e5.align[r3]) ? e5.align[r3] = "left" : e5.align[r3] = null;
                for (s2 = e5.rows.length, r3 = 0; r3 < s2; r3++)
                  e5.rows[r3] = fr(e5.rows[r3], e5.header.length).map((e6) => ({ text: e6 }));
                for (s2 = e5.header.length, n3 = 0; n3 < s2; n3++)
                  e5.header[n3].tokens = [], this.lexer.inlineTokens(e5.header[n3].text, e5.header[n3].tokens);
                for (s2 = e5.rows.length, n3 = 0; n3 < s2; n3++)
                  for (i2 = e5.rows[n3], o2 = 0; o2 < i2.length; o2++)
                    i2[o2].tokens = [], this.lexer.inlineTokens(i2[o2].text, i2[o2].tokens);
                return e5;
              }
            }
          }
          lheading(e4) {
            const t4 = this.rules.block.lheading.exec(e4);
            if (t4) {
              const e5 = { type: "heading", raw: t4[0], depth: "=" === t4[2].charAt(0) ? 1 : 2, text: t4[1], tokens: [] };
              return this.lexer.inline(e5.text, e5.tokens), e5;
            }
          }
          paragraph(e4) {
            const t4 = this.rules.block.paragraph.exec(e4);
            if (t4) {
              const e5 = { type: "paragraph", raw: t4[0], text: "\n" === t4[1].charAt(t4[1].length - 1) ? t4[1].slice(0, -1) : t4[1], tokens: [] };
              return this.lexer.inline(e5.text, e5.tokens), e5;
            }
          }
          text(e4) {
            const t4 = this.rules.block.text.exec(e4);
            if (t4) {
              const e5 = { type: "text", raw: t4[0], text: t4[0], tokens: [] };
              return this.lexer.inline(e5.text, e5.tokens), e5;
            }
          }
          escape(e4) {
            const t4 = this.rules.inline.escape.exec(e4);
            if (t4)
              return { type: "escape", raw: t4[0], text: tr(t4[1]) };
          }
          tag(e4) {
            const t4 = this.rules.inline.tag.exec(e4);
            if (t4)
              return !this.lexer.state.inLink && /^<a /i.test(t4[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && /^<\/a>/i.test(t4[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t4[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t4[0]) && (this.lexer.state.inRawBlock = false), { type: this.options.sanitize ? "text" : "html", raw: t4[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t4[0]) : tr(t4[0]) : t4[0] };
          }
          link(e4) {
            const t4 = this.rules.inline.link.exec(e4);
            if (t4) {
              const e5 = t4[2].trim();
              if (!this.options.pedantic && /^</.test(e5)) {
                if (!/>$/.test(e5))
                  return;
                const t5 = gr(e5.slice(0, -1), "\\");
                if ((e5.length - t5.length) % 2 == 0)
                  return;
              } else {
                const e6 = function(e7, t5) {
                  if (-1 === e7.indexOf(t5[1]))
                    return -1;
                  const r4 = e7.length;
                  let n4 = 0, o2 = 0;
                  for (; o2 < r4; o2++)
                    if ("\\" === e7[o2])
                      o2++;
                    else if (e7[o2] === t5[0])
                      n4++;
                    else if (e7[o2] === t5[1] && (n4--, n4 < 0))
                      return o2;
                  return -1;
                }(t4[2], "()");
                if (e6 > -1) {
                  const r4 = (0 === t4[0].indexOf("!") ? 5 : 4) + t4[1].length + e6;
                  t4[2] = t4[2].substring(0, e6), t4[0] = t4[0].substring(0, r4).trim(), t4[3] = "";
                }
              }
              let r3 = t4[2], n3 = "";
              if (this.options.pedantic) {
                const e6 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r3);
                e6 && (r3 = e6[1], n3 = e6[3]);
              } else
                n3 = t4[3] ? t4[3].slice(1, -1) : "";
              return r3 = r3.trim(), /^</.test(r3) && (r3 = this.options.pedantic && !/>$/.test(e5) ? r3.slice(1) : r3.slice(1, -1)), xr(t4, { href: r3 ? r3.replace(this.rules.inline._escapes, "$1") : r3, title: n3 ? n3.replace(this.rules.inline._escapes, "$1") : n3 }, t4[0], this.lexer);
            }
          }
          reflink(e4, t4) {
            let r3;
            if ((r3 = this.rules.inline.reflink.exec(e4)) || (r3 = this.rules.inline.nolink.exec(e4))) {
              let e5 = (r3[2] || r3[1]).replace(/\s+/g, " ");
              if (e5 = t4[e5.toLowerCase()], !e5 || !e5.href) {
                const e6 = r3[0].charAt(0);
                return { type: "text", raw: e6, text: e6 };
              }
              return xr(r3, e5, r3[0], this.lexer);
            }
          }
          emStrong(e4, t4, r3 = "") {
            let n3 = this.rules.inline.emStrong.lDelim.exec(e4);
            if (!n3)
              return;
            if (n3[3] && r3.match(/[\p{L}\p{N}]/u))
              return;
            const o2 = n3[1] || n3[2] || "";
            if (!o2 || o2 && ("" === r3 || this.rules.inline.punctuation.exec(r3))) {
              const r4 = n3[0].length - 1;
              let o3, i2, s2 = r4, a2 = 0;
              const l3 = "*" === n3[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              for (l3.lastIndex = 0, t4 = t4.slice(-1 * e4.length + r4); null != (n3 = l3.exec(t4)); ) {
                if (o3 = n3[1] || n3[2] || n3[3] || n3[4] || n3[5] || n3[6], !o3)
                  continue;
                if (i2 = o3.length, n3[3] || n3[4]) {
                  s2 += i2;
                  continue;
                }
                if ((n3[5] || n3[6]) && r4 % 3 && !((r4 + i2) % 3)) {
                  a2 += i2;
                  continue;
                }
                if (s2 -= i2, s2 > 0)
                  continue;
                if (i2 = Math.min(i2, i2 + s2 + a2), Math.min(r4, i2) % 2) {
                  const t6 = e4.slice(1, r4 + n3.index + i2);
                  return { type: "em", raw: e4.slice(0, r4 + n3.index + i2 + 1), text: t6, tokens: this.lexer.inlineTokens(t6, []) };
                }
                const t5 = e4.slice(2, r4 + n3.index + i2 - 1);
                return { type: "strong", raw: e4.slice(0, r4 + n3.index + i2 + 1), text: t5, tokens: this.lexer.inlineTokens(t5, []) };
              }
            }
          }
          codespan(e4) {
            const t4 = this.rules.inline.code.exec(e4);
            if (t4) {
              let e5 = t4[2].replace(/\n/g, " ");
              const r3 = /[^ ]/.test(e5), n3 = /^ /.test(e5) && / $/.test(e5);
              return r3 && n3 && (e5 = e5.substring(1, e5.length - 1)), e5 = tr(e5, true), { type: "codespan", raw: t4[0], text: e5 };
            }
          }
          br(e4) {
            const t4 = this.rules.inline.br.exec(e4);
            if (t4)
              return { type: "br", raw: t4[0] };
          }
          del(e4) {
            const t4 = this.rules.inline.del.exec(e4);
            if (t4)
              return { type: "del", raw: t4[0], text: t4[2], tokens: this.lexer.inlineTokens(t4[2], []) };
          }
          autolink(e4, t4) {
            const r3 = this.rules.inline.autolink.exec(e4);
            if (r3) {
              let e5, n3;
              return "@" === r3[2] ? (e5 = tr(this.options.mangle ? t4(r3[1]) : r3[1]), n3 = "mailto:" + e5) : (e5 = tr(r3[1]), n3 = e5), { type: "link", raw: r3[0], text: e5, href: n3, tokens: [{ type: "text", raw: e5, text: e5 }] };
            }
          }
          url(e4, t4) {
            let r3;
            if (r3 = this.rules.inline.url.exec(e4)) {
              let e5, n3;
              if ("@" === r3[2])
                e5 = tr(this.options.mangle ? t4(r3[0]) : r3[0]), n3 = "mailto:" + e5;
              else {
                let t5;
                do {
                  t5 = r3[0], r3[0] = this.rules.inline._backpedal.exec(r3[0])[0];
                } while (t5 !== r3[0]);
                e5 = tr(r3[0]), n3 = "www." === r3[1] ? "http://" + e5 : e5;
              }
              return { type: "link", raw: r3[0], text: e5, href: n3, tokens: [{ type: "text", raw: e5, text: e5 }] };
            }
          }
          inlineText(e4, t4) {
            const r3 = this.rules.inline.text.exec(e4);
            if (r3) {
              let e5;
              return e5 = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r3[0]) : tr(r3[0]) : r3[0] : tr(this.options.smartypants ? t4(r3[0]) : r3[0]), { type: "text", raw: r3[0], text: e5 };
            }
          }
        }
        const wr = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: hr, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ };
        wr.def = ir(wr.def).replace("label", wr._label).replace("title", wr._title).getRegex(), wr.bullet = /(?:[*+-]|\d{1,9}[.)])/, wr.listItemStart = ir(/^( *)(bull) */).replace("bull", wr.bullet).getRegex(), wr.list = ir(wr.list).replace(/bull/g, wr.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + wr.def.source + ")").getRegex(), wr._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", wr._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, wr.html = ir(wr.html, "i").replace("comment", wr._comment).replace("tag", wr._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), wr.paragraph = ir(wr._paragraph).replace("hr", wr.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wr._tag).getRegex(), wr.blockquote = ir(wr.blockquote).replace("paragraph", wr.paragraph).getRegex(), wr.normal = mr({}, wr), wr.gfm = mr({}, wr.normal, { table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }), wr.gfm.table = ir(wr.gfm.table).replace("hr", wr.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wr._tag).getRegex(), wr.gfm.paragraph = ir(wr._paragraph).replace("hr", wr.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", wr.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", wr._tag).getRegex(), wr.pedantic = mr({}, wr.normal, { html: ir(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", wr._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: hr, paragraph: ir(wr.normal._paragraph).replace("hr", wr.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", wr.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() });
        const kr = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: hr, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/, rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: hr, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ };
        function Or(e4) {
          return e4.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
        }
        function Er(e4) {
          let t4, r3, n3 = "";
          const o2 = e4.length;
          for (t4 = 0; t4 < o2; t4++)
            r3 = e4.charCodeAt(t4), Math.random() > 0.5 && (r3 = "x" + r3.toString(16)), n3 += "&#" + r3 + ";";
          return n3;
        }
        kr._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", kr.punctuation = ir(kr.punctuation).replace(/punctuation/g, kr._punctuation).getRegex(), kr.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, kr.escapedEmSt = /\\\*|\\_/g, kr._comment = ir(wr._comment).replace("(?:-->|$)", "-->").getRegex(), kr.emStrong.lDelim = ir(kr.emStrong.lDelim).replace(/punct/g, kr._punctuation).getRegex(), kr.emStrong.rDelimAst = ir(kr.emStrong.rDelimAst, "g").replace(/punct/g, kr._punctuation).getRegex(), kr.emStrong.rDelimUnd = ir(kr.emStrong.rDelimUnd, "g").replace(/punct/g, kr._punctuation).getRegex(), kr._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, kr._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, kr._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, kr.autolink = ir(kr.autolink).replace("scheme", kr._scheme).replace("email", kr._email).getRegex(), kr._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, kr.tag = ir(kr.tag).replace("comment", kr._comment).replace("attribute", kr._attribute).getRegex(), kr._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, kr._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, kr._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, kr.link = ir(kr.link).replace("label", kr._label).replace("href", kr._href).replace("title", kr._title).getRegex(), kr.reflink = ir(kr.reflink).replace("label", kr._label).replace("ref", wr._label).getRegex(), kr.nolink = ir(kr.nolink).replace("ref", wr._label).getRegex(), kr.reflinkSearch = ir(kr.reflinkSearch, "g").replace("reflink", kr.reflink).replace("nolink", kr.nolink).getRegex(), kr.normal = mr({}, kr), kr.pedantic = mr({}, kr.normal, { strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: ir(/^!?\[(label)\]\((.*?)\)/).replace("label", kr._label).getRegex(), reflink: ir(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", kr._label).getRegex() }), kr.gfm = mr({}, kr.normal, { escape: ir(kr.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }), kr.gfm.url = ir(kr.gfm.url, "i").replace("email", kr.gfm._extended_email).getRegex(), kr.breaks = mr({}, kr.gfm, { br: ir(kr.br).replace("{2,}", "*").getRegex(), text: ir(kr.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() });
        class jr {
          constructor(e4) {
            this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e4 || Jt, this.options.tokenizer = this.options.tokenizer || new vr(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
            const t4 = { block: wr.normal, inline: kr.normal };
            this.options.pedantic ? (t4.block = wr.pedantic, t4.inline = kr.pedantic) : this.options.gfm && (t4.block = wr.gfm, this.options.breaks ? t4.inline = kr.breaks : t4.inline = kr.gfm), this.tokenizer.rules = t4;
          }
          static get rules() {
            return { block: wr, inline: kr };
          }
          static lex(e4, t4) {
            return new jr(t4).lex(e4);
          }
          static lexInline(e4, t4) {
            return new jr(t4).inlineTokens(e4);
          }
          lex(e4) {
            let t4;
            for (e4 = e4.replace(/\r\n|\r/g, "\n"), this.blockTokens(e4, this.tokens); t4 = this.inlineQueue.shift(); )
              this.inlineTokens(t4.src, t4.tokens);
            return this.tokens;
          }
          blockTokens(e4, t4 = []) {
            let r3, n3, o2, i2;
            for (e4 = this.options.pedantic ? e4.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e4.replace(/^( *)(\t+)/gm, (e5, t5, r4) => t5 + "    ".repeat(r4.length)); e4; )
              if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((n4) => !!(r3 = n4.call({ lexer: this }, e4, t4)) && (e4 = e4.substring(r3.raw.length), t4.push(r3), true))))
                if (r3 = this.tokenizer.space(e4))
                  e4 = e4.substring(r3.raw.length), 1 === r3.raw.length && t4.length > 0 ? t4[t4.length - 1].raw += "\n" : t4.push(r3);
                else if (r3 = this.tokenizer.code(e4))
                  e4 = e4.substring(r3.raw.length), n3 = t4[t4.length - 1], !n3 || "paragraph" !== n3.type && "text" !== n3.type ? t4.push(r3) : (n3.raw += "\n" + r3.raw, n3.text += "\n" + r3.text, this.inlineQueue[this.inlineQueue.length - 1].src = n3.text);
                else if (r3 = this.tokenizer.fences(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.heading(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.hr(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.blockquote(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.list(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.html(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.def(e4))
                  e4 = e4.substring(r3.raw.length), n3 = t4[t4.length - 1], !n3 || "paragraph" !== n3.type && "text" !== n3.type ? this.tokens.links[r3.tag] || (this.tokens.links[r3.tag] = { href: r3.href, title: r3.title }) : (n3.raw += "\n" + r3.raw, n3.text += "\n" + r3.raw, this.inlineQueue[this.inlineQueue.length - 1].src = n3.text);
                else if (r3 = this.tokenizer.table(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.lheading(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else {
                  if (o2 = e4, this.options.extensions && this.options.extensions.startBlock) {
                    let t5 = 1 / 0;
                    const r4 = e4.slice(1);
                    let n4;
                    this.options.extensions.startBlock.forEach(function(e5) {
                      n4 = e5.call({ lexer: this }, r4), "number" == typeof n4 && n4 >= 0 && (t5 = Math.min(t5, n4));
                    }), t5 < 1 / 0 && t5 >= 0 && (o2 = e4.substring(0, t5 + 1));
                  }
                  if (this.state.top && (r3 = this.tokenizer.paragraph(o2)))
                    n3 = t4[t4.length - 1], i2 && "paragraph" === n3.type ? (n3.raw += "\n" + r3.raw, n3.text += "\n" + r3.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = n3.text) : t4.push(r3), i2 = o2.length !== e4.length, e4 = e4.substring(r3.raw.length);
                  else if (r3 = this.tokenizer.text(e4))
                    e4 = e4.substring(r3.raw.length), n3 = t4[t4.length - 1], n3 && "text" === n3.type ? (n3.raw += "\n" + r3.raw, n3.text += "\n" + r3.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = n3.text) : t4.push(r3);
                  else if (e4) {
                    const t5 = "Infinite loop on byte: " + e4.charCodeAt(0);
                    if (this.options.silent) {
                      console.error(t5);
                      break;
                    }
                    throw new Error(t5);
                  }
                }
            return this.state.top = true, t4;
          }
          inline(e4, t4) {
            this.inlineQueue.push({ src: e4, tokens: t4 });
          }
          inlineTokens(e4, t4 = []) {
            let r3, n3, o2, i2, s2, a2, l3 = e4;
            if (this.tokens.links) {
              const e5 = Object.keys(this.tokens.links);
              if (e5.length > 0)
                for (; null != (i2 = this.tokenizer.rules.inline.reflinkSearch.exec(l3)); )
                  e5.includes(i2[0].slice(i2[0].lastIndexOf("[") + 1, -1)) && (l3 = l3.slice(0, i2.index) + "[" + br("a", i2[0].length - 2) + "]" + l3.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
            }
            for (; null != (i2 = this.tokenizer.rules.inline.blockSkip.exec(l3)); )
              l3 = l3.slice(0, i2.index) + "[" + br("a", i2[0].length - 2) + "]" + l3.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            for (; null != (i2 = this.tokenizer.rules.inline.escapedEmSt.exec(l3)); )
              l3 = l3.slice(0, i2.index) + "++" + l3.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
            for (; e4; )
              if (s2 || (a2 = ""), s2 = false, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((n4) => !!(r3 = n4.call({ lexer: this }, e4, t4)) && (e4 = e4.substring(r3.raw.length), t4.push(r3), true))))
                if (r3 = this.tokenizer.escape(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.tag(e4))
                  e4 = e4.substring(r3.raw.length), n3 = t4[t4.length - 1], n3 && "text" === r3.type && "text" === n3.type ? (n3.raw += r3.raw, n3.text += r3.text) : t4.push(r3);
                else if (r3 = this.tokenizer.link(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.reflink(e4, this.tokens.links))
                  e4 = e4.substring(r3.raw.length), n3 = t4[t4.length - 1], n3 && "text" === r3.type && "text" === n3.type ? (n3.raw += r3.raw, n3.text += r3.text) : t4.push(r3);
                else if (r3 = this.tokenizer.emStrong(e4, l3, a2))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.codespan(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.br(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.del(e4))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (r3 = this.tokenizer.autolink(e4, Er))
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
                else if (this.state.inLink || !(r3 = this.tokenizer.url(e4, Er))) {
                  if (o2 = e4, this.options.extensions && this.options.extensions.startInline) {
                    let t5 = 1 / 0;
                    const r4 = e4.slice(1);
                    let n4;
                    this.options.extensions.startInline.forEach(function(e5) {
                      n4 = e5.call({ lexer: this }, r4), "number" == typeof n4 && n4 >= 0 && (t5 = Math.min(t5, n4));
                    }), t5 < 1 / 0 && t5 >= 0 && (o2 = e4.substring(0, t5 + 1));
                  }
                  if (r3 = this.tokenizer.inlineText(o2, Or))
                    e4 = e4.substring(r3.raw.length), "_" !== r3.raw.slice(-1) && (a2 = r3.raw.slice(-1)), s2 = true, n3 = t4[t4.length - 1], n3 && "text" === n3.type ? (n3.raw += r3.raw, n3.text += r3.text) : t4.push(r3);
                  else if (e4) {
                    const t5 = "Infinite loop on byte: " + e4.charCodeAt(0);
                    if (this.options.silent) {
                      console.error(t5);
                      break;
                    }
                    throw new Error(t5);
                  }
                } else
                  e4 = e4.substring(r3.raw.length), t4.push(r3);
            return t4;
          }
        }
        class $r {
          constructor(e4) {
            this.options = e4 || Jt;
          }
          code(e4, t4, r3) {
            const n3 = (t4 || "").match(/\S*/)[0];
            if (this.options.highlight) {
              const t5 = this.options.highlight(e4, n3);
              null != t5 && t5 !== e4 && (r3 = true, e4 = t5);
            }
            return e4 = e4.replace(/\n$/, "") + "\n", n3 ? '<pre><code class="' + this.options.langPrefix + tr(n3, true) + '">' + (r3 ? e4 : tr(e4, true)) + "</code></pre>\n" : "<pre><code>" + (r3 ? e4 : tr(e4, true)) + "</code></pre>\n";
          }
          blockquote(e4) {
            return `<blockquote>
${e4}</blockquote>
`;
          }
          html(e4) {
            return e4;
          }
          heading(e4, t4, r3, n3) {
            return this.options.headerIds ? `<h${t4} id="${this.options.headerPrefix + n3.slug(r3)}">${e4}</h${t4}>
` : `<h${t4}>${e4}</h${t4}>
`;
          }
          hr() {
            return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
          }
          list(e4, t4, r3) {
            const n3 = t4 ? "ol" : "ul";
            return "<" + n3 + (t4 && 1 !== r3 ? ' start="' + r3 + '"' : "") + ">\n" + e4 + "</" + n3 + ">\n";
          }
          listitem(e4) {
            return `<li>${e4}</li>
`;
          }
          checkbox(e4) {
            return "<input " + (e4 ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
          }
          paragraph(e4) {
            return `<p>${e4}</p>
`;
          }
          table(e4, t4) {
            return t4 && (t4 = `<tbody>${t4}</tbody>`), "<table>\n<thead>\n" + e4 + "</thead>\n" + t4 + "</table>\n";
          }
          tablerow(e4) {
            return `<tr>
${e4}</tr>
`;
          }
          tablecell(e4, t4) {
            const r3 = t4.header ? "th" : "td";
            return (t4.align ? `<${r3} align="${t4.align}">` : `<${r3}>`) + e4 + `</${r3}>
`;
          }
          strong(e4) {
            return `<strong>${e4}</strong>`;
          }
          em(e4) {
            return `<em>${e4}</em>`;
          }
          codespan(e4) {
            return `<code>${e4}</code>`;
          }
          br() {
            return this.options.xhtml ? "<br/>" : "<br>";
          }
          del(e4) {
            return `<del>${e4}</del>`;
          }
          link(e4, t4, r3) {
            if (null === (e4 = lr(this.options.sanitize, this.options.baseUrl, e4)))
              return r3;
            let n3 = '<a href="' + tr(e4) + '"';
            return t4 && (n3 += ' title="' + t4 + '"'), n3 += ">" + r3 + "</a>", n3;
          }
          image(e4, t4, r3) {
            if (null === (e4 = lr(this.options.sanitize, this.options.baseUrl, e4)))
              return r3;
            let n3 = `<img src="${e4}" alt="${r3}"`;
            return t4 && (n3 += ` title="${t4}"`), n3 += this.options.xhtml ? "/>" : ">", n3;
          }
          text(e4) {
            return e4;
          }
        }
        class Sr {
          strong(e4) {
            return e4;
          }
          em(e4) {
            return e4;
          }
          codespan(e4) {
            return e4;
          }
          del(e4) {
            return e4;
          }
          html(e4) {
            return e4;
          }
          text(e4) {
            return e4;
          }
          link(e4, t4, r3) {
            return "" + r3;
          }
          image(e4, t4, r3) {
            return "" + r3;
          }
          br() {
            return "";
          }
        }
        class Cr {
          constructor() {
            this.seen = {};
          }
          serialize(e4) {
            return e4.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
          }
          getNextSafeSlug(e4, t4) {
            let r3 = e4, n3 = 0;
            if (this.seen.hasOwnProperty(r3)) {
              n3 = this.seen[e4];
              do {
                n3++, r3 = e4 + "-" + n3;
              } while (this.seen.hasOwnProperty(r3));
            }
            return t4 || (this.seen[e4] = n3, this.seen[r3] = 0), r3;
          }
          slug(e4, t4 = {}) {
            const r3 = this.serialize(e4);
            return this.getNextSafeSlug(r3, t4.dryrun);
          }
        }
        class Pr {
          constructor(e4) {
            this.options = e4 || Jt, this.options.renderer = this.options.renderer || new $r(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Sr(), this.slugger = new Cr();
          }
          static parse(e4, t4) {
            return new Pr(t4).parse(e4);
          }
          static parseInline(e4, t4) {
            return new Pr(t4).parseInline(e4);
          }
          parse(e4, t4 = true) {
            let r3, n3, o2, i2, s2, a2, l3, c3, p3, u3, d3, h3, m3, f3, g3, y3, b3, x3, v3, w3 = "";
            const k3 = e4.length;
            for (r3 = 0; r3 < k3; r3++)
              if (u3 = e4[r3], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[u3.type] && (v3 = this.options.extensions.renderers[u3.type].call({ parser: this }, u3), false !== v3 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(u3.type)))
                w3 += v3 || "";
              else
                switch (u3.type) {
                  case "space":
                    continue;
                  case "hr":
                    w3 += this.renderer.hr();
                    continue;
                  case "heading":
                    w3 += this.renderer.heading(this.parseInline(u3.tokens), u3.depth, nr(this.parseInline(u3.tokens, this.textRenderer)), this.slugger);
                    continue;
                  case "code":
                    w3 += this.renderer.code(u3.text, u3.lang, u3.escaped);
                    continue;
                  case "table":
                    for (c3 = "", l3 = "", i2 = u3.header.length, n3 = 0; n3 < i2; n3++)
                      l3 += this.renderer.tablecell(this.parseInline(u3.header[n3].tokens), { header: true, align: u3.align[n3] });
                    for (c3 += this.renderer.tablerow(l3), p3 = "", i2 = u3.rows.length, n3 = 0; n3 < i2; n3++) {
                      for (a2 = u3.rows[n3], l3 = "", s2 = a2.length, o2 = 0; o2 < s2; o2++)
                        l3 += this.renderer.tablecell(this.parseInline(a2[o2].tokens), { header: false, align: u3.align[o2] });
                      p3 += this.renderer.tablerow(l3);
                    }
                    w3 += this.renderer.table(c3, p3);
                    continue;
                  case "blockquote":
                    p3 = this.parse(u3.tokens), w3 += this.renderer.blockquote(p3);
                    continue;
                  case "list":
                    for (d3 = u3.ordered, h3 = u3.start, m3 = u3.loose, i2 = u3.items.length, p3 = "", n3 = 0; n3 < i2; n3++)
                      g3 = u3.items[n3], y3 = g3.checked, b3 = g3.task, f3 = "", g3.task && (x3 = this.renderer.checkbox(y3), m3 ? g3.tokens.length > 0 && "paragraph" === g3.tokens[0].type ? (g3.tokens[0].text = x3 + " " + g3.tokens[0].text, g3.tokens[0].tokens && g3.tokens[0].tokens.length > 0 && "text" === g3.tokens[0].tokens[0].type && (g3.tokens[0].tokens[0].text = x3 + " " + g3.tokens[0].tokens[0].text)) : g3.tokens.unshift({ type: "text", text: x3 }) : f3 += x3), f3 += this.parse(g3.tokens, m3), p3 += this.renderer.listitem(f3, b3, y3);
                    w3 += this.renderer.list(p3, d3, h3);
                    continue;
                  case "html":
                    w3 += this.renderer.html(u3.text);
                    continue;
                  case "paragraph":
                    w3 += this.renderer.paragraph(this.parseInline(u3.tokens));
                    continue;
                  case "text":
                    for (p3 = u3.tokens ? this.parseInline(u3.tokens) : u3.text; r3 + 1 < k3 && "text" === e4[r3 + 1].type; )
                      u3 = e4[++r3], p3 += "\n" + (u3.tokens ? this.parseInline(u3.tokens) : u3.text);
                    w3 += t4 ? this.renderer.paragraph(p3) : p3;
                    continue;
                  default: {
                    const e5 = 'Token with "' + u3.type + '" type was not found.';
                    if (this.options.silent)
                      return void console.error(e5);
                    throw new Error(e5);
                  }
                }
            return w3;
          }
          parseInline(e4, t4) {
            t4 = t4 || this.renderer;
            let r3, n3, o2, i2 = "";
            const s2 = e4.length;
            for (r3 = 0; r3 < s2; r3++)
              if (n3 = e4[r3], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[n3.type] && (o2 = this.options.extensions.renderers[n3.type].call({ parser: this }, n3), false !== o2 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(n3.type)))
                i2 += o2 || "";
              else
                switch (n3.type) {
                  case "escape":
                  case "text":
                    i2 += t4.text(n3.text);
                    break;
                  case "html":
                    i2 += t4.html(n3.text);
                    break;
                  case "link":
                    i2 += t4.link(n3.href, n3.title, this.parseInline(n3.tokens, t4));
                    break;
                  case "image":
                    i2 += t4.image(n3.href, n3.title, n3.text);
                    break;
                  case "strong":
                    i2 += t4.strong(this.parseInline(n3.tokens, t4));
                    break;
                  case "em":
                    i2 += t4.em(this.parseInline(n3.tokens, t4));
                    break;
                  case "codespan":
                    i2 += t4.codespan(n3.text);
                    break;
                  case "br":
                    i2 += t4.br();
                    break;
                  case "del":
                    i2 += t4.del(this.parseInline(n3.tokens, t4));
                    break;
                  default: {
                    const e5 = 'Token with "' + n3.type + '" type was not found.';
                    if (this.options.silent)
                      return void console.error(e5);
                    throw new Error(e5);
                  }
                }
            return i2;
          }
        }
        function Ar(e4, t4, r3) {
          if (null == e4)
            throw new Error("marked(): input parameter is undefined or null");
          if ("string" != typeof e4)
            throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e4) + ", string expected");
          if ("function" == typeof t4 && (r3 = t4, t4 = null), yr(t4 = mr({}, Ar.defaults, t4 || {})), r3) {
            const n3 = t4.highlight;
            let o2;
            try {
              o2 = jr.lex(e4, t4);
            } catch (e5) {
              return r3(e5);
            }
            const i2 = function(e5) {
              let i3;
              if (!e5)
                try {
                  t4.walkTokens && Ar.walkTokens(o2, t4.walkTokens), i3 = Pr.parse(o2, t4);
                } catch (t5) {
                  e5 = t5;
                }
              return t4.highlight = n3, e5 ? r3(e5) : r3(null, i3);
            };
            if (!n3 || n3.length < 3)
              return i2();
            if (delete t4.highlight, !o2.length)
              return i2();
            let s2 = 0;
            return Ar.walkTokens(o2, function(e5) {
              "code" === e5.type && (s2++, setTimeout(() => {
                n3(e5.text, e5.lang, function(t5, r4) {
                  if (t5)
                    return i2(t5);
                  null != r4 && r4 !== e5.text && (e5.text = r4, e5.escaped = true), s2--, 0 === s2 && i2();
                });
              }, 0));
            }), void (0 === s2 && i2());
          }
          try {
            const r4 = jr.lex(e4, t4);
            return t4.walkTokens && Ar.walkTokens(r4, t4.walkTokens), Pr.parse(r4, t4);
          } catch (e5) {
            if (e5.message += "\nPlease report this to https://github.com/markedjs/marked.", t4.silent)
              return "<p>An error occurred:</p><pre>" + tr(e5.message + "", true) + "</pre>";
            throw e5;
          }
        }
        Ar.options = Ar.setOptions = function(e4) {
          var t4;
          return mr(Ar.defaults, e4), t4 = Ar.defaults, Jt = t4, Ar;
        }, Ar.getDefaults = function() {
          return { baseUrl: null, breaks: false, extensions: null, gfm: true, headerIds: true, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: true, pedantic: false, renderer: null, sanitize: false, sanitizer: null, silent: false, smartLists: false, smartypants: false, tokenizer: null, walkTokens: null, xhtml: false };
        }, Ar.defaults = Jt, Ar.use = function(...e4) {
          const t4 = mr({}, ...e4), r3 = Ar.defaults.extensions || { renderers: {}, childTokens: {} };
          let n3;
          e4.forEach((e5) => {
            if (e5.extensions && (n3 = true, e5.extensions.forEach((e6) => {
              if (!e6.name)
                throw new Error("extension name required");
              if (e6.renderer) {
                const t5 = r3.renderers ? r3.renderers[e6.name] : null;
                r3.renderers[e6.name] = t5 ? function(...r4) {
                  let n4 = e6.renderer.apply(this, r4);
                  return false === n4 && (n4 = t5.apply(this, r4)), n4;
                } : e6.renderer;
              }
              if (e6.tokenizer) {
                if (!e6.level || "block" !== e6.level && "inline" !== e6.level)
                  throw new Error("extension level must be 'block' or 'inline'");
                r3[e6.level] ? r3[e6.level].unshift(e6.tokenizer) : r3[e6.level] = [e6.tokenizer], e6.start && ("block" === e6.level ? r3.startBlock ? r3.startBlock.push(e6.start) : r3.startBlock = [e6.start] : "inline" === e6.level && (r3.startInline ? r3.startInline.push(e6.start) : r3.startInline = [e6.start]));
              }
              e6.childTokens && (r3.childTokens[e6.name] = e6.childTokens);
            })), e5.renderer) {
              const r4 = Ar.defaults.renderer || new $r();
              for (const t5 in e5.renderer) {
                const n4 = r4[t5];
                r4[t5] = (...o2) => {
                  let i2 = e5.renderer[t5].apply(r4, o2);
                  return false === i2 && (i2 = n4.apply(r4, o2)), i2;
                };
              }
              t4.renderer = r4;
            }
            if (e5.tokenizer) {
              const r4 = Ar.defaults.tokenizer || new vr();
              for (const t5 in e5.tokenizer) {
                const n4 = r4[t5];
                r4[t5] = (...o2) => {
                  let i2 = e5.tokenizer[t5].apply(r4, o2);
                  return false === i2 && (i2 = n4.apply(r4, o2)), i2;
                };
              }
              t4.tokenizer = r4;
            }
            if (e5.walkTokens) {
              const r4 = Ar.defaults.walkTokens;
              t4.walkTokens = function(t5) {
                e5.walkTokens.call(this, t5), r4 && r4.call(this, t5);
              };
            }
            n3 && (t4.extensions = r3), Ar.setOptions(t4);
          });
        }, Ar.walkTokens = function(e4, t4) {
          for (const r3 of e4)
            switch (t4.call(Ar, r3), r3.type) {
              case "table":
                for (const e5 of r3.header)
                  Ar.walkTokens(e5.tokens, t4);
                for (const e5 of r3.rows)
                  for (const r4 of e5)
                    Ar.walkTokens(r4.tokens, t4);
                break;
              case "list":
                Ar.walkTokens(r3.items, t4);
                break;
              default:
                Ar.defaults.extensions && Ar.defaults.extensions.childTokens && Ar.defaults.extensions.childTokens[r3.type] ? Ar.defaults.extensions.childTokens[r3.type].forEach(function(e5) {
                  Ar.walkTokens(r3[e5], t4);
                }) : r3.tokens && Ar.walkTokens(r3.tokens, t4);
            }
        }, Ar.parseInline = function(e4, t4) {
          if (null == e4)
            throw new Error("marked.parseInline(): input parameter is undefined or null");
          if ("string" != typeof e4)
            throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(e4) + ", string expected");
          yr(t4 = mr({}, Ar.defaults, t4 || {}));
          try {
            const r3 = jr.lexInline(e4, t4);
            return t4.walkTokens && Ar.walkTokens(r3, t4.walkTokens), Pr.parseInline(r3, t4);
          } catch (e5) {
            if (e5.message += "\nPlease report this to https://github.com/markedjs/marked.", t4.silent)
              return "<p>An error occurred:</p><pre>" + tr(e5.message + "", true) + "</pre>";
            throw e5;
          }
        }, Ar.Parser = Pr, Ar.parser = Pr.parse, Ar.Renderer = $r, Ar.TextRenderer = Sr, Ar.Lexer = jr, Ar.lexer = jr.lex, Ar.Tokenizer = vr, Ar.Slugger = Cr, Ar.parse = Ar, Ar.options, Ar.setOptions, Ar.use, Ar.walkTokens, Ar.parseInline, Pr.parse, jr.lex;
        var Ir = Object.defineProperty, Tr = Object.defineProperties, _r = Object.getOwnPropertyDescriptors, Rr = Object.getOwnPropertySymbols, Lr = Object.prototype.hasOwnProperty, Dr = Object.prototype.propertyIsEnumerable, zr = (e4, t4, r3) => t4 in e4 ? Ir(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Nr = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Lr.call(t4, r3) && zr(e4, r3, t4[r3]);
          if (Rr)
            for (var r3 of Rr(t4))
              Dr.call(t4, r3) && zr(e4, r3, t4[r3]);
          return e4;
        };
        const Mr = new Ar.Renderer();
        Ar.setOptions({ renderer: Mr, highlight: (e4, t4) => jt(e4, t4) });
        const qr = "^ {0,3}<!-- ReDoc-Inject:\\s+?<({component}).*?/?>\\s+?-->\\s*$", Fr = "(?:^ {0,3}<({component})([\\s\\S]*?)>([\\s\\S]*?)</\\2>|^ {0,3}<({component})([\\s\\S]*?)(?:/>|\\n{2,}))", Br = "(?:" + qr + "|" + Fr + ")";
        function Qr(e4) {
          return `<!-- ReDoc-Inject: <${e4}> -->`;
        }
        class Ur {
          constructor(e4, t4) {
            this.options = e4, this.parentId = t4, this.headings = [], this.headingRule = (e5, t5, r3, n3) => (1 === t5 ? this.currentTopHeading = this.saveHeading(e5, t5) : 2 === t5 && this.saveHeading(e5, t5, this.currentTopHeading && this.currentTopHeading.items, this.currentTopHeading && this.currentTopHeading.id), this.originalHeadingRule(e5, t5, r3, n3)), this.parentId = t4, this.parser = new Ar.Parser(), this.headingEnhanceRenderer = new Ar.Renderer(), this.originalHeadingRule = this.headingEnhanceRenderer.heading.bind(this.headingEnhanceRenderer), this.headingEnhanceRenderer.heading = this.headingRule;
          }
          static containsComponent(e4, t4) {
            return new RegExp(Br.replace(/{component}/g, t4), "gmi").test(e4);
          }
          static getTextBeforeHading(e4, t4) {
            const r3 = e4.search(new RegExp(`^##?\\s+${t4}`, "m"));
            return r3 > -1 ? e4.substring(0, r3) : e4;
          }
          saveHeading(e4, t4, r3 = this.headings, n3) {
            e4 = P2(e4);
            const o2 = { id: n3 ? `${n3}/${w2(e4)}` : `${this.parentId || "section"}/${w2(e4)}`, name: e4, level: t4, items: [] };
            return r3.push(o2), o2;
          }
          flattenHeadings(e4) {
            if (void 0 === e4)
              return [];
            const t4 = [];
            for (const r3 of e4)
              t4.push(r3), t4.push(...this.flattenHeadings(r3.items));
            return t4;
          }
          attachHeadingsDescriptions(e4) {
            const t4 = (e5) => new RegExp(`##?\\s+${e5.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}s*(
|\r
|$|s*)`), r3 = this.flattenHeadings(this.headings);
            if (r3.length < 1)
              return;
            let n3 = r3[0], o2 = t4(n3), i2 = e4.search(o2);
            for (let s2 = 1; s2 < r3.length; s2++) {
              const a2 = r3[s2], l3 = t4(a2), c3 = e4.substr(i2 + 1).search(l3) + i2 + 1;
              n3.description = e4.substring(i2, c3).replace(o2, "").trim(), n3 = a2, o2 = l3, i2 = c3;
            }
            n3.description = e4.substring(i2).replace(o2, "").trim();
          }
          renderMd(e4, t4 = false) {
            const r3 = t4 ? { renderer: this.headingEnhanceRenderer } : void 0;
            return Ar(e4.toString(), r3);
          }
          extractHeadings(e4) {
            this.renderMd(e4, true), this.attachHeadingsDescriptions(e4);
            const t4 = this.headings;
            return this.headings = [], t4;
          }
          renderMdWithComponents(e4) {
            const t4 = this.options && this.options.allowedMdComponents;
            if (!t4 || 0 === Object.keys(t4).length)
              return [this.renderMd(e4)];
            const r3 = Object.keys(t4).join("|"), n3 = new RegExp(Br.replace(/{component}/g, r3), "mig"), o2 = [], i2 = [];
            let s2 = n3.exec(e4), a2 = 0;
            for (; s2; ) {
              o2.push(e4.substring(a2, s2.index)), a2 = n3.lastIndex;
              const r4 = t4[s2[1] || s2[2] || s2[5]], p4 = s2[3] || s2[6], u3 = s2[4];
              r4 && i2.push({ component: r4.component, propsSelector: r4.propsSelector, props: (l3 = Nr(Nr({}, Wr(p4)), r4.props), c3 = { children: u3 }, Tr(l3, _r(c3))) }), s2 = n3.exec(e4);
            }
            var l3, c3;
            o2.push(e4.substring(a2));
            const p3 = [];
            for (let e5 = 0; e5 < o2.length; e5++) {
              const t5 = o2[e5];
              t5 && p3.push(this.renderMd(t5)), i2[e5] && p3.push(i2[e5]);
            }
            return p3;
          }
        }
        function Wr(e4) {
          if (!e4)
            return {};
          const t4 = /([\w-]+)\s*=\s*(?:{([^}]+?)}|"([^"]+?)")/gim, r3 = {};
          let n3;
          for (; null !== (n3 = t4.exec(e4)); )
            if (n3[3])
              r3[n3[1]] = n3[3];
            else if (n3[2]) {
              let e5;
              try {
                e5 = JSON.parse(n3[2]);
              } catch (e6) {
              }
              r3[n3[1]] = e5;
            }
          return r3;
        }
        class Vr {
          constructor(e4, t4 = new W2({})) {
            this.parser = e4, this.options = t4, Object.assign(this, e4.spec.info), this.description = e4.spec.info.description || "", this.summary = e4.spec.info.summary || "";
            const r3 = this.description.search(/^\s*##?\s+/m);
            r3 > -1 && (this.description = this.description.substring(0, r3)), this.downloadLink = this.getDownloadLink(), this.downloadFileName = this.getDownloadFileName();
          }
          getDownloadLink() {
            if (this.options.downloadDefinitionUrl)
              return this.options.downloadDefinitionUrl;
            if (this.parser.specUrl)
              return this.parser.specUrl;
            if (s && window.Blob && window.URL && window.URL.createObjectURL) {
              const e4 = new Blob([JSON.stringify(this.parser.spec, null, 2)], { type: "application/json" });
              return window.URL.createObjectURL(e4);
            }
          }
          getDownloadFileName() {
            return this.parser.specUrl || this.options.downloadDefinitionUrl ? this.options.downloadFileName : this.options.downloadFileName || "openapi.json";
          }
        }
        var Hr = Object.defineProperty, Jr = Object.defineProperties, Yr = Object.getOwnPropertyDescriptors, Zr = Object.getOwnPropertySymbols, Gr = Object.prototype.hasOwnProperty, Xr = Object.prototype.propertyIsEnumerable, Kr = (e4, t4, r3) => t4 in e4 ? Hr(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        class en {
          constructor(e4, t4) {
            const r3 = t4.spec.components && t4.spec.components.securitySchemes || {};
            this.schemes = Object.keys(e4 || {}).map((n3) => {
              const { resolved: o2 } = t4.deref(r3[n3]), i2 = e4[n3] || [];
              if (!o2)
                return void console.warn(`Non existing security scheme referenced: ${n3}. Skipping`);
              const s2 = o2["x-displayName"] || n3;
              return a2 = ((e5, t5) => {
                for (var r4 in t5 || (t5 = {}))
                  Gr.call(t5, r4) && Kr(e5, r4, t5[r4]);
                if (Zr)
                  for (var r4 of Zr(t5))
                    Xr.call(t5, r4) && Kr(e5, r4, t5[r4]);
                return e5;
              })({}, o2), Jr(a2, Yr({ id: n3, sectionId: n3, displayName: s2, scopes: i2 }));
              var a2;
            }).filter((e5) => void 0 !== e5);
          }
        }
        var tn = Object.defineProperty, rn = Object.defineProperties, nn = Object.getOwnPropertyDescriptor, on = Object.getOwnPropertyDescriptors, sn = Object.getOwnPropertySymbols, an = Object.prototype.hasOwnProperty, ln = Object.prototype.propertyIsEnumerable, cn = (e4, t4, r3) => t4 in e4 ? tn(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, pn = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            an.call(t4, r3) && cn(e4, r3, t4[r3]);
          if (sn)
            for (var r3 of sn(t4))
              ln.call(t4, r3) && cn(e4, r3, t4[r3]);
          return e4;
        }, un = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? nn(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && tn(t4, r3, i2), i2;
        };
        class dn {
          constructor(e4, t4, r3, n3, o2) {
            this.expanded = false, this.operations = [], (0, de2.makeObservable)(this), this.name = t4;
            const { resolved: i2 } = e4.deref(r3);
            for (const r4 of Object.keys(i2)) {
              const l3 = i2[r4], c3 = Object.keys(l3).filter(Me2);
              for (const i3 of c3) {
                const c4 = l3[i3], p3 = new yo(e4, (s2 = pn({}, c4), a2 = { pathName: r4, pointer: Oe2.compile([n3, t4, r4, i3]), httpVerb: i3, pathParameters: l3.parameters || [], pathServers: l3.servers }, rn(s2, on(a2))), void 0, o2, true);
                this.operations.push(p3);
              }
            }
            var s2, a2;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        un([de2.observable], dn.prototype, "expanded", 2), un([de2.action], dn.prototype, "toggle", 1);
        var hn = Object.defineProperty, mn = Object.defineProperties, fn2 = Object.getOwnPropertyDescriptors, gn = Object.getOwnPropertySymbols, yn = Object.prototype.hasOwnProperty, bn = Object.prototype.propertyIsEnumerable, xn = (e4, t4, r3) => t4 in e4 ? hn(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, vn = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            yn.call(t4, r3) && xn(e4, r3, t4[r3]);
          if (gn)
            for (var r3 of gn(t4))
              bn.call(t4, r3) && xn(e4, r3, t4[r3]);
          return e4;
        }, wn = (e4, t4) => mn(e4, fn2(t4)), kn = (e4, t4) => {
          var r3 = {};
          for (var n3 in e4)
            yn.call(e4, n3) && t4.indexOf(n3) < 0 && (r3[n3] = e4[n3]);
          if (null != e4 && gn)
            for (var n3 of gn(e4))
              t4.indexOf(n3) < 0 && bn.call(e4, n3) && (r3[n3] = e4[n3]);
          return r3;
        };
        function On(e4, t4) {
          return t4 && e4[e4.length - 1] !== t4 ? [...e4, t4] : e4;
        }
        function En(e4, t4) {
          return t4 ? e4.concat(t4) : e4;
        }
        class jn {
          constructor(e4, t4, r3 = new W2({})) {
            this.options = r3, this.allowMergeRefs = false, this.byRef = (e5) => {
              let t5;
              if (this.spec) {
                "#" !== e5.charAt(0) && (e5 = "#" + e5), e5 = decodeURIComponent(e5);
                try {
                  t5 = Oe2.get(this.spec, e5);
                } catch (e6) {
                }
                return t5 || {};
              }
            }, this.validate(e4), this.spec = e4, this.allowMergeRefs = e4.openapi.startsWith("3.1");
            const n3 = s ? window.location.href : "";
            "string" == typeof t4 && (this.specUrl = n3 ? new URL(t4, n3).href : t4);
          }
          validate(e4) {
            if (void 0 === e4.openapi)
              throw new Error("Document must be valid OpenAPI 3.0.0 definition");
          }
          isRef(e4) {
            return !!e4 && void 0 !== e4.$ref && null !== e4.$ref;
          }
          deref(e4, t4 = [], r3 = false) {
            const n3 = null == e4 ? void 0 : e4["x-refsStack"];
            if (t4 = En(t4, n3), this.isRef(e4)) {
              const n4 = rt2(e4.$ref);
              if (n4 && this.options.ignoreNamedSchemas.has(n4))
                return { resolved: { type: "object", title: n4 }, refsStack: t4 };
              let o2 = this.byRef(e4.$ref);
              if (!o2)
                throw new Error(`Failed to resolve $ref "${e4.$ref}"`);
              let i2 = t4;
              if (t4.includes(e4.$ref) || t4.length > 999)
                o2 = Object.assign({}, o2, { "x-circular-ref": true });
              else if (this.isRef(o2)) {
                const e5 = this.deref(o2, t4, r3);
                i2 = e5.refsStack, o2 = e5.resolved;
              }
              return i2 = On(t4, e4.$ref), o2 = this.allowMergeRefs ? this.mergeRefs(e4, o2, r3) : o2, { resolved: o2, refsStack: i2 };
            }
            return { resolved: e4, refsStack: En(t4, n3) };
          }
          mergeRefs(e4, t4, r3) {
            const n3 = e4, i2 = kn(n3, ["$ref"]), s2 = Object.keys(i2);
            if (0 === s2.length)
              return t4;
            if (r3 && s2.some((e5) => !["description", "title", "externalDocs", "x-refsStack", "x-parentRefs", "readOnly", "writeOnly"].includes(e5))) {
              const e5 = i2, { description: r4, title: n4, readOnly: o2, writeOnly: s3 } = e5;
              return { allOf: [{ description: r4, title: n4, readOnly: o2, writeOnly: s3 }, t4, kn(e5, ["description", "title", "readOnly", "writeOnly"])] };
            }
            return vn(vn({}, t4), i2);
          }
          mergeAllOf(e4, t4, r3) {
            var n3;
            if (e4["x-circular-ref"])
              return e4;
            if (void 0 === (e4 = this.hoistOneOfs(e4, r3)).allOf)
              return e4;
            let o2 = wn(vn({}, e4), { "x-parentRefs": [], allOf: void 0, title: e4.title || rt2(t4) });
            void 0 !== o2.properties && "object" == typeof o2.properties && (o2.properties = vn({}, o2.properties)), void 0 !== o2.items && "object" == typeof o2.items && (o2.items = vn({}, o2.items));
            const i2 = function(e5, t5) {
              const r4 = /* @__PURE__ */ new Set();
              return e5.filter((e6) => {
                const t6 = e6.$ref;
                return !t6 || t6 && !r4.has(t6) && r4.add(t6);
              });
            }(e4.allOf.map((e5) => {
              var t5;
              const { resolved: n4, refsStack: i3 } = this.deref(e5, r3, true), s2 = e5.$ref || void 0, a2 = this.mergeAllOf(n4, s2, i3);
              if (!a2["x-circular-ref"] || !a2.allOf)
                return s2 && (null == (t5 = o2["x-parentRefs"]) || t5.push(...a2["x-parentRefs"] || [], s2)), { $ref: s2, refsStack: On(i3, s2), schema: a2 };
            }).filter((e5) => void 0 !== e5));
            for (const { schema: e5, refsStack: r4 } of i2) {
              const i3 = e5, { type: s2, enum: a2, properties: l3, items: c3, required: p3, title: u3, description: d3, readOnly: h3, writeOnly: m3, oneOf: f3, anyOf: g3, "x-circular-ref": y3 } = i3, b3 = kn(i3, ["type", "enum", "properties", "items", "required", "title", "description", "readOnly", "writeOnly", "oneOf", "anyOf", "x-circular-ref"]);
              if (o2.type !== s2 && void 0 !== o2.type && void 0 !== s2 && console.warn(`Incompatible types in allOf at "${t4}": "${o2.type}" and "${s2}"`), void 0 !== s2 && (Array.isArray(s2) && Array.isArray(o2.type) ? o2.type = [...s2, ...o2.type] : o2.type = s2), void 0 !== a2 && (Array.isArray(a2) && Array.isArray(o2.enum) ? o2.enum = Array.from(/* @__PURE__ */ new Set([...a2, ...o2.enum])) : o2.enum = a2), void 0 !== l3 && "object" == typeof l3) {
                o2.properties = o2.properties || {};
                for (const e6 in l3) {
                  const i4 = En(r4, null == (n3 = l3[e6]) ? void 0 : n3["x-refsStack"]);
                  if (o2.properties[e6]) {
                    if (!y3) {
                      const r5 = this.mergeAllOf({ allOf: [o2.properties[e6], wn(vn({}, l3[e6]), { "x-refsStack": i4 })], "x-refsStack": i4 }, t4 + "/properties/" + e6, i4);
                      o2.properties[e6] = r5;
                    }
                  } else
                    o2.properties[e6] = wn(vn({}, l3[e6]), { "x-refsStack": i4 });
                }
              }
              if (void 0 !== c3 && !y3) {
                const n4 = "boolean" == typeof o2.items ? {} : Object.assign({}, o2.items), i4 = "boolean" == typeof e5.items ? {} : Object.assign({}, e5.items);
                o2.items = this.mergeAllOf({ allOf: [n4, i4] }, t4 + "/items", r4);
              }
              void 0 !== f3 && (o2.oneOf = f3), void 0 !== g3 && (o2.anyOf = g3), void 0 !== p3 && (o2.required = [...o2.required || [], ...p3]), o2 = vn(wn(vn({}, o2), { title: o2.title || u3, description: o2.description || d3, readOnly: void 0 !== o2.readOnly ? o2.readOnly : h3, writeOnly: void 0 !== o2.writeOnly ? o2.writeOnly : m3, "x-circular-ref": o2["x-circular-ref"] || y3 }), b3);
            }
            return o2;
          }
          findDerived(e4) {
            const t4 = {}, r3 = this.spec.components && this.spec.components.schemas || {};
            for (const n3 in r3) {
              const { resolved: o2 } = this.deref(r3[n3]);
              void 0 !== o2.allOf && o2.allOf.find((t5) => void 0 !== t5.$ref && e4.indexOf(t5.$ref) > -1) && (t4["#/components/schemas/" + n3] = [o2["x-discriminator-value"] || n3]);
            }
            return t4;
          }
          hoistOneOfs(e4, t4) {
            if (void 0 === e4.allOf)
              return e4;
            const r3 = e4.allOf;
            for (let e5 = 0; e5 < r3.length; e5++) {
              const n3 = r3[e5];
              if (Array.isArray(n3.oneOf)) {
                const o2 = r3.slice(0, e5), i2 = r3.slice(e5 + 1);
                return { oneOf: n3.oneOf.map((e6) => ({ allOf: [...o2, e6, ...i2], "x-refsStack": t4 })) };
              }
            }
            return e4;
          }
        }
        var $n = Object.defineProperty, Sn = Object.defineProperties, Cn = Object.getOwnPropertyDescriptor, Pn = Object.getOwnPropertyDescriptors, An = Object.getOwnPropertySymbols, In = Object.prototype.hasOwnProperty, Tn = Object.prototype.propertyIsEnumerable, _n = (e4, t4, r3) => t4 in e4 ? $n(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Rn = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            In.call(t4, r3) && _n(e4, r3, t4[r3]);
          if (An)
            for (var r3 of An(t4))
              Tn.call(t4, r3) && _n(e4, r3, t4[r3]);
          return e4;
        }, Ln = (e4, t4) => Sn(e4, Pn(t4)), Dn = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? Cn(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && $n(t4, r3, i2), i2;
        };
        const zn = class {
          constructor(e4, t4, r3, n3, o2 = false, i2 = []) {
            this.options = n3, this.refsStack = i2, this.typePrefix = "", this.isCircular = false, this.activeOneOf = 0, (0, de2.makeObservable)(this), this.pointer = t4.$ref || r3 || "";
            const { resolved: s2, refsStack: a2 } = e4.deref(t4, i2, true);
            this.refsStack = On(a2, this.pointer), this.rawSchema = s2, this.schema = e4.mergeAllOf(this.rawSchema, this.pointer, this.refsStack), this.init(e4, o2), n3.showExtensions && (this.extensions = xt(this.schema, n3.showExtensions));
          }
          activateOneOf(e4) {
            this.activeOneOf = e4;
          }
          hasType(e4) {
            return this.type === e4 || A2(this.type) && this.type.includes(e4);
          }
          init(e4, t4) {
            var r3, n3, o2, i2, s2, a2, l3, c3;
            const p3 = this.schema;
            if (this.isCircular = !!p3["x-circular-ref"], this.title = p3.title || tt2(this.pointer) && Oe2.baseName(this.pointer) || "", this.description = p3.description || "", this.type = p3.type || Be2(p3), this.format = p3.format, this.enum = p3.enum || [], this.example = p3.example, this.examples = p3.examples, this.deprecated = !!p3.deprecated, this.pattern = p3.pattern, this.externalDocs = p3.externalDocs, this.constraints = it2(p3), this.displayFormat = this.format, this.isPrimitive = Qe2(p3, this.type), this.default = p3.default, this.readOnly = !!p3.readOnly, this.writeOnly = !!p3.writeOnly, this.const = p3.const || "", this.contentEncoding = p3.contentEncoding, this.contentMediaType = p3.contentMediaType, this.minItems = p3.minItems, this.maxItems = p3.maxItems, (p3.nullable || p3["x-nullable"]) && (A2(this.type) && !this.type.some((e5) => null === e5 || "null" === e5) ? this.type = [...this.type, "null"] : A2(this.type) || null === this.type && "null" === this.type || (this.type = [this.type, "null"])), this.displayType = A2(this.type) ? this.type.map((e5) => null === e5 ? "null" : e5).join(" or ") : this.type, !this.isCircular)
              if (p3.if && p3.then || p3.if && p3.else)
                this.initConditionalOperators(p3, e4);
              else if (t4 || void 0 === qn(p3)) {
                if (t4 && A2(p3.oneOf) && p3.oneOf.find((e5) => e5.$ref === this.pointer) && delete p3.oneOf, void 0 !== p3.oneOf)
                  return this.initOneOf(p3.oneOf, e4), this.oneOfType = "One of", void (void 0 !== p3.anyOf && console.warn(`oneOf and anyOf are not supported on the same level. Skipping anyOf at ${this.pointer}`));
                if (void 0 !== p3.anyOf)
                  return this.initOneOf(p3.anyOf, e4), void (this.oneOfType = "Any of");
                if (this.hasType("object"))
                  this.fields = Mn(e4, p3, this.pointer, this.options, this.refsStack);
                else if (this.hasType("array") && (A2(p3.items) || A2(p3.prefixItems) ? this.fields = Mn(e4, p3, this.pointer, this.options, this.refsStack) : p3.items && (this.items = new zn(e4, p3.items, this.pointer + "/items", this.options, false, this.refsStack)), this.displayType = p3.prefixItems || A2(p3.items) ? "items" : vt((null == (r3 = this.items) ? void 0 : r3.displayType) || this.displayType), this.displayFormat = (null == (n3 = this.items) ? void 0 : n3.format) || "", this.typePrefix = (null == (o2 = this.items) ? void 0 : o2.typePrefix) || "" + _2("arrayOf"), this.title = this.title || (null == (i2 = this.items) ? void 0 : i2.title) || "", this.isPrimitive = void 0 !== (null == (s2 = this.items) ? void 0 : s2.isPrimitive) ? null == (a2 = this.items) ? void 0 : a2.isPrimitive : this.isPrimitive, void 0 === this.example && void 0 !== (null == (l3 = this.items) ? void 0 : l3.example) && (this.example = [this.items.example]), (null == (c3 = this.items) ? void 0 : c3.isPrimitive) && (this.enum = this.items.enum), A2(this.type))) {
                  const e5 = this.type.filter((e6) => "array" !== e6);
                  e5.length && (this.displayType += ` or ${e5.join(" or ")}`);
                }
                this.enum.length && this.options.sortEnumValuesAlphabetically && this.enum.sort();
              } else
                this.initDiscriminator(p3, e4);
          }
          initOneOf(e4, t4) {
            if (this.oneOf = e4.map((e5, r3) => {
              const { resolved: n3, refsStack: o2 } = t4.deref(e5, this.refsStack, true), i2 = t4.mergeAllOf(n3, this.pointer + "/oneOf/" + r3, o2), s2 = tt2(e5.$ref) && !i2.title ? Oe2.baseName(e5.$ref) : `${i2.title || ""}${void 0 !== i2.const && JSON.stringify(i2.const) || ""}`;
              return new zn(t4, Ln(Rn({}, i2), { title: s2, allOf: [Ln(Rn({}, this.schema), { oneOf: void 0, anyOf: void 0 })], discriminator: n3.allOf ? void 0 : i2.discriminator }), e5.$ref || this.pointer + "/oneOf/" + r3, this.options, false, o2);
            }), this.options.simpleOneOfTypeLabel) {
              const e5 = function(e6) {
                const t5 = /* @__PURE__ */ new Set();
                return function e7(r3) {
                  for (const n3 of r3.oneOf || [])
                    n3.oneOf ? e7(n3) : n3.type && t5.add(n3.type);
                }(e6), Array.from(t5.values());
              }(this);
              this.displayType = e5.join(" or ");
            } else
              this.displayType = this.oneOf.map((e5) => {
                let t5 = e5.typePrefix + (e5.title ? `${e5.title} (${e5.displayType})` : e5.displayType);
                return t5.indexOf(" or ") > -1 && (t5 = `(${t5})`), t5;
              }).join(" or ");
          }
          initDiscriminator(e4, t4) {
            const r3 = qn(e4);
            this.discriminatorProp = r3.propertyName;
            const n3 = t4.findDerived([...this.schema["x-parentRefs"] || [], this.pointer]);
            if (e4.oneOf)
              for (const t5 of e4.oneOf) {
                if (void 0 === t5.$ref)
                  continue;
                const e5 = Oe2.baseName(t5.$ref);
                n3[t5.$ref] = e5;
              }
            const o2 = r3.mapping || {};
            let i2 = r3["x-explicitMappingOnly"] || false;
            0 === Object.keys(o2).length && (i2 = false);
            const s2 = {};
            for (const e5 in o2) {
              const t5 = o2[e5];
              A2(s2[t5]) ? s2[t5].push(e5) : s2[t5] = [e5];
            }
            const a2 = Rn(i2 ? {} : Rn({}, n3), s2);
            let l3 = [];
            for (const e5 of Object.keys(a2)) {
              const t5 = a2[e5];
              if (A2(t5))
                for (const r4 of t5)
                  l3.push({ $ref: e5, name: r4 });
              else
                l3.push({ $ref: e5, name: t5 });
            }
            const c3 = Object.keys(o2);
            0 !== c3.length && (l3 = l3.sort((e5, t5) => {
              const r4 = c3.indexOf(e5.name), n4 = c3.indexOf(t5.name);
              return r4 < 0 && n4 < 0 ? e5.name.localeCompare(t5.name) : r4 < 0 ? 1 : n4 < 0 ? -1 : r4 - n4;
            })), this.oneOf = l3.map(({ $ref: e5, name: r4 }) => {
              const n4 = new zn(t4, { $ref: e5 }, e5, this.options, true, this.refsStack.slice(0, -1));
              return n4.title = r4, n4;
            });
          }
          initConditionalOperators(e4, t4) {
            const r3 = e4, { if: n3, else: o2 = {}, then: i2 = {} } = r3, s2 = ((e5, t5) => {
              var r4 = {};
              for (var n4 in e5)
                In.call(e5, n4) && t5.indexOf(n4) < 0 && (r4[n4] = e5[n4]);
              if (null != e5 && An)
                for (var n4 of An(e5))
                  t5.indexOf(n4) < 0 && Tn.call(e5, n4) && (r4[n4] = e5[n4]);
              return r4;
            })(r3, ["if", "else", "then"]), a2 = [{ allOf: [s2, i2, n3], title: n3 && n3["x-displayName"] || (null == n3 ? void 0 : n3.title) || "case 1" }, { allOf: [s2, o2], title: o2 && o2["x-displayName"] || (null == o2 ? void 0 : o2.title) || "case 2" }];
            this.oneOf = a2.map((e5, r4) => new zn(t4, Rn({}, e5), this.pointer + "/oneOf/" + r4, this.options, false, this.refsStack)), this.oneOfType = "One of";
          }
        };
        let Nn = zn;
        function Mn(e4, t4, r3, n3, o2) {
          const i2 = t4.properties || t4.prefixItems || t4.items || {}, s2 = t4.patternProperties || {}, a2 = t4.additionalProperties || t4.unevaluatedProperties, l3 = t4.prefixItems ? t4.items : t4.additionalItems, c3 = t4.default;
          let p3 = Object.keys(i2 || []).map((s3) => {
            let a3 = i2[s3];
            a3 || (console.warn(`Field "${s3}" is invalid, skipping.
 Field must be an object but got ${typeof a3} at "${r3}"`), a3 = {});
            const l4 = void 0 !== t4.required && t4.required.indexOf(s3) > -1;
            return new Hn(e4, { name: t4.properties ? s3 : `[${s3}]`, required: l4, schema: Ln(Rn({}, a3), { default: void 0 === a3.default && c3 ? c3[s3] : a3.default }) }, r3 + "/properties/" + s3, n3, o2);
          });
          return n3.sortPropsAlphabetically && (p3 = at2(p3, "name")), n3.requiredPropsFirst && (p3 = st2(p3, n3.sortPropsAlphabetically ? void 0 : t4.required)), p3.push(...Object.keys(s2).map((t5) => {
            let i3 = s2[t5];
            return i3 || (console.warn(`Field "${t5}" is invalid, skipping.
 Field must be an object but got ${typeof i3} at "${r3}"`), i3 = {}), new Hn(e4, { name: t5, required: false, schema: i3, kind: "patternProperties" }, `${r3}/patternProperties/${t5}`, n3, o2);
          })), "object" != typeof a2 && true !== a2 || p3.push(new Hn(e4, { name: ("object" == typeof a2 && a2["x-additionalPropertiesName"] || "property name").concat("*"), required: false, schema: true === a2 ? {} : a2, kind: "additionalProperties" }, r3 + "/additionalProperties", n3, o2)), p3.push(...function({ parser: e5, schema: t5 = false, fieldsCount: r4, $ref: n4, options: o3, refsStack: i3 }) {
            return I2(t5) ? t5 ? [new Hn(e5, { name: `[${r4}...]`, schema: {} }, `${n4}/additionalItems`, o3, i3)] : [] : A2(t5) ? [...t5.map((t6, s3) => new Hn(e5, { name: `[${r4 + s3}]`, schema: t6 }, `${n4}/additionalItems`, o3, i3))] : x2(t5) ? [new Hn(e5, { name: `[${r4}...]`, schema: t5 }, `${n4}/additionalItems`, o3, i3)] : [];
          }({ parser: e4, schema: l3, fieldsCount: p3.length, $ref: r3, options: n3, refsStack: o2 })), p3;
        }
        function qn(e4) {
          return e4.discriminator || e4["x-discriminator"];
        }
        Dn([de2.observable], Nn.prototype, "activeOneOf", 2), Dn([de2.action], Nn.prototype, "activateOneOf", 1);
        const Fn = {};
        class Bn {
          constructor(e4, t4, r3, n3) {
            this.mime = r3;
            const { resolved: o2 } = e4.deref(t4);
            this.value = o2.value, this.summary = o2.summary, this.description = o2.description, o2.externalValue && (this.externalValueUrl = new URL(o2.externalValue, e4.specUrl).href), We2(r3) && this.value && "object" == typeof this.value && (this.value = Ye2(this.value, n3));
          }
          getExternalValue(e4) {
            return this.externalValueUrl ? (this.externalValueUrl in Fn || (Fn[this.externalValueUrl] = fetch(this.externalValueUrl).then((t4) => t4.text().then((r3) => {
              if (!t4.ok)
                return Promise.reject(new Error(r3));
              if (!Ue2(e4))
                return r3;
              try {
                return JSON.parse(r3);
              } catch (e5) {
                return r3;
              }
            }))), Fn[this.externalValueUrl]) : Promise.resolve(void 0);
          }
        }
        var Qn = Object.defineProperty, Un = Object.getOwnPropertyDescriptor, Wn = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? Un(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && Qn(t4, r3, i2), i2;
        };
        const Vn = { path: { style: "simple", explode: false }, query: { style: "form", explode: true }, header: { style: "simple", explode: false }, cookie: { style: "form", explode: true } };
        class Hn {
          constructor(e4, t4, r3, n3, o2) {
            var i2, s2, a2, l3, c3;
            this.expanded = void 0, (0, de2.makeObservable)(this);
            const { resolved: p3 } = e4.deref(t4);
            this.kind = t4.kind || "field", this.name = t4.name || p3.name, this.in = p3.in, this.required = !!p3.required;
            let u3 = p3.schema, d3 = "";
            if (!u3 && p3.in && p3.content && (d3 = Object.keys(p3.content)[0], u3 = p3.content[d3] && p3.content[d3].schema), this.schema = new Nn(e4, u3 || {}, r3, n3, false, o2), this.description = void 0 === p3.description ? this.schema.description || "" : p3.description, this.example = p3.example || this.schema.example, void 0 !== p3.examples || void 0 !== this.schema.examples) {
              const t5 = p3.examples || this.schema.examples;
              this.examples = A2(t5) ? t5 : h2(t5, (t6, r4) => new Bn(e4, t6, r4, p3.encoding));
            }
            d3 ? this.serializationMime = d3 : p3.style ? this.style = p3.style : this.in && (this.style = null != (s2 = null == (i2 = Vn[this.in]) ? void 0 : i2.style) ? s2 : "form"), void 0 === p3.explode && this.in ? this.explode = null == (l3 = null == (a2 = Vn[this.in]) ? void 0 : a2.explode) || l3 : this.explode = !!p3.explode, this.deprecated = void 0 === p3.deprecated ? !!this.schema.deprecated : p3.deprecated, n3.showExtensions && (this.extensions = xt(p3, n3.showExtensions)), this.const = (null == (c3 = this.schema) ? void 0 : c3.const) || (null == p3 ? void 0 : p3.const) || "";
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          collapse() {
            this.expanded = false;
          }
          expand() {
            this.expanded = true;
          }
        }
        Wn([de2.observable], Hn.prototype, "expanded", 2), Wn([de2.action], Hn.prototype, "toggle", 1), Wn([de2.action], Hn.prototype, "collapse", 1), Wn([de2.action], Hn.prototype, "expand", 1);
        var Jn = require$$42;
        class Yn {
          constructor(e4, t4, r3, n3, o2) {
            this.name = t4, this.isRequestType = r3, this.schema = n3.schema && new Nn(e4, n3.schema, "", o2), this.onlyRequiredInSamples = o2.onlyRequiredInSamples, this.generatedPayloadSamplesMaxDepth = o2.generatedPayloadSamplesMaxDepth, void 0 !== n3.examples ? this.examples = h2(n3.examples, (r4) => new Bn(e4, r4, t4, n3.encoding)) : void 0 !== n3.example ? this.examples = { default: new Bn(e4, { value: e4.deref(n3.example).resolved }, t4, n3.encoding) } : Ue2(t4) && this.generateExample(e4, n3);
          }
          generateExample(e4, t4) {
            const r3 = { skipReadOnly: this.isRequestType, skipWriteOnly: !this.isRequestType, skipNonRequired: this.isRequestType && this.onlyRequiredInSamples, maxSampleDepth: this.generatedPayloadSamplesMaxDepth };
            if (this.schema && this.schema.oneOf) {
              this.examples = {};
              for (const n3 of this.schema.oneOf) {
                const o2 = Jn.sample(n3.rawSchema, r3, e4.spec);
                this.schema.discriminatorProp && "object" == typeof o2 && o2 && (o2[this.schema.discriminatorProp] = n3.title), this.examples[n3.title] = new Bn(e4, { value: o2 }, this.name, t4.encoding);
              }
            } else
              this.schema && (this.examples = { default: new Bn(e4, { value: Jn.sample(t4.schema, r3, e4.spec) }, this.name, t4.encoding) });
          }
        }
        var Zn = Object.defineProperty, Gn = Object.getOwnPropertyDescriptor, Xn = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? Gn(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && Zn(t4, r3, i2), i2;
        };
        class Kn {
          constructor(e4, t4, r3, n3) {
            this.isRequestType = r3, this.activeMimeIdx = 0, (0, de2.makeObservable)(this), n3.unstable_ignoreMimeParameters && (t4 = ct2(t4)), this.mediaTypes = Object.keys(t4).map((o2) => {
              const i2 = t4[o2];
              return new Yn(e4, o2, r3, i2, n3);
            });
          }
          activate(e4) {
            this.activeMimeIdx = e4;
          }
          get active() {
            return this.mediaTypes[this.activeMimeIdx];
          }
          get hasSample() {
            return this.mediaTypes.filter((e4) => !!e4.examples).length > 0;
          }
        }
        Xn([de2.observable], Kn.prototype, "activeMimeIdx", 2), Xn([de2.action], Kn.prototype, "activate", 1), Xn([de2.computed], Kn.prototype, "active", 1);
        class eo {
          constructor({ parser: e4, infoOrRef: t4, options: r3, isEvent: n3 }) {
            const o2 = !n3, { resolved: i2 } = e4.deref(t4);
            this.description = i2.description || "", this.required = i2.required;
            const s2 = wt(i2);
            void 0 !== s2 && (this.content = new Kn(e4, s2, o2, r3));
          }
        }
        var to = Object.defineProperty, ro = Object.defineProperties, no = Object.getOwnPropertyDescriptor, oo = Object.getOwnPropertyDescriptors, io = Object.getOwnPropertySymbols, so = Object.prototype.hasOwnProperty, ao = Object.prototype.propertyIsEnumerable, lo = (e4, t4, r3) => t4 in e4 ? to(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, co = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? no(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && to(t4, r3, i2), i2;
        };
        class po {
          constructor({ parser: e4, code: t4, defaultAsError: r3, infoOrRef: n3, options: o2, isEvent: i2 }) {
            this.expanded = false, this.headers = [], (0, de2.makeObservable)(this), this.expanded = "all" === o2.expandResponses || o2.expandResponses[t4];
            const { resolved: s2 } = e4.deref(n3);
            this.code = t4, void 0 !== s2.content && (this.content = new Kn(e4, s2.content, i2, o2)), void 0 !== s2["x-summary"] ? (this.summary = s2["x-summary"], this.description = s2.description || "") : (this.summary = s2.description || "", this.description = ""), this.type = ze2(t4, r3);
            const a2 = s2.headers;
            void 0 !== a2 && (this.headers = Object.keys(a2).map((t5) => {
              const r4 = a2[t5];
              return new Hn(e4, (n4 = ((e5, t6) => {
                for (var r5 in t6 || (t6 = {}))
                  so.call(t6, r5) && lo(e5, r5, t6[r5]);
                if (io)
                  for (var r5 of io(t6))
                    ao.call(t6, r5) && lo(e5, r5, t6[r5]);
                return e5;
              })({}, r4), ro(n4, oo({ name: t5 }))), "", o2);
              var n4;
            })), o2.showExtensions && (this.extensions = xt(s2, o2.showExtensions));
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        co([de2.observable], po.prototype, "expanded", 2), co([de2.action], po.prototype, "toggle", 1);
        var uo = Object.defineProperty, ho = Object.getOwnPropertyDescriptor, mo = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? ho(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && uo(t4, r3, i2), i2;
        };
        function fo(e4) {
          return "payload" === e4.lang && e4.requestBodyContent;
        }
        let go = false;
        class yo {
          constructor(e4, t4, r3, n3, o2 = false) {
            this.parser = e4, this.operationSpec = t4, this.options = n3, this.type = "operation", this.items = [], this.ready = true, this.active = false, this.expanded = false, (0, de2.makeObservable)(this), this.pointer = t4.pointer, this.description = t4.description, this.parent = r3, this.externalDocs = t4.externalDocs, this.deprecated = !!t4.deprecated, this.httpVerb = t4.httpVerb, this.deprecated = !!t4.deprecated, this.operationId = t4.operationId, this.path = t4.pathName, this.isCallback = o2, this.isWebhook = t4.isWebhook, this.isEvent = this.isCallback || this.isWebhook, this.name = qe2(t4), this.sidebarLabel = n3.sideNavStyle === R2.IdOnly ? this.operationId || this.path : n3.sideNavStyle === R2.PathOnly ? this.path : this.name, this.isCallback ? (this.security = (t4.security || []).map((t5) => new en(t5, e4)), this.servers = ut2("", t4.servers || t4.pathServers || [])) : (this.operationHash = t4.operationId && "operation/" + t4.operationId, this.id = void 0 !== t4.operationId ? (r3 ? r3.id + "/" : "") + this.operationHash : void 0 !== r3 ? r3.id + this.pointer : this.pointer, this.security = (t4.security || e4.spec.security || []).map((t5) => new en(t5, e4)), this.servers = ut2(e4.specUrl, t4.servers || t4.pathServers || e4.spec.servers || [])), n3.showExtensions && (this.extensions = xt(t4, n3.showExtensions));
          }
          activate() {
            this.active = true;
          }
          deactivate() {
            this.active = false;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          expand() {
            this.parent && this.parent.expand();
          }
          collapse() {
          }
          get requestBody() {
            return this.operationSpec.requestBody && new eo({ parser: this.parser, infoOrRef: this.operationSpec.requestBody, options: this.options, isEvent: this.isEvent });
          }
          get codeSamples() {
            const { payloadSampleIdx: e4, hideRequestPayloadSample: t4 } = this.options;
            let r3 = this.operationSpec["x-codeSamples"] || this.operationSpec["x-code-samples"] || [];
            this.operationSpec["x-code-samples"] && !go && (go = true, console.warn('"x-code-samples" is deprecated. Use "x-codeSamples" instead'));
            const n3 = this.requestBody && this.requestBody.content;
            if (n3 && n3.hasSample && !t4) {
              const t5 = Math.min(r3.length, e4);
              r3 = [...r3.slice(0, t5), { lang: "payload", label: "Payload", source: "", requestBodyContent: n3 }, ...r3.slice(t5)];
            }
            return r3;
          }
          get parameters() {
            const e4 = lt2(this.parser, this.operationSpec.pathParameters, this.operationSpec.parameters).map((e5) => new Hn(this.parser, e5, this.pointer, this.options));
            return this.options.sortPropsAlphabetically ? at2(e4, "name") : this.options.requiredPropsFirst ? st2(e4) : e4;
          }
          get responses() {
            let e4 = false;
            return Object.keys(this.operationSpec.responses || []).filter((t4) => "default" === t4 || ("success" === ze2(t4) && (e4 = true), De2(t4))).map((t4) => new po({ parser: this.parser, code: t4, defaultAsError: e4, infoOrRef: this.operationSpec.responses[t4], options: this.options, isEvent: this.isEvent }));
          }
          get callbacks() {
            return Object.keys(this.operationSpec.callbacks || []).map((e4) => new dn(this.parser, e4, this.operationSpec.callbacks[e4], this.pointer, this.options));
          }
        }
        mo([de2.observable], yo.prototype, "ready", 2), mo([de2.observable], yo.prototype, "active", 2), mo([de2.observable], yo.prototype, "expanded", 2), mo([de2.action], yo.prototype, "activate", 1), mo([de2.action], yo.prototype, "deactivate", 1), mo([de2.action], yo.prototype, "toggle", 1), mo([Mt], yo.prototype, "requestBody", 1), mo([Mt], yo.prototype, "codeSamples", 1), mo([Mt], yo.prototype, "parameters", 1), mo([Mt], yo.prototype, "responses", 1), mo([Mt], yo.prototype, "callbacks", 1);
        var bo = Object.defineProperty, xo = Object.defineProperties, vo = Object.getOwnPropertyDescriptors, wo = Object.getOwnPropertySymbols, ko = Object.prototype.hasOwnProperty, Oo = Object.prototype.propertyIsEnumerable, Eo = (e4, t4, r3) => t4 in e4 ? bo(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, jo = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            ko.call(t4, r3) && Eo(e4, r3, t4[r3]);
          if (wo)
            for (var r3 of wo(t4))
              Oo.call(t4, r3) && Eo(e4, r3, t4[r3]);
          return e4;
        };
        class $o {
          constructor(e4, t4, r3) {
            this.operations = [];
            const { resolved: n3 } = e4.deref(r3 || {});
            this.initWebhooks(e4, n3, t4);
          }
          initWebhooks(e4, t4, r3) {
            for (const o2 of Object.keys(t4)) {
              const i2 = t4[o2], s2 = Object.keys(i2).filter(Me2);
              for (const t5 of s2) {
                const o3 = i2[t5];
                if (i2.$ref) {
                  const n4 = e4.deref(i2 || {});
                  this.initWebhooks(e4, { [t5]: n4 }, r3);
                }
                if (!o3)
                  continue;
                const s3 = new yo(e4, (n3 = jo({}, o3), xo(n3, vo({ httpVerb: t5 }))), void 0, r3, false);
                this.operations.push(s3);
              }
            }
            var n3;
          }
        }
        class So {
          constructor(e4, t4, r3) {
            const { resolved: n3 } = e4.deref(r3);
            this.id = t4, this.sectionId = ft + t4, this.type = n3.type, this.displayName = n3["x-displayName"] || t4, this.description = n3.description || "", "apiKey" === n3.type && (this.apiKey = { name: n3.name, in: n3.in }), "http" === n3.type && (this.http = { scheme: n3.scheme, bearerFormat: n3.bearerFormat }), "openIdConnect" === n3.type && (this.openId = { connectUrl: n3.openIdConnectUrl }), "oauth2" === n3.type && n3.flows && (this.flows = n3.flows);
          }
        }
        class Co {
          constructor(e4) {
            const t4 = e4.spec.components && e4.spec.components.securitySchemes || {};
            this.schemes = Object.keys(t4).map((r3) => new So(e4, r3, t4[r3]));
          }
        }
        var Po = Object.defineProperty, Ao = Object.getOwnPropertySymbols, Io = Object.prototype.hasOwnProperty, To = Object.prototype.propertyIsEnumerable, _o = (e4, t4, r3) => t4 in e4 ? Po(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Ro = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Io.call(t4, r3) && _o(e4, r3, t4[r3]);
          if (Ao)
            for (var r3 of Ao(t4))
              To.call(t4, r3) && _o(e4, r3, t4[r3]);
          return e4;
        };
        class Lo {
          constructor(e4, t4, r3) {
            var n3, o2, i2;
            this.options = r3, this.parser = new jn(e4, t4, r3), this.info = new Vr(this.parser, this.options), this.externalDocs = this.parser.spec.externalDocs, this.contentItems = Zo.buildStructure(this.parser, this.options), this.securitySchemes = new Co(this.parser);
            const s2 = Ro(Ro({}, null == (o2 = null == (n3 = this.parser) ? void 0 : n3.spec) ? void 0 : o2["x-webhooks"]), null == (i2 = this.parser) ? void 0 : i2.spec.webhooks);
            this.webhooks = new $o(this.parser, r3, s2);
          }
        }
        var Do = Object.defineProperty, zo = Object.getOwnPropertyDescriptor, No = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? zo(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && Do(t4, r3, i2), i2;
        };
        class Mo {
          constructor(e4, t4, r3) {
            this.items = [], this.active = false, this.expanded = false, (0, de2.makeObservable)(this), this.id = t4.id || e4 + "/" + w2(t4.name), this.type = e4, this.name = t4["x-displayName"] || t4.name, this.level = t4.level || 1, this.sidebarLabel = this.name, this.description = t4.description || "";
            const n3 = t4.items;
            n3 && n3.length && (this.description = Ur.getTextBeforeHading(this.description, n3[0].name)), this.parent = r3, this.externalDocs = t4.externalDocs, "group" === this.type && (this.expanded = true);
          }
          activate() {
            this.active = true;
          }
          expand() {
            this.parent && this.parent.expand(), this.expanded = true;
          }
          collapse() {
            "group" !== this.type && (this.expanded = false);
          }
          deactivate() {
            this.active = false;
          }
        }
        No([de2.observable], Mo.prototype, "active", 2), No([de2.observable], Mo.prototype, "expanded", 2), No([de2.action], Mo.prototype, "activate", 1), No([de2.action], Mo.prototype, "expand", 1), No([de2.action], Mo.prototype, "collapse", 1), No([de2.action], Mo.prototype, "deactivate", 1);
        var qo = Object.defineProperty, Fo = Object.defineProperties, Bo = Object.getOwnPropertyDescriptors, Qo = Object.getOwnPropertySymbols, Uo = Object.prototype.hasOwnProperty, Wo = Object.prototype.propertyIsEnumerable, Vo = (e4, t4, r3) => t4 in e4 ? qo(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Ho = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Uo.call(t4, r3) && Vo(e4, r3, t4[r3]);
          if (Qo)
            for (var r3 of Qo(t4))
              Wo.call(t4, r3) && Vo(e4, r3, t4[r3]);
          return e4;
        }, Jo = (e4, t4) => Fo(e4, Bo(t4));
        const Yo = 0;
        class Zo {
          static buildStructure(e4, t4) {
            const r3 = e4.spec, n3 = [], o2 = Zo.getTagsWithOperations(e4, r3);
            return n3.push(...Zo.addMarkdownItems(r3.info.description || "", void 0, 1, t4)), r3["x-tagGroups"] && r3["x-tagGroups"].length > 0 ? n3.push(...Zo.getTagGroupsItems(e4, void 0, r3["x-tagGroups"], o2, t4)) : n3.push(...Zo.getTagsItems(e4, o2, void 0, void 0, t4)), n3;
          }
          static addMarkdownItems(e4, t4, r3, n3) {
            const o2 = new Ur(n3, null == t4 ? void 0 : t4.id).extractHeadings(e4 || "");
            o2.length && t4 && t4.description && (t4.description = Ur.getTextBeforeHading(t4.description, o2[0].name));
            const i2 = (e5, t5, r4 = 1) => t5.map((t6) => {
              const n4 = new Mo("section", t6, e5);
              return n4.depth = r4, t6.items && (n4.items = i2(n4, t6.items, r4 + 1)), n4;
            });
            return i2(t4, o2, r3);
          }
          static getTagGroupsItems(e4, t4, r3, n3, o2) {
            const i2 = [];
            for (const s2 of r3) {
              const r4 = new Mo("group", s2, t4);
              r4.depth = Yo, r4.items = Zo.getTagsItems(e4, n3, r4, s2, o2), i2.push(r4);
            }
            return i2;
          }
          static getTagsItems(e4, t4, r3, n3, o2) {
            let i2;
            i2 = void 0 === n3 ? Object.keys(t4) : n3.tags;
            const s2 = i2.map((e5) => t4[e5] ? (t4[e5].used = true, t4[e5]) : (console.warn(`Non-existing tag "${e5}" is added to the group "${n3.name}"`), null)), a2 = [];
            for (const t5 of s2) {
              if (!t5)
                continue;
              const n4 = new Mo("tag", t5, r3);
              if (n4.depth = Yo + 1, "" === t5.name) {
                const r4 = [...Zo.addMarkdownItems(t5.description || "", n4, n4.depth + 1, o2), ...this.getOperationsItems(e4, void 0, t5, n4.depth + 1, o2)];
                a2.push(...r4);
                continue;
              }
              const i3 = this.getTagRelatedSchema({ parser: e4, tag: t5, parent: n4 });
              n4.items = [...i3, ...Zo.addMarkdownItems(t5.description || "", n4, n4.depth + 1, o2), ...this.getOperationsItems(e4, n4, t5, n4.depth + 1, o2)], a2.push(n4);
            }
            return o2.sortTagsAlphabetically && a2.sort(qt("name")), a2;
          }
          static getOperationsItems(e4, t4, r3, n3, o2) {
            if (0 === r3.operations.length)
              return [];
            const i2 = [];
            for (const s2 of r3.operations) {
              const r4 = new yo(e4, s2, t4, o2);
              r4.depth = n3, i2.push(r4);
            }
            return o2.sortOperationsAlphabetically && i2.sort(qt("name")), i2;
          }
          static getTagsWithOperations(e4, t4) {
            const r3 = {}, n3 = t4["x-webhooks"] || t4.webhooks;
            for (const e5 of t4.tags || [])
              r3[e5.name] = Jo(Ho({}, e5), { operations: [] });
            function o2(e5, t5, n4) {
              for (const i2 of Object.keys(t5)) {
                const s2 = t5[i2], a2 = Object.keys(s2).filter(Me2);
                for (const t6 of a2) {
                  const a3 = s2[t6];
                  if (s2.$ref) {
                    const { resolved: t7 } = e5.deref(s2);
                    o2(e5, { [i2]: t7 }, n4);
                    continue;
                  }
                  let l3 = null == a3 ? void 0 : a3.tags;
                  l3 && l3.length || (l3 = [""]);
                  for (const e6 of l3) {
                    let o3 = r3[e6];
                    void 0 === o3 && (o3 = { name: e6, operations: [] }, r3[e6] = o3), o3["x-traitTag"] || o3.operations.push(Jo(Ho({}, a3), { pathName: i2, pointer: Oe2.compile(["paths", i2, t6]), httpVerb: t6, pathParameters: s2.parameters || [], pathServers: s2.servers, isWebhook: !!n4 }));
                  }
                }
              }
            }
            return n3 && o2(e4, n3, true), t4.paths && o2(e4, t4.paths), r3;
          }
          static getTagRelatedSchema({ parser: e4, tag: t4, parent: r3 }) {
            var n3;
            return Object.entries((null == (n3 = e4.spec.components) ? void 0 : n3.schemas) || {}).map(([e5, n4]) => {
              const o2 = n4["x-tags"];
              if (!(null == o2 ? void 0 : o2.includes(t4.name)))
                return null;
              const i2 = new Mo("schema", { name: e5, "x-displayName": `${n4.title || e5}`, description: `<SchemaDefinition showWriteOnly={true} schemaRef="#/components/schemas/${e5}" />` }, r3);
              return i2.depth = r3.depth + 1, i2;
            }).filter(Boolean);
          }
        }
        var Go = Object.defineProperty, Xo = Object.getOwnPropertyDescriptor, Ko = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? Xo(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && Go(t4, r3, i2), i2;
        };
        const ei2 = "data-section-id";
        class ti2 {
          constructor(e4, t4, r3) {
            this.scroll = t4, this.history = r3, this.activeItemIdx = -1, this.sideBarOpened = false, this.updateOnScroll = (e5) => {
              const t5 = e5 ? 1 : -1;
              let r4 = this.activeItemIdx;
              for (; (-1 !== r4 || e5) && !(r4 >= this.flatItems.length - 1 && e5); ) {
                if (e5) {
                  const e6 = this.getElementAtOrFirstChild(r4 + 1);
                  if (this.scroll.isElementBellow(e6))
                    break;
                } else {
                  const e6 = this.getElementAt(r4);
                  if (this.scroll.isElementAbove(e6))
                    break;
                }
                r4 += t5;
              }
              this.activate(this.flatItems[r4], true, true);
            }, this.updateOnHistory = (e5 = this.history.currentId) => {
              if (!e5)
                return;
              let t5;
              t5 = this.flatItems.find((t6) => t6.id === e5), t5 ? this.activateAndScroll(t5, false) : (e5.startsWith(ft) && (t5 = this.flatItems.find((e6) => ft.startsWith(e6.id)), this.activateAndScroll(t5, false)), this.scroll.scrollIntoViewBySelector(`[${ei2}="${C2(e5)}"]`));
            }, this.getItemById = (e5) => this.flatItems.find((t5) => t5.id === e5), (0, de2.makeObservable)(this), this.items = e4.contentItems, this.flatItems = m2(this.items || [], "items"), this.flatItems.forEach((e5, t5) => e5.absoluteIdx = t5), this.subscribe();
          }
          static updateOnHistory(e4 = Wt.currentId, t4) {
            e4 && t4.scrollIntoViewBySelector(`[${ei2}="${C2(e4)}"]`);
          }
          subscribe() {
            this._unsubscribe = this.scroll.subscribe(this.updateOnScroll), this._hashUnsubscribe = this.history.subscribe(this.updateOnHistory);
          }
          toggleSidebar() {
            this.sideBarOpened = !this.sideBarOpened;
          }
          closeSidebar() {
            this.sideBarOpened = false;
          }
          getElementAt(e4) {
            const t4 = this.flatItems[e4];
            return t4 && a(`[${ei2}="${C2(t4.id)}"]`) || null;
          }
          getElementAtOrFirstChild(e4) {
            let t4 = this.flatItems[e4];
            return t4 && "group" === t4.type && (t4 = t4.items[0]), t4 && a(`[${ei2}="${C2(t4.id)}"]`) || null;
          }
          get activeItem() {
            return this.flatItems[this.activeItemIdx] || void 0;
          }
          activate(e4, t4 = true, r3 = false) {
            if ((this.activeItem && this.activeItem.id) !== (e4 && e4.id) && (!e4 || "group" !== e4.type)) {
              if (this.deactivate(this.activeItem), !e4)
                return this.activeItemIdx = -1, void this.history.replace("", r3);
              e4.depth <= Yo || (this.activeItemIdx = e4.absoluteIdx, t4 && this.history.replace(encodeURI(e4.id), r3), e4.activate(), e4.expand());
            }
          }
          deactivate(e4) {
            if (void 0 !== e4)
              for (e4.deactivate(); void 0 !== e4; )
                e4.collapse(), e4 = e4.parent;
          }
          activateAndScroll(e4, t4, r3) {
            const n3 = e4 && this.getItemById(e4.id) || e4;
            this.activate(n3, t4, r3), this.scrollToActive(), n3 && n3.items.length || this.closeSidebar();
          }
          scrollToActive() {
            this.scroll.scrollIntoView(this.getElementAt(this.activeItemIdx));
          }
          dispose() {
            this._unsubscribe(), this._hashUnsubscribe();
          }
        }
        Ko([de2.observable], ti2.prototype, "activeItemIdx", 2), Ko([de2.observable], ti2.prototype, "sideBarOpened", 2), Ko([de2.action], ti2.prototype, "toggleSidebar", 1), Ko([de2.action], ti2.prototype, "closeSidebar", 1), Ko([de2.action], ti2.prototype, "activate", 1), Ko([de2.action.bound], ti2.prototype, "activateAndScroll", 1);
        var ri2 = Object.defineProperty, ni2 = Object.getOwnPropertyDescriptor;
        const oi2 = "scroll";
        class ii2 {
          constructor(e4) {
            this.options = e4, this._prevOffsetY = 0, this._scrollParent = s ? window : void 0, this._emiter = new ve2(), this.bind();
          }
          bind() {
            this._prevOffsetY = this.scrollY(), this._scrollParent && this._scrollParent.addEventListener("scroll", this.handleScroll);
          }
          dispose() {
            this._scrollParent && this._scrollParent.removeEventListener("scroll", this.handleScroll), this._emiter.removeAllListeners(oi2);
          }
          scrollY() {
            return "undefined" != typeof HTMLElement && this._scrollParent instanceof HTMLElement ? this._scrollParent.scrollTop : void 0 !== this._scrollParent ? this._scrollParent.pageYOffset : 0;
          }
          isElementBellow(e4) {
            if (null !== e4)
              return e4.getBoundingClientRect().top > this.options.scrollYOffset();
          }
          isElementAbove(e4) {
            if (null === e4)
              return;
            const t4 = e4.getBoundingClientRect().top;
            return (t4 > 0 ? Math.floor(t4) : Math.ceil(t4)) <= this.options.scrollYOffset();
          }
          subscribe(e4) {
            const t4 = this._emiter.addListener(oi2, e4);
            return () => t4.removeListener(oi2, e4);
          }
          scrollIntoView(e4) {
            null !== e4 && (e4.scrollIntoView(), this._scrollParent && this._scrollParent.scrollBy && this._scrollParent.scrollBy(0, 1 - this.options.scrollYOffset()));
          }
          scrollIntoViewBySelector(e4) {
            const t4 = a(e4);
            this.scrollIntoView(t4);
          }
          handleScroll() {
            const e4 = this.scrollY() - this._prevOffsetY > 0;
            this._prevOffsetY = this.scrollY(), this._emiter.emit(oi2, e4);
          }
        }
        ((e4, t4, r3, n3) => {
          for (var o2, i2 = ni2(t4, r3), s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(t4, r3, i2) || i2);
          i2 && ri2(t4, r3, i2);
        })([xe2.bind, $t(100)], ii2.prototype, "handleScroll");
        class si2 {
          constructor() {
            this.searchWorker = function() {
              let e4;
              if (s)
                try {
                  e4 = r2(595);
                } catch (t4) {
                  e4 = r2(388).ZP;
                }
              else
                e4 = r2(388).ZP;
              return new e4();
            }();
          }
          indexItems(e4) {
            const t4 = (e5) => {
              e5.forEach((e6) => {
                "group" !== e6.type && this.add(e6.name, (e6.description || "").concat(" ", e6.path || ""), e6.id), t4(e6.items);
              });
            };
            t4(e4), this.searchWorker.done();
          }
          add(e4, t4, r3) {
            this.searchWorker.add(e4, t4, r3);
          }
          dispose() {
            this.searchWorker.terminate(), this.searchWorker.dispose();
          }
          search(e4) {
            return this.searchWorker.search(e4);
          }
          toJS() {
            return e4 = this, t4 = function* () {
              return this.searchWorker.toJS();
            }, new Promise((r3, n3) => {
              var o2 = (e5) => {
                try {
                  s2(t4.next(e5));
                } catch (e6) {
                  n3(e6);
                }
              }, i2 = (e5) => {
                try {
                  s2(t4.throw(e5));
                } catch (e6) {
                  n3(e6);
                }
              }, s2 = (e5) => e5.done ? r3(e5.value) : Promise.resolve(e5.value).then(o2, i2);
              s2((t4 = t4.apply(e4, null)).next());
            });
            var e4, t4;
          }
          load(e4) {
            this.searchWorker.load(e4);
          }
          fromExternalJS(e4, t4) {
            e4 && t4 && this.searchWorker.fromExternalJS(e4, t4);
          }
        }
        const ai2 = ee2.div`
  width: calc(100% - ${(e4) => e4.theme.rightPanel.width});
  padding: 0 ${(e4) => e4.theme.spacing.sectionHorizontal}px;

  ${({ $compact: e4, theme: t4 }) => K2.lessThan("medium", true)`
    width: 100%;
    padding: ${`${e4 ? 0 : t4.spacing.sectionVertical}px ${t4.spacing.sectionHorizontal}px`};
  `};
`, li2 = ee2.div.attrs((e4) => ({ [ei2]: e4.id }))`
  padding: ${(e4) => e4.theme.spacing.sectionVertical}px 0;

  &:last-child {
    min-height: calc(100vh + 1px);
  }

  & > &:last-child {
    min-height: initial;
  }

  ${K2.lessThan("medium", true)`
    padding: 0;
  `}
  ${({ $underlined: e4 }) => e4 ? "\n    position: relative;\n\n    &:not(:last-of-type):after {\n      position: absolute;\n      bottom: 0;\n      width: 100%;\n      display: block;\n      content: '';\n      border-bottom: 1px solid rgba(0, 0, 0, 0.2);\n    }\n  " : ""}
`, ci2 = ee2.div`
  width: ${(e4) => e4.theme.rightPanel.width};
  color: ${({ theme: e4 }) => e4.rightPanel.textColor};
  background-color: ${(e4) => e4.theme.rightPanel.backgroundColor};
  padding: 0 ${(e4) => e4.theme.spacing.sectionHorizontal}px;

  ${K2.lessThan("medium", true)`
    width: 100%;
    padding: ${(e4) => `${e4.theme.spacing.sectionVertical}px ${e4.theme.spacing.sectionHorizontal}px`};
  `};
`, pi2 = ee2(ci2)`
  background-color: ${(e4) => e4.theme.rightPanel.backgroundColor};
`, ui2 = ee2.div`
  display: flex;
  width: 100%;
  padding: 0;

  ${K2.lessThan("medium", true)`
    flex-direction: column;
  `};
`, di2 = { 1: "1.85714em", 2: "1.57143em", 3: "1.27em" }, hi2 = (e4) => Y2`
  font-family: ${({ theme: e5 }) => e5.typography.headings.fontFamily};
  font-weight: ${({ theme: e5 }) => e5.typography.headings.fontWeight};
  font-size: ${di2[e4]};
  line-height: ${({ theme: e5 }) => e5.typography.headings.lineHeight};
`, mi2 = ee2.h1`
  ${hi2(1)};
  color: ${({ theme: e4 }) => e4.colors.text.primary};

  ${te2("H1")};
`, fi2 = ee2.h2`
  ${hi2(2)};
  color: ${({ theme: e4 }) => e4.colors.text.primary};
  margin: 0 0 20px;

  ${te2("H2")};
`, gi2 = (ee2.h2`
  ${hi2(3)};
  color: ${({ theme: e4 }) => e4.colors.text.primary};

  ${te2("H3")};
`, ee2.h3`
  color: ${({ theme: e4 }) => e4.rightPanel.textColor};

  ${te2("RightPanelHeader")};
`), yi2 = ee2.h5`
  border-bottom: 1px solid rgba(38, 50, 56, 0.3);
  margin: 1em 0 1em 0;
  color: rgba(38, 50, 56, 0.5);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 0.929em;
  line-height: 20px;

  ${te2("UnderlinedHeader")};
`;
        var bi2 = (e4, t4, r3) => new Promise((n3, o2) => {
          var i2 = (e5) => {
            try {
              a2(r3.next(e5));
            } catch (e6) {
              o2(e6);
            }
          }, s2 = (e5) => {
            try {
              a2(r3.throw(e5));
            } catch (e6) {
              o2(e6);
            }
          }, a2 = (e5) => e5.done ? n3(e5.value) : Promise.resolve(e5.value).then(i2, s2);
          a2((r3 = r3.apply(e4, t4)).next());
        });
        const xi2 = (0, e3.createContext)(void 0), { Provider: vi2, Consumer: wi2 } = xi2;
        function ki2(t4) {
          const { spec: r3, specUrl: n3, options: o2, onLoaded: i2, children: s2 } = t4, [a2, l3] = e3.useState(null), [c3, p3] = e3.useState(null);
          if (c3)
            throw c3;
          e3.useEffect(() => {
            !function() {
              bi2(this, null, function* () {
                if (r3 || n3) {
                  l3(null);
                  try {
                    const e4 = yield ye2(r3 || n3);
                    l3(e4);
                  } catch (e4) {
                    throw i2 && i2(e4), p3(e4), e4;
                  }
                }
              });
            }();
          }, [r3, n3]);
          const u3 = e3.useMemo(() => {
            if (!a2)
              return null;
            try {
              return new uc2(a2, n3, o2);
            } catch (e4) {
              throw i2 && i2(e4), e4;
            }
          }, [a2, n3, o2]);
          return e3.useEffect(() => {
            u3 && i2 && i2();
          }, [u3, i2]), s2({ loading: !u3, store: u3 });
        }
        function Oi2() {
          return (0, e3.useContext)(xi2);
        }
        const Ei2 = (e4) => Y2`
  ${e4} {
    cursor: pointer;
    margin-left: -20px;
    padding: 0;
    line-height: 1;
    width: 20px;
    display: inline-block;
    outline: 0;
  }
  ${e4}:before {
    content: '';
    width: 15px;
    height: 15px;
    background-size: contain;
    background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDU5LjcgMjMzLjRsLTkwLjUgOTAuNWMtNTAgNTAtMTMxIDUwLTE4MSAwIC03LjktNy44LTE0LTE2LjctMTkuNC0yNS44bDQyLjEtNDIuMWMyLTIgNC41LTMuMiA2LjgtNC41IDIuOSA5LjkgOCAxOS4zIDE1LjggMjcuMiAyNSAyNSA2NS42IDI0LjkgOTAuNSAwbDkwLjUtOTAuNWMyNS0yNSAyNS02NS42IDAtOTAuNSAtMjQuOS0yNS02NS41LTI1LTkwLjUgMGwtMzIuMiAzMi4yYy0yNi4xLTEwLjItNTQuMi0xMi45LTgxLjYtOC45bDY4LjYtNjguNmM1MC01MCAxMzEtNTAgMTgxIDBDNTA5LjYgMTAyLjMgNTA5LjYgMTgzLjQgNDU5LjcgMjMzLjR6TTIyMC4zIDM4Mi4ybC0zMi4yIDMyLjJjLTI1IDI0LjktNjUuNiAyNC45LTkwLjUgMCAtMjUtMjUtMjUtNjUuNiAwLTkwLjVsOTAuNS05MC41YzI1LTI1IDY1LjUtMjUgOTAuNSAwIDcuOCA3LjggMTIuOSAxNy4yIDE1LjggMjcuMSAyLjQtMS40IDQuOC0yLjUgNi44LTQuNWw0Mi4xLTQyYy01LjQtOS4yLTExLjYtMTgtMTkuNC0yNS44IC01MC01MC0xMzEtNTAtMTgxIDBsLTkwLjUgOTAuNWMtNTAgNTAtNTAgMTMxIDAgMTgxIDUwIDUwIDEzMSA1MCAxODEgMGw2OC42LTY4LjZDMjc0LjYgMzk1LjEgMjQ2LjQgMzkyLjMgMjIwLjMgMzgyLjJ6Ii8+PC9zdmc+Cg==');
    opacity: 0.5;
    visibility: hidden;
    display: inline-block;
    vertical-align: middle;
  }

  h1:hover > ${e4}::before, h2:hover > ${e4}::before, ${e4}:hover::before {
    visibility: visible;
  }
`, ji2 = ee2(function(t4) {
          const r3 = e3.useContext(xi2), n3 = e3.useCallback((e4) => {
            r3 && function(e5, t5, r4) {
              t5.defaultPrevented || 0 !== t5.button || ((e6) => !!(e6.metaKey || e6.altKey || e6.ctrlKey || e6.shiftKey))(t5) || (t5.preventDefault(), e5.replace(encodeURI(r4)));
            }(r3.menu.history, e4, t4.to);
          }, [r3, t4.to]);
          return r3 ? e3.createElement("a", { className: t4.className, href: r3.menu.history.linkForId(t4.to), onClick: n3, "aria-label": t4.to }, t4.children) : null;
        })`
  ${Ei2("&")};
`;
        function $i2(t4) {
          return e3.createElement(ji2, { to: t4.to });
        }
        const Si2 = { left: "90deg", right: "-90deg", up: "-180deg", down: "0" }, Ci2 = ee2((t4) => e3.createElement("svg", { className: t4.className, style: t4.style, version: "1.1", viewBox: "0 0 24 24", x: "0", xmlns: "http://www.w3.org/2000/svg", y: "0", "aria-hidden": "true" }, e3.createElement("polygon", { points: "17.3 8.3 12 13.6 6.7 8.3 5.3 9.7 12 16.4 18.7 9.7 " })))`
  height: ${(e4) => e4.size || "18px"};
  width: ${(e4) => e4.size || "18px"};
  min-width: ${(e4) => e4.size || "18px"};
  vertical-align: middle;
  float: ${(e4) => e4.float || ""};
  transition: transform 0.2s ease-out;
  transform: rotateZ(${(e4) => Si2[e4.direction || "down"]});

  polygon {
    fill: ${({ color: e4, theme: t4 }) => e4 && t4.colors.responses[e4] && t4.colors.responses[e4].color || e4};
  }
`, Pi2 = ee2.span`
  display: inline-block;
  padding: 2px 8px;
  margin: 0;
  background-color: ${(e4) => e4.theme.colors[e4.type].main};
  color: ${(e4) => e4.theme.colors[e4.type].contrastText};
  font-size: ${(e4) => e4.theme.typography.code.fontSize};
  vertical-align: middle;
  line-height: 1.6;
  border-radius: 4px;
  font-weight: ${({ theme: e4 }) => e4.typography.fontWeightBold};
  font-size: 12px;
  + span[type] {
    margin-left: 4px;
  }
`, Ai2 = Y2`
  text-decoration: line-through;
  color: #707070;
`, Ii2 = ee2.caption`
  text-align: right;
  font-size: 0.9em;
  font-weight: normal;
  color: ${(e4) => e4.theme.colors.text.secondary};
`, Ti2 = ee2.td`
  border-left: 1px solid ${(e4) => e4.theme.schema.linesColor};
  box-sizing: border-box;
  position: relative;
  padding: 10px 10px 10px 0;

  ${K2.lessThan("small")`
    display: block;
    overflow: hidden;
  `}

  tr:first-of-type > &,
  tr.last > & {
    border-left-width: 0;
    background-position: top left;
    background-repeat: no-repeat;
    background-size: 1px 100%;
  }

  tr:first-of-type > & {
    background-image: linear-gradient(
      to bottom,
      transparent 0%,
      transparent 22px,
      ${(e4) => e4.theme.schema.linesColor} 22px,
      ${(e4) => e4.theme.schema.linesColor} 100%
    );
  }

  tr.last > & {
    background-image: linear-gradient(
      to bottom,
      ${(e4) => e4.theme.schema.linesColor} 0%,
      ${(e4) => e4.theme.schema.linesColor} 22px,
      transparent 22px,
      transparent 100%
    );
  }

  tr.last + tr > & {
    border-left-color: transparent;
  }

  tr.last:first-child > & {
    background: none;
    border-left-color: transparent;
  }
`, _i = ee2(Ti2)`
  padding: 0;
`, Ri2 = ee2(Ti2)`
  vertical-align: top;
  line-height: 20px;
  white-space: nowrap;
  font-size: 13px;
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};

  &.deprecated {
    ${Ai2};
  }

  ${({ kind: e4 }) => "patternProperties" === e4 && Y2`
      > span.property-name {
        display: inline-table;
        white-space: break-spaces;
        margin-right: 20px;

        ::before,
        ::after {
          content: '/';
          filter: opacity(0.2);
        }
      }
    `}

  ${({ kind: e4 = "" }) => ["field", "additionalProperties", "patternProperties"].includes(e4) ? "" : "font-style: italic"};

  ${te2("PropertyNameCell")};
`, Li2 = ee2.td`
  border-bottom: 1px solid #9fb4be;
  padding: 10px 0;
  width: ${(e4) => e4.theme.schema.defaultDetailsWidth};
  box-sizing: border-box;

  tr.expanded & {
    border-bottom: none;
  }

  ${K2.lessThan("small")`
    padding: 0 20px;
    border-bottom: none;
    border-left: 1px solid ${(e4) => e4.theme.schema.linesColor};

    tr.last > & {
      border-left: none;
    }
  `}

  ${te2("PropertyDetailsCell")};
`, Di2 = ee2.span`
  color: ${(e4) => e4.theme.schema.linesColor};
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  margin-right: 10px;

  &::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 10px;
    height: 1px;
    background: ${(e4) => e4.theme.schema.linesColor};
  }

  &::after {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 1px;
    background: ${(e4) => e4.theme.schema.linesColor};
    height: 7px;
  }
`, zi2 = ee2.div`
  padding: ${({ theme: e4 }) => e4.schema.nestingSpacing};
`, Ni2 = ee2.table`
  border-collapse: separate;
  border-radius: 3px;
  font-size: ${(e4) => e4.theme.typography.fontSize};

  border-spacing: 0;
  width: 100%;

  > tr {
    vertical-align: middle;
  }

  ${K2.lessThan("small")`
    display: block;
    > tr, > tbody > tr {
      display: block;
    }
  `}

  ${K2.lessThan("small", false, " and (-ms-high-contrast:none)")`
    td {
      float: left;
      width: 100%;
    }
  `}

  &
    ${zi2},
    &
    ${zi2}
    ${zi2}
    ${zi2},
    &
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2} {
    margin: ${({ theme: e4 }) => e4.schema.nestingSpacing};
    margin-right: 0;
    background: ${({ theme: e4 }) => e4.schema.nestedBackground};
  }

  &
    ${zi2}
    ${zi2},
    &
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2},
    &
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2}
    ${zi2} {
    background: #ffffff;
  }
`, Mi2 = ee2.div`
  margin: 0 0 3px 0;
  display: inline-block;
`, qi2 = ee2.span`
  font-size: 0.9em;
  margin-right: 10px;
  color: ${(e4) => e4.theme.colors.primary.main};
  font-family: ${(e4) => e4.theme.typography.headings.fontFamily};
}
`, Fi2 = ee2.button`
  display: inline-block;
  margin-right: 10px;
  margin-bottom: 5px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid ${(e4) => e4.theme.colors.primary.main};
  padding: 2px 10px;
  line-height: 1.5em;
  outline: none;
  &:focus {
    box-shadow: 0 0 0 1px ${(e4) => e4.theme.colors.primary.main};
  }

  ${({ $deprecated: e4 }) => e4 && Ai2 || ""};

  ${(e4) => e4.$active ? `
      color: white;
      background-color: ${e4.theme.colors.primary.main};
      &:focus {
        box-shadow: none;
        background-color: ${(0, t3.darken)(0.15, e4.theme.colors.primary.main)};
      }
      ` : `
        color: ${e4.theme.colors.primary.main};
        background-color: white;
      `}
`, Bi2 = ee2.div`
  font-size: 0.9em;
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  &::after {
    content: ' [';
  }
`, Qi2 = ee2.div`
  font-size: 0.9em;
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  &::after {
    content: ']';
  }
`;
        var Ui2 = require$$43;
        const Wi2 = ee2(Ui2.Tabs)`
  > ul {
    list-style: none;
    padding: 0;
    margin: 0;
    margin: 0 -5px;

    > li {
      padding: 5px 10px;
      display: inline-block;

      background-color: ${({ theme: e4 }) => e4.codeBlock.backgroundColor};
      border-bottom: 1px solid rgba(0, 0, 0, 0.5);
      cursor: pointer;
      text-align: center;
      outline: none;
      color: ${({ theme: e4 }) => (0, t3.darken)(e4.colors.tonalOffset, e4.rightPanel.textColor)};
      margin: 0
        ${({ theme: e4 }) => `${e4.spacing.unit}px ${e4.spacing.unit}px ${e4.spacing.unit}px`};
      border: 1px solid ${({ theme: e4 }) => (0, t3.darken)(0.05, e4.codeBlock.backgroundColor)};
      border-radius: 5px;
      min-width: 60px;
      font-size: 0.9em;
      font-weight: bold;

      &.react-tabs__tab--selected {
        color: ${(e4) => e4.theme.colors.text.primary};
        background: ${({ theme: e4 }) => e4.rightPanel.textColor};
        &:focus {
          outline: auto;
        }
      }

      &:only-child {
        flex: none;
        min-width: 100px;
      }

      &.tab-success {
        color: ${(e4) => e4.theme.colors.responses.success.tabTextColor};
      }

      &.tab-redirect {
        color: ${(e4) => e4.theme.colors.responses.redirect.tabTextColor};
      }

      &.tab-info {
        color: ${(e4) => e4.theme.colors.responses.info.tabTextColor};
      }

      &.tab-error {
        color: ${(e4) => e4.theme.colors.responses.error.tabTextColor};
      }
    }
  }
  > .react-tabs__tab-panel {
    background: ${({ theme: e4 }) => e4.codeBlock.backgroundColor};
    & > div,
    & > pre {
      padding: ${(e4) => 4 * e4.theme.spacing.unit}px;
      margin: 0;
    }

    & > div > pre {
      padding: 0;
    }
  }
`, Vi2 = (ee2(Wi2)`
  > ul {
    display: block;
    > li {
      padding: 2px 5px;
      min-width: auto;
      margin: 0 15px 0 0;
      font-size: 13px;
      font-weight: normal;
      border-bottom: 1px dashed;
      color: ${({ theme: e4 }) => (0, t3.darken)(e4.colors.tonalOffset, e4.rightPanel.textColor)};
      border-radius: 0;
      background: none;

      &:last-child {
        margin-right: 0;
      }

      &.react-tabs__tab--selected {
        color: ${({ theme: e4 }) => e4.rightPanel.textColor};
        background: none;
      }
    }
  }
  > .react-tabs__tab-panel {
    & > div,
    & > pre {
      padding: ${(e4) => 2 * e4.theme.spacing.unit}px 0;
    }
  }
`, ee2.div`
  /**
  * Based on prism-dark.css
  */

  code[class*='language-'],
  pre[class*='language-'] {
    /* color: white;
    background: none; */
    text-shadow: 0 -0.1em 0.2em black;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }

  /* Code blocks */
  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: hsl(30, 20%, 50%);
  }

  .token.punctuation {
    opacity: 0.7;
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.number,
  .token.constant,
  .token.symbol {
    color: #4a8bb3;
  }

  .token.boolean {
    color: #e64441;
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: #a0fbaa;
    & + a,
    & + a:visited {
      color: #4ed2ba;
      text-decoration: underline;
    }
  }

  .token.property.string {
    color: white;
  }

  .token.operator,
  .token.entity,
  .token.url,
  .token.variable {
    color: hsl(40, 90%, 60%);
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: hsl(350, 40%, 70%);
  }

  .token.regex,
  .token.important {
    color: #e90;
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }
  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }

  .token.deleted {
    color: red;
  }

  ${te2("Prism")};
`), Hi2 = ee2.div`
  opacity: 0.7;
  transition: opacity 0.3s ease;
  text-align: right;
  &:focus-within {
    opacity: 1;
  }
  > button {
    background-color: transparent;
    border: 0;
    color: inherit;
    padding: 2px 10px;
    font-family: ${({ theme: e4 }) => e4.typography.fontFamily};
    font-size: ${({ theme: e4 }) => e4.typography.fontSize};
    line-height: ${({ theme: e4 }) => e4.typography.lineHeight};
    cursor: pointer;
    outline: 0;

    :hover,
    :focus {
      background: rgba(255, 255, 255, 0.1);
    }
  }
`, Ji2 = ee2.div`
  &:hover ${Hi2} {
    opacity: 1;
  }
`, Yi2 = ee2(Vi2).attrs({ as: "pre" })`
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  font-size: ${(e4) => e4.theme.typography.code.fontSize};
  overflow-x: auto;
  margin: 0;

  white-space: ${({ theme: e4 }) => e4.typography.code.wrap ? "pre-wrap" : "pre"};
`;
        var Zi2 = require$$44, Gi2 = r2.n(Zi2), Xi2 = Object.defineProperty, Ki2 = Object.getOwnPropertySymbols, es = Object.prototype.hasOwnProperty, ts = Object.prototype.propertyIsEnumerable, rs = (e4, t4, r3) => t4 in e4 ? Xi2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        const ns = Gi2() || Zi2;
        let os = "";
        s && (os = r2(232), os = "function" == typeof os.toString && os.toString() || "", os = "[object Object]" === os ? "" : os);
        const is2 = Z2`${os}`, ss = ee2.div`
  position: relative;
`;
        class as extends e3.Component {
          constructor() {
            super(...arguments), this.handleRef = (e4) => {
              this._container = e4;
            };
          }
          componentDidMount() {
            const e4 = this._container.parentElement && this._container.parentElement.scrollTop || 0;
            this.inst = new ns(this._container, this.props.options || {}), this._container.scrollTo && this._container.scrollTo(0, e4);
          }
          componentDidUpdate() {
            this.inst.update();
          }
          componentWillUnmount() {
            this.inst.destroy();
          }
          render() {
            const { children: t4, className: r3, updateFn: n3 } = this.props;
            return n3 && n3(this.componentDidUpdate.bind(this)), e3.createElement(e3.Fragment, null, os && e3.createElement(is2, null), e3.createElement(ss, { className: `scrollbar-container ${r3}`, ref: this.handleRef }, t4));
          }
        }
        function ls(t4) {
          return e3.createElement(ce2.Consumer, null, (r3) => r3.nativeScrollbars ? e3.createElement("div", { style: { overflow: "auto", overscrollBehavior: "contain", msOverflowStyle: "-ms-autohiding-scrollbar" } }, t4.children) : e3.createElement(as, ((e4, t5) => {
            for (var r4 in t5 || (t5 = {}))
              es.call(t5, r4) && rs(e4, r4, t5[r4]);
            if (Ki2)
              for (var r4 of Ki2(t5))
                ts.call(t5, r4) && rs(e4, r4, t5[r4]);
            return e4;
          })({}, t4), t4.children));
        }
        const cs = ee2(({ className: t4, style: r3 }) => e3.createElement("svg", { className: t4, style: r3, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, e3.createElement("polyline", { points: "6 9 12 15 18 9" })))`
  position: absolute;
  pointer-events: none;
  z-index: 1;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  right: 8px;
  margin: auto;
  text-align: center;
  polyline {
    color: ${(e4) => "dark" === e4.variant && "white"};
  }
`, ps = e3.memo((t4) => {
          const { options: r3, onChange: n3, placeholder: o2, value: i2 = "", variant: s2, className: a2 } = t4;
          return e3.createElement("div", { className: a2 }, e3.createElement(cs, { variant: s2 }), e3.createElement("select", { onChange: (e4) => {
            const { selectedIndex: t5 } = e4.target;
            n3(r3[o2 ? t5 - 1 : t5]);
          }, value: i2, className: "dropdown-select" }, o2 && e3.createElement("option", { disabled: true, hidden: true, value: o2 }, o2), r3.map(({ idx: t5, value: r4, title: n4 }, o3) => e3.createElement("option", { key: t5 || r4 + o3, value: r4 }, n4 || r4))), e3.createElement("label", null, i2));
        }), us = H2()(ps)`
  label {
    box-sizing: border-box;
    min-width: 100px;
    outline: none;
    display: inline-block;
    font-family: ${(e4) => e4.theme.typography.headings.fontFamily};
    color: ${({ theme: e4 }) => e4.colors.text.primary};
    vertical-align: bottom;
    width: ${({ fullWidth: e4 }) => e4 ? "100%" : "auto"};
    text-transform: none;
    padding: 0 22px 0 4px;

    font-size: 0.929em;
    line-height: 1.5em;
    font-family: inherit;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  .dropdown-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border: none;
    appearance: none;
    cursor: pointer;

    color: ${({ theme: e4 }) => e4.colors.text.primary};
    line-height: inherit;
    font-family: inherit;
  }
  box-sizing: border-box;
  min-width: 100px;
  outline: none;
  display: inline-block;
  border-radius: 2px;
  border: 1px solid rgba(38, 50, 56, 0.5);
  vertical-align: bottom;
  padding: 2px 0px 2px 6px;
  position: relative;
  width: auto;
  background: white;
  color: #263238;
  font-family: ${(e4) => e4.theme.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
  cursor: pointer;
  transition: border 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;

  &:hover,
  &:focus-within {
    border: 1px solid ${(e4) => e4.theme.colors.primary.main};
    color: ${(e4) => e4.theme.colors.primary.main};
    box-shadow: 0px 0px 0px 1px ${(e4) => e4.theme.colors.primary.main};
  }
`, ds = H2()(us)`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.969em;

  font-size: 1em;
  border: none;
  padding: 0 1.2em 0 0;
  background: transparent;

  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    label {
      color: ${(e4) => e4.theme.colors.primary.main};
      text-shadow: 0px 0px 0px ${(e4) => e4.theme.colors.primary.main};
    }
  }
`, hs = H2().span`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.929em;
  color: black;
`;
        var ms = Object.defineProperty, fs = Object.getOwnPropertySymbols, gs = Object.prototype.hasOwnProperty, ys = Object.prototype.propertyIsEnumerable, bs = (e4, t4, r3) => t4 in e4 ? ms(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, xs = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            gs.call(t4, r3) && bs(e4, r3, t4[r3]);
          if (fs)
            for (var r3 of fs(t4))
              ys.call(t4, r3) && bs(e4, r3, t4[r3]);
          return e4;
        };
        function vs(t4) {
          const { Label: r3 = hs, Dropdown: n3 = ds } = t4;
          return 1 === t4.options.length ? e3.createElement(r3, null, t4.options[0].value) : e3.createElement(n3, xs({}, t4));
        }
        var ws = requirePurify();
        const ks = Y2`
  a {
    text-decoration: ${(e4) => e4.theme.typography.links.textDecoration};
    color: ${(e4) => e4.theme.typography.links.color};

    &:visited {
      color: ${(e4) => e4.theme.typography.links.visited};
    }

    &:hover {
      color: ${(e4) => e4.theme.typography.links.hover};
      text-decoration: ${(e4) => e4.theme.typography.links.hoverTextDecoration};
    }
  }
`, Os = ee2(Vi2)`
  font-family: ${(e4) => e4.theme.typography.fontFamily};
  font-weight: ${(e4) => e4.theme.typography.fontWeightRegular};
  line-height: ${(e4) => e4.theme.typography.lineHeight};

  p {
    &:last-child {
      margin-bottom: 0;
    }
  }

  ${({ $compact: e4 }) => e4 && "\n    p:first-child {\n      margin-top: 0;\n    }\n    p:last-child {\n      margin-bottom: 0;\n    }\n  "}

  ${({ $inline: e4 }) => e4 && " p {\n    display: inline-block;\n  }"}

  h1 {
    ${hi2(1)};
    color: ${(e4) => e4.theme.colors.primary.main};
    margin-top: 0;
  }

  h2 {
    ${hi2(2)};
    color: ${(e4) => e4.theme.colors.text.primary};
  }

  code {
    color: ${({ theme: e4 }) => e4.typography.code.color};
    background-color: ${({ theme: e4 }) => e4.typography.code.backgroundColor};

    font-family: ${(e4) => e4.theme.typography.code.fontFamily};
    border-radius: 2px;
    border: 1px solid rgba(38, 50, 56, 0.1);
    padding: 0 ${({ theme: e4 }) => e4.spacing.unit}px;
    font-size: ${(e4) => e4.theme.typography.code.fontSize};
    font-weight: ${({ theme: e4 }) => e4.typography.code.fontWeight};

    word-break: break-word;
  }

  pre {
    font-family: ${(e4) => e4.theme.typography.code.fontFamily};
    white-space: ${({ theme: e4 }) => e4.typography.code.wrap ? "pre-wrap" : "pre"};
    background-color: ${({ theme: e4 }) => e4.codeBlock.backgroundColor};
    color: white;
    padding: ${(e4) => 4 * e4.theme.spacing.unit}px;
    overflow-x: auto;
    line-height: normal;
    border-radius: 0;
    border: 1px solid rgba(38, 50, 56, 0.1);

    code {
      background-color: transparent;
      color: white;
      padding: 0;

      &:before,
      &:after {
        content: none;
      }
    }
  }

  blockquote {
    margin: 0;
    margin-bottom: 1em;
    padding: 0 15px;
    color: #777;
    border-left: 4px solid #ddd;
  }

  img {
    max-width: 100%;
    box-sizing: content-box;
  }

  ul,
  ol {
    padding-left: 2em;
    margin: 0;
    margin-bottom: 1em;

    ul,
    ol {
      margin-bottom: 0;
      margin-top: 0;
    }
  }

  table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
  }

  table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;

    &:nth-child(2n) {
      background-color: ${({ theme: e4 }) => e4.schema.nestedBackground};
    }
  }

  table th,
  table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
  }

  table th {
    text-align: left;
    font-weight: bold;
  }

  ${Ei2(".share-link")};

  ${ks}

  ${te2("Markdown")};
`;
        var Es = Object.defineProperty, js = Object.defineProperties, $s = Object.getOwnPropertyDescriptors, Ss = Object.getOwnPropertySymbols, Cs = Object.prototype.hasOwnProperty, Ps = Object.prototype.propertyIsEnumerable, As = (e4, t4, r3) => t4 in e4 ? Es(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Is = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Cs.call(t4, r3) && As(e4, r3, t4[r3]);
          if (Ss)
            for (var r3 of Ss(t4))
              Ps.call(t4, r3) && As(e4, r3, t4[r3]);
          return e4;
        };
        const Ts = H2()((t4) => e3.createElement(Os, Is({}, t4)))`
  display: inline;
`;
        function _s(t4) {
          var r3 = t4, { inline: n3, compact: o2 } = r3, i2 = ((e4, t5) => {
            var r4 = {};
            for (var n4 in e4)
              Cs.call(e4, n4) && t5.indexOf(n4) < 0 && (r4[n4] = e4[n4]);
            if (null != e4 && Ss)
              for (var n4 of Ss(e4))
                t5.indexOf(n4) < 0 && Ps.call(e4, n4) && (r4[n4] = e4[n4]);
            return r4;
          })(r3, ["inline", "compact"]);
          const s2 = n3 ? Ts : Os;
          return e3.createElement(ue2, null, (t5) => {
            return e3.createElement(s2, (r4 = Is({ className: "redoc-markdown " + (i2.className || ""), dangerouslySetInnerHTML: { __html: (a2 = t5.untrustedSpec, l3 = i2.html, a2 ? ws.sanitize(l3) : l3) }, "data-role": i2["data-role"] }, i2), js(r4, $s({ $inline: n3, $compact: o2 }))));
            var r4, a2, l3;
          });
        }
        class Rs extends e3.Component {
          render() {
            const { source: t4, inline: r3, compact: n3, className: o2, "data-role": i2 } = this.props, s2 = new Ur();
            return e3.createElement(_s, { html: s2.renderMd(t4), inline: r3, compact: n3, className: o2, "data-role": i2 });
          }
        }
        const Ls = ee2.div`
  position: relative;
`, Ds = ee2.div`
  position: absolute;
  min-width: 80px;
  max-width: 500px;
  background: #fff;
  bottom: 100%;
  left: 50%;
  margin-bottom: 10px;
  transform: translateX(-50%);

  border-radius: 4px;
  padding: 0.3em 0.6em;
  text-align: center;
  box-shadow: 0px 0px 5px 0px rgba(204, 204, 204, 1);
`, zs = ee2.div`
  background: #fff;
  color: #000;
  display: inline;
  font-size: 0.85em;
  white-space: nowrap;
`, Ns = ee2.div`
  position: absolute;
  width: 0;
  height: 0;
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
  border-left: solid transparent 5px;
  border-right: solid transparent 5px;
  border-top: solid #fff 5px;
`, Ms = ee2.div`
  position: absolute;
  width: 100%;
  height: 20px;
  bottom: -20px;
`;
        class qs2 extends e3.Component {
          render() {
            const { open: t4, title: r3, children: n3 } = this.props;
            return e3.createElement(Ls, null, n3, t4 && e3.createElement(Ds, null, e3.createElement(zs, null, r3), e3.createElement(Ns, null), e3.createElement(Ms, null)));
          }
        }
        const Fs = "undefined" != typeof document && document.queryCommandSupported && document.queryCommandSupported("copy");
        class Bs {
          static isSupported() {
            return Fs;
          }
          static selectElement(e4) {
            let t4, r3;
            document.body.createTextRange ? (t4 = document.body.createTextRange(), t4.moveToElementText(e4), t4.select()) : document.createRange && window.getSelection && (r3 = window.getSelection(), t4 = document.createRange(), t4.selectNodeContents(e4), r3.removeAllRanges(), r3.addRange(t4));
          }
          static deselect() {
            if (document.selection)
              document.selection.empty();
            else if (window.getSelection) {
              const e4 = window.getSelection();
              e4 && e4.removeAllRanges();
            }
          }
          static copySelected() {
            let e4;
            try {
              e4 = document.execCommand("copy");
            } catch (t4) {
              e4 = false;
            }
            return e4;
          }
          static copyElement(e4) {
            Bs.selectElement(e4);
            const t4 = Bs.copySelected();
            return t4 && Bs.deselect(), t4;
          }
          static copyCustom(e4) {
            const t4 = document.createElement("textarea");
            t4.style.position = "fixed", t4.style.top = "0", t4.style.left = "0", t4.style.width = "2em", t4.style.height = "2em", t4.style.padding = "0", t4.style.border = "none", t4.style.outline = "none", t4.style.boxShadow = "none", t4.style.background = "transparent", t4.value = e4, document.body.appendChild(t4), t4.select();
            const r3 = Bs.copySelected();
            return document.body.removeChild(t4), r3;
          }
        }
        const Qs = (t4) => {
          const [r3, n3] = e3.useState(false), o2 = () => {
            const e4 = "string" == typeof t4.data ? t4.data : JSON.stringify(t4.data, null, 2);
            Bs.copyCustom(e4), i2();
          }, i2 = () => {
            n3(true), setTimeout(() => {
              n3(false);
            }, 1500);
          };
          return t4.children({ renderCopyButton: () => e3.createElement("button", { onClick: o2 }, e3.createElement(qs2, { title: Bs.isSupported() ? "Copied" : "Not supported in your browser", open: r3 }, "Copy")) });
        };
        let Us = 1;
        function Ws(e4, t4) {
          Us = 1;
          let r3 = "";
          return r3 += '<div class="redoc-json">', r3 += "<code>", r3 += Zs(e4, t4), r3 += "</code>", r3 += "</div>", r3;
        }
        function Vs(e4) {
          return void 0 !== e4 ? e4.toString().replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
        }
        function Hs(e4) {
          return JSON.stringify(e4).slice(1, -1);
        }
        function Js(e4, t4) {
          return '<span class="' + t4 + '">' + Vs(e4) + "</span>";
        }
        function Ys(e4) {
          return '<span class="token punctuation">' + e4 + "</span>";
        }
        function Zs(e4, t4) {
          const r3 = typeof e4;
          let n3 = "";
          return null == e4 ? n3 += Js("null", "token keyword") : e4 && e4.constructor === Array ? (Us++, n3 += function(e5, t5) {
            const r4 = Us > t5 ? "collapsed" : "";
            let n4 = `<button class="collapser" aria-label="${Us > t5 + 1 ? "expand" : "collapse"}"></button>${Ys("[")}<span class="ellipsis"></span><ul class="array collapsible">`, o2 = false;
            const i2 = e5.length;
            for (let s2 = 0; s2 < i2; s2++)
              o2 = true, n4 += '<li><div class="hoverable ' + r4 + '">', n4 += Zs(e5[s2], t5), s2 < i2 - 1 && (n4 += ","), n4 += "</div></li>";
            return n4 += `</ul>${Ys("]")}`, o2 || (n4 = Ys("[ ]")), n4;
          }(e4, t4), Us--) : e4 && e4.constructor === Date ? n3 += Js('"' + e4.toISOString() + '"', "token string") : "object" === r3 ? (Us++, n3 += function(e5, t5) {
            const r4 = Us > t5 ? "collapsed" : "", n4 = Object.keys(e5), o2 = n4.length;
            let i2 = `<button class="collapser" aria-label="${Us > t5 + 1 ? "expand" : "collapse"}"></button>${Ys("{")}<span class="ellipsis"></span><ul class="obj collapsible">`, s2 = false;
            for (let a2 = 0; a2 < o2; a2++) {
              const l3 = n4[a2];
              s2 = true, i2 += '<li><div class="hoverable ' + r4 + '">', i2 += '<span class="property token string">"' + Vs(l3) + '"</span>: ', i2 += Zs(e5[l3], t5), a2 < o2 - 1 && (i2 += Ys(",")), i2 += "</div></li>";
            }
            return i2 += `</ul>${Ys("}")}`, s2 || (i2 = Ys("{ }")), i2;
          }(e4, t4), Us--) : "number" === r3 ? n3 += Js(e4, "token number") : "string" === r3 ? /^(http|https):\/\/[^\s]+$/.test(e4) ? n3 += Js('"', "token string") + '<a href="' + encodeURI(e4) + '">' + Vs(Hs(e4)) + "</a>" + Js('"', "token string") : n3 += Js('"' + Hs(e4) + '"', "token string") : "boolean" === r3 && (n3 += Js(e4, "token boolean")), n3;
        }
        const Gs = Y2`
  .redoc-json code > .collapser {
    display: none;
    pointer-events: none;
  }

  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  font-size: ${(e4) => e4.theme.typography.code.fontSize};

  white-space: ${({ theme: e4 }) => e4.typography.code.wrap ? "pre-wrap" : "pre"};
  contain: content;
  overflow-x: auto;

  .callback-function {
    color: gray;
  }

  .collapser:after {
    content: '-';
    cursor: pointer;
  }

  .collapsed > .collapser:after {
    content: '+';
    cursor: pointer;
  }

  .ellipsis:after {
    content: '  ';
  }

  .collapsible {
    margin-left: 2em;
  }

  .hoverable {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 2px;
    padding-right: 2px;
    border-radius: 2px;
  }

  .hovered {
    background-color: rgba(235, 238, 249, 1);
  }

  .collapser {
    background-color: transparent;
    border: 0;
    color: #fff;
    font-family: ${(e4) => e4.theme.typography.code.fontFamily};
    font-size: ${(e4) => e4.theme.typography.code.fontSize};
    padding-right: 6px;
    padding-left: 6px;
    padding-top: 0;
    padding-bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 4px;
    left: -1.5em;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    padding: 2px;
    &:focus {
      outline-color: #fff;
      outline-style: dotted;
      outline-width: 1px;
    }
  }

  ul {
    list-style-type: none;
    padding: 0px;
    margin: 0px 0px 0px 26px;
  }

  li {
    position: relative;
    display: block;
  }

  .hoverable {
    display: inline-block;
  }

  .selected {
    outline-style: solid;
    outline-width: 1px;
    outline-style: dotted;
  }

  .collapsed > .collapsible {
    display: none;
  }

  .ellipsis {
    display: none;
  }

  .collapsed > .ellipsis {
    display: inherit;
  }
`, Xs = ee2.div`
  &:hover > ${Hi2} {
    opacity: 1;
  }
`, Ks = ee2((t4) => {
          const [r3, n3] = e3.useState(), o2 = ({ renderCopyButton: r4 }) => {
            const o3 = t4.data && Object.values(t4.data).some((e4) => "object" == typeof e4 && null !== e4);
            return e3.createElement(Xs, null, e3.createElement(Hi2, null, r4(), o3 && e3.createElement(e3.Fragment, null, e3.createElement("button", { onClick: i2 }, " Expand all "), e3.createElement("button", { onClick: s2 }, " Collapse all "))), e3.createElement(ce2.Consumer, null, (r5) => e3.createElement(Vi2, { className: t4.className, ref: (e4) => n3(e4), dangerouslySetInnerHTML: { __html: Ws(t4.data, r5.jsonSampleExpandLevel) } })));
          }, i2 = () => {
            const e4 = null == r3 ? void 0 : r3.getElementsByClassName("collapsible");
            for (const t5 of Array.prototype.slice.call(e4)) {
              const e5 = t5.parentNode;
              e5.classList.remove("collapsed"), e5.querySelector(".collapser").setAttribute("aria-label", "collapse");
            }
          }, s2 = () => {
            const e4 = null == r3 ? void 0 : r3.getElementsByClassName("collapsible"), t5 = Array.prototype.slice.call(e4, 1);
            for (const e5 of t5) {
              const t6 = e5.parentNode;
              t6.classList.add("collapsed"), t6.querySelector(".collapser").setAttribute("aria-label", "expand");
            }
          }, a2 = (e4) => {
            let t5;
            "collapser" === e4.className && (t5 = e4.parentElement.getElementsByClassName("collapsible")[0], t5.parentElement.classList.contains("collapsed") ? (t5.parentElement.classList.remove("collapsed"), e4.setAttribute("aria-label", "collapse")) : (t5.parentElement.classList.add("collapsed"), e4.setAttribute("aria-label", "expand")));
          }, l3 = e3.useCallback((e4) => {
            a2(e4.target);
          }, []), c3 = e3.useCallback((e4) => {
            "Enter" === e4.key && a2(e4.target);
          }, []);
          return e3.useEffect(() => (null == r3 || r3.addEventListener("click", l3), null == r3 || r3.addEventListener("focus", c3), () => {
            null == r3 || r3.removeEventListener("click", l3), null == r3 || r3.removeEventListener("focus", c3);
          }), [l3, c3, r3]), e3.createElement(Qs, { data: t4.data }, o2);
        })`
  ${Gs};
`, ea2 = (t4) => {
          const { source: r3, lang: n3 } = t4;
          return e3.createElement(Yi2, { dangerouslySetInnerHTML: { __html: jt(r3, n3) } });
        }, ta2 = (t4) => {
          const { source: r3, lang: n3 } = t4;
          return e3.createElement(Qs, { data: r3 }, ({ renderCopyButton: t5 }) => e3.createElement(Ji2, null, e3.createElement(Hi2, null, t5()), e3.createElement(ea2, { lang: n3, source: r3 })));
        };
        function ra2({ value: t4, mimeType: r3 }) {
          return Ue2(r3) ? e3.createElement(Ks, { data: t4 }) : ("object" == typeof t4 && (t4 = JSON.stringify(t4, null, 2)), e3.createElement(ta2, { lang: Ke2(r3), source: t4 }));
        }
        var na = (e4, t4, r3) => new Promise((n3, o2) => {
          var i2 = (e5) => {
            try {
              a2(r3.next(e5));
            } catch (e6) {
              o2(e6);
            }
          }, s2 = (e5) => {
            try {
              a2(r3.throw(e5));
            } catch (e6) {
              o2(e6);
            }
          }, a2 = (e5) => e5.done ? n3(e5.value) : Promise.resolve(e5.value).then(i2, s2);
          a2((r3 = r3.apply(e4, t4)).next());
        });
        function oa2({ example: t4, mimeType: r3 }) {
          return void 0 === t4.value && t4.externalValueUrl ? e3.createElement(ia2, { example: t4, mimeType: r3 }) : e3.createElement(ra2, { value: t4.value, mimeType: r3 });
        }
        function ia2({ example: t4, mimeType: r3 }) {
          const n3 = function(t5, r4) {
            const [, n4] = (0, e3.useState)(true), o2 = (0, e3.useRef)(void 0), i2 = (0, e3.useRef)(void 0);
            return i2.current !== t5 && (o2.current = void 0), i2.current = t5, (0, e3.useEffect)(() => {
              (() => {
                na(this, null, function* () {
                  n4(true);
                  try {
                    o2.current = yield t5.getExternalValue(r4);
                  } catch (e4) {
                    o2.current = e4;
                  }
                  n4(false);
                });
              })();
            }, [t5, r4]), o2.current;
          }(t4, r3);
          return void 0 === n3 ? e3.createElement("span", null, "Loading...") : n3 instanceof Error ? e3.createElement(Yi2, null, "Error loading external example: ", e3.createElement("br", null), e3.createElement("a", { className: "token string", href: t4.externalValueUrl, target: "_blank", rel: "noopener noreferrer" }, t4.externalValueUrl)) : e3.createElement(ra2, { value: n3, mimeType: r3 });
        }
        const sa2 = ee2.div`
  padding: 0.9em;
  background-color: ${({ theme: e4 }) => (0, t3.transparentize)(0.6, e4.rightPanel.backgroundColor)};
  margin: 0 0 10px 0;
  display: block;
  font-family: ${({ theme: e4 }) => e4.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
`, aa2 = ee2.span`
  font-family: ${({ theme: e4 }) => e4.typography.headings.fontFamily};
  font-size: 12px;
  position: absolute;
  z-index: 1;
  top: -11px;
  left: 12px;
  font-weight: ${({ theme: e4 }) => e4.typography.fontWeightBold};
  color: ${({ theme: e4 }) => (0, t3.transparentize)(0.3, e4.rightPanel.textColor)};
`, la2 = ee2.div`
  position: relative;
`, ca2 = ee2(us)`
  label {
    color: ${({ theme: e4 }) => e4.rightPanel.textColor};
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 1em;
    text-transform: none;
    border: none;
  }
  margin: 0 0 10px 0;
  display: block;
  background-color: ${({ theme: e4 }) => (0, t3.transparentize)(0.6, e4.rightPanel.backgroundColor)};
  border: none;
  padding: 0.9em 1.6em 0.9em 0.9em;
  box-shadow: none;
  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    background-color: ${({ theme: e4 }) => (0, t3.transparentize)(0.3, e4.rightPanel.backgroundColor)};
  }
`, pa2 = ee2.div`
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  font-size: 12px;
  color: #ee807f;
`;
        class ua2 extends e3.Component {
          constructor() {
            super(...arguments), this.state = { activeIdx: 0 }, this.switchMedia = ({ idx: e4 }) => {
              void 0 !== e4 && this.setState({ activeIdx: e4 });
            };
          }
          render() {
            const { activeIdx: t4 } = this.state, r3 = this.props.mediaType.examples || {}, n3 = this.props.mediaType.name, o2 = e3.createElement(pa2, null, "No sample"), i2 = Object.keys(r3);
            if (0 === i2.length)
              return o2;
            if (i2.length > 1) {
              const o3 = i2.map((e4, t5) => ({ value: r3[e4].summary || e4, idx: t5 })), s2 = r3[i2[t4]], a2 = s2.description;
              return e3.createElement(da2, null, e3.createElement(la2, null, e3.createElement(aa2, null, "Example"), this.props.renderDropdown({ value: o3[t4].value, options: o3, onChange: this.switchMedia, ariaLabel: "Example" })), e3.createElement("div", null, a2 && e3.createElement(Rs, { source: a2 }), e3.createElement(oa2, { example: s2, mimeType: n3 })));
            }
            {
              const t5 = r3[i2[0]];
              return e3.createElement(da2, null, t5.description && e3.createElement(Rs, { source: t5.description }), e3.createElement(oa2, { example: t5, mimeType: n3 }));
            }
          }
        }
        const da2 = ee2.div`
  margin-top: 15px;
`;
        var ha2 = require$$46;
        const ma2 = ee2(Ri2)`
  button {
    background-color: transparent;
    border: 0;
    outline: 0;
    font-size: 13px;
    font-family: ${(e4) => e4.theme.typography.code.fontFamily};
    cursor: pointer;
    padding: 0;
    color: ${(e4) => e4.theme.colors.text.primary};
    &:focus {
      font-weight: ${({ theme: e4 }) => e4.typography.fontWeightBold};
    }
    ${({ kind: e4 }) => "patternProperties" === e4 && Y2`
        display: inline-flex;
        margin-right: 20px;

        > span.property-name {
          white-space: break-spaces;
          text-align: left;

          ::before,
          ::after {
            content: '/';
            filter: opacity(0.2);
          }
        }

        > svg {
          align-self: center;
        }
      `}
  }
  ${Ci2} {
    height: ${({ theme: e4 }) => e4.schema.arrow.size};
    width: ${({ theme: e4 }) => e4.schema.arrow.size};
    polygon {
      fill: ${({ theme: e4 }) => e4.schema.arrow.color};
    }
  }
`, fa2 = ee2.span`
  vertical-align: middle;
  font-size: ${({ theme: e4 }) => e4.typography.code.fontSize};
  line-height: 20px;
`, ga = ee2(fa2)`
  color: ${(e4) => (0, t3.transparentize)(0.1, e4.theme.schema.typeNameColor)};
`, ya2 = ee2(fa2)`
  color: ${(e4) => e4.theme.schema.typeNameColor};
`, ba = ee2(fa2)`
  color: ${(e4) => e4.theme.schema.typeTitleColor};
  word-break: break-word;
`, xa = ya2, va2 = ee2(fa2).attrs({ as: "div" })`
  color: ${(e4) => e4.theme.schema.requireLabelColor};
  font-size: ${(e4) => e4.theme.schema.labelsTextSize};
  font-weight: normal;
  margin-left: 20px;
  line-height: 1;
`, wa2 = ee2(va2)`
  color: ${(e4) => e4.theme.colors.primary.light};
`, ka2 = ee2(fa2)`
  color: ${({ theme: e4 }) => e4.colors.warning.main};
  font-size: 13px;
`, Oa2 = ee2(fa2)`
  color: #0e7c86;
  &::before,
  &::after {
    font-weight: bold;
  }
`, Ea2 = ee2(fa2)`
  border-radius: 2px;
  word-break: break-word;
  ${({ theme: e4 }) => `
    background-color: ${(0, t3.transparentize)(0.95, e4.colors.text.primary)};
    color: ${(0, t3.transparentize)(0.1, e4.colors.text.primary)};

    padding: 0 ${e4.spacing.unit}px;
    border: 1px solid ${(0, t3.transparentize)(0.9, e4.colors.text.primary)};
    font-family: ${e4.typography.code.fontFamily};
}`};
  & + & {
    margin-left: 0;
  }
  ${te2("ExampleValue")};
`, ja2 = ee2(Ea2)``, $a = ee2(fa2)`
  border-radius: 2px;
  ${({ theme: e4 }) => `
    background-color: ${(0, t3.transparentize)(0.95, e4.colors.primary.light)};
    color: ${(0, t3.transparentize)(0.1, e4.colors.primary.main)};

    margin: 0 ${e4.spacing.unit}px;
    padding: 0 ${e4.spacing.unit}px;
    border: 1px solid ${(0, t3.transparentize)(0.9, e4.colors.primary.main)};
}`};
  & + & {
    margin-left: 0;
  }
  ${te2("ConstraintItem")};
`, Sa2 = ee2.button`
  background-color: transparent;
  border: 0;
  color: ${({ theme: e4 }) => e4.colors.text.secondary};
  margin-left: ${({ theme: e4 }) => e4.spacing.unit}px;
  border-radius: 2px;
  cursor: pointer;
  outline-color: ${({ theme: e4 }) => e4.colors.text.secondary};
  font-size: 12px;
`;
        const Ca2 = ee2.div`
  ${ks};
  ${({ $compact: e4 }) => e4 ? "" : "margin: 1em 0"}
`;
        let Pa2 = class extends e3.Component {
          render() {
            const { externalDocs: t4 } = this.props;
            return t4 && t4.url ? e3.createElement(Ca2, { $compact: this.props.compact }, e3.createElement("a", { href: t4.url }, t4.description || t4.url)) : null;
          }
        };
        Pa2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Pa2);
        class Aa2 extends e3.PureComponent {
          constructor() {
            super(...arguments), this.state = { collapsed: true };
          }
          toggle() {
            this.setState({ collapsed: !this.state.collapsed });
          }
          render() {
            const { values: t4, isArrayType: r3 } = this.props, { collapsed: n3 } = this.state, { enumSkipQuotes: o2, maxDisplayedEnumValues: i2 } = this.context;
            if (!t4.length)
              return null;
            const s2 = this.state.collapsed && i2 ? t4.slice(0, i2) : t4, a2 = !!i2 && t4.length > i2, l3 = i2 ? n3 ? ` ${t4.length - i2} more` : "Hide" : "";
            return e3.createElement("div", null, e3.createElement(fa2, null, r3 ? _2("enumArray") : "", " ", 1 === t4.length ? _2("enumSingleValue") : _2("enum"), ":"), " ", s2.map((t5, r4) => {
              const n4 = o2 ? String(t5) : JSON.stringify(t5);
              return e3.createElement(e3.Fragment, { key: r4 }, e3.createElement(Ea2, null, n4), " ");
            }), a2 ? e3.createElement(Ia2, { onClick: () => {
              this.toggle();
            } }, l3) : null);
          }
        }
        Aa2.contextType = ce2;
        const Ia2 = ee2.span`
  color: ${(e4) => e4.theme.colors.primary.main};
  vertical-align: middle;
  font-size: 13px;
  line-height: 20px;
  padding: 0 5px;
  cursor: pointer;
`, Ta2 = ee2(Os)`
  margin: 2px 0;
`;
        class _a4 extends e3.PureComponent {
          render() {
            const t4 = this.props.extensions;
            return e3.createElement(ce2.Consumer, null, (r3) => e3.createElement(e3.Fragment, null, r3.showExtensions && Object.keys(t4).map((r4) => e3.createElement(Ta2, { key: r4 }, e3.createElement(fa2, null, " ", r4.substring(2), ": "), " ", e3.createElement(ja2, null, "string" == typeof t4[r4] ? t4[r4] : JSON.stringify(t4[r4]))))));
          }
        }
        function Ra2({ field: t4 }) {
          return t4.examples ? e3.createElement(e3.Fragment, null, e3.createElement(fa2, null, " ", _2("examples"), ": "), A2(t4.examples) ? t4.examples.map((r3, n3) => {
            const o2 = Xe2(t4, r3), i2 = t4.in ? String(o2) : JSON.stringify(o2);
            return e3.createElement(e3.Fragment, { key: n3 }, e3.createElement(Ea2, null, i2), " ");
          }) : e3.createElement(La2, null, Object.values(t4.examples).map((r3, n3) => e3.createElement("li", { key: n3 + r3.value }, e3.createElement(Ea2, null, Xe2(t4, r3.value)), " -", " ", r3.summary || r3.description)))) : null;
        }
        const La2 = ee2.ul`
  margin-top: 1em;
  list-style-position: outside;
`;
        class Da2 extends e3.PureComponent {
          render() {
            return 0 === this.props.constraints.length ? null : e3.createElement("span", null, " ", this.props.constraints.map((t4) => e3.createElement($a, { key: t4 }, " ", t4, " ")));
          }
        }
        const za2 = e3.memo(function({ value: t4, label: r3, raw: n3 }) {
          if (void 0 === t4)
            return null;
          const o2 = n3 ? String(t4) : JSON.stringify(t4);
          return e3.createElement("div", null, e3.createElement(fa2, null, " ", r3, " "), " ", e3.createElement(Ea2, null, o2));
        }), Na2 = 45;
        function Ma2(t4) {
          const r3 = t4.schema.pattern, { hideSchemaPattern: n3 } = e3.useContext(ce2), [o2, i2] = e3.useState(false), s2 = e3.useCallback(() => i2(!o2), [o2]);
          return !r3 || n3 ? null : e3.createElement(e3.Fragment, null, e3.createElement(Oa2, null, o2 || r3.length < Na2 ? r3 : `${r3.substr(0, Na2)}...`), r3.length > Na2 && e3.createElement(Sa2, { onClick: s2 }, o2 ? "Hide pattern" : "Show pattern"));
        }
        function qa2({ schema: t4 }) {
          var r3;
          const { hideSchemaPattern: n3 } = e3.useContext(ce2);
          return t4 && ((null == t4 ? void 0 : t4.pattern) && !n3 || t4.items || t4.displayFormat || (null == (r3 = t4.constraints) ? void 0 : r3.length)) ? "string" === t4.type && t4.pattern ? e3.createElement(Fa2, null, "[", e3.createElement(Ma2, { schema: t4 }), "]") : e3.createElement(Fa2, null, "[ items", t4.displayFormat && e3.createElement(xa, null, " <", t4.displayFormat, " >"), e3.createElement(Da2, { constraints: t4.constraints }), e3.createElement(Ma2, { schema: t4 }), t4.items && e3.createElement(qa2, { schema: t4.items }), " ]") : null;
        }
        const Fa2 = ee2(ga)`
  margin: 0 5px;
  vertical-align: text-top;
`;
        var Ba2 = Object.defineProperty, Qa2 = Object.getOwnPropertySymbols, Ua2 = Object.prototype.hasOwnProperty, Wa2 = Object.prototype.propertyIsEnumerable, Va2 = (e4, t4, r3) => t4 in e4 ? Ba2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Ha2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Ua2.call(t4, r3) && Va2(e4, r3, t4[r3]);
          if (Qa2)
            for (var r3 of Qa2(t4))
              Wa2.call(t4, r3) && Va2(e4, r3, t4[r3]);
          return e4;
        };
        const Ja2 = (0, ha2.observer)((t4) => {
          const { enumSkipQuotes: r3, hideSchemaTitles: n3 } = e3.useContext(ce2), { showExamples: o2, field: i2, renderDiscriminatorSwitch: s2 } = t4, { schema: a2, description: l3, deprecated: c3, extensions: p3, in: u3, const: d3 } = i2, h3 = "array" === a2.type, m3 = r3 || "header" === u3, f3 = e3.useMemo(() => !o2 || void 0 === i2.example && void 0 === i2.examples ? null : void 0 !== i2.examples ? e3.createElement(Ra2, { field: i2 }) : e3.createElement(za2, { label: _2("example") + ":", value: Xe2(i2, i2.example), raw: Boolean(i2.in) }), [i2, o2]), g3 = x2(a2.default) && i2.in ? Xe2(i2, a2.default).replace(`${i2.name}=`, "") : a2.default;
          return e3.createElement("div", null, e3.createElement("div", null, e3.createElement(ga, null, a2.typePrefix), e3.createElement(ya2, null, a2.displayType), a2.displayFormat && e3.createElement(xa, null, " ", "<", a2.displayFormat, ">", " "), a2.contentEncoding && e3.createElement(xa, null, " ", "<", a2.contentEncoding, ">", " "), a2.contentMediaType && e3.createElement(xa, null, " ", "<", a2.contentMediaType, ">", " "), a2.title && !n3 && e3.createElement(ba, null, " (", a2.title, ") "), e3.createElement(Da2, { constraints: a2.constraints }), e3.createElement(Ma2, { schema: a2 }), a2.isCircular && e3.createElement(ka2, null, " ", _2("recursive"), " "), h3 && a2.items && e3.createElement(qa2, { schema: a2.items })), c3 && e3.createElement("div", null, e3.createElement(Pi2, { type: "warning" }, " ", _2("deprecated"), " ")), e3.createElement(za2, { raw: m3, label: _2("default") + ":", value: g3 }), !s2 && e3.createElement(Aa2, { isArrayType: h3, values: a2.enum }), " ", f3, e3.createElement(_a4, { extensions: Ha2(Ha2({}, p3), a2.extensions) }), e3.createElement("div", null, e3.createElement(Rs, { compact: true, source: l3 })), a2.externalDocs && e3.createElement(Pa2, { externalDocs: a2.externalDocs, compact: true }), s2 && s2(t4) || null, d3 && e3.createElement(za2, { label: _2("const") + ":", value: d3 }) || null);
        }), Ya2 = e3.memo(Ja2);
        var Za2 = Object.defineProperty, Ga2 = Object.getOwnPropertySymbols, Xa2 = Object.prototype.hasOwnProperty, Ka2 = Object.prototype.propertyIsEnumerable, el2 = (e4, t4, r3) => t4 in e4 ? Za2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        let tl2 = class extends e3.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              void 0 === this.props.field.expanded && this.props.expandByDefault ? this.props.field.collapse() : this.props.field.toggle();
            }, this.handleKeyPress = (e4) => {
              "Enter" === e4.key && (e4.preventDefault(), this.toggle());
            };
          }
          render() {
            const { className: t4 = "", field: r3, isLast: n3, expandByDefault: o2 } = this.props, { name: i2, deprecated: s2, required: a2, kind: l3 } = r3, c3 = !r3.schema.isPrimitive && !r3.schema.isCircular, p3 = void 0 === r3.expanded ? o2 : r3.expanded, u3 = e3.createElement(e3.Fragment, null, "additionalProperties" === l3 && e3.createElement(wa2, null, "additional property"), "patternProperties" === l3 && e3.createElement(wa2, null, "pattern property"), a2 && e3.createElement(va2, null, "required")), d3 = c3 ? e3.createElement(ma2, { className: s2 ? "deprecated" : "", kind: l3, title: i2 }, e3.createElement(Di2, null), e3.createElement("button", { onClick: this.toggle, onKeyPress: this.handleKeyPress, "aria-label": `expand ${i2}` }, e3.createElement("span", { className: "property-name" }, i2), e3.createElement(Ci2, { direction: p3 ? "down" : "right" })), u3) : e3.createElement(Ri2, { className: s2 ? "deprecated" : void 0, kind: l3, title: i2 }, e3.createElement(Di2, null), e3.createElement("span", { className: "property-name" }, i2), u3);
            return e3.createElement(e3.Fragment, null, e3.createElement("tr", { className: n3 ? "last " + t4 : t4 }, d3, e3.createElement(Li2, null, e3.createElement(Ya2, ((e4, t5) => {
              for (var r4 in t5 || (t5 = {}))
                Xa2.call(t5, r4) && el2(e4, r4, t5[r4]);
              if (Ga2)
                for (var r4 of Ga2(t5))
                  Ka2.call(t5, r4) && el2(e4, r4, t5[r4]);
              return e4;
            })({}, this.props)))), p3 && c3 && e3.createElement("tr", { key: r3.name + "inner" }, e3.createElement(_i, { colSpan: 2 }, e3.createElement(zi2, null, e3.createElement(Dl, { schema: r3.schema, skipReadOnly: this.props.skipReadOnly, skipWriteOnly: this.props.skipWriteOnly, showTitle: this.props.showTitle, level: this.props.level })))));
          }
        };
        tl2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], tl2);
        let rl2 = class extends e3.Component {
          constructor() {
            super(...arguments), this.changeActiveChild = (e4) => {
              void 0 !== e4.idx && this.props.parent.activateOneOf(e4.idx);
            };
          }
          sortOptions(e4, t4) {
            if (0 === t4.length)
              return;
            const r3 = {};
            t4.forEach((e5, t5) => {
              r3[e5] = t5;
            }), e4.sort((e5, t5) => r3[e5.value] > r3[t5.value] ? 1 : -1);
          }
          render() {
            const { parent: t4, enumValues: r3 } = this.props;
            if (void 0 === t4.oneOf)
              return null;
            const n3 = t4.oneOf.map((e4, t5) => ({ value: e4.title, idx: t5 })), o2 = n3[t4.activeOneOf].value;
            return this.sortOptions(n3, r3), e3.createElement(us, { value: o2, options: n3, onChange: this.changeActiveChild, ariaLabel: "Example" });
          }
        };
        rl2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], rl2);
        const nl2 = (0, ha2.observer)(({ schema: { fields: t4 = [], title: r3 }, showTitle: n3, discriminator: o2, skipReadOnly: i2, skipWriteOnly: s2, level: a2 }) => {
          const { expandSingleSchemaField: l3, showObjectSchemaExamples: c3, schemaExpansionLevel: p3 } = e3.useContext(ce2), u3 = e3.useMemo(() => i2 || s2 ? t4.filter((e4) => !(i2 && e4.schema.readOnly || s2 && e4.schema.writeOnly)) : t4, [i2, s2, t4]), h3 = l3 && 1 === u3.length || p3 >= a2;
          return e3.createElement(Ni2, null, n3 && e3.createElement(Ii2, null, r3), e3.createElement("tbody", null, d2(u3, (t5, r4) => e3.createElement(tl2, { key: t5.name, isLast: r4, field: t5, expandByDefault: h3, renderDiscriminatorSwitch: (null == o2 ? void 0 : o2.fieldName) === t5.name ? () => e3.createElement(rl2, { parent: o2.parentSchema, enumValues: t5.schema.enum }) : void 0, className: t5.expanded ? "expanded" : void 0, showExamples: c3, skipReadOnly: i2, skipWriteOnly: s2, showTitle: n3, level: a2 }))));
        });
        var ol2 = Object.defineProperty, il2 = Object.defineProperties, sl2 = Object.getOwnPropertyDescriptors, al2 = Object.getOwnPropertySymbols, ll2 = Object.prototype.hasOwnProperty, cl2 = Object.prototype.propertyIsEnumerable, pl2 = (e4, t4, r3) => t4 in e4 ? ol2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, ul2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            ll2.call(t4, r3) && pl2(e4, r3, t4[r3]);
          if (al2)
            for (var r3 of al2(t4))
              cl2.call(t4, r3) && pl2(e4, r3, t4[r3]);
          return e4;
        }, dl2 = (e4, t4) => il2(e4, sl2(t4));
        const hl2 = ee2.div`
  padding-left: ${({ theme: e4 }) => 2 * e4.spacing.unit}px;
`;
        class ml2 extends e3.PureComponent {
          render() {
            const t4 = this.props.schema, r3 = t4.items, n3 = void 0 === t4.minItems && void 0 === t4.maxItems ? "" : `(${it2(t4)})`;
            return t4.fields ? e3.createElement(nl2, dl2(ul2({}, this.props), { level: this.props.level })) : !t4.displayType || r3 || n3.length ? e3.createElement("div", null, e3.createElement(Bi2, null, " Array ", n3), e3.createElement(hl2, null, e3.createElement(Dl, dl2(ul2({}, this.props), { schema: r3 }))), e3.createElement(Qi2, null)) : e3.createElement("div", null, e3.createElement(ya2, null, t4.displayType));
          }
        }
        var fl2 = Object.defineProperty, gl2 = Object.defineProperties, yl = Object.getOwnPropertyDescriptor, bl2 = Object.getOwnPropertyDescriptors, xl = Object.getOwnPropertySymbols, vl2 = Object.prototype.hasOwnProperty, wl = Object.prototype.propertyIsEnumerable, kl2 = (e4, t4, r3) => t4 in e4 ? fl2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Ol = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? yl(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && fl2(t4, r3, i2), i2;
        };
        let El = class extends e3.Component {
          constructor() {
            super(...arguments), this.activateOneOf = () => {
              this.props.schema.activateOneOf(this.props.idx);
            };
          }
          render() {
            const { idx: t4, schema: r3, subSchema: n3 } = this.props;
            return e3.createElement(Fi2, { $deprecated: n3.deprecated, $active: t4 === r3.activeOneOf, onClick: this.activateOneOf }, n3.title || n3.typePrefix + n3.displayType);
          }
        };
        El = Ol([ha2.observer], El);
        let jl2 = class extends e3.Component {
          render() {
            const { schema: { oneOf: t4 }, schema: r3 } = this.props;
            if (void 0 === t4)
              return null;
            const n3 = t4[r3.activeOneOf];
            return e3.createElement("div", null, e3.createElement(qi2, null, " ", r3.oneOfType, " "), e3.createElement(Mi2, null, t4.map((t5, n4) => e3.createElement(El, { key: t5.pointer, schema: r3, subSchema: t5, idx: n4 }))), e3.createElement("div", null, t4[r3.activeOneOf].deprecated && e3.createElement(Pi2, { type: "warning" }, "Deprecated")), e3.createElement(Da2, { constraints: n3.constraints }), e3.createElement(Dl, (o2 = ((e4, t5) => {
              for (var r4 in t5 || (t5 = {}))
                vl2.call(t5, r4) && kl2(e4, r4, t5[r4]);
              if (xl)
                for (var r4 of xl(t5))
                  wl.call(t5, r4) && kl2(e4, r4, t5[r4]);
              return e4;
            })({}, this.props), gl2(o2, bl2({ schema: n3 })))));
            var o2;
          }
        };
        jl2 = Ol([ha2.observer], jl2);
        const $l = (0, ha2.observer)(({ schema: t4 }) => e3.createElement("div", null, e3.createElement(ya2, null, t4.displayType), t4.title && e3.createElement(ba, null, " ", t4.title, " "), e3.createElement(ka2, null, " ", _2("recursive"), " ")));
        var Sl = Object.defineProperty, Cl = Object.defineProperties, Pl = Object.getOwnPropertyDescriptors, Al = Object.getOwnPropertySymbols, Il = Object.prototype.hasOwnProperty, Tl = Object.prototype.propertyIsEnumerable, _l = (e4, t4, r3) => t4 in e4 ? Sl(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Rl = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            Il.call(t4, r3) && _l(e4, r3, t4[r3]);
          if (Al)
            for (var r3 of Al(t4))
              Tl.call(t4, r3) && _l(e4, r3, t4[r3]);
          return e4;
        }, Ll = (e4, t4) => Cl(e4, Pl(t4));
        let Dl = class extends e3.Component {
          render() {
            var t4;
            const r3 = this.props, { schema: n3 } = r3, o2 = ((e4, t5) => {
              var r4 = {};
              for (var n4 in e4)
                Il.call(e4, n4) && t5.indexOf(n4) < 0 && (r4[n4] = e4[n4]);
              if (null != e4 && Al)
                for (var n4 of Al(e4))
                  t5.indexOf(n4) < 0 && Tl.call(e4, n4) && (r4[n4] = e4[n4]);
              return r4;
            })(r3, ["schema"]), i2 = (o2.level || 0) + 1;
            if (!n3)
              return e3.createElement("em", null, " Schema not provided ");
            const { type: s2, oneOf: a2, discriminatorProp: l3, isCircular: c3 } = n3;
            if (c3)
              return e3.createElement($l, { schema: n3 });
            if (void 0 !== l3) {
              if (!a2 || !a2.length)
                return console.warn(`Looks like you are using discriminator wrong: you don't have any definition inherited from the ${n3.title}`), null;
              const t5 = a2[n3.activeOneOf];
              return t5.isCircular ? e3.createElement($l, { schema: t5 }) : e3.createElement(nl2, Ll(Rl({}, o2), { level: i2, schema: t5, discriminator: { fieldName: l3, parentSchema: n3 } }));
            }
            if (void 0 !== a2)
              return e3.createElement(jl2, Rl({ schema: n3 }, o2));
            const p3 = A2(s2) ? s2 : [s2];
            if (p3.includes("object")) {
              if (null == (t4 = n3.fields) ? void 0 : t4.length)
                return e3.createElement(nl2, Ll(Rl({}, this.props), { level: i2 }));
            } else if (p3.includes("array"))
              return e3.createElement(ml2, Ll(Rl({}, this.props), { level: i2 }));
            const u3 = { schema: n3, name: "", required: false, description: n3.description, externalDocs: n3.externalDocs, deprecated: false, toggle: () => null, expanded: false };
            return e3.createElement("div", null, e3.createElement(Ya2, { field: u3 }));
          }
        };
        Dl = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Dl);
        var zl = Object.defineProperty, Nl = Object.defineProperties, Ml = Object.getOwnPropertyDescriptors, ql2 = Object.getOwnPropertySymbols, Fl = Object.prototype.hasOwnProperty, Bl = Object.prototype.propertyIsEnumerable, Ql = (e4, t4, r3) => t4 in e4 ? zl(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        class Ul extends e3.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (t4) => {
              return e3.createElement(vs, (r3 = ((e4, t5) => {
                for (var r4 in t5 || (t5 = {}))
                  Fl.call(t5, r4) && Ql(e4, r4, t5[r4]);
                if (ql2)
                  for (var r4 of ql2(t5))
                    Bl.call(t5, r4) && Ql(e4, r4, t5[r4]);
                return e4;
              })({ Label: hs, Dropdown: ca2 }, t4), Nl(r3, Ml({ variant: "dark" }))));
              var r3;
            };
          }
          static getMediaType(e4, t4) {
            if (!e4)
              return {};
            const r3 = { schema: { $ref: e4 } };
            return t4 && (r3.examples = { example: { $ref: t4 } }), r3;
          }
          get mediaModel() {
            const { parser: e4, schemaRef: t4, exampleRef: r3, options: n3 } = this.props;
            return this._mediaModel || (this._mediaModel = new Yn(e4, "json", false, Ul.getMediaType(t4, r3), n3)), this._mediaModel;
          }
          render() {
            const { showReadOnly: t4 = true, showWriteOnly: r3 = false, showExample: n3 = true } = this.props;
            return e3.createElement(li2, null, e3.createElement(ui2, null, e3.createElement(ai2, null, e3.createElement(Dl, { skipWriteOnly: !r3, skipReadOnly: !t4, schema: this.mediaModel.schema })), n3 && e3.createElement(pi2, null, e3.createElement(Wl, null, e3.createElement(ua2, { renderDropdown: this.renderDropdown, mediaType: this.mediaModel })))));
          }
        }
        const Wl = ee2.div`
  background: ${({ theme: e4 }) => e4.codeBlock.backgroundColor};
  & > div,
  & > pre {
    padding: ${(e4) => 4 * e4.theme.spacing.unit}px;
    margin: 0;
  }

  & > div > pre {
    padding: 0;
  }
`, Vl = (H2().div`
  background-color: #e4e7eb;
`, H2().ul`
  display: inline;
  list-style: none;
  padding: 0;

  li {
    display: inherit;

    &:after {
      content: ',';
    }
    &:last-child:after {
      content: none;
    }
  }
`, H2().code`
  font-size: ${(e4) => e4.theme.typography.code.fontSize};
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  margin: 0 3px;
  padding: 0.2em;
  display: inline-block;
  line-height: 1;

  &:after {
    content: ',';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }
`), Hl = H2().span`
  &:after {
    content: ' and ';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }

  ${ks};
`, Jl = H2().span`
  ${(e4) => !e4.$expanded && "white-space: nowrap;"}
  &:after {
    content: ' or ';
    ${(e4) => e4.$expanded && "content: ' or \\a';"}
    white-space: pre;
  }

  &:last-child:after,
  &:only-child:after {
    content: none;
  }

  ${ks};
`, Yl = H2().div`
  flex: 1 1 auto;
  cursor: pointer;
`, Zl = H2().div`
  width: ${(e4) => e4.theme.schema.defaultDetailsWidth};
  text-overflow: ellipsis;
  border-radius: 4px;
  overflow: hidden;
  ${(e4) => e4.$expanded && `background: ${e4.theme.colors.gray[100]};
     padding: 8px 9.6px;
     margin: 20px 0;
     width: 100%;
    `};
  ${K2.lessThan("small")`
    margin-top: 10px;
  `}
`, Gl = H2()(yi2)`
  display: inline-block;
  margin: 0;
`, Xl = H2().div`
  width: 100%;
  display: flex;
  margin: 1em 0;
  flex-direction: ${(e4) => e4.$expanded ? "column" : "row"};
  ${K2.lessThan("small")`
    flex-direction: column;
  `}
`, Kl = H2().div`
  margin: 0.5em 0;
`, ec2 = H2().div`
  border-bottom: 1px solid ${({ theme: e4 }) => e4.colors.border.dark};
  margin-bottom: 1.5em;
  padding-bottom: 0.7em;

  h5 {
    line-height: 1em;
    margin: 0 0 0.6em;
    font-size: ${({ theme: e4 }) => e4.typography.fontSize};
  }

  .redoc-markdown p:first-child {
    display: inline;
  }
`;
        function tc2({ children: t4, height: r3 }) {
          const n3 = e3.createRef(), [o2, i2] = e3.useState(false), [s2, a2] = e3.useState(false);
          return e3.useEffect(() => {
            n3.current && n3.current.clientHeight + 20 < n3.current.scrollHeight && a2(true);
          }, [n3]), e3.createElement(e3.Fragment, null, e3.createElement(rc2, { ref: n3, className: o2 ? "" : "container", style: { height: o2 ? "auto" : r3 } }, t4), e3.createElement(nc2, { $dimmed: !o2 }, s2 && e3.createElement(oc2, { onClick: () => {
            i2(!o2);
          } }, o2 ? "See less" : "See more")));
        }
        const rc2 = H2().div`
  overflow-y: hidden;
`, nc2 = H2().div`
  text-align: center;
  line-height: 1.5em;
  ${({ $dimmed: e4 }) => e4 && "background-image: linear-gradient(to bottom, transparent,rgb(255 255 255));\n     position: relative;\n     top: -0.5em;\n     padding-top: 0.5em;\n     background-position-y: -1em;\n    "}
`, oc2 = H2().a`
  cursor: pointer;
`, ic2 = e3.memo(function(t4) {
          const { type: r3, flow: n3, RequiredScopes: o2 } = t4, i2 = Object.keys((null == n3 ? void 0 : n3.scopes) || {});
          return e3.createElement(e3.Fragment, null, e3.createElement(Kl, null, e3.createElement("b", null, "Flow type: "), e3.createElement("code", null, r3, " ")), ("implicit" === r3 || "authorizationCode" === r3) && e3.createElement(Kl, null, e3.createElement("strong", null, " Authorization URL: "), e3.createElement("code", null, e3.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: n3.authorizationUrl }, n3.authorizationUrl))), ("password" === r3 || "clientCredentials" === r3 || "authorizationCode" === r3) && e3.createElement(Kl, null, e3.createElement("b", null, " Token URL: "), e3.createElement("code", null, n3.tokenUrl)), n3.refreshUrl && e3.createElement(Kl, null, e3.createElement("strong", null, " Refresh URL: "), e3.createElement("code", null, n3.refreshUrl)), !!i2.length && e3.createElement(e3.Fragment, null, o2 || null, e3.createElement(Kl, null, e3.createElement("b", null, " Scopes: ")), e3.createElement(tc2, { height: "4em" }, e3.createElement("ul", null, i2.map((t5) => e3.createElement("li", { key: t5 }, e3.createElement("code", null, t5), " -", " ", e3.createElement(Rs, { className: "redoc-markdown", inline: true, source: n3.scopes[t5] || "" })))))));
        });
        function sc2(t4) {
          const { RequiredScopes: r3, scheme: n3 } = t4;
          return e3.createElement(Os, null, n3.apiKey ? e3.createElement(e3.Fragment, null, e3.createElement(Kl, null, e3.createElement("b", null, j(n3.apiKey.in || ""), " parameter name: "), e3.createElement("code", null, n3.apiKey.name)), r3) : n3.http ? e3.createElement(e3.Fragment, null, e3.createElement(Kl, null, e3.createElement("b", null, "HTTP Authorization Scheme: "), e3.createElement("code", null, n3.http.scheme)), e3.createElement(Kl, null, "bearer" === n3.http.scheme && n3.http.bearerFormat && e3.createElement(e3.Fragment, null, e3.createElement("b", null, "Bearer format: "), e3.createElement("code", null, n3.http.bearerFormat))), r3) : n3.openId ? e3.createElement(e3.Fragment, null, e3.createElement(Kl, null, e3.createElement("b", null, "Connect URL: "), e3.createElement("code", null, e3.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: n3.openId.connectUrl }, n3.openId.connectUrl))), r3) : n3.flows ? Object.keys(n3.flows).map((t5) => e3.createElement(ic2, { key: t5, type: t5, RequiredScopes: r3, flow: n3.flows[t5] })) : null);
        }
        const ac2 = { oauth2: "OAuth2", apiKey: "API Key", http: "HTTP", openIdConnect: "OpenID Connect" };
        class lc2 extends e3.PureComponent {
          render() {
            return this.props.securitySchemes.schemes.map((t4) => e3.createElement(li2, { id: t4.sectionId, key: t4.id }, e3.createElement(ui2, null, e3.createElement(ai2, null, e3.createElement(fi2, null, e3.createElement($i2, { to: t4.sectionId }), t4.displayName), e3.createElement(Rs, { source: t4.description || "" }), e3.createElement(ec2, null, e3.createElement(Kl, null, e3.createElement("b", null, "Security Scheme Type: "), e3.createElement("span", null, ac2[t4.type] || t4.type)), e3.createElement(sc2, { scheme: t4 }))))));
          }
        }
        var cc2 = (e4, t4, r3) => new Promise((n3, o2) => {
          var i2 = (e5) => {
            try {
              a2(r3.next(e5));
            } catch (e6) {
              o2(e6);
            }
          }, s2 = (e5) => {
            try {
              a2(r3.throw(e5));
            } catch (e6) {
              o2(e6);
            }
          }, a2 = (e5) => e5.done ? n3(e5.value) : Promise.resolve(e5.value).then(i2, s2);
          a2((r3 = r3.apply(e4, t4)).next());
        });
        function pc2(e4, t4) {
          return cc2(this, arguments, function* (e5, t5, r3 = {}) {
            const n3 = yield ye2(e5 || t5);
            return new uc2(n3, t5, r3);
          });
        }
        class uc2 {
          constructor(e4, t4, r3 = {}, n3 = true) {
            this.marker = new Ht(), this.disposer = null, this.rawOptions = r3, this.options = new W2(r3, dc2), this.scroll = new ii2(this.options), ti2.updateOnHistory(Wt.currentId, this.scroll), this.spec = new Lo(e4, t4, this.options), this.menu = new ti2(this.spec, this.scroll, Wt), this.options.disableSearch || (this.search = new si2(), n3 && this.search.indexItems(this.menu.items), this.disposer = (0, de2.observe)(this.menu, "activeItemIdx", (e5) => {
              this.updateMarkOnMenu(e5.newValue);
            }));
          }
          static fromJS(e4) {
            const t4 = new uc2(e4.spec.data, e4.spec.url, e4.options, false);
            return t4.menu.activeItemIdx = e4.menu.activeItemIdx || 0, t4.menu.activate(t4.menu.flatItems[t4.menu.activeItemIdx]), t4.options.disableSearch || t4.search.load(e4.searchIndex), t4;
          }
          onDidMount() {
            this.menu.updateOnHistory(), this.updateMarkOnMenu(this.menu.activeItemIdx);
          }
          dispose() {
            this.scroll.dispose(), this.menu.dispose(), this.search && this.search.dispose(), null != this.disposer && this.disposer();
          }
          toJS() {
            return cc2(this, null, function* () {
              return { menu: { activeItemIdx: this.menu.activeItemIdx }, spec: { url: this.spec.parser.specUrl, data: this.spec.parser.spec }, searchIndex: this.search ? yield this.search.toJS() : void 0, options: this.rawOptions };
            });
          }
          updateMarkOnMenu(e4) {
            const t4 = Math.max(0, e4), r3 = Math.min(this.menu.flatItems.length, t4 + 5), n3 = [];
            for (let e5 = t4; e5 < r3; e5++) {
              const t5 = this.menu.getElementAt(e5);
              t5 && n3.push(t5);
            }
            if (-1 === e4 && s) {
              const e5 = document.querySelector('[data-role="redoc-description"]'), t5 = document.querySelector('[data-role="redoc-summary"]');
              e5 && n3.push(e5), t5 && n3.push(t5);
            }
            this.marker.addOnly(n3), this.marker.mark();
          }
        }
        const dc2 = { allowedMdComponents: { [dt]: { component: lc2, propsSelector: (e4) => ({ securitySchemes: e4.spec.securitySchemes }) }, [ht]: { component: lc2, propsSelector: (e4) => ({ securitySchemes: e4.spec.securitySchemes }) }, [mt]: { component: Ul, propsSelector: (e4) => ({ parser: e4.spec.parser, options: e4.options }) } } }, hc2 = ee2(mi2)`
  margin-top: 0;
  margin-bottom: 0.5em;

  ${te2("ApiHeader")};
`, mc2 = ee2.a`
  border: 1px solid ${(e4) => e4.theme.colors.primary.main};
  color: ${(e4) => e4.theme.colors.primary.main};
  font-weight: normal;
  margin-left: 0.5em;
  padding: 4px 8px 4px;
  display: inline-block;
  text-decoration: none;
  cursor: pointer;

  ${te2("DownloadButton")};
`, fc2 = ee2.span`
  &::before {
    content: '|';
    display: inline-block;
    opacity: 0.5;
    width: ${15}px;
    text-align: center;
  }

  &:last-child::after {
    display: none;
  }
`, gc2 = ee2.div`
  overflow: hidden;
`, yc2 = ee2.div`
  display: flex;
  flex-wrap: wrap;
  // hide separator on new lines: idea from https://stackoverflow.com/a/31732902/1749888
  margin-left: -${15}px;
`;
        let bc2 = class extends e3.Component {
          constructor() {
            super(...arguments), this.handleDownloadClick = (e4) => {
              e4.target.href || (e4.target.href = this.props.store.spec.info.downloadLink);
            };
          }
          render() {
            const { store: t4 } = this.props, { info: r3, externalDocs: n3 } = t4.spec, o2 = t4.options.hideDownloadButton, i2 = r3.downloadFileName, s2 = r3.downloadLink, a2 = r3.license && e3.createElement(fc2, null, "License:", " ", r3.license.identifier ? r3.license.identifier : e3.createElement("a", { href: r3.license.url }, r3.license.name)) || null, l3 = r3.contact && r3.contact.url && e3.createElement(fc2, null, "URL: ", e3.createElement("a", { href: r3.contact.url }, r3.contact.url)) || null, c3 = r3.contact && r3.contact.email && e3.createElement(fc2, null, r3.contact.name || "E-mail", ":", " ", e3.createElement("a", { href: "mailto:" + r3.contact.email }, r3.contact.email)) || null, p3 = r3.termsOfService && e3.createElement(fc2, null, e3.createElement("a", { href: r3.termsOfService }, "Terms of Service")) || null, u3 = r3.version && e3.createElement("span", null, "(", r3.version, ")") || null;
            return e3.createElement(li2, null, e3.createElement(ui2, null, e3.createElement(ai2, { className: "api-info" }, e3.createElement(hc2, null, r3.title, " ", u3), !o2 && e3.createElement("p", null, _2("downloadSpecification"), ":", e3.createElement(mc2, { download: i2 || true, target: "_blank", href: s2, onClick: this.handleDownloadClick }, _2("download"))), e3.createElement(Os, null, (r3.license || r3.contact || r3.termsOfService) && e3.createElement(gc2, null, e3.createElement(yc2, null, c3, " ", l3, " ", a2, " ", p3)) || null), e3.createElement(Rs, { source: t4.spec.info.summary, "data-role": "redoc-summary" }), e3.createElement(Rs, { source: t4.spec.info.description, "data-role": "redoc-description" }), n3 && e3.createElement(Pa2, { externalDocs: n3 }))));
          }
        };
        bc2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], bc2);
        const xc2 = ee2.img`
  max-height: ${(e4) => e4.theme.logo.maxHeight};
  max-width: ${(e4) => e4.theme.logo.maxWidth};
  padding: ${(e4) => e4.theme.logo.gutter};
  width: 100%;
  display: block;
`, vc2 = ee2.div`
  text-align: center;
`, wc2 = ee2.a`
  display: inline-block;
`;
        let kc2 = class extends e3.Component {
          render() {
            const { info: t4 } = this.props, r3 = t4["x-logo"];
            if (!r3 || !r3.url)
              return null;
            const n3 = r3.href || t4.contact && t4.contact.url, o2 = r3.altText ? r3.altText : "logo", i2 = e3.createElement(xc2, { src: r3.url, alt: o2 });
            return e3.createElement(vc2, { style: { backgroundColor: r3.backgroundColor } }, n3 ? (s2 = n3, (t5) => e3.createElement(wc2, { href: s2 }, t5))(i2) : i2);
            var s2;
          }
        };
        kc2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], kc2);
        var Oc2 = Object.defineProperty, Ec2 = Object.getOwnPropertySymbols, jc2 = Object.prototype.hasOwnProperty, $c2 = Object.prototype.propertyIsEnumerable, Sc2 = (e4, t4, r3) => t4 in e4 ? Oc2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Cc2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            jc2.call(t4, r3) && Sc2(e4, r3, t4[r3]);
          if (Ec2)
            for (var r3 of Ec2(t4))
              $c2.call(t4, r3) && Sc2(e4, r3, t4[r3]);
          return e4;
        };
        class Pc2 extends e3.Component {
          render() {
            return e3.createElement(ue2, null, (t4) => e3.createElement(wi2, null, (e4) => this.renderWithOptionsAndStore(t4, e4)));
          }
          renderWithOptionsAndStore(t4, r3) {
            const { source: n3, htmlWrap: o2 = (e4) => e4 } = this.props;
            if (!r3)
              throw new Error("When using components in markdown, store prop must be provided");
            const i2 = new Ur(t4, this.props.parentId).renderMdWithComponents(n3);
            return i2.length ? i2.map((t5, n4) => {
              if ("string" == typeof t5)
                return e3.cloneElement(o2(e3.createElement(_s, { html: t5, inline: false, compact: false })), { key: n4 });
              const i3 = t5.component;
              return e3.createElement(i3, Cc2({ key: n4 }, Cc2(Cc2({}, t5.props), t5.propsSelector(r3))));
            }) : null;
          }
        }
        var Ac2 = requireClassnames(), Ic2 = r2.n(Ac2);
        const Tc2 = ee2.span.attrs((e4) => ({ className: `operation-type ${e4.type}` }))`
  width: 9ex;
  display: inline-block;
  height: ${(e4) => e4.theme.typography.code.fontSize};
  line-height: ${(e4) => e4.theme.typography.code.fontSize};
  background-color: #333;
  border-radius: 3px;
  background-repeat: no-repeat;
  background-position: 6px 4px;
  font-size: 7px;
  font-family: Verdana, sans-serif; // web-safe
  color: white;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  vertical-align: middle;
  margin-right: 6px;
  margin-top: 2px;

  &.get {
    background-color: ${({ theme: e4 }) => e4.colors.http.get};
  }

  &.post {
    background-color: ${({ theme: e4 }) => e4.colors.http.post};
  }

  &.put {
    background-color: ${({ theme: e4 }) => e4.colors.http.put};
  }

  &.options {
    background-color: ${({ theme: e4 }) => e4.colors.http.options};
  }

  &.patch {
    background-color: ${({ theme: e4 }) => e4.colors.http.patch};
  }

  &.delete {
    background-color: ${({ theme: e4 }) => e4.colors.http.delete};
  }

  &.basic {
    background-color: ${({ theme: e4 }) => e4.colors.http.basic};
  }

  &.link {
    background-color: ${({ theme: e4 }) => e4.colors.http.link};
  }

  &.head {
    background-color: ${({ theme: e4 }) => e4.colors.http.head};
  }

  &.hook {
    background-color: ${({ theme: e4 }) => e4.colors.primary.main};
  }

  &.schema {
    background-color: ${({ theme: e4 }) => e4.colors.http.basic};
  }
`;
        function _c2(e4, { theme: t4 }, r3) {
          return e4 > 1 ? t4.sidebar.level1Items[r3] : 1 === e4 ? t4.sidebar.groupItems[r3] : "";
        }
        const Rc2 = ee2.ul`
  margin: 0;
  padding: 0;

  &:first-child {
    padding-bottom: 32px;
  }

  & & {
    font-size: 0.929em;
  }

  ${(e4) => e4.$expanded ? "" : "display: none;"};
`, Lc2 = ee2.li`
  list-style: none inside none;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0;
  ${(e4) => 0 === e4.depth ? "margin-top: 15px" : ""};
`, Dc2 = { 0: Y2`
    opacity: 0.7;
    text-transform: ${({ theme: e4 }) => e4.sidebar.groupItems.textTransform};
    font-size: 0.8em;
    padding-bottom: 0;
    cursor: default;
  `, 1: Y2`
    font-size: 0.929em;
    text-transform: ${({ theme: e4 }) => e4.sidebar.level1Items.textTransform};
  ` }, zc2 = ee2.label.attrs((e4) => ({ className: Ic2()("-depth" + e4.$depth, { active: e4.$active }) }))`
  cursor: pointer;
  color: ${(e4) => e4.$active ? _c2(e4.$depth, e4, "activeTextColor") : e4.theme.sidebar.textColor};
  margin: 0;
  padding: 12.5px ${(e4) => 4 * e4.theme.spacing.unit}px;
  ${({ $depth: e4, $type: t4, theme: r3 }) => "section" === t4 && e4 > 1 && "padding-left: " + 8 * r3.spacing.unit + "px;" || ""}
  display: flex;
  justify-content: space-between;
  font-family: ${(e4) => e4.theme.typography.headings.fontFamily};
  ${(e4) => Dc2[e4.$depth]};
  background-color: ${(e4) => e4.$active ? _c2(e4.$depth, e4, "activeBackgroundColor") : e4.theme.sidebar.backgroundColor};

  ${(e4) => e4.$deprecated && Ai2 || ""};

  &:hover {
    color: ${(e4) => _c2(e4.$depth, e4, "activeTextColor")};
    background-color: ${(e4) => _c2(e4.$depth, e4, "activeBackgroundColor")};
  }

  ${Ci2} {
    height: ${({ theme: e4 }) => e4.sidebar.arrow.size};
    width: ${({ theme: e4 }) => e4.sidebar.arrow.size};
    polygon {
      fill: ${({ theme: e4 }) => e4.sidebar.arrow.color};
    }
  }
`, Nc2 = ee2.span`
  display: inline-block;
  vertical-align: middle;
  width: ${(e4) => e4.width ? e4.width : "auto"};
  overflow: hidden;
  text-overflow: ellipsis;
`, Mc2 = ee2.div`
  ${({ theme: e4 }) => Y2`
    font-size: 0.8em;
    margin-top: ${2 * e4.spacing.unit}px;
    text-align: center;
    position: fixed;
    width: ${e4.sidebar.width};
    bottom: 0;
    background: ${e4.sidebar.backgroundColor};

    a,
    a:visited,
    a:hover {
      color: ${e4.sidebar.textColor} !important;
      padding: ${e4.spacing.unit}px 0;
      border-top: 1px solid ${(0, t3.darken)(0.1, e4.sidebar.backgroundColor)};
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `};
  img {
    width: 15px;
    margin-right: 5px;
  }

  ${K2.lessThan("small")`
    width: 100%;
  `};
`, qc2 = ee2.button`
  border: 0;
  width: 100%;
  text-align: left;
  & > * {
    vertical-align: middle;
  }

  ${Ci2} {
    polygon {
      fill: ${({ theme: e4 }) => (0, t3.darken)(e4.colors.tonalOffset, e4.colors.gray[100])};
    }
  }
`, Fc2 = ee2.span`
  text-decoration: ${(e4) => e4.$deprecated ? "line-through" : "none"};
  margin-right: 8px;
`, Bc2 = ee2(Tc2)`
  margin: 0 5px 0 0;
`, Qc2 = ee2((t4) => {
          const { name: r3, opened: n3, className: o2, onClick: i2, httpVerb: s2, deprecated: a2 } = t4;
          return e3.createElement(qc2, { className: o2, onClick: i2 || void 0 }, e3.createElement(Bc2, { type: s2 }, yt(s2)), e3.createElement(Ci2, { size: "1.5em", direction: n3 ? "down" : "right", float: "left" }), e3.createElement(Fc2, { $deprecated: a2 }, r3), a2 ? e3.createElement(Pi2, { type: "warning" }, " ", _2("deprecated"), " ") : null);
        })`
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  background-color: ${({ theme: e4 }) => e4.colors.gray[100]};
  cursor: pointer;
  outline-color: ${({ theme: e4 }) => (0, t3.darken)(e4.colors.tonalOffset, e4.colors.gray[100])};
`, Uc2 = ee2.div`
  padding: 10px 25px;
  background-color: ${({ theme: e4 }) => e4.colors.gray[50]};
  margin-bottom: 5px;
  margin-top: 5px;
`;
        class Wc2 extends e3.PureComponent {
          constructor() {
            super(...arguments), this.selectElement = () => {
              Bs.selectElement(this.child);
            };
          }
          render() {
            const { children: t4 } = this.props;
            return e3.createElement("div", { ref: (e4) => this.child = e4, onClick: this.selectElement, onFocus: this.selectElement, tabIndex: 0, role: "button" }, t4);
          }
        }
        const Vc2 = ee2.div`
  cursor: pointer;
  position: relative;
  margin-bottom: 5px;
`, Hc2 = ee2.span`
  font-family: ${(e4) => e4.theme.typography.code.fontFamily};
  margin-left: 10px;
  flex: 1;
  overflow-x: hidden;
  text-overflow: ellipsis;
`, Jc2 = ee2.button`
  outline: 0;
  color: inherit;
  width: 100%;
  text-align: left;
  cursor: pointer;
  padding: 10px 30px 10px ${(e4) => e4.$inverted ? "10px" : "20px"};
  border-radius: ${(e4) => e4.$inverted ? "0" : "4px 4px 0 0"};
  background-color: ${(e4) => e4.$inverted ? "transparent" : e4.theme.codeBlock.backgroundColor};
  display: flex;
  white-space: nowrap;
  align-items: center;
  border: ${(e4) => e4.$inverted ? "0" : "1px solid transparent"};
  border-bottom: ${(e4) => e4.$inverted ? "1px solid #ccc" : "0"};
  transition: border-color 0.25s ease;

  ${(e4) => e4.$expanded && !e4.$inverted && `border-color: ${e4.theme.colors.border.dark};` || ""}

  .${Hc2} {
    color: ${(e4) => e4.$inverted ? e4.theme.colors.text.primary : "#ffffff"};
  }
  &:focus {
    box-shadow: inset 0 2px 2px rgba(0, 0, 0, 0.45), 0 2px 0 rgba(128, 128, 128, 0.25);
  }
`, Yc2 = ee2.span.attrs((e4) => ({ className: `http-verb ${e4.type}` }))`
  font-size: ${(e4) => e4.$compact ? "0.8em" : "0.929em"};
  line-height: ${(e4) => e4.$compact ? "18px" : "20px"};
  background-color: ${(e4) => e4.theme.colors.http[e4.type] || "#999999"};
  color: #ffffff;
  padding: ${(e4) => e4.$compact ? "2px 8px" : "3px 10px"};
  text-transform: uppercase;
  font-family: ${(e4) => e4.theme.typography.headings.fontFamily};
  margin: 0;
`, Zc2 = ee2.div`
  position: absolute;
  width: 100%;
  z-index: 100;
  background: ${(e4) => e4.theme.rightPanel.servers.overlay.backgroundColor};
  color: ${(e4) => e4.theme.rightPanel.servers.overlay.textColor};
  box-sizing: border-box;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.33);
  overflow: hidden;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
  transition: all 0.25s ease;
  visibility: hidden;
  ${(e4) => e4.$expanded ? "visibility: visible;" : "transform: translateY(-50%) scaleY(0);"}
`, Gc2 = ee2.div`
  padding: 10px;
`, Xc2 = ee2.div`
  padding: 5px;
  border: 1px solid #ccc;
  background: ${(e4) => e4.theme.rightPanel.servers.url.backgroundColor};
  word-break: break-all;
  color: ${(e4) => e4.theme.colors.primary.main};
  > span {
    color: ${(e4) => e4.theme.colors.text.primary};
  }
`;
        class Kc2 extends e3.Component {
          constructor(e4) {
            super(e4), this.toggle = () => {
              this.setState({ expanded: !this.state.expanded });
            }, this.state = { expanded: false };
          }
          render() {
            const { operation: t4, inverted: r3, hideHostname: n3 } = this.props, { expanded: o2 } = this.state;
            return e3.createElement(ce2.Consumer, null, (i2) => e3.createElement(Vc2, null, e3.createElement(Jc2, { onClick: this.toggle, $expanded: o2, $inverted: r3 }, e3.createElement(Yc2, { type: t4.httpVerb, $compact: this.props.compact }, t4.httpVerb), e3.createElement(Hc2, null, t4.path), e3.createElement(Ci2, { float: "right", color: r3 ? "black" : "white", size: "20px", direction: o2 ? "up" : "down", style: { marginRight: "-25px" } })), e3.createElement(Zc2, { $expanded: o2, "aria-hidden": !o2 }, t4.servers.map((r4) => {
              const o3 = i2.expandDefaultServerVariables ? pt2(r4.url, r4.variables) : r4.url, s2 = E2(o3);
              return e3.createElement(Gc2, { key: o3 }, e3.createElement(Rs, { source: r4.description || "", compact: true }), e3.createElement(Wc2, null, e3.createElement(Xc2, null, e3.createElement("span", null, n3 || i2.hideHostname ? "/" === s2 ? "" : s2 : o3), t4.path)));
            }))));
          }
        }
        class ep extends e3.PureComponent {
          render() {
            const { place: t4, parameters: r3 } = this.props;
            return r3 && r3.length ? e3.createElement("div", { key: t4 }, e3.createElement(yi2, null, t4, " Parameters"), e3.createElement(Ni2, null, e3.createElement("tbody", null, d2(r3, (t5, r4) => e3.createElement(tl2, { key: t5.name, isLast: r4, field: t5, showExamples: true }))))) : null;
          }
        }
        let tp = class extends e3.Component {
          constructor() {
            super(...arguments), this.switchMedia = ({ idx: e4 }) => {
              this.props.content && void 0 !== e4 && this.props.content.activate(e4);
            };
          }
          render() {
            const { content: t4 } = this.props;
            if (!t4 || !t4.mediaTypes || !t4.mediaTypes.length)
              return null;
            const r3 = t4.activeMimeIdx, n3 = t4.mediaTypes.map((e4, t5) => ({ value: e4.name, idx: t5 })), o2 = ({ children: t5 }) => this.props.withLabel ? e3.createElement(la2, null, e3.createElement(aa2, null, "Content type"), t5) : t5;
            return e3.createElement(e3.Fragment, null, e3.createElement(o2, null, this.props.renderDropdown({ value: n3[r3].value, options: n3, onChange: this.switchMedia, ariaLabel: "Content type" })), this.props.children(t4.active));
          }
        };
        tp = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], tp);
        var rp = Object.defineProperty, np = Object.getOwnPropertySymbols, op = Object.prototype.hasOwnProperty, ip = Object.prototype.propertyIsEnumerable, sp = (e4, t4, r3) => t4 in e4 ? rp(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, ap = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            op.call(t4, r3) && sp(e4, r3, t4[r3]);
          if (np)
            for (var r3 of np(t4))
              ip.call(t4, r3) && sp(e4, r3, t4[r3]);
          return e4;
        }, lp = (e4, t4) => {
          var r3 = {};
          for (var n3 in e4)
            op.call(e4, n3) && t4.indexOf(n3) < 0 && (r3[n3] = e4[n3]);
          if (null != e4 && np)
            for (var n3 of np(e4))
              t4.indexOf(n3) < 0 && ip.call(e4, n3) && (r3[n3] = e4[n3]);
          return r3;
        };
        const cp = ["path", "query", "cookie", "header"];
        class pp extends e3.PureComponent {
          orderParams(e4) {
            const t4 = {};
            return e4.forEach((e5) => {
              var r3, n3, o2;
              o2 = e5, (r3 = t4)[n3 = e5.in] || (r3[n3] = []), r3[n3].push(o2);
            }), t4;
          }
          render() {
            const { body: t4, parameters: r3 = [] } = this.props;
            if (void 0 === t4 && void 0 === r3)
              return null;
            const n3 = this.orderParams(r3), o2 = r3.length > 0 ? cp : [], i2 = t4 && t4.content, s2 = t4 && t4.description, a2 = t4 && t4.required;
            return e3.createElement(e3.Fragment, null, o2.map((t5) => e3.createElement(ep, { key: t5, place: t5, parameters: n3[t5] })), i2 && e3.createElement(dp, { content: i2, description: s2, bodyRequired: a2 }));
          }
        }
        function up(t4) {
          var r3 = t4, { bodyRequired: n3 } = r3, o2 = lp(r3, ["bodyRequired"]);
          const i2 = "boolean" == typeof n3 && !!n3, s2 = "boolean" == typeof n3 && !n3;
          return e3.createElement(yi2, { key: "header" }, "Request Body schema: ", e3.createElement(vs, ap({}, o2)), i2 && e3.createElement(mp, null, "required"), s2 && e3.createElement(fp, null, "optional"));
        }
        function dp(t4) {
          const { content: r3, description: n3, bodyRequired: o2 } = t4, { isRequestType: i2 } = r3;
          return e3.createElement(tp, { content: r3, renderDropdown: (t5) => e3.createElement(up, ap({ bodyRequired: o2 }, t5)) }, ({ schema: t5 }) => e3.createElement(e3.Fragment, null, void 0 !== n3 && e3.createElement(Rs, { source: n3 }), "object" === (null == t5 ? void 0 : t5.type) && e3.createElement(Da2, { constraints: (null == t5 ? void 0 : t5.constraints) || [] }), e3.createElement(Dl, { skipReadOnly: i2, skipWriteOnly: !i2, key: "schema", schema: t5 })));
        }
        const hp = "\n  text-transform: lowercase;\n  margin-left: 0;\n  line-height: 1.5em;\n", mp = ee2(va2)`
  ${hp}
`, fp = ee2("div")`
  ${hp}
  color: ${({ theme: e4 }) => e4.colors.text.secondary};
  font-size: ${(e4) => e4.theme.schema.labelsTextSize};
`, gp = e3.memo(function({ title: t4, type: r3, empty: n3, code: o2, opened: i2, className: s2, onClick: a2 }) {
          return e3.createElement("button", { className: s2, onClick: !n3 && a2 || void 0, "aria-expanded": i2, disabled: n3 }, !n3 && e3.createElement(Ci2, { size: "1.5em", color: r3, direction: i2 ? "down" : "right", float: "left" }), e3.createElement(vp, null, o2, " "), e3.createElement(Rs, { compact: true, inline: true, source: t4 }));
        }), yp = ee2(gp)`
  display: block;
  border: 0;
  width: 100%;
  text-align: left;
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  cursor: pointer;

  color: ${(e4) => e4.theme.colors.responses[e4.type].color};
  background-color: ${(e4) => e4.theme.colors.responses[e4.type].backgroundColor};
  &:focus {
    outline: auto ${(e4) => e4.theme.colors.responses[e4.type].color};
  }
  ${(e4) => e4.empty ? '\ncursor: default;\n&::before {\n  content: "";\n  font-weight: bold;\n  width: 1.5em;\n  text-align: center;\n  display: inline-block;\n  vertical-align: top;\n}\n&:focus {\n  outline: 0;\n}\n' : ""};
`, bp = ee2.div`
  padding: 10px;
`, xp = ee2(yi2).attrs({ as: "caption" })`
  text-align: left;
  margin-top: 1em;
  caption-side: top;
`, vp = ee2.strong`
  vertical-align: top;
`;
        class wp extends e3.PureComponent {
          render() {
            const { headers: t4 } = this.props;
            return void 0 === t4 || 0 === t4.length ? null : e3.createElement(Ni2, null, e3.createElement(xp, null, " Response Headers "), e3.createElement("tbody", null, d2(t4, (t5, r3) => e3.createElement(tl2, { isLast: r3, key: t5.name, field: t5, showExamples: true }))));
          }
        }
        var kp = Object.defineProperty, Op = Object.getOwnPropertySymbols, Ep = Object.prototype.hasOwnProperty, jp = Object.prototype.propertyIsEnumerable, $p = (e4, t4, r3) => t4 in e4 ? kp(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        class Sp extends e3.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (t4) => e3.createElement(yi2, { key: "header" }, "Response Schema: ", e3.createElement(vs, ((e4, t5) => {
              for (var r3 in t5 || (t5 = {}))
                Ep.call(t5, r3) && $p(e4, r3, t5[r3]);
              if (Op)
                for (var r3 of Op(t5))
                  jp.call(t5, r3) && $p(e4, r3, t5[r3]);
              return e4;
            })({}, t4)));
          }
          render() {
            const { description: t4, extensions: r3, headers: n3, content: o2 } = this.props.response;
            return e3.createElement(e3.Fragment, null, t4 && e3.createElement(Rs, { source: t4 }), e3.createElement(_a4, { extensions: r3 }), e3.createElement(wp, { headers: n3 }), e3.createElement(tp, { content: o2, renderDropdown: this.renderDropdown }, ({ schema: t5 }) => e3.createElement(e3.Fragment, null, "object" === (null == t5 ? void 0 : t5.type) && e3.createElement(Da2, { constraints: (null == t5 ? void 0 : t5.constraints) || [] }), e3.createElement(Dl, { skipWriteOnly: true, key: "schema", schema: t5 }))));
          }
        }
        const Cp = (0, ha2.observer)(({ response: t4 }) => {
          const { extensions: r3, headers: n3, type: o2, summary: i2, description: s2, code: a2, expanded: l3, content: c3 } = t4, p3 = e3.useMemo(() => void 0 === c3 ? [] : c3.mediaTypes.filter((e4) => void 0 !== e4.schema), [c3]), u3 = e3.useMemo(() => !(r3 && 0 !== Object.keys(r3).length || 0 !== n3.length || 0 !== p3.length || s2), [r3, n3, p3, s2]);
          return e3.createElement("div", null, e3.createElement(yp, { onClick: () => t4.toggle(), type: o2, empty: u3, title: i2 || "", code: a2, opened: l3 }), l3 && !u3 && e3.createElement(bp, null, e3.createElement(Sp, { response: t4 })));
        }), Pp = ee2.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: e4 }) => e4.colors.text.primary};
  font-weight: normal;
`;
        class Ap extends e3.PureComponent {
          render() {
            const { responses: t4, isCallback: r3 } = this.props;
            return t4 && 0 !== t4.length ? e3.createElement("div", null, e3.createElement(Pp, null, _2(r3 ? "callbackResponses" : "responses")), t4.map((t5) => e3.createElement(Cp, { key: t5.code, response: t5 }))) : null;
          }
        }
        function Ip(t4) {
          const { security: r3, showSecuritySchemeType: n3, expanded: o2 } = t4, i2 = r3.schemes.length > 1;
          return 0 === r3.schemes.length ? e3.createElement(Jl, { $expanded: o2 }, "None") : e3.createElement(Jl, { $expanded: o2 }, i2 && "(", r3.schemes.map((t5) => e3.createElement(Hl, { key: t5.id }, n3 && `${ac2[t5.type] || t5.type}: `, e3.createElement("i", null, t5.displayName), o2 && t5.scopes.length ? [" (", t5.scopes.map((t6) => e3.createElement(Vl, { key: t6 }, t6)), ") "] : null)), i2 && ") ");
        }
        const Tp = ({ scopes: t4 }) => t4.length ? e3.createElement("div", null, e3.createElement("b", null, "Required scopes: "), t4.map((t5, r3) => e3.createElement(e3.Fragment, { key: r3 }, e3.createElement("code", null, t5), " "))) : null;
        function _p(t4) {
          const r3 = Oi2(), n3 = null == r3 ? void 0 : r3.options.showSecuritySchemeType, [o2, i2] = (0, e3.useState)(false), { securities: s2 } = t4;
          if (!(null == s2 ? void 0 : s2.length) || (null == r3 ? void 0 : r3.options.hideSecuritySection))
            return null;
          const a2 = null == r3 ? void 0 : r3.spec.securitySchemes.schemes.filter(({ id: e4 }) => s2.find((t5) => t5.schemes.find((t6) => t6.id === e4)));
          return e3.createElement(e3.Fragment, null, e3.createElement(Xl, { $expanded: o2 }, e3.createElement(Yl, { onClick: () => i2(!o2) }, e3.createElement(Gl, null, "Authorizations:"), e3.createElement(Ci2, { size: "1.3em", direction: o2 ? "down" : "right" })), e3.createElement(Zl, { $expanded: o2 }, s2.map((t5, r4) => e3.createElement(Ip, { key: r4, expanded: o2, showSecuritySchemeType: n3, security: t5 })))), o2 && (null == a2 ? void 0 : a2.length) && a2.map((t5, r4) => e3.createElement(ec2, { key: r4 }, e3.createElement("h5", null, e3.createElement(Rp, null), " ", ac2[t5.type] || t5.type, ": ", t5.id), e3.createElement(Rs, { source: t5.description || "" }), e3.createElement(sc2, { key: t5.id, scheme: t5, RequiredScopes: e3.createElement(Tp, { scopes: Lp(t5.id, s2) }) }))));
        }
        const Rp = () => e3.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "11", height: "11" }, e3.createElement("path", { fill: "currentColor", d: "M18 10V6A6 6 0 0 0 6 6v4H3v14h18V10h-3zM8 6c0-2.206 1.794-4 4-4s4 1.794 4 4v4H8V6zm11 16H5V12h14v10z" }));
        function Lp(e4, t4) {
          const r3 = [];
          let n3 = t4.length;
          for (; n3--; ) {
            const o2 = t4[n3];
            let i2 = o2.schemes.length;
            for (; i2--; ) {
              const t5 = o2.schemes[i2];
              t5.id === e4 && Array.isArray(t5.scopes) && r3.push(...t5.scopes);
            }
          }
          return Array.from(new Set(r3));
        }
        let Dp = class extends e3.Component {
          render() {
            const { operation: t4 } = this.props, { description: r3, externalDocs: n3 } = t4, o2 = !(!r3 && !n3);
            return e3.createElement(Uc2, null, o2 && e3.createElement(zp, null, void 0 !== r3 && e3.createElement(Rs, { source: r3 }), n3 && e3.createElement(Pa2, { externalDocs: n3 })), e3.createElement(Kc2, { operation: this.props.operation, inverted: true, compact: true }), e3.createElement(_a4, { extensions: t4.extensions }), e3.createElement(_p, { securities: t4.security }), e3.createElement(pp, { parameters: t4.parameters, body: t4.requestBody }), e3.createElement(Ap, { responses: t4.responses, isCallback: t4.isCallback }));
          }
        };
        Dp = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Dp);
        const zp = ee2.div`
  margin-bottom: ${({ theme: e4 }) => 3 * e4.spacing.unit}px;
`;
        let Np = class extends e3.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              this.props.callbackOperation.toggle();
            };
          }
          render() {
            const { name: t4, expanded: r3, httpVerb: n3, deprecated: o2 } = this.props.callbackOperation;
            return e3.createElement(e3.Fragment, null, e3.createElement(Qc2, { onClick: this.toggle, name: t4, opened: r3, httpVerb: n3, deprecated: o2 }), r3 && e3.createElement(Dp, { operation: this.props.callbackOperation }));
          }
        };
        Np = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Np);
        class Mp extends e3.PureComponent {
          render() {
            const { callbacks: t4 } = this.props;
            return t4 && 0 !== t4.length ? e3.createElement("div", null, e3.createElement(qp, null, " Callbacks "), t4.map((t5) => t5.operations.map((r3, n3) => e3.createElement(Np, { key: `${t5.name}_${n3}`, callbackOperation: r3 })))) : null;
          }
        }
        const qp = ee2.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: e4 }) => e4.colors.text.primary};
  font-weight: normal;
`;
        let Fp = class extends e3.Component {
          constructor(e4) {
            super(e4), this.switchItem = ({ idx: e5 }) => {
              this.props.items && void 0 !== e5 && this.setState({ activeItemIdx: e5 });
            }, this.state = { activeItemIdx: 0 };
          }
          render() {
            const { items: t4 } = this.props;
            if (!t4 || !t4.length)
              return null;
            const r3 = ({ children: t5 }) => this.props.label ? e3.createElement(la2, null, e3.createElement(aa2, null, this.props.label), t5) : t5;
            return e3.createElement(e3.Fragment, null, e3.createElement(r3, null, this.props.renderDropdown({ value: this.props.options[this.state.activeItemIdx].value, options: this.props.options, onChange: this.switchItem, ariaLabel: this.props.label || "Callback" })), this.props.children(t4[this.state.activeItemIdx]));
          }
        };
        Fp = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Fp);
        var Bp = Object.defineProperty, Qp = Object.defineProperties, Up = Object.getOwnPropertyDescriptors, Wp = Object.getOwnPropertySymbols, Vp = Object.prototype.hasOwnProperty, Hp = Object.prototype.propertyIsEnumerable, Jp = (e4, t4, r3) => t4 in e4 ? Bp(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        let Yp = class extends e3.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (t4) => {
              return e3.createElement(vs, (r3 = ((e4, t5) => {
                for (var r4 in t5 || (t5 = {}))
                  Vp.call(t5, r4) && Jp(e4, r4, t5[r4]);
                if (Wp)
                  for (var r4 of Wp(t5))
                    Hp.call(t5, r4) && Jp(e4, r4, t5[r4]);
                return e4;
              })({ Label: sa2, Dropdown: ca2 }, t4), Qp(r3, Up({ variant: "dark" }))));
              var r3;
            };
          }
          render() {
            const t4 = this.props.content;
            return void 0 === t4 ? null : e3.createElement(tp, { content: t4, renderDropdown: this.renderDropdown, withLabel: true }, (t5) => e3.createElement(ua2, { key: "samples", mediaType: t5, renderDropdown: this.renderDropdown }));
          }
        };
        Yp = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Yp);
        class Zp extends e3.Component {
          render() {
            const t4 = this.props.callback.codeSamples.find((e4) => fo(e4));
            return t4 ? e3.createElement(Gp, null, e3.createElement(Yp, { content: t4.requestBodyContent })) : null;
          }
        }
        const Gp = ee2.div`
  margin-top: 15px;
`;
        var Xp = Object.defineProperty, Kp = Object.defineProperties, eu = Object.getOwnPropertyDescriptors, tu = Object.getOwnPropertySymbols, ru = Object.prototype.hasOwnProperty, nu = Object.prototype.propertyIsEnumerable, ou = (e4, t4, r3) => t4 in e4 ? Xp(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        let iu = class extends e3.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (t4) => {
              return e3.createElement(vs, (r3 = ((e4, t5) => {
                for (var r4 in t5 || (t5 = {}))
                  ru.call(t5, r4) && ou(e4, r4, t5[r4]);
                if (tu)
                  for (var r4 of tu(t5))
                    nu.call(t5, r4) && ou(e4, r4, t5[r4]);
                return e4;
              })({ Label: sa2, Dropdown: ca2 }, t4), Kp(r3, eu({ variant: "dark" }))));
              var r3;
            };
          }
          render() {
            const { callbacks: t4 } = this.props;
            if (!t4 || 0 === t4.length)
              return null;
            const r3 = t4.map((e4) => e4.operations.map((e5) => e5)).reduce((e4, t5) => e4.concat(t5), []);
            if (!r3.some((e4) => e4.codeSamples.length > 0))
              return null;
            const n3 = r3.map((e4, t5) => ({ value: `${e4.httpVerb.toUpperCase()}: ${e4.name}`, idx: t5 }));
            return e3.createElement("div", null, e3.createElement(gi2, null, " Callback payload samples "), e3.createElement(su, null, e3.createElement(Fp, { items: r3, renderDropdown: this.renderDropdown, label: "Callback", options: n3 }, (t5) => e3.createElement(Zp, { key: "callbackPayloadSample", callback: t5, renderDropdown: this.renderDropdown }))));
          }
        };
        iu.contextType = ce2, iu = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], iu);
        const su = ee2.div`
  background: ${({ theme: e4 }) => e4.codeBlock.backgroundColor};
  padding: ${(e4) => 4 * e4.theme.spacing.unit}px;
`;
        let au = class extends e3.Component {
          render() {
            const { operation: t4 } = this.props, r3 = t4.codeSamples, n3 = r3.length > 0, o2 = 1 === r3.length && this.context.hideSingleRequestSampleTab;
            return n3 && e3.createElement("div", null, e3.createElement(gi2, null, " ", _2("requestSamples"), " "), e3.createElement(Wi2, { defaultIndex: 0 }, e3.createElement(Ui2.TabList, { hidden: o2 }, r3.map((t5) => e3.createElement(Ui2.Tab, { key: t5.lang + "_" + (t5.label || "") }, void 0 !== t5.label ? t5.label : t5.lang))), r3.map((t5) => e3.createElement(Ui2.TabPanel, { key: t5.lang + "_" + (t5.label || "") }, fo(t5) ? e3.createElement("div", null, e3.createElement(Yp, { content: t5.requestBodyContent })) : e3.createElement(ta2, { lang: t5.lang, source: t5.source }))))) || null;
          }
        };
        au.contextType = ce2, au = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], au);
        let lu = class extends e3.Component {
          render() {
            const { operation: t4 } = this.props, r3 = t4.responses.filter((e4) => e4.content && e4.content.hasSample);
            return r3.length > 0 && e3.createElement("div", null, e3.createElement(gi2, null, " ", _2("responseSamples"), " "), e3.createElement(Wi2, { defaultIndex: 0 }, e3.createElement(Ui2.TabList, null, r3.map((t5) => e3.createElement(Ui2.Tab, { className: "tab-" + t5.type, key: t5.code }, t5.code))), r3.map((t5) => e3.createElement(Ui2.TabPanel, { key: t5.code }, e3.createElement("div", null, e3.createElement(Yp, { content: t5.content })))))) || null;
          }
        };
        lu = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], lu);
        var cu = Object.defineProperty, pu = Object.defineProperties, uu = Object.getOwnPropertyDescriptors, du = Object.getOwnPropertySymbols, hu = Object.prototype.hasOwnProperty, mu = Object.prototype.propertyIsEnumerable, fu = (e4, t4, r3) => t4 in e4 ? cu(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        const gu = ee2.div`
  margin-bottom: ${({ theme: e4 }) => 6 * e4.spacing.unit}px;
`, yu = (0, ha2.observer)(({ operation: t4 }) => {
          const { name: r3, description: n3, deprecated: o2, externalDocs: i2, isWebhook: s2, httpVerb: a2 } = t4, l3 = !(!n3 && !i2), { showWebhookVerb: c3 } = e3.useContext(ce2);
          return e3.createElement(ce2.Consumer, null, (p3) => {
            return e3.createElement(ui2, (u3 = ((e4, t5) => {
              for (var r4 in t5 || (t5 = {}))
                hu.call(t5, r4) && fu(e4, r4, t5[r4]);
              if (du)
                for (var r4 of du(t5))
                  mu.call(t5, r4) && fu(e4, r4, t5[r4]);
              return e4;
            })({}, { [ei2]: t4.operationHash }), d3 = { id: t4.operationHash }, pu(u3, uu(d3))), e3.createElement(ai2, null, e3.createElement(fi2, null, e3.createElement($i2, { to: t4.id }), r3, " ", o2 && e3.createElement(Pi2, { type: "warning" }, " Deprecated "), s2 && e3.createElement(Pi2, { type: "primary" }, " ", "Webhook ", c3 && a2 && "| " + a2.toUpperCase())), p3.pathInMiddlePanel && !s2 && e3.createElement(Kc2, { operation: t4, inverted: true }), l3 && e3.createElement(gu, null, void 0 !== n3 && e3.createElement(Rs, { source: n3 }), i2 && e3.createElement(Pa2, { externalDocs: i2 })), e3.createElement(_a4, { extensions: t4.extensions }), e3.createElement(_p, { securities: t4.security }), e3.createElement(pp, { parameters: t4.parameters, body: t4.requestBody }), e3.createElement(Ap, { responses: t4.responses }), e3.createElement(Mp, { callbacks: t4.callbacks })), e3.createElement(pi2, null, !p3.pathInMiddlePanel && !s2 && e3.createElement(Kc2, { operation: t4 }), e3.createElement(au, { operation: t4 }), e3.createElement(lu, { operation: t4 }), e3.createElement(iu, { callbacks: t4.callbacks })));
            var u3, d3;
          });
        });
        var bu = Object.defineProperty, xu = Object.getOwnPropertyDescriptor, vu = Object.getOwnPropertySymbols, wu = Object.prototype.hasOwnProperty, ku = Object.prototype.propertyIsEnumerable, Ou = (e4, t4, r3) => t4 in e4 ? bu(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, Eu = (e4, t4, r3, n3) => {
          for (var o2, i2 = n3 > 1 ? void 0 : n3 ? xu(t4, r3) : t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = (n3 ? o2(t4, r3, i2) : o2(i2)) || i2);
          return n3 && i2 && bu(t4, r3, i2), i2;
        };
        let ju = class extends e3.Component {
          render() {
            const t4 = this.props.items;
            return 0 === t4.length ? null : t4.map((t5) => e3.createElement($u, { key: t5.id, item: t5 }));
          }
        };
        ju = Eu([ha2.observer], ju);
        let $u = class extends e3.Component {
          render() {
            const t4 = this.props.item;
            let r3;
            const { type: n3 } = t4;
            switch (n3) {
              case "group":
                r3 = null;
                break;
              case "tag":
              case "section":
              default:
                r3 = e3.createElement(Cu, ((e4, t5) => {
                  for (var r4 in t5 || (t5 = {}))
                    wu.call(t5, r4) && Ou(e4, r4, t5[r4]);
                  if (vu)
                    for (var r4 of vu(t5))
                      ku.call(t5, r4) && Ou(e4, r4, t5[r4]);
                  return e4;
                })({}, this.props));
                break;
              case "operation":
                r3 = e3.createElement(Pu, { item: t4 });
            }
            return e3.createElement(e3.Fragment, null, r3 && e3.createElement(li2, { id: t4.id, $underlined: "operation" === t4.type }, r3), t4.items && e3.createElement(ju, { items: t4.items }));
          }
        };
        $u = Eu([ha2.observer], $u);
        const Su = (t4) => e3.createElement(ai2, { $compact: true }, t4);
        let Cu = class extends e3.Component {
          render() {
            const { name: t4, description: r3, externalDocs: n3, level: o2 } = this.props.item, i2 = 2 === o2 ? fi2 : mi2;
            return e3.createElement(e3.Fragment, null, e3.createElement(ui2, null, e3.createElement(ai2, { $compact: false }, e3.createElement(i2, null, e3.createElement($i2, { to: this.props.item.id }), t4))), e3.createElement(Pc2, { parentId: this.props.item.id, source: r3 || "", htmlWrap: Su }), n3 && e3.createElement(ui2, null, e3.createElement(ai2, null, e3.createElement(Pa2, { externalDocs: n3 }))));
          }
        };
        Cu = Eu([ha2.observer], Cu);
        let Pu = class extends e3.Component {
          render() {
            return e3.createElement(yu, { operation: this.props.item });
          }
        };
        Pu = Eu([ha2.observer], Pu);
        var Au = Object.defineProperty, Iu = Object.defineProperties, Tu = Object.getOwnPropertyDescriptors, _u = Object.getOwnPropertySymbols, Ru = Object.prototype.hasOwnProperty, Lu = Object.prototype.propertyIsEnumerable, Du = (e4, t4, r3) => t4 in e4 ? Au(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        let zu = class extends e3.Component {
          constructor() {
            super(...arguments), this.ref = e3.createRef(), this.activate = (e4) => {
              this.props.onActivate(this.props.item), e4.stopPropagation();
            };
          }
          componentDidMount() {
            this.scrollIntoViewIfActive();
          }
          componentDidUpdate() {
            this.scrollIntoViewIfActive();
          }
          scrollIntoViewIfActive() {
            this.props.item.active && this.ref.current && c2(this.ref.current);
          }
          render() {
            const { item: t4, withoutChildren: r3 } = this.props;
            return e3.createElement(Lc2, { tabIndex: 0, onClick: this.activate, depth: t4.depth, "data-item-id": t4.id, role: "menuitem" }, "operation" === t4.type ? e3.createElement(Nu, (n3 = ((e4, t5) => {
              for (var r4 in t5 || (t5 = {}))
                Ru.call(t5, r4) && Du(e4, r4, t5[r4]);
              if (_u)
                for (var r4 of _u(t5))
                  Lu.call(t5, r4) && Du(e4, r4, t5[r4]);
              return e4;
            })({}, this.props), Iu(n3, Tu({ item: t4 })))) : e3.createElement(zc2, { $depth: t4.depth, $active: t4.active, $type: t4.type, ref: this.ref }, "schema" === t4.type && e3.createElement(Tc2, { type: "schema" }, "schema"), e3.createElement(Nc2, { width: "calc(100% - 38px)", title: t4.sidebarLabel }, t4.sidebarLabel, this.props.children), t4.depth > 0 && t4.items.length > 0 && e3.createElement(Ci2, { float: "right", direction: t4.expanded ? "down" : "right" }) || null), !r3 && t4.items && t4.items.length > 0 && e3.createElement(Uu, { expanded: t4.expanded, items: t4.items, onActivate: this.props.onActivate }));
            var n3;
          }
        };
        zu = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], zu);
        const Nu = (0, ha2.observer)((t4) => {
          const { item: r3 } = t4, n3 = e3.createRef(), { showWebhookVerb: o2 } = e3.useContext(ce2);
          return e3.useEffect(() => {
            t4.item.active && n3.current && c2(n3.current);
          }, [t4.item.active, n3]), e3.createElement(zc2, { $depth: r3.depth, $active: r3.active, $deprecated: r3.deprecated, ref: n3 }, r3.isWebhook ? e3.createElement(Tc2, { type: "hook" }, o2 ? r3.httpVerb : _2("webhook")) : e3.createElement(Tc2, { type: r3.httpVerb }, yt(r3.httpVerb)), e3.createElement(Nc2, { tabIndex: 0, width: "calc(100% - 38px)" }, r3.sidebarLabel, t4.children));
        });
        var Mu = Object.defineProperty, qu = Object.getOwnPropertySymbols, Fu = Object.prototype.hasOwnProperty, Bu = Object.prototype.propertyIsEnumerable, Qu = (e4, t4, r3) => t4 in e4 ? Mu(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3;
        let Uu = class extends e3.Component {
          render() {
            const { items: t4, root: r3, className: n3 } = this.props, o2 = null == this.props.expanded || this.props.expanded;
            return e3.createElement(Rc2, ((e4, t5) => {
              for (var r4 in t5 || (t5 = {}))
                Fu.call(t5, r4) && Qu(e4, r4, t5[r4]);
              if (qu)
                for (var r4 of qu(t5))
                  Bu.call(t5, r4) && Qu(e4, r4, t5[r4]);
              return e4;
            })({ className: n3, style: this.props.style, $expanded: o2 }, r3 ? { role: "menu" } : {}), t4.map((t5, r4) => e3.createElement(zu, { key: r4, item: t5, onActivate: this.props.onActivate })));
          }
        };
        function Wu() {
          const [t4, r3] = (0, e3.useState)(false);
          return (0, e3.useEffect)(() => {
            r3(true);
          }, []), t4 ? e3.createElement("img", { alt: "redocly logo", onError: () => r3(false), src: "https://cdn.redoc.ly/redoc/logo-mini.svg" }) : null;
        }
        Uu = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Uu);
        let Vu = class extends e3.Component {
          constructor() {
            super(...arguments), this.activate = (e4) => {
              if (e4 && e4.active && this.context.menuToggle)
                return e4.expanded ? e4.collapse() : e4.expand();
              this.props.menu.activateAndScroll(e4, true), setTimeout(() => {
                this._updateScroll && this._updateScroll();
              });
            }, this.saveScrollUpdate = (e4) => {
              this._updateScroll = e4;
            };
          }
          render() {
            const t4 = this.props.menu;
            return e3.createElement(ls, { updateFn: this.saveScrollUpdate, className: this.props.className, options: { wheelPropagation: false } }, e3.createElement(Uu, { items: t4.items, onActivate: this.activate, root: true }), e3.createElement(Mc2, null, e3.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: "https://redocly.com/redoc/" }, e3.createElement(Wu, null), "API docs by Redocly")));
          }
        };
        Vu.contextType = ce2, Vu = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], Vu);
        const Hu = ({ open: t4 }) => {
          const r3 = t4 ? 8 : -4;
          return e3.createElement(Yu, null, e3.createElement(Ju, { size: 15, style: { transform: `translate(2px, ${r3}px) rotate(180deg)`, transition: "transform 0.2s ease" } }), e3.createElement(Ju, { size: 15, style: { transform: `translate(2px, ${0 - r3}px)`, transition: "transform 0.2s ease" } }));
        }, Ju = ({ size: t4 = 10, className: r3 = "", style: n3 }) => e3.createElement("svg", { className: r3, style: n3 || {}, viewBox: "0 0 926.23699 573.74994", version: "1.1", x: "0px", y: "0px", width: t4, height: t4 }, e3.createElement("g", { transform: "translate(904.92214,-879.1482)" }, e3.createElement("path", { d: "\n          m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,\n          -55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,\n          0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,\n          -174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,\n          -174.68583 0.6895,0 26.281,25.03215 56.8701,\n          55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864\n          -231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,\n          -104.0616 -231.873,-231.248 z\n        ", fill: "currentColor" }))), Yu = ee2.div`
  user-select: none;
  width: 20px;
  height: 20px;
  align-self: center;
  display: flex;
  flex-direction: column;
  color: ${(e4) => e4.theme.colors.primary.main};
`;
        let Zu;
        s && (Zu = r2(322));
        const Gu = Zu && Zu(), Xu = ee2.div`
  width: ${(e4) => e4.theme.sidebar.width};
  background-color: ${(e4) => e4.theme.sidebar.backgroundColor};
  overflow: hidden;
  display: flex;
  flex-direction: column;

  backface-visibility: hidden;
  /* contain: strict; TODO: breaks layout since Chrome 80*/

  height: 100vh;
  position: sticky;
  position: -webkit-sticky;
  top: 0;

  ${K2.lessThan("small")`
    position: fixed;
    z-index: 20;
    width: 100%;
    background: ${({ theme: e4 }) => e4.sidebar.backgroundColor};
    display: ${(e4) => e4.$open ? "flex" : "none"};
  `};

  @media print {
    display: none;
  }
`, Ku = ee2.div`
  outline: none;
  user-select: none;
  background-color: ${({ theme: e4 }) => e4.fab.backgroundColor};
  color: ${(e4) => e4.theme.colors.primary.main};
  display: none;
  cursor: pointer;
  position: fixed;
  right: 20px;
  z-index: 100;
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
  ${K2.lessThan("small")`
    display: flex;
  `};

  bottom: 44px;

  width: 60px;
  height: 60px;
  padding: 0 20px;
  svg {
    color: ${({ theme: e4 }) => e4.fab.color};
  }

  @media print {
    display: none;
  }
`;
        let ed2 = class extends e3.Component {
          constructor() {
            super(...arguments), this.state = { offsetTop: "0px" }, this.toggleNavMenu = () => {
              this.props.menu.toggleSidebar();
            };
          }
          componentDidMount() {
            Gu && Gu.add(this.stickyElement), this.setState({ offsetTop: this.getScrollYOffset(this.context) });
          }
          componentWillUnmount() {
            Gu && Gu.remove(this.stickyElement);
          }
          getScrollYOffset(e4) {
            let t4;
            return t4 = void 0 !== this.props.scrollYOffset ? W2.normalizeScrollYOffset(this.props.scrollYOffset)() : e4.scrollYOffset(), t4 + "px";
          }
          render() {
            const t4 = this.props.menu.sideBarOpened, r3 = this.state.offsetTop;
            return e3.createElement(e3.Fragment, null, e3.createElement(Xu, { $open: t4, className: this.props.className, style: { top: r3, height: `calc(100vh - ${r3})` }, ref: (e4) => {
              this.stickyElement = e4;
            } }, this.props.children), !this.context.hideFab && e3.createElement(Ku, { onClick: this.toggleNavMenu }, e3.createElement(Hu, { open: t4 })));
          }
        };
        ed2.contextType = ce2, ed2 = ((e4, t4, r3, n3) => {
          for (var o2, i2 = t4, s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(i2) || i2);
          return i2;
        })([ha2.observer], ed2);
        const td2 = ee2.div`
  ${({ theme: e4 }) => `
  font-family: ${e4.typography.fontFamily};
  font-size: ${e4.typography.fontSize};
  font-weight: ${e4.typography.fontWeightRegular};
  line-height: ${e4.typography.lineHeight};
  color: ${e4.colors.text.primary};
  display: flex;
  position: relative;
  text-align: left;

  -webkit-font-smoothing: ${e4.typography.smoothing};
  font-smoothing: ${e4.typography.smoothing};
  ${e4.typography.optimizeSpeed ? "text-rendering: optimizeSpeed !important" : ""};

  tap-highlight-color: rgba(0, 0, 0, 0);
  text-size-adjust: 100%;

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  }
`};
`, rd2 = ee2.div`
  z-index: 1;
  position: relative;
  overflow: hidden;
  width: calc(100% - ${(e4) => e4.theme.sidebar.width});
  ${K2.lessThan("small", true)`
    width: 100%;
  `};

  contain: layout;
`, nd2 = ee2.div`
  background: ${({ theme: e4 }) => e4.rightPanel.backgroundColor};
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: ${({ theme: e4 }) => {
          if (e4.rightPanel.width.endsWith("%")) {
            const t4 = parseInt(e4.rightPanel.width, 10);
            return `calc((100% - ${e4.sidebar.width}) * ${t4 / 100})`;
          }
          return e4.rightPanel.width;
        }};
  ${K2.lessThan("medium", true)`
    display: none;
  `};
`, od2 = ee2.div`
  padding: 5px 0;
`, id2 = ee2.input.attrs(() => ({ className: "search-input" }))`
  width: calc(100% - ${(e4) => 8 * e4.theme.spacing.unit}px);
  box-sizing: border-box;
  margin: 0 ${(e4) => 4 * e4.theme.spacing.unit}px;
  padding: 5px ${(e4) => 2 * e4.theme.spacing.unit}px 5px
    ${(e4) => 4 * e4.theme.spacing.unit}px;
  border: 0;
  border-bottom: 1px solid
    ${({ theme: e4 }) => ((0, t3.getLuminance)(e4.sidebar.backgroundColor) > 0.5 ? t3.darken : t3.lighten)(0.1, e4.sidebar.backgroundColor)};
  font-family: ${({ theme: e4 }) => e4.typography.fontFamily};
  font-weight: bold;
  font-size: 13px;
  color: ${(e4) => e4.theme.sidebar.textColor};
  background-color: transparent;
  outline: none;
`, sd2 = ee2((t4) => e3.createElement("svg", { className: t4.className, version: "1.1", viewBox: "0 0 1000 1000", x: "0px", xmlns: "http://www.w3.org/2000/svg", y: "0px" }, e3.createElement("path", { d: "M968.2,849.4L667.3,549c83.9-136.5,66.7-317.4-51.7-435.6C477.1-25,252.5-25,113.9,113.4c-138.5,138.3-138.5,362.6,0,501C219.2,730.1,413.2,743,547.6,666.5l301.9,301.4c43.6,43.6,76.9,14.9,104.2-12.4C981,928.3,1011.8,893,968.2,849.4z M524.5,522c-88.9,88.7-233,88.7-321.8,0c-88.9-88.7-88.9-232.6,0-321.3c88.9-88.7,233-88.7,321.8,0C613.4,289.4,613.4,433.3,524.5,522z" }))).attrs({ className: "search-icon" })`
  position: absolute;
  left: ${(e4) => 4 * e4.theme.spacing.unit}px;
  height: 1.8em;
  width: 0.9em;

  path {
    fill: ${(e4) => e4.theme.sidebar.textColor};
  }
`, ad2 = ee2.div`
  padding: ${(e4) => e4.theme.spacing.unit}px 0;
  background-color: ${({ theme: e4 }) => (0, t3.darken)(0.05, e4.sidebar.backgroundColor)}};
  color: ${(e4) => e4.theme.sidebar.textColor};
  min-height: 150px;
  max-height: 250px;
  border-top: ${({ theme: e4 }) => (0, t3.darken)(0.1, e4.sidebar.backgroundColor)}};
  border-bottom: ${({ theme: e4 }) => (0, t3.darken)(0.1, e4.sidebar.backgroundColor)}};
  margin-top: 10px;
  line-height: 1.4;
  font-size: 0.9em;
  
  li {
    background-color: inherit;
  }

  ${zc2} {
    padding-top: 6px;
    padding-bottom: 6px;

    &:hover,
    &.active {
      background-color: ${({ theme: e4 }) => (0, t3.darken)(0.1, e4.sidebar.backgroundColor)};
    }

    > svg {
      display: none;
    }
  }
`, ld2 = ee2.i`
  position: absolute;
  display: inline-block;
  width: ${(e4) => 2 * e4.theme.spacing.unit}px;
  text-align: center;
  right: ${(e4) => 4 * e4.theme.spacing.unit}px;
  line-height: 2em;
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  font-style: normal;
  color: '#666';
`;
        var cd2 = Object.defineProperty, pd2 = Object.getOwnPropertyDescriptor;
        class ud2 extends e3.PureComponent {
          constructor(e4) {
            super(e4), this.activeItemRef = null, this.clear = () => {
              this.setState({ results: [], noResults: false, term: "", activeItemIdx: -1 }), this.props.marker.unmark();
            }, this.handleKeyDown = (e5) => {
              if (27 === e5.keyCode && this.clear(), 40 === e5.keyCode && (this.setState({ activeItemIdx: Math.min(this.state.activeItemIdx + 1, this.state.results.length - 1) }), e5.preventDefault()), 38 === e5.keyCode && (this.setState({ activeItemIdx: Math.max(0, this.state.activeItemIdx - 1) }), e5.preventDefault()), 13 === e5.keyCode) {
                const e6 = this.state.results[this.state.activeItemIdx];
                if (e6) {
                  const t4 = this.props.getItemById(e6.meta);
                  t4 && this.props.onActivate(t4);
                }
              }
            }, this.search = (e5) => {
              const { minCharacterLengthToInitSearch: t4 } = this.context, r3 = e5.target.value;
              r3.length < t4 ? this.clearResults(r3) : this.setState({ term: r3 }, () => this.searchCallback(this.state.term));
            }, this.state = { results: [], noResults: false, term: "", activeItemIdx: -1 };
          }
          clearResults(e4) {
            this.setState({ results: [], noResults: false, term: e4 }), this.props.marker.unmark();
          }
          setResults(e4, t4) {
            this.setState({ results: e4, noResults: 0 === e4.length }), this.props.marker.mark(t4);
          }
          searchCallback(e4) {
            this.props.search.search(e4).then((t4) => {
              this.setResults(t4, e4);
            });
          }
          render() {
            const { activeItemIdx: t4 } = this.state, r3 = this.state.results.filter((e4) => this.props.getItemById(e4.meta)).map((e4) => ({ item: this.props.getItemById(e4.meta), score: e4.score })).sort((e4, t5) => t5.score - e4.score);
            return e3.createElement(od2, { role: "search" }, this.state.term && e3.createElement(ld2, { onClick: this.clear }, ""), e3.createElement(sd2, null), e3.createElement(id2, { value: this.state.term, onKeyDown: this.handleKeyDown, placeholder: "Search...", "aria-label": "Search", type: "text", onChange: this.search }), r3.length > 0 && e3.createElement(ls, { options: { wheelPropagation: false } }, e3.createElement(ad2, { "data-role": "search:results" }, r3.map((r4, n3) => e3.createElement(zu, { item: Object.create(r4.item, { active: { value: n3 === t4 } }), onActivate: this.props.onActivate, withoutChildren: true, key: r4.item.id, "data-role": "search:result" })))), this.state.term && this.state.noResults ? e3.createElement(ad2, { "data-role": "search:results" }, _2("noResultsFound")) : null);
          }
        }
        ud2.contextType = ce2, ((e4, t4, r3, n3) => {
          for (var o2, i2 = pd2(t4, r3), s2 = e4.length - 1; s2 >= 0; s2--)
            (o2 = e4[s2]) && (i2 = o2(t4, r3, i2) || i2);
          i2 && cd2(t4, r3, i2);
        })([xe2.bind, (0, xe2.debounce)(400)], ud2.prototype, "searchCallback");
        class dd2 extends e3.Component {
          componentDidMount() {
            this.props.store.onDidMount();
          }
          componentWillUnmount() {
            this.props.store.dispose();
          }
          render() {
            const { store: { spec: t4, menu: r3, options: n3, search: o2, marker: i2 } } = this.props, s2 = this.props.store;
            return e3.createElement(X2, { theme: n3.theme }, e3.createElement(vi2, { value: s2 }, e3.createElement(pe2, { value: n3 }, e3.createElement(td2, { className: "redoc-wrap" }, e3.createElement(ed2, { menu: r3, className: "menu-content" }, e3.createElement(kc2, { info: t4.info }), !n3.disableSearch && e3.createElement(ud2, { search: o2, marker: i2, getItemById: r3.getItemById, onActivate: r3.activateAndScroll }) || null, e3.createElement(Vu, { menu: r3 })), e3.createElement(rd2, { className: "api-content" }, e3.createElement(bc2, { store: s2 }), e3.createElement(ju, { items: r3.items })), e3.createElement(nd2, null)))));
          }
        }
        dd2.propTypes = { store: le2.instanceOf(uc2).isRequired };
        var hd2 = Object.defineProperty, md2 = Object.getOwnPropertySymbols, fd2 = Object.prototype.hasOwnProperty, gd2 = Object.prototype.propertyIsEnumerable, yd2 = (e4, t4, r3) => t4 in e4 ? hd2(e4, t4, { enumerable: true, configurable: true, writable: true, value: r3 }) : e4[t4] = r3, bd2 = (e4, t4) => {
          for (var r3 in t4 || (t4 = {}))
            fd2.call(t4, r3) && yd2(e4, r3, t4[r3]);
          if (md2)
            for (var r3 of md2(t4))
              gd2.call(t4, r3) && yd2(e4, r3, t4[r3]);
          return e4;
        };
        const xd2 = function(t4) {
          const { spec: n3, specUrl: o2, options: i2 = {}, onLoaded: s2 } = t4, a2 = Q2(i2.hideLoading, false), l3 = new W2(i2);
          if (void 0 !== l3.nonce)
            try {
              r2.nc = l3.nonce;
            } catch (e4) {
            }
          return e3.createElement(ne2, null, e3.createElement(ki2, { spec: n3 ? bd2({}, n3) : void 0, specUrl: o2, options: i2, onLoaded: s2 }, ({ loading: t5, store: r3 }) => t5 ? a2 ? null : e3.createElement(ae2, { color: l3.theme.colors.primary.main }) : e3.createElement(dd2, { store: r3 })));
        };
      }(), n2;
    }();
  });
})(redoc_browser_lib);
var redoc_browser_libExports = redoc_browser_lib.exports;
const token = "%[a-f0-9]{2}";
const singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
const multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components2, split) {
  try {
    return [decodeURIComponent(components2.join(""))];
  } catch {
  }
  if (components2.length === 1) {
    return components2;
  }
  split = split || 1;
  const left2 = components2.slice(0, split);
  const right2 = components2.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right2));
}
function decode$1(input) {
  try {
    return decodeURIComponent(input);
  } catch {
    let tokens2 = input.match(singleMatcher) || [];
    for (let i = 1; i < tokens2.length; i++) {
      input = decodeComponents(tokens2, i).join("");
      tokens2 = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  const replaceMap = {
    "%FE%FF": "",
    "%FF%FE": ""
  };
  let match2 = multiMatcher.exec(input);
  while (match2) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch {
      const result = decode$1(match2[0]);
      if (result !== match2[0]) {
        replaceMap[match2[0]] = result;
      }
    }
    match2 = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "";
  const entries2 = Object.keys(replaceMap);
  for (const key2 of entries2) {
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
function decodeUriComponent(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    return decodeURIComponent(encodedURI);
  } catch {
    return customDecodeURIComponent(encodedURI);
  }
}
var lib = { exports: {} };
var UTF8_ACCEPT = 12;
var UTF8_REJECT = 0;
var UTF8_DATA = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
function decodeURIComponent$1(uri) {
  var percentPosition = uri.indexOf("%");
  if (percentPosition === -1)
    return uri;
  var length2 = uri.length;
  var decoded = "";
  var last2 = 0;
  var codepoint = 0;
  var startOfOctets = percentPosition;
  var state2 = UTF8_ACCEPT;
  while (percentPosition > -1 && percentPosition < length2) {
    var high = hexCodeToInt(uri[percentPosition + 1], 4);
    var low = hexCodeToInt(uri[percentPosition + 2], 0);
    var byte = high | low;
    var type2 = UTF8_DATA[byte];
    state2 = UTF8_DATA[256 + state2 + type2];
    codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
    if (state2 === UTF8_ACCEPT) {
      decoded += uri.slice(last2, startOfOctets);
      decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
        55232 + (codepoint >> 10),
        56320 + (codepoint & 1023)
      );
      codepoint = 0;
      last2 = percentPosition + 3;
      percentPosition = startOfOctets = uri.indexOf("%", last2);
    } else if (state2 === UTF8_REJECT) {
      return null;
    } else {
      percentPosition += 3;
      if (percentPosition < length2 && uri.charCodeAt(percentPosition) === 37)
        continue;
      return null;
    }
  }
  return decoded + uri.slice(last2);
}
var HEX = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
function hexCodeToInt(c2, shift2) {
  var i = HEX[c2];
  return i === void 0 ? 255 : i << shift2;
}
var fastDecodeUriComponent = decodeURIComponent$1;
const fastDecode = fastDecodeUriComponent;
const plusRegex = /\+/g;
const Empty = function() {
};
Empty.prototype = /* @__PURE__ */ Object.create(null);
function parse$4(input) {
  const result = new Empty();
  if (typeof input !== "string") {
    return result;
  }
  let inputLength = input.length;
  let key2 = "";
  let value = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let shouldDecodeKey = false;
  let shouldDecodeValue = false;
  let keyHasPlus = false;
  let valueHasPlus = false;
  let hasBothKeyValuePair = false;
  let c2 = 0;
  for (let i = 0; i < inputLength + 1; i++) {
    c2 = i !== inputLength ? input.charCodeAt(i) : 38;
    if (c2 === 38) {
      hasBothKeyValuePair = equalityIndex > startingIndex;
      if (!hasBothKeyValuePair) {
        equalityIndex = i;
      }
      key2 = input.slice(startingIndex + 1, equalityIndex);
      if (hasBothKeyValuePair || key2.length > 0) {
        if (keyHasPlus) {
          key2 = key2.replace(plusRegex, " ");
        }
        if (shouldDecodeKey) {
          key2 = fastDecode(key2) || key2;
        }
        if (hasBothKeyValuePair) {
          value = input.slice(equalityIndex + 1, i);
          if (valueHasPlus) {
            value = value.replace(plusRegex, " ");
          }
          if (shouldDecodeValue) {
            value = fastDecode(value) || value;
          }
        }
        const currentValue = result[key2];
        if (currentValue === void 0) {
          result[key2] = value;
        } else {
          if (currentValue.pop) {
            currentValue.push(value);
          } else {
            result[key2] = [currentValue, value];
          }
        }
      }
      value = "";
      startingIndex = i;
      equalityIndex = i;
      shouldDecodeKey = false;
      shouldDecodeValue = false;
      keyHasPlus = false;
      valueHasPlus = false;
    } else if (c2 === 61) {
      if (equalityIndex <= startingIndex) {
        equalityIndex = i;
      } else {
        shouldDecodeValue = true;
      }
    } else if (c2 === 43) {
      if (equalityIndex > startingIndex) {
        valueHasPlus = true;
      } else {
        keyHasPlus = true;
      }
    } else if (c2 === 37) {
      if (equalityIndex > startingIndex) {
        shouldDecodeValue = true;
      } else {
        shouldDecodeKey = true;
      }
    }
  }
  return result;
}
var parse_1 = parse$4;
const hexTable = Array.from(
  { length: 256 },
  (_2, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
);
const noEscape = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  // 80 - 95
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
  // 112 - 127
]);
function encodeString$1(str2) {
  const len = str2.length;
  if (len === 0)
    return "";
  let out = "";
  let lastPos = 0;
  let i = 0;
  outer:
    for (; i < len; i++) {
      let c2 = str2.charCodeAt(i);
      while (c2 < 128) {
        if (noEscape[c2] !== 1) {
          if (lastPos < i)
            out += str2.slice(lastPos, i);
          lastPos = i + 1;
          out += hexTable[c2];
        }
        if (++i === len)
          break outer;
        c2 = str2.charCodeAt(i);
      }
      if (lastPos < i)
        out += str2.slice(lastPos, i);
      if (c2 < 2048) {
        lastPos = i + 1;
        out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
        continue;
      }
      if (c2 < 55296 || c2 >= 57344) {
        lastPos = i + 1;
        out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        continue;
      }
      ++i;
      if (i >= len) {
        throw new Error("URI malformed");
      }
      const c22 = str2.charCodeAt(i) & 1023;
      lastPos = i + 1;
      c2 = 65536 + ((c2 & 1023) << 10 | c22);
      out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
    }
  if (lastPos === 0)
    return str2;
  if (lastPos < len)
    return out + str2.slice(lastPos);
  return out;
}
var querystring = { encodeString: encodeString$1 };
const { encodeString } = querystring;
function getAsPrimitive(value) {
  const type2 = typeof value;
  if (type2 === "string") {
    return encodeString(value);
  } else if (type2 === "bigint") {
    return value.toString();
  } else if (type2 === "boolean") {
    return value ? "true" : "false";
  } else if (type2 === "number" && Number.isFinite(value)) {
    return value < 1e21 ? "" + value : encodeString("" + value);
  }
  return "";
}
function stringify$5(input) {
  let result = "";
  if (input === null || typeof input !== "object") {
    return result;
  }
  const separator = "&";
  const keys2 = Object.keys(input);
  const keyLength = keys2.length;
  let valueLength = 0;
  for (let i = 0; i < keyLength; i++) {
    const key2 = keys2[i];
    const value = input[key2];
    const encodedKey = encodeString(key2) + "=";
    if (i) {
      result += separator;
    }
    if (Array.isArray(value)) {
      valueLength = value.length;
      for (let j = 0; j < valueLength; j++) {
        if (j) {
          result += separator;
        }
        result += encodedKey;
        result += getAsPrimitive(value[j]);
      }
    } else {
      result += encodedKey;
      result += getAsPrimitive(value);
    }
  }
  return result;
}
var stringify_1 = stringify$5;
const parse$3 = parse_1;
const stringify$4 = stringify_1;
const fastQuerystring = {
  parse: parse$3,
  stringify: stringify$4
};
lib.exports = fastQuerystring;
lib.exports.default = fastQuerystring;
lib.exports.parse = parse$3;
lib.exports.stringify = stringify$4;
var libExports = lib.exports;
const qs = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
const ignoreTheseHeaders = [
  ":authority",
  ":method",
  ":path",
  ":scheme",
  ":status",
  "a-im",
  "accept-additions",
  "accept-ch-lifetime",
  "accept-ch",
  "accept-charset",
  "accept-datetime",
  "accept-encoding",
  "accept-features",
  "accept-language",
  "accept-patch",
  "accept-post",
  "accept-ranges",
  "accept",
  "access-control-allow-credentials",
  "access-control-allow-headers",
  "access-control-allow-methods",
  "access-control-allow-origin",
  "access-control-expose-headers",
  "access-control-max-age",
  "access-control-request-headers",
  "access-control-request-method",
  "age",
  "allow",
  "alpn",
  "alt-svc",
  "alternate-protocol",
  "alternates",
  "amp-access-control-allow-source-origin",
  "apply-to-redirect-ref",
  "authentication-info",
  "authorization",
  "c-ext",
  "c-man",
  "c-opt",
  "c-pep-info",
  "c-pep",
  "cache-control",
  "ch",
  "connection",
  "content-base",
  "content-disposition",
  "content-dpr",
  "content-encoding",
  "content-id",
  "content-language",
  "content-length",
  "content-location",
  "content-md5",
  "content-range",
  "content-script-type",
  "content-security-policy-report-only",
  "content-security-policy",
  "content-style-type",
  "content-type",
  "content-version",
  "cross-origin-resource-policy",
  "dasl",
  "date",
  "dav",
  "default-style",
  "delta-base",
  "depth",
  "derived-from",
  "destination",
  "differential-id",
  "digest",
  "dnt",
  "dpr",
  "encryption-key",
  "encryption",
  "etag",
  "expect-ct",
  "expect",
  "expires",
  "ext",
  "forwarded",
  "from",
  "front-end-https",
  "getprofile",
  "host",
  "http2-settings",
  "if-match",
  "if-modified-since",
  "if-none-match",
  "if-range",
  "if-schedule-tag-match",
  "if-unmodified-since",
  "if",
  "im",
  "keep-alive",
  "key",
  "label",
  "last-event-id",
  "last-modified",
  "link-template",
  "link",
  "location",
  "lock-token",
  "man",
  "max-forwards",
  "md",
  "meter",
  "mime-version",
  "negotiate",
  "nice",
  "opt",
  "ordering-type",
  "origin-trial",
  "origin",
  "overwrite",
  "p3p",
  "pep-info",
  "pep",
  "pics-label",
  "poe-links",
  "poe",
  "position",
  "pragma",
  "prefer",
  "preference-applied",
  "profileobject",
  "protocol-info",
  "protocol-query",
  "protocol-request",
  "protocol",
  "proxy-authenticate",
  "proxy-authentication-info",
  "proxy-authorization",
  "proxy-connection",
  "proxy-features",
  "proxy-instruction",
  "public",
  "range",
  "redirect-ref",
  "referer",
  "referrer-policy",
  "report-to",
  "retry-after",
  "rw",
  "safe",
  "save-data",
  "schedule-reply",
  "schedule-tag",
  "sec-ch-ua-mobile",
  "sec-ch-ua-platform",
  "sec-ch-ua",
  "sec-fetch-dest",
  "sec-fetch-mode",
  "sec-fetch-site",
  "sec-fetch-user",
  "sec-websocket-accept",
  "sec-websocket-extensions",
  "sec-websocket-key",
  "sec-websocket-protocol",
  "sec-websocket-version",
  "security-scheme",
  "server-timing",
  "server",
  "set-cookie",
  "set-cookie2",
  "setprofile",
  "slug",
  "soapaction",
  "status-uri",
  "strict-transport-security",
  "sunset",
  "surrogate-capability",
  "surrogate-control",
  "tcn",
  "te",
  "timeout",
  "timing-allow-origin",
  "tk",
  "trailer",
  "transfer-encoding",
  "upgrade-insecure-requests",
  "upgrade",
  "uri",
  "user-agent",
  "variant-vary",
  "vary",
  "via",
  "want-digest",
  "warning",
  "www-authenticate",
  "x-att-deviceid",
  "x-csrf-token",
  "x-forwarded-for",
  "x-forwarded-host",
  "x-forwarded-proto",
  "x-frame-options",
  "x-frontend",
  "x-http-method-override",
  "x-powered-by",
  "x-request-id",
  "x-requested-with",
  "x-uidh",
  "x-wap-profile",
  "x-xss-protection"
];
const headersToIgnore = new Set(ignoreTheseHeaders);
const filterIgnoreHeaders = (headers) => {
  return headers.filter(({ name: name2 }) => {
    return !headersToIgnore.has(name2.toLowerCase());
  });
};
const defaultAuthHeaders = [
  "access-key",
  "access-token",
  "api-key",
  "apikey",
  "auth-token",
  "authorization-token",
  "authorization",
  "cookie",
  "key",
  "secret",
  "token",
  "x-access-token",
  "x-api-key",
  "x-auth-token",
  "x-auth",
  "x-csrf-token",
  "x-secret"
];
const authHeaders = new Set(defaultAuthHeaders);
const isAuthHeader = (header) => {
  return authHeaders.has(header.toLowerCase());
};
var dist = {};
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = void 0;
  (function(ValueType) {
    ValueType["Null"] = "null";
    ValueType["Boolean"] = "boolean";
    ValueType["Integer"] = "integer";
    ValueType["Number"] = "number";
    ValueType["String"] = "string";
    ValueType["Object"] = "object";
    ValueType["Array"] = "array";
  })(exports.ValueType || (exports.ValueType = {}));
})(types);
var schemaBuilder = {};
Object.defineProperty(schemaBuilder, "__esModule", { value: true });
schemaBuilder.createCompoundSchema = schemaBuilder.extendSchema = schemaBuilder.mergeSchemas = schemaBuilder.createSchema = schemaBuilder.wrapAnyOfSchema = schemaBuilder.unwrapSchemas = schemaBuilder.unwrapSchema = void 0;
const types_1 = types;
function createSchemaFor(value, options2) {
  switch (typeof value) {
    case "number":
      if (Number.isInteger(value)) {
        return { type: types_1.ValueType.Integer };
      }
      return { type: types_1.ValueType.Number };
    case "boolean":
      return { type: types_1.ValueType.Boolean };
    case "string":
      return { type: types_1.ValueType.String };
    case "object":
      if (value === null) {
        return { type: types_1.ValueType.Null };
      }
      if (Array.isArray(value)) {
        return createSchemaForArray(value, options2);
      }
      return createSchemaForObject(value, options2);
  }
}
function createSchemaForArray(arr, options2) {
  if (arr.length === 0) {
    return { type: types_1.ValueType.Array };
  }
  const elementSchemas = arr.map((value) => createSchemaFor(value, options2));
  const items = combineSchemas(elementSchemas);
  return { type: types_1.ValueType.Array, items };
}
function createSchemaForObject(obj, options2) {
  const keys2 = Object.keys(obj);
  if (keys2.length === 0) {
    return {
      type: types_1.ValueType.Object
    };
  }
  const properties = Object.entries(obj).reduce((props, [key2, val]) => {
    props[key2] = createSchemaFor(val, options2);
    return props;
  }, {});
  const schema2 = { type: types_1.ValueType.Object, properties };
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.noRequired)) {
    schema2.required = keys2;
  }
  return schema2;
}
function combineSchemas(schemas2, options2) {
  const schemasByType = {
    [types_1.ValueType.Null]: [],
    [types_1.ValueType.Boolean]: [],
    [types_1.ValueType.Integer]: [],
    [types_1.ValueType.Number]: [],
    [types_1.ValueType.String]: [],
    [types_1.ValueType.Array]: [],
    [types_1.ValueType.Object]: []
  };
  const unwrappedSchemas = unwrapSchemas(schemas2);
  for (const unwrappedSchema of unwrappedSchemas) {
    const type2 = unwrappedSchema.type;
    if (schemasByType[type2].length === 0 || isContainerSchema(unwrappedSchema)) {
      schemasByType[type2].push(unwrappedSchema);
    } else {
      continue;
    }
  }
  const resultSchemasByType = {
    [types_1.ValueType.Null]: schemasByType[types_1.ValueType.Null][0],
    [types_1.ValueType.Boolean]: schemasByType[types_1.ValueType.Boolean][0],
    [types_1.ValueType.Number]: schemasByType[types_1.ValueType.Number][0],
    [types_1.ValueType.Integer]: schemasByType[types_1.ValueType.Integer][0],
    [types_1.ValueType.String]: schemasByType[types_1.ValueType.String][0],
    [types_1.ValueType.Array]: combineArraySchemas(schemasByType[types_1.ValueType.Array]),
    [types_1.ValueType.Object]: combineObjectSchemas(schemasByType[types_1.ValueType.Object], options2)
  };
  if (resultSchemasByType[types_1.ValueType.Number]) {
    delete resultSchemasByType[types_1.ValueType.Integer];
  }
  const schemasFound = Object.values(resultSchemasByType).filter(Boolean);
  const multiType = schemasFound.length > 1;
  if (multiType) {
    const wrapped = wrapAnyOfSchema({ anyOf: schemasFound });
    return wrapped;
  }
  return schemasFound[0];
}
function combineArraySchemas(schemas2) {
  if (!schemas2 || schemas2.length === 0) {
    return void 0;
  }
  const itemSchemas = [];
  for (const schema2 of schemas2) {
    if (!schema2.items)
      continue;
    const unwrappedSchemas = unwrapSchema(schema2.items);
    itemSchemas.push(...unwrappedSchemas);
  }
  if (itemSchemas.length === 0) {
    return {
      type: types_1.ValueType.Array
    };
  }
  const items = combineSchemas(itemSchemas);
  return {
    type: types_1.ValueType.Array,
    items
  };
}
function combineObjectSchemas(schemas2, options2) {
  if (!schemas2 || schemas2.length === 0) {
    return void 0;
  }
  const allPropSchemas = schemas2.map((s) => s.properties).filter(Boolean);
  const schemasByProp = /* @__PURE__ */ Object.create(null);
  for (const propSchemas of allPropSchemas) {
    for (const [prop, schema2] of Object.entries(propSchemas)) {
      if (!schemasByProp[prop]) {
        schemasByProp[prop] = [];
      }
      const unwrappedSchemas = unwrapSchema(schema2);
      schemasByProp[prop].push(...unwrappedSchemas);
    }
  }
  const properties = Object.entries(schemasByProp).reduce((props, [prop, schemas3]) => {
    if (schemas3.length === 1) {
      props[prop] = schemas3[0];
    } else {
      props[prop] = combineSchemas(schemas3);
    }
    return props;
  }, {});
  const combinedSchema = { type: types_1.ValueType.Object };
  if (Object.keys(properties).length > 0) {
    combinedSchema.properties = properties;
  }
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.noRequired)) {
    const required = intersection(schemas2.map((s) => s.required || []));
    if (required.length > 0) {
      combinedSchema.required = required;
    }
  }
  return combinedSchema;
}
function unwrapSchema(schema2) {
  if (!schema2)
    return [];
  if (schema2.anyOf) {
    return unwrapSchemas(schema2.anyOf);
  }
  if (Array.isArray(schema2.type)) {
    return schema2.type.map((x2) => ({ type: x2 }));
  }
  return [schema2];
}
schemaBuilder.unwrapSchema = unwrapSchema;
function unwrapSchemas(schemas2) {
  if (!schemas2 || schemas2.length === 0)
    return [];
  const unwrappedSchemas = schemas2.flatMap((schema2) => unwrapSchema(schema2));
  return unwrappedSchemas;
}
schemaBuilder.unwrapSchemas = unwrapSchemas;
function wrapAnyOfSchema(schema2) {
  const simpleSchemas = [];
  const complexSchemas = [];
  for (const subSchema of schema2.anyOf) {
    if (Array.isArray(subSchema.type)) {
      simpleSchemas.push(...subSchema.type);
    } else if (isSimpleSchema(subSchema)) {
      simpleSchemas.push(subSchema.type);
    } else {
      complexSchemas.push(subSchema);
    }
  }
  if (complexSchemas.length === 0) {
    return { type: simpleSchemas };
  }
  const anyOf = [];
  if (simpleSchemas.length > 0) {
    anyOf.push({ type: simpleSchemas.length > 1 ? simpleSchemas : simpleSchemas[0] });
  }
  anyOf.push(...complexSchemas);
  return { anyOf };
}
schemaBuilder.wrapAnyOfSchema = wrapAnyOfSchema;
function intersection(valuesArr) {
  if (valuesArr.length === 0)
    return [];
  const arrays = valuesArr.filter(Array.isArray);
  const counter2 = {};
  for (const arr of arrays) {
    for (const val of arr) {
      if (!counter2[val]) {
        counter2[val] = 1;
      } else {
        counter2[val]++;
      }
    }
  }
  const result = Object.entries(counter2).filter(([_2, value]) => value === arrays.length).map(([key2]) => key2);
  return result;
}
function isSimpleSchema(schema2) {
  const keys2 = Object.keys(schema2);
  return keys2.length === 1 && keys2[0] === "type";
}
function isContainerSchema(schema2) {
  const type2 = schema2.type;
  return type2 === types_1.ValueType.Array || type2 === types_1.ValueType.Object;
}
function createSchema(value, options2) {
  if (typeof value === "undefined")
    value = null;
  const clone = JSON.parse(JSON.stringify(value));
  return createSchemaFor(clone, options2);
}
schemaBuilder.createSchema = createSchema;
function mergeSchemas(schemas2, options2) {
  const mergedSchema = combineSchemas(schemas2, options2);
  return mergedSchema;
}
schemaBuilder.mergeSchemas = mergeSchemas;
function extendSchema(schema2, value, options2) {
  const valueSchema = createSchema(value, options2);
  const mergedSchema = combineSchemas([schema2, valueSchema], options2);
  return mergedSchema;
}
schemaBuilder.extendSchema = extendSchema;
function createCompoundSchema(values2, options2) {
  const schemas2 = values2.map((value) => createSchema(value, options2));
  return mergeSchemas(schemas2, options2);
}
schemaBuilder.createCompoundSchema = createCompoundSchema;
var schemaComparator = {};
Object.defineProperty(schemaComparator, "__esModule", { value: true });
schemaComparator.isSubset = schemaComparator.areSchemasEqual = void 0;
const schema_builder_1 = schemaBuilder;
function areSchemasEqual(schema1, schema2, options2) {
  if (schema1 === void 0 && schema2 === void 0)
    return true;
  if (schema1 === void 0 || schema2 === void 0)
    return false;
  const anyOf1 = schema_builder_1.unwrapSchema(schema1);
  const anyOf2 = schema_builder_1.unwrapSchema(schema2);
  if (anyOf1.length != anyOf2.length)
    return false;
  if (anyOf1.length === 0)
    return true;
  const typeComparator = (s1, s2) => s1.type.toLocaleString().localeCompare(s2.type.toLocaleString());
  const sorted1 = [...anyOf1].sort(typeComparator);
  const sorted2 = [...anyOf2].sort(typeComparator);
  for (let i = 0; i < anyOf1.length; i++) {
    const s1 = sorted1[i];
    const s2 = sorted2[i];
    if (s1.type !== s2.type)
      return false;
    if (!(options2 === null || options2 === void 0 ? void 0 : options2.ignoreRequired) && !areArraysEqual(s1.required, s2.required))
      return false;
    if (!arePropsEqual(s1.properties, s2.properties, options2))
      return false;
    if (!areSchemasEqual(s1.items, s2.items, options2))
      return false;
  }
  return true;
}
schemaComparator.areSchemasEqual = areSchemasEqual;
function areArraysEqual(arr1, arr2) {
  if (arr1 === void 0 && arr2 === void 0)
    return true;
  if (arr1 === void 0 || arr2 === void 0)
    return false;
  const set1 = new Set(arr1);
  const set22 = new Set(arr2);
  const combined = /* @__PURE__ */ new Set([...arr1, ...arr2]);
  const areEqual = combined.size === set1.size && combined.size === set22.size;
  return areEqual;
}
function arePropsEqual(props1, props2, options2) {
  if (props1 === void 0 && props2 === void 0)
    return true;
  if (props1 === void 0 || props2 === void 0)
    return false;
  const keys1 = Object.keys(props1);
  const keys2 = Object.keys(props2);
  if (!areArraysEqual(keys1, keys2))
    return false;
  for (const key2 of keys1) {
    if (!areSchemasEqual(props1[key2], props2[key2], options2))
      return false;
  }
  return true;
}
function isSubset(mainSchema, subSchema, options2) {
  const mergedSchema = schema_builder_1.mergeSchemas([mainSchema, subSchema]);
  const isModified = areSchemasEqual(mergedSchema, mainSchema, options2);
  return isModified;
}
schemaComparator.isSubset = isSubset;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCompoundSchema = exports.createSchema = exports.mergeSchemas = exports.extendSchema = void 0;
  __exportStar(types, exports);
  var schema_builder_12 = schemaBuilder;
  Object.defineProperty(exports, "extendSchema", { enumerable: true, get: function() {
    return schema_builder_12.extendSchema;
  } });
  Object.defineProperty(exports, "mergeSchemas", { enumerable: true, get: function() {
    return schema_builder_12.mergeSchemas;
  } });
  Object.defineProperty(exports, "createSchema", { enumerable: true, get: function() {
    return schema_builder_12.createSchema;
  } });
  Object.defineProperty(exports, "createCompoundSchema", { enumerable: true, get: function() {
    return schema_builder_12.createCompoundSchema;
  } });
  __exportStar(schemaComparator, exports);
})(dist);
const DEFAULT_PARAM_PREFIX = ":";
const DEFAULT_PARAM_NAME = `${DEFAULT_PARAM_PREFIX}param`;
const isGraphQLURI = (url) => url.toLowerCase().endsWith("graphql");
const isJSONFile = (url) => url.toLowerCase().endsWith(".json");
const isValidURL = (url) => {
  try {
    new URL(url);
    return true;
  } catch (e2) {
    return false;
  }
};
const isValidJSONString = (content) => {
  try {
    JSON.parse(content);
    return true;
  } catch (e2) {
    return false;
  }
};
const validStatuses = /* @__PURE__ */ new Set(["GET", "POST", "PUT", "DELETE", "PATCH"]);
const validResourceTypes = /* @__PURE__ */ new Set(["xhr", "fetch", "document"]);
const isValidStatus = (status) => validStatuses.has(status);
const isValidRequest = (harRequest, content) => {
  var _a4;
  const isNotAJAXRequest = !!harRequest._resourceType && !validResourceTypes.has(harRequest._resourceType);
  if (isNotAJAXRequest)
    return false;
  const didNotReachServer = !harRequest.serverIPAddress;
  if (didNotReachServer)
    return false;
  const isNotJSON = !harRequest.response.content.mimeType.startsWith("application/json") && !isValidJSONString(content);
  const isNotXWWWFormUrlEncoded = !((_a4 = harRequest.request.postData) == null ? void 0 : _a4.mimeType.startsWith(
    "application/x-www-form-urlencoded"
  ));
  const isNotValidMime = isNotJSON && isNotXWWWFormUrlEncoded;
  if (isNotValidMime)
    return false;
  const isNotValidStatus = !isValidStatus(harRequest.request.method);
  if (isNotValidStatus)
    return false;
  if (!isValidURL(harRequest.request.url))
    return false;
  if (isGraphQLURI(harRequest.request.url))
    return false;
  if (isJSONFile(harRequest.request.url))
    return false;
  return true;
};
const pathToArray = (pathname) => {
  return pathname.split("/").slice(1);
};
const arrayToPath = (parts) => `/${parts.join("/")}`;
const getParamName = (index2) => `${DEFAULT_PARAM_NAME}${index2}`;
const entriesToJSONType = (entries2) => {
  if (!entries2 || !entries2.length)
    return null;
  return entries2.reduce((acc, { name: name2, value }) => {
    acc[name2] = value;
    return acc;
  }, {});
};
const parseJSON = (json2) => {
  if (!json2)
    return null;
  try {
    return JSON.parse(json2 || "");
  } catch (e2) {
    return null;
  }
};
const createSchemaElseUndefined = (json2) => {
  if (!json2)
    return void 0;
  return dist.createSchema(json2);
};
const safelyGetURLHost = (url) => {
  try {
    const { host } = new URL(url);
    return host;
  } catch (e2) {
    return null;
  }
};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag2] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array2, setter, iteratee, accumulator) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        var value = array2[index2];
        setter(accumulator, value, iteratee(value), array2);
      }
      return accumulator;
    }
    function arrayEach(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEachRight(array2, iteratee) {
      var length2 = array2 == null ? 0 : array2.length;
      while (length2--) {
        if (iteratee(array2[length2], length2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEvery(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (!predicate(array2[index2], index2, array2)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array2, value) {
      var length2 = array2 == null ? 0 : array2.length;
      return !!length2 && baseIndexOf(array2, value, 0) > -1;
    }
    function arrayIncludesWith(array2, value, comparator) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (comparator(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    function arrayPush(array2, values2) {
      var index2 = -1, length2 = values2.length, offset2 = array2.length;
      while (++index2 < length2) {
        array2[offset2 + index2] = values2[index2];
      }
      return array2;
    }
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      if (initAccum && length2) {
        accumulator = array2[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
      var length2 = array2 == null ? 0 : array2.length;
      if (initAccum && length2) {
        accumulator = array2[--length2];
      }
      while (length2--) {
        accumulator = iteratee(accumulator, array2[length2], length2, array2);
      }
      return accumulator;
    }
    function arraySome(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string2) {
      return string2.split("");
    }
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2)) {
          result = key2;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length2 = array2.length;
      while (++index2 < length2) {
        if (comparator(array2[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array2, iteratee) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? baseSum(array2, iteratee) / length2 : NAN;
    }
    function baseProperty(key2) {
      return function(object2) {
        return object2 == null ? undefined$1 : object2[key2];
      };
    }
    function basePropertyOf(object2) {
      return function(key2) {
        return object2 == null ? undefined$1 : object2[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array2, comparer2) {
      var length2 = array2.length;
      array2.sort(comparer2);
      while (length2--) {
        array2[length2] = array2[length2].value;
      }
      return array2;
    }
    function baseSum(array2, iteratee) {
      var result, index2 = -1, length2 = array2.length;
      while (++index2 < length2) {
        var current = iteratee(array2[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object2, props) {
      return arrayMap(props, function(key2) {
        return [key2, object2[key2]];
      });
    }
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key2) {
        return object2[key2];
      });
    }
    function cacheHas(cache2, key2) {
      return cache2.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length2 = strSymbols.length;
      while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array2, placeholder) {
      var length2 = array2.length, result = 0;
      while (length2--) {
        if (array2[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object2, key2) {
      return object2 == null ? undefined$1 : object2[key2];
    }
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map3) {
      var index2 = -1, result = Array(map3.size);
      map3.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array2, placeholder) {
      var index2 = -1, length2 = array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set5) {
      var index2 = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set5) {
      var index2 = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array2.length;
      while (++index2 < length2) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string2) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter2 = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty3 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result2 = new object2();
          object2.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length2 = end2 - start2, index2 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
          return baseWrapperValue(array2, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length2-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array2[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed3 = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed3;
              } else if (!computed3) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key2) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key2];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key2) ? data[key2] : undefined$1;
      }
      function hashHas(key2) {
        var data = this.__data__;
        return nativeCreate ? data[key2] !== undefined$1 : hasOwnProperty2.call(data, key2);
      }
      function hashSet(key2, value) {
        var data = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key2) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key2) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key2);
        if (index2 < 0) {
          ++this.size;
          data.push([key2, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key2) {
        var result2 = getMapData(this, key2)["delete"](key2);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data = getMapData(this, key2), size3 = data.size;
        data.set(key2, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index2 = -1, length2 = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache();
        while (++index2 < length2) {
          this.add(values3[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries2) {
        var data = this.__data__ = new ListCache(entries2);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key2) {
        var data = this.__data__, result2 = data["delete"](key2);
        this.size = data.size;
        return result2;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs2 = data.__data__;
          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key2, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs2);
        }
        data.set(key2, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function arraySample(array2) {
        var length2 = array2.length;
        return length2 ? array2[baseRandom(0, length2 - 1)] : undefined$1;
      }
      function arraySampleSize(array2, n2) {
        return shuffleSelf(copyArray(array2), baseClamp(n2, 0, array2.length));
      }
      function arrayShuffle(array2) {
        return shuffleSelf(copyArray(array2));
      }
      function assignMergeValue(object2, key2, value) {
        if (value !== undefined$1 && !eq2(object2[key2], value) || value === undefined$1 && !(key2 in object2)) {
          baseAssignValue(object2, key2, value);
        }
      }
      function assignValue(object2, key2, value) {
        var objValue = object2[key2];
        if (!(hasOwnProperty2.call(object2, key2) && eq2(objValue, value)) || value === undefined$1 && !(key2 in object2)) {
          baseAssignValue(object2, key2, value);
        }
      }
      function assocIndexOf(array2, key2) {
        var length2 = array2.length;
        while (length2--) {
          if (eq2(array2[length2][0], key2)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys2(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      function baseAssignValue(object2, key2, value) {
        if (key2 == "__proto__" && defineProperty3) {
          defineProperty3(object2, key2, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key2] = value;
        }
      }
      function baseAt(object2, paths) {
        var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object2 == null;
        while (++index2 < length2) {
          result2[index2] = skip ? undefined$1 : get4(object2, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key2, object2, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object2 ? customizer(value, key2, object2, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object2) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key3) {
          if (props) {
            key3 = subValue;
            subValue = value[key3];
          }
          assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object2) {
          return baseConformsTo(object2, source, props);
        };
      }
      function baseConformsTo(object2, source, props) {
        var length2 = props.length;
        if (object2 == null) {
          return !length2;
        }
        object2 = Object2(object2);
        while (length2--) {
          var key2 = props[length2], predicate = source[key2], value = object2[key2];
          if (value === undefined$1 && !(key2 in object2) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array2, values3, iteratee2, comparator) {
        var index2 = -1, includes3 = arrayIncludes, isCommon = true, length2 = array2.length, result2 = [], valuesLength = values3.length;
        if (!length2) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator) {
          includes3 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes3 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index2 < length2) {
            var value = array2[index2], computed3 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed3 === computed3) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed3) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values3, computed3, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array2, iteratee2, comparator) {
        var index2 = -1, length2 = array2.length;
        while (++index2 < length2) {
          var value = array2[index2], current = iteratee2(value);
          if (current != null && (computed3 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed3))) {
            var computed3 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array2, value, start2, end2) {
        var length2 = array2.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 === undefined$1 || end2 > length2 ? length2 : toInteger(end2);
        if (end2 < 0) {
          end2 += length2;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array2[start2++] = value;
        }
        return array2;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array2, depth, predicate, isStrict, result2) {
        var index2 = -1, length2 = array2.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length2) {
          var value = array2[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object2, iteratee2) {
        return object2 && baseFor(object2, iteratee2, keys2);
      }
      function baseForOwnRight(object2, iteratee2) {
        return object2 && baseForRight(object2, iteratee2, keys2);
      }
      function baseFunctions(object2, props) {
        return arrayFilter(props, function(key2) {
          return isFunction2(object2[key2]);
        });
      }
      function baseGet(object2, path2) {
        path2 = castPath(path2, object2);
        var index2 = 0, length2 = path2.length;
        while (object2 != null && index2 < length2) {
          object2 = object2[toKey(path2[index2++])];
        }
        return index2 && index2 == length2 ? object2 : undefined$1;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object2);
        return isArray2(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag2;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object2, key2) {
        return object2 != null && hasOwnProperty2.call(object2, key2);
      }
      function baseHasIn(object2, key2) {
        return object2 != null && key2 in Object2(object2);
      }
      function baseInRange(number2, start2, end2) {
        return number2 >= nativeMin(start2, end2) && number2 < nativeMax(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array2 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array2 = arrayMap(array2, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array2.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
        }
        array2 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length2 && result2.length < maxLength) {
            var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed3) : includes3(result2, computed3, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed3) : includes3(arrays[othIndex], computed3, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed3);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object2, setter, iteratee2, accumulator) {
        baseForOwn(object2, function(value, key2, object3) {
          setter(accumulator, iteratee2(value), key2, object3);
        });
        return accumulator;
      }
      function baseInvoke(object2, path2, args) {
        path2 = castPath(path2, object2);
        object2 = parent(object2, path2);
        var func = object2 == null ? object2 : object2[toKey(last2(path2))];
        return func == null ? undefined$1 : apply(func, object2, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag;
      }
      function baseIsMatch(object2, source, matchData, customizer) {
        var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
        if (object2 == null) {
          return !length2;
        }
        object2 = Object2(object2);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index2 < length2) {
          data = matchData[index2];
          var key2 = data[0], objValue = object2[key2], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key2 in object2)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key2, object2, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag2(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result2 = [];
        for (var key2 in Object2(object2)) {
          if (hasOwnProperty2.call(object2, key2) && key2 != "constructor") {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseKeysIn(object2) {
        if (!isObject2(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result2 = [];
        for (var key2 in object2) {
          if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object2, key2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key2, collection2) {
          result2[++index2] = iteratee2(value, key2, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        if (isKey(path2) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path2), srcValue);
        }
        return function(object2) {
          var objValue = get4(object2, path2);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object2, source, srcIndex, customizer, stack) {
        if (object2 === source) {
          return;
        }
        baseFor(source, function(srcValue, key2) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep(object2, source, key2, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object2, key2), srcValue, key2 + "", object2, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object2, key2, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object2, source, key2, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object2, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object2, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object2, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object2, key2, newValue);
      }
      function baseNth(array2, n2) {
        var length2 = array2.length;
        if (!length2) {
          return;
        }
        n2 += n2 < 0 ? length2 : 0;
        return isIndex(n2, length2) ? array2[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object2, other) {
          return compareMultiple(object2, other, orders);
        });
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path2) {
          return hasIn(object2, path2);
        });
      }
      function basePickBy(object2, paths, predicate) {
        var index2 = -1, length2 = paths.length, result2 = {};
        while (++index2 < length2) {
          var path2 = paths[index2], value = baseGet(object2, path2);
          if (predicate(value, path2)) {
            baseSet(result2, castPath(path2, object2), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path2) {
        return function(object2) {
          return baseGet(object2, path2);
        };
      }
      function basePullAll(array2, values3, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values3.length, seen = array2;
        if (array2 === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen = arrayMap(array2, baseUnary(iteratee2));
        }
        while (++index2 < length2) {
          var fromIndex = 0, value = values3[index2], computed3 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed3, fromIndex, comparator)) > -1) {
            if (seen !== array2) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array2, fromIndex, 1);
          }
        }
        return array2;
      }
      function basePullAt(array2, indexes) {
        var length2 = array2 ? indexes.length : 0, lastIndex = length2 - 1;
        while (length2--) {
          var index2 = indexes[length2];
          if (length2 == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice2.call(array2, index2, 1);
            } else {
              baseUnset(array2, index2);
            }
          }
        }
        return array2;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length2);
        while (length2--) {
          result2[fromRight ? length2 : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string2, n2) {
        var result2 = "";
        if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string2;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string2 += string2;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n2) {
        var array2 = values2(collection);
        return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
      }
      function baseSet(object2, path2, value, customizer) {
        if (!isObject2(object2)) {
          return object2;
        }
        path2 = castPath(path2, object2);
        var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
        while (nested != null && ++index2 < length2) {
          var key2 = toKey(path2[index2]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
            return object2;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key2, newValue);
          nested = nested[key2];
        }
        return object2;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty3 ? identity : function(func, string2) {
        return defineProperty3(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice(array2, start2, end2) {
        var index2 = -1, length2 = array2.length;
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 > length2 ? length2 : end2;
        if (end2 < 0) {
          end2 += length2;
        }
        length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length2);
        while (++index2 < length2) {
          result2[index2] = array2[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array2, value, retHighest) {
        var low = 0, high = array2 == null ? low : array2.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed3 = array2[mid];
            if (computed3 !== null && !isSymbol2(computed3) && (retHighest ? computed3 <= value : computed3 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array2, value, identity, retHighest);
      }
      function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
        var low = 0, high = array2 == null ? 0 : array2.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed3 = iteratee2(array2[mid]), othIsDefined = computed3 !== undefined$1, othIsNull = computed3 === null, othIsReflexive = computed3 === computed3, othIsSymbol = isSymbol2(computed3);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed3 <= value : computed3 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array2, iteratee2) {
        var index2 = -1, length2 = array2.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq2(computed3, seen)) {
            var seen = computed3;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq(array2, iteratee2, comparator) {
        var index2 = -1, includes3 = arrayIncludes, length2 = array2.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes3 = arrayIncludesWith;
        } else if (length2 >= LARGE_ARRAY_SIZE) {
          var set6 = iteratee2 ? null : createSet2(array2);
          if (set6) {
            return setToArray(set6);
          }
          isCommon = false;
          includes3 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length2) {
            var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed3 === computed3) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed3) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed3);
              }
              result2.push(value);
            } else if (!includes3(seen, computed3, comparator)) {
              if (seen !== result2) {
                seen.push(computed3);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object2, path2) {
        path2 = castPath(path2, object2);
        object2 = parent(object2, path2);
        return object2 == null || delete object2[toKey(last2(path2))];
      }
      function baseUpdate(object2, path2, updater, customizer) {
        return baseSet(object2, path2, updater(baseGet(object2, path2)), customizer);
      }
      function baseWhile(array2, predicate, isDrop, fromRight) {
        var length2 = array2.length, index2 = fromRight ? length2 : -1;
        while ((fromRight ? index2-- : ++index2 < length2) && predicate(array2[index2], index2, array2)) {
        }
        return isDrop ? baseSlice(array2, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array2, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
      }
      function baseWrapperValue(value, actions2) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions2, function(result3, action2) {
          return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length2 = arrays.length;
        if (length2 < 2) {
          return length2 ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length2);
        while (++index2 < length2) {
          var array2 = arrays[index2], othIndex = -1;
          while (++othIndex < length2) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array2, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length2 = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length2) {
          var value = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object2) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array2, start2, end2) {
        var length2 = array2.length;
        end2 = end2 === undefined$1 ? length2 : end2;
        return !start2 && end2 >= length2 ? array2 : baseSlice(array2, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object2, other, orders) {
        var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length2) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order2 = orders[index2];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object2.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array2) {
        var index2 = -1, length2 = source.length;
        array2 || (array2 = Array2(length2));
        while (++index2 < length2) {
          array2[index2] = source[index2];
        }
        return array2;
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index2 = -1, length2 = props.length;
        while (++index2 < length2) {
          var key2 = props[index2];
          var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key2];
          }
          if (isNew) {
            baseAssignValue(object2, key2, newValue);
          } else {
            assignValue(object2, key2, newValue);
          }
        }
        return object2;
      }
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols(source), object2);
      }
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn(source), object2);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object2, sources) {
          var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard2 = length2 > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
          if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
            customizer = length2 < 3 ? undefined$1 : customizer;
            length2 = 1;
          }
          object2 = Object2(object2);
          while (++index2 < length2) {
            var source = sources[index2];
            if (source) {
              assigner(object2, source, index2, customizer);
            }
          }
          return object2;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length2) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object2, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object2), props = keysFunc(object2), length2 = props.length;
          while (length2--) {
            var key2 = props[fromRight ? length2 : ++index2];
            if (iteratee2(iterable[key2], key2, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var fn2 = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper2;
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper2() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper2);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length2 -= holders.length;
          if (length2 < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper2.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length2
            );
          }
          var fn2 = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper2;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
              var wrapper2 = new LodashWrapper([], true);
            }
          }
          index2 = wrapper2 ? index2 : length2;
          while (++index2 < length2) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
            } else {
              wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper2 && args.length == 1 && isArray2(value)) {
              return wrapper2.plant(value).value();
            }
            var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
            while (++index3 < length2) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper2() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length2 -= holdersCount;
          if (isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper2.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length2
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length2 = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length2 > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length2) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper2) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper2;
      }
      function createInverter(setter, toIteratee) {
        return function(object2, iteratee2) {
          return baseInverter(object2, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length2, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length2) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper2 ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper2;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet2 = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop4 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object2) {
          var tag = getTag2(object2);
          if (tag == mapTag) {
            return mapToArray(object2);
          }
          if (tag == setTag) {
            return setToPairs(object2);
          }
          return baseToPairs(object2, keysFunc(object2));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length2 = partials ? partials.length : 0;
        if (!length2) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length2 -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object2) {
        if (objValue === undefined$1 || eq2(objValue, objectProto[key2]) && !hasOwnProperty2.call(object2, key2)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object2, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index2 < arrLength) {
          var arrValue = array2[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag:
          case numberTag:
            return eq2(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result2 = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object2[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys2, getSymbols);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop4 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array2 = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
        while (length2--) {
          var data = array2[length2], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object2 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object2.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map4, key2) {
        var data = map4.__data__;
        return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object2) {
        var result2 = keys2(object2), length2 = result2.length;
        while (length2--) {
          var key2 = result2[length2], value = object2[key2];
          result2[length2] = [key2, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object2, key2) {
        var value = getValue(object2, key2);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object2(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result2 = [];
        while (object2) {
          arrayPush(result2, getSymbols(object2));
          object2 = getPrototype(object2);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms2) {
        var index2 = -1, length2 = transforms2.length;
        while (++index2 < length2) {
          var data = transforms2[index2], size3 = data.size;
          switch (data.type) {
            case "drop":
              start2 += size3;
              break;
            case "dropRight":
              end2 -= size3;
              break;
            case "take":
              end2 = nativeMin(end2, start2 + size3);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end2 - size3);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object2, path2, hasFunc) {
        path2 = castPath(path2, object2);
        var index2 = -1, length2 = path2.length, result2 = false;
        while (++index2 < length2) {
          var key2 = toKey(path2[index2]);
          if (!(result2 = object2 != null && hasFunc(object2, key2))) {
            break;
          }
          object2 = object2[key2];
        }
        if (result2 || ++index2 != length2) {
          return result2;
        }
        length2 = object2 == null ? 0 : object2.length;
        return !!length2 && isLength2(length2) && isIndex(key2, length2) && (isArray2(object2) || isArguments(object2));
      }
      function initCloneArray(array2) {
        var length2 = array2.length, result2 = new array2.constructor(length2);
        if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
          result2.index = array2.index;
          result2.input = array2.input;
        }
        return result2;
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
      }
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object2);
          case boolTag2:
          case dateTag:
            return new Ctor(+object2);
          case dataViewTag:
            return cloneDataView(object2, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object2, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object2);
          case regexpTag:
            return cloneRegExp(object2);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object2);
        }
      }
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2) {
          return source;
        }
        var lastIndex = length2 - 1;
        details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length2 > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length2) {
        var type2 = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
        return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall(value, index2, object2) {
        if (!isObject2(object2)) {
          return false;
        }
        var type2 = typeof index2;
        if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
          return eq2(object2[index2], value);
        }
        return false;
      }
      function isKey(value, object2) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key2, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object2));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize2(func, function(key2) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key2;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object2) {
        var result2 = [];
        if (object2 != null) {
          for (var key2 in Object2(object2)) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform3) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array2(length2);
          while (++index2 < length2) {
            array2[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform3(array2);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object2, path2) {
        return path2.length < 2 ? object2 : baseGet(object2, baseSlice(path2, 0, -1));
      }
      function reorder(array2, indexes) {
        var arrLength = array2.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
        while (length2--) {
          var index2 = indexes[length2];
          array2[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array2;
      }
      function safeGet(object2, key2) {
        if (key2 === "constructor" && typeof object2[key2] === "function") {
          return;
        }
        if (key2 == "__proto__") {
          return;
        }
        return object2[key2];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper2, reference2, bitmask) {
        var source = reference2 + "";
        return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count2 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count2 = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array2, size3) {
        var index2 = -1, length2 = array2.length, lastIndex = length2 - 1;
        size3 = size3 === undefined$1 ? length2 : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value = array2[rand];
          array2[rand] = array2[index2];
          array2[index2] = value;
        }
        array2.length = size3;
        return array2;
      }
      var stringToPath = memoizeCapped(function(string2) {
        var result2 = [];
        if (string2.charCodeAt(0) === 46) {
          result2.push("");
        }
        string2.replace(rePropName, function(match2, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper2) {
        if (wrapper2 instanceof LazyWrapper) {
          return wrapper2.clone();
        }
        var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
        result2.__actions__ = copyArray(wrapper2.__actions__);
        result2.__index__ = wrapper2.__index__;
        result2.__values__ = wrapper2.__values__;
        return result2;
      }
      function chunk(array2, size3, guard2) {
        if (guard2 ? isIterateeCall(array2, size3, guard2) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2 || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size3));
        while (index2 < length2) {
          result2[resIndex++] = baseSlice(array2, index2, index2 += size3);
        }
        return result2;
      }
      function compact(array2) {
        var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array2[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length2 = arguments.length;
        if (!length2) {
          return [];
        }
        var args = Array2(length2 - 1), array2 = arguments[0], index2 = length2;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array2, values3) {
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array2, values3) {
        var iteratee2 = last2(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array2, values3) {
        var comparator = last2(values3);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array2, n2, guard2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard2 || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array2, n2 < 0 ? 0 : n2, length2);
      }
      function dropRight(array2, n2, guard2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard2 || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length2 - n2;
        return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
      }
      function fill(array2, value, start2, end2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
          start2 = 0;
          end2 = length2;
        }
        return baseFill(array2, value, start2, end2);
      }
      function findIndex(array2, predicate, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length2 + index2, 0);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array2, predicate, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2 - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseFlatten(array2, 1) : [];
      }
      function flattenDeep(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseFlatten(array2, INFINITY2) : [];
      }
      function flattenDepth(array2, depth) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array2, depth);
      }
      function fromPairs(pairs2) {
        var index2 = -1, length2 = pairs2 == null ? 0 : pairs2.length, result2 = {};
        while (++index2 < length2) {
          var pair = pairs2[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array2) {
        return array2 && array2.length ? array2[0] : undefined$1;
      }
      function indexOf(array2, value, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length2 + index2, 0);
        }
        return baseIndexOf(array2, value, index2);
      }
      function initial(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseSlice(array2, 0, -1) : [];
      }
      var intersection2 = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array2, separator) {
        return array2 == null ? "" : nativeJoin.call(array2, separator);
      }
      function last2(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? array2[length2 - 1] : undefined$1;
      }
      function lastIndexOf(array2, value, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
        }
        return value === value ? strictLastIndexOf(array2, value, index2) : baseFindIndex(array2, baseIsNaN, index2, true);
      }
      function nth(array2, n2) {
        return array2 && array2.length ? baseNth(array2, toInteger(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array2, values3) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3) : array2;
      }
      function pullAllBy(array2, values3, iteratee2) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, getIteratee(iteratee2, 2)) : array2;
      }
      function pullAllWith(array2, values3, comparator) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, undefined$1, comparator) : array2;
      }
      var pullAt = flatRest(function(array2, indexes) {
        var length2 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
        basePullAt(array2, arrayMap(indexes, function(index2) {
          return isIndex(index2, length2) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove3(array2, predicate) {
        var result2 = [];
        if (!(array2 && array2.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length2 = array2.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length2) {
          var value = array2[index2];
          if (predicate(value, index2, array2)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array2, indexes);
        return result2;
      }
      function reverse2(array2) {
        return array2 == null ? array2 : nativeReverse.call(array2);
      }
      function slice2(array2, start2, end2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array2, start2, end2)) {
          start2 = 0;
          end2 = length2;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end2 = end2 === undefined$1 ? length2 : toInteger(end2);
        }
        return baseSlice(array2, start2, end2);
      }
      function sortedIndex(array2, value) {
        return baseSortedIndex(array2, value);
      }
      function sortedIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array2, value) {
        var length2 = array2 == null ? 0 : array2.length;
        if (length2) {
          var index2 = baseSortedIndex(array2, value);
          if (index2 < length2 && eq2(array2[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array2, value) {
        return baseSortedIndex(array2, value, true);
      }
      function sortedLastIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array2, value) {
        var length2 = array2 == null ? 0 : array2.length;
        if (length2) {
          var index2 = baseSortedIndex(array2, value, true) - 1;
          if (eq2(array2[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array2) {
        return array2 && array2.length ? baseSortedUniq(array2) : [];
      }
      function sortedUniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseSlice(array2, 1, length2) : [];
      }
      function take(array2, n2, guard2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        n2 = guard2 || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array2, n2, guard2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard2 || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length2 - n2;
        return baseSlice(array2, n2 < 0 ? 0 : n2, length2);
      }
      function takeRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array2) {
        return array2 && array2.length ? baseUniq(array2) : [];
      }
      function uniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array2, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
      }
      function unzip(array2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var length2 = 0;
        array2 = arrayFilter(array2, function(group) {
          if (isArrayLikeObject(group)) {
            length2 = nativeMax(group.length, length2);
            return true;
          }
        });
        return baseTimes(length2, function(index2) {
          return arrayMap(array2, baseProperty(index2));
        });
      }
      function unzipWith(array2, iteratee2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var result2 = unzip(array2);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array2, values3) {
        return isArrayLikeObject(array2) ? baseDifference(array2, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
          return baseAt(object2, paths);
        };
        if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length2 ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array2) {
          if (length2 && !array2.length) {
            array2.push(undefined$1);
          }
          return array2;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse2],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse2);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          ++result2[key2];
        } else {
          baseAssignValue(result2, key2, 1);
        }
      });
      function every(collection, predicate, guard2) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard2 && isIterateeCall(collection, predicate, guard2)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map3(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          result2[key2].push(value);
        } else {
          baseAssignValue(result2, key2, [value]);
        }
      });
      function includes2(collection, value, fromIndex, guard2) {
        collection = isArrayLike(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard2 ? toInteger(fromIndex) : 0;
        var length2 = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length2 + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path2, args) {
        var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key2) {
        baseAssignValue(result2, key2, value);
      });
      function map3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard2) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard2 ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate2(getIteratee(predicate, 3)));
      }
      function sample2(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard2) {
        if (guard2 ? isIterateeCall(collection, n2, guard2) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard2) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard2 && isIterateeCall(collection, predicate, guard2)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard2) {
        n2 = guard2 ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object2, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object2, partials, holders);
      });
      function curry2(func, arity, guard2) {
        arity = guard2 ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry2.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard2) {
        arity = guard2 ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key2)) {
            return cache2.get(key2);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key2, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache)();
        return memoized;
      }
      memoize2.Cache = MapCache;
      function negate2(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once3(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms2) {
        transforms2 = transforms2.length == 1 && isArray2(transforms2[0]) ? arrayMap(transforms2[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms2, 1), baseUnary(getIteratee()));
        var funcsLength = transforms2.length;
        return baseRest(function(args) {
          var index2 = -1, length2 = nativeMin(args.length, funcsLength);
          while (++index2 < length2) {
            args[index2] = transforms2[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array2) {
            arrayPush(otherArgs, array2);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options2) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options2)) {
          leading = "leading" in options2 ? !!options2.leading : leading;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper2) {
        return partial(castFunction(wrapper2), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object2, source) {
        return source == null || baseConformsTo(object2, source, keys2(source));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag2;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key2 in value) {
          if (hasOwnProperty2.call(value, key2)) {
            return false;
          }
        }
        return true;
      }
      function isEqual3(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object2, source) {
        return object2 === source || baseIsMatch(object2, source, getMatchData(source));
      }
      function isMatchWith(object2, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object2, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign2 = createAssigner(function(object2, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object2);
          return;
        }
        for (var key2 in source) {
          if (hasOwnProperty2.call(source, key2)) {
            assignValue(object2, key2, source[key2]);
          }
        }
      });
      var assignIn = createAssigner(function(object2, source) {
        copyObject(source, keysIn(source), object2);
      });
      var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object2, customizer);
      });
      var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object2, customizer);
      });
      var at2 = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object2, sources) {
        object2 = Object2(object2);
        var index2 = -1;
        var length2 = sources.length;
        var guard2 = length2 > 2 ? sources[2] : undefined$1;
        if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
          length2 = 1;
        }
        while (++index2 < length2) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key2 = props[propsIndex];
            var value = object2[key2];
            if (value === undefined$1 || eq2(value, objectProto[key2]) && !hasOwnProperty2.call(object2, key2)) {
              object2[key2] = source[key2];
            }
          }
        }
        return object2;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith2, undefined$1, args);
      });
      function findKey(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object2, iteratee2) {
        return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object2, iteratee2) {
        return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object2, iteratee2) {
        return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object2, iteratee2) {
        return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
      }
      function functions(object2) {
        return object2 == null ? [] : baseFunctions(object2, keys2(object2));
      }
      function functionsIn(object2) {
        return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
      }
      function get4(object2, path2, defaultValue) {
        var result2 = object2 == null ? undefined$1 : baseGet(object2, path2);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has3(object2, path2) {
        return object2 != null && hasPath(object2, path2, baseHas);
      }
      function hasIn(object2, path2) {
        return object2 != null && hasPath(object2, path2, baseHasIn);
      }
      var invert2 = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key2;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key2);
        } else {
          result2[value] = [key2];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      function mapKeys(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key2, object3) {
          baseAssignValue(result2, iteratee2(value, key2, object3), value);
        });
        return result2;
      }
      function mapValues(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key2, object3) {
          baseAssignValue(result2, key2, iteratee2(value, key2, object3));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object2, source, srcIndex) {
        baseMerge(object2, source, srcIndex);
      });
      var mergeWith2 = createAssigner(function(object2, source, srcIndex, customizer) {
        baseMerge(object2, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object2, paths) {
        var result2 = {};
        if (object2 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path2) {
          path2 = castPath(path2, object2);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject(object2, getAllKeysIn(object2), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length2 = paths.length;
        while (length2--) {
          baseUnset(result2, paths[length2]);
        }
        return result2;
      });
      function omitBy(object2, predicate) {
        return pickBy(object2, negate2(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      function pickBy(object2, predicate) {
        if (object2 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object2), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object2, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result(object2, path2, defaultValue) {
        path2 = castPath(path2, object2);
        var index2 = -1, length2 = path2.length;
        if (!length2) {
          length2 = 1;
          object2 = undefined$1;
        }
        while (++index2 < length2) {
          var value = object2 == null ? undefined$1 : object2[toKey(path2[index2])];
          if (value === undefined$1) {
            index2 = length2;
            value = defaultValue;
          }
          object2 = isFunction2(value) ? value.call(object2) : value;
        }
        return object2;
      }
      function set5(object2, path2, value) {
        return object2 == null ? object2 : baseSet(object2, path2, value);
      }
      function setWith(object2, path2, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object2 == null ? object2 : baseSet(object2, path2, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object2, iteratee2, accumulator) {
        var isArr = isArray2(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object2 && object2.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object2)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object2)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
          return iteratee2(accumulator, value, index2, object3);
        });
        return accumulator;
      }
      function unset(object2, path2) {
        return object2 == null ? true : baseUnset(object2, path2);
      }
      function update2(object2, path2, updater) {
        return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater));
      }
      function updateWith(object2, path2, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater), customizer);
      }
      function values2(object2) {
        return object2 == null ? [] : baseValues(object2, keys2(object2));
      }
      function valuesIn(object2) {
        return object2 == null ? [] : baseValues(object2, keysIn(object2));
      }
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number2), lower, upper);
      }
      function inRange(number2, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number2 = toNumber(number2);
        return baseInRange(number2, start2, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string2, target, position2) {
        string2 = toString2(string2);
        target = baseToString2(target);
        var length2 = string2.length;
        position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
        var end2 = position2;
        position2 -= target.length;
        return position2 >= 0 && string2.slice(position2, end2) == target;
      }
      function escape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      function escapeRegExp(string2) {
        string2 = toString2(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        if (!length2 || strLength >= length2) {
          return string2;
        }
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        return length2 && strLength < length2 ? string2 + createPadding(length2 - strLength, chars) : string2;
      }
      function padStart(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string2 : string2;
      }
      function parseInt2(string2, radix, guard2) {
        if (guard2 || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string2, n2, guard2) {
        if (guard2 ? isIterateeCall(string2, n2, guard2) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString2(string2), n2);
      }
      function replace3() {
        var args = arguments, string2 = toString2(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string2, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString2(string2);
        if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string2, target, position2) {
        string2 = toString2(string2);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string2.length);
        target = baseToString2(target);
        return string2.slice(position2, position2 + target.length) == target;
      }
      function template2(string2, options2, guard2) {
        var settings = lodash2.templateSettings;
        if (guard2 && isIterateeCall(string2, options2, guard2)) {
          options2 = undefined$1;
        }
        string2 = toString2(string2);
        options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate2 = options2.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options2.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string2, chars, guard2) {
        string2 = toString2(string2);
        if (string2 && (guard2 || chars === undefined$1)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string2, chars, guard2) {
        string2 = toString2(string2);
        if (string2 && (guard2 || chars === undefined$1)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string2, chars, guard2) {
        string2 = toString2(string2);
        if (string2 && (guard2 || chars === undefined$1)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string2, options2) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options2)) {
          var separator = "separator" in options2 ? options2.separator : separator;
          length2 = "length" in options2 ? toInteger(options2.length) : length2;
          omission = "omission" in options2 ? baseToString2(options2.omission) : omission;
        }
        string2 = toString2(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength) {
          return string2;
        }
        var end2 = length2 - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string2.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp(separator)) {
          if (string2.slice(end2).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string2.indexOf(baseToString2(separator), end2) != end2) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard2) {
        string2 = toString2(string2);
        pattern = guard2 ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object2, methodNames) {
        arrayEach(methodNames, function(key2) {
          key2 = toKey(key2);
          baseAssignValue(object2, key2, bind3(object2[key2], object2));
        });
        return object2;
      });
      function cond(pairs2) {
        var length2 = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
        pairs2 = !length2 ? [] : arrayMap(pairs2, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length2) {
            var pair = pairs2[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow3 = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path2, args) {
        return function(object2) {
          return baseInvoke(object2, path2, args);
        };
      });
      var methodOf = baseRest(function(object2, args) {
        return function(path2) {
          return baseInvoke(object2, path2, args);
        };
      });
      function mixin(object2, source, options2) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options2 = source;
          source = object2;
          object2 = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object2);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object2[methodName] = func;
          if (isFunc) {
            object2.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object2(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                actions2.push({ "func": func, "args": arguments, "thisArg": object2 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object2, arrayPush([this.value()], arguments));
            };
          }
        });
        return object2;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop4() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function propertyOf(object2) {
        return function(path2) {
          return object2 == null ? undefined$1 : baseGet(object2, path2);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length2, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix2) {
        var id2 = ++idCounter2;
        return toString2(prefix2) + id2;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined$1;
      }
      function maxBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array2) {
        return baseMean(array2, identity);
      }
      function meanBy(array2, iteratee2) {
        return baseMean(array2, getIteratee(iteratee2, 2));
      }
      function min2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined$1;
      }
      function minBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract3 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array2) {
        return array2 && array2.length ? baseSum(array2, identity) : 0;
      }
      function sumBy(array2, iteratee2) {
        return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry2;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow3;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection2;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert2;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map3;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith2;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate2;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once3;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove3;
      lodash2.rest = rest;
      lodash2.reverse = reverse2;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set5;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update2;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq2;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get4;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has3;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes2;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual3;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply2;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop4;
      lodash2.now = now2;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace3;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample2;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract3;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template2;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        if (typeof path2 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate2(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key2)) {
            realNames[key2] = [];
          }
          realNames[key2].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
var AuthType = /* @__PURE__ */ ((AuthType2) => {
  AuthType2["HTTP_HEADER_BEARER"] = "Bearer";
  AuthType2["HTTP_HEADER_BASIC"] = "Basic";
  AuthType2["HTTP_HEADER_DIGEST"] = "Digest";
  AuthType2["APIKEY_HEADER_"] = "APIKEY_HEADER_";
  AuthType2["APIKEY_COOKIE_"] = "APIKEY_COOKIE_";
  return AuthType2;
})(AuthType || {});
var PartType = /* @__PURE__ */ ((PartType2) => {
  PartType2[PartType2["Static"] = 0] = "Static";
  PartType2[PartType2["Dynamic"] = 1] = "Dynamic";
  return PartType2;
})(PartType || {});
var Status = /* @__PURE__ */ ((Status2) => {
  Status2[Status2["INIT"] = 0] = "INIT";
  Status2[Status2["RECORDING"] = 1] = "RECORDING";
  Status2[Status2["STOPPED"] = 2] = "STOPPED";
  return Status2;
})(Status || {});
const parseHTTPAuthHeader = (value) => {
  const authType = getAuthType(value);
  if (authType === "basic") {
    const basicAuth = {
      authType: AuthType.HTTP_HEADER_BASIC,
      type: "http",
      in: "header",
      scheme: "Basic",
      description: ""
    };
    return basicAuth;
  } else if (authType === "bearer") {
    const bearerAuth = {
      authType: AuthType.HTTP_HEADER_BEARER,
      type: "http",
      in: "header",
      scheme: "Bearer",
      description: ""
    };
    return bearerAuth;
  } else if (authType === "digest") {
    const digestAuth = {
      authType: AuthType.HTTP_HEADER_DIGEST,
      type: "http",
      in: "header",
      scheme: "Digest",
      description: ""
    };
    return digestAuth;
  }
};
var cookie = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie.parse = parse$2;
cookie.serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$2(str2, options2) {
  if (typeof str2 !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode;
  var index2 = 0;
  while (index2 < str2.length) {
    var eqIdx = str2.indexOf("=", index2);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str2.indexOf(";", index2);
    if (endIdx === -1) {
      endIdx = str2.length;
    } else if (endIdx < eqIdx) {
      index2 = str2.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str2.slice(index2, eqIdx).trim();
    if (void 0 === obj[key2]) {
      var val = str2.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index2 = endIdx + 1;
  }
  return obj;
}
function serialize(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str2 = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str2 += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str2 += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str2 += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate$1(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str2 += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str2 += "; HttpOnly";
  }
  if (opt.secure) {
    str2 += "; Secure";
  }
  if (opt.partitioned) {
    str2 += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str2 += "; Priority=Low";
        break;
      case "medium":
        str2 += "; Priority=Medium";
        break;
      case "high":
        str2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str2 += "; SameSite=Strict";
        break;
      case "lax":
        str2 += "; SameSite=Lax";
        break;
      case "strict":
        str2 += "; SameSite=Strict";
        break;
      case "none":
        str2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str2;
}
function decode(str2) {
  return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate$1(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str2, decode2) {
  try {
    return decode2(str2);
  } catch (e2) {
    return str2;
  }
}
const AUTHORIZATION = "AUTHORIZATION";
const COOKIE = "COOKIE";
const cookieSecurityNames = ["token", "session", "id", "jwt", "auth", "cookie", "key", "api"];
const parseAPIKeyAuthCookie = (cookieStr) => {
  const cookies = cookie.parse(cookieStr);
  const filteredSecurityNames = Object.keys(cookies).filter((cookieKey) => cookieSecurityNames.some((str2) => cookieKey.toLowerCase().includes(str2)));
  return filteredSecurityNames.map((cookieKey) => {
    const lowerName = cookieKey.toLowerCase();
    const upperName = cookieKey.toUpperCase();
    return {
      authType: AuthType.APIKEY_COOKIE_ + upperName,
      name: lowerName,
      type: "apiKey",
      in: "cookie",
      description: ""
    };
  });
};
const parseAuthHeaders = (headers) => {
  const visited = /* @__PURE__ */ new Set();
  let results = [];
  for (const header of headers) {
    const upperName = header.name.toUpperCase();
    const isAPIKey = isAuthHeader(upperName);
    const wasVisited = visited.has(upperName);
    if (upperName === AUTHORIZATION && !wasVisited) {
      const httpAuth = parseHTTPAuthHeader(header.value);
      if (httpAuth)
        results.push(httpAuth);
    }
    if (upperName === COOKIE && !wasVisited) {
      results = results.concat(parseAPIKeyAuthCookie(header.value));
    }
    if (isAPIKey && !wasVisited) {
      visited.add(upperName);
      const apiKey = {
        authType: AuthType.APIKEY_HEADER_ + upperName,
        name: upperName,
        type: "apiKey",
        in: "header",
        description: ""
      };
      results.push(apiKey);
    }
  }
  return results;
};
const getAuthType = (auth) => {
  const split = auth.split(" ");
  if (!split.length)
    return "";
  return split[0].toLowerCase();
};
const determineAuthFromHAR = (harRequest) => {
  const finalAuth = {};
  const authItems = parseAuthHeaders(harRequest.request.headers);
  authItems.forEach((auth) => {
    finalAuth[auth.authType] = auth;
  });
  if (lodashExports.isEmpty(finalAuth))
    return;
  return finalAuth;
};
const APPLICATION_JSON = "application/json";
const APPLICATION_X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded";
const parseRequestBody = (harRequest) => {
  const { mimeType, text } = harRequest.request.postData || {};
  if (mimeType == null ? void 0 : mimeType.startsWith(APPLICATION_JSON))
    return parseJSON(text);
  else if ((mimeType == null ? void 0 : mimeType.startsWith(APPLICATION_X_WWW_FORM_URLENCODED)) && text)
    return qs.parse(text);
  return null;
};
function createLeaf({ harRequest, responseBody, options: options2 }) {
  var _a4;
  const { enableMoreInfo } = options2;
  const authentication = determineAuthFromHAR(harRequest);
  harRequest.request.headers = filterIgnoreHeaders(harRequest.request.headers);
  harRequest.response.headers = filterIgnoreHeaders(
    harRequest.response.headers
  );
  const method = harRequest.request.method;
  const statusCode = harRequest.response.status.toString();
  const requestMime = (_a4 = harRequest.request.postData) == null ? void 0 : _a4.mimeType;
  const responseMime = harRequest.response.content.mimeType;
  const requestBody = parseRequestBody(harRequest);
  const requestHeaders = entriesToJSONType(harRequest.request.headers);
  const responseHeaders = entriesToJSONType(harRequest.response.headers);
  const queryParameters = entriesToJSONType(harRequest.request.queryString);
  const pathname = decodeUriComponent(new URL(harRequest.request.url).pathname);
  const leafPart = {
    ...authentication && { authentication },
    pathname,
    methods: {
      [method]: {
        ...requestMime && {
          request: {
            [requestMime]: {
              body: createSchemaElseUndefined(requestBody),
              ...enableMoreInfo && { mostRecent: requestBody }
            }
          }
        },
        requestHeaders: createSchemaElseUndefined(requestHeaders),
        response: {
          [statusCode]: {
            [responseMime]: {
              body: createSchemaElseUndefined(responseBody),
              ...enableMoreInfo && { mostRecent: responseBody }
            }
          }
        },
        responseHeaders: createSchemaElseUndefined(responseHeaders),
        queryParameters: createSchemaElseUndefined(queryParameters)
      }
    }
  };
  return leafPart;
}
function parameterise({
  store: store3,
  index: index2,
  path: path2,
  host
}) {
  const removedPaths = [];
  const matchedLeaves = [];
  const router = store3[host];
  if (!router)
    return null;
  const matchedRoute = router.lookup(path2);
  if (!matchedRoute)
    return null;
  const nextPath = getNextPath(index2, path2, matchedRoute);
  const foundPathnames = findPathnamesInRouter(router.ctx, nextPath);
  for (const found of foundPathnames) {
    matchedLeaves.push(found.leaf);
    removedPaths.push(found.pathname);
    remove2(router.ctx, found.pathname);
    pruneRouterWrapper(router.ctx.rootNode, pathToArray(found.pathname));
  }
  const mergedLeaf = matchedLeaves.reduce(mergeLeaves);
  mergedLeaf.pathname = nextPath;
  removedPaths.forEach((path22) => lodashExports.unset(store3[host].ctx.staticRoutesMap, path22));
  lodashExports.unset(store3[host].ctx.staticRoutesMap, nextPath);
  router.insert(nextPath, { data: mergedLeaf });
  return {
    removedPaths,
    insertedPath: nextPath,
    insertedLeaf: mergedLeaf
  };
}
const NODE_TYPES = {
  NORMAL: 0,
  WILDCARD: 1,
  PLACEHOLDER: 2
};
function createRouter(options2 = {}) {
  const ctx = {
    options: options2,
    rootNode: createRadixNode(),
    staticRoutesMap: {}
  };
  const normalizeTrailingSlash = (p2) => options2.strictTrailingSlash ? p2 : p2.replace(/\/$/, "") || "/";
  if (options2.routes) {
    for (const path2 in options2.routes) {
      insert(ctx, normalizeTrailingSlash(path2), options2.routes[path2]);
    }
  }
  return {
    ctx,
    // @ts-ignore
    lookup: (path2) => lookup(ctx, normalizeTrailingSlash(path2)),
    insert: (path2, data) => insert(ctx, normalizeTrailingSlash(path2), data),
    remove: (path2) => remove$1(ctx, normalizeTrailingSlash(path2))
  };
}
function lookup(ctx, path2) {
  const staticPathNode = ctx.staticRoutesMap[path2];
  if (staticPathNode) {
    return staticPathNode.data;
  }
  const sections = path2.split("/");
  const params = {};
  let paramsFound = false;
  let wildcardNode = null;
  let node2 = ctx.rootNode;
  let wildCardParam = null;
  for (let i = 0; i < sections.length; i++) {
    const section = sections[i];
    if (node2.wildcardChildNode !== null) {
      wildcardNode = node2.wildcardChildNode;
      wildCardParam = sections.slice(i).join("/");
    }
    const nextNode = node2.children.get(section);
    if (nextNode !== void 0) {
      node2 = nextNode;
    } else {
      node2 = node2.placeholderChildNode;
      if (node2 !== null) {
        params[node2.paramName] = section;
        paramsFound = true;
      } else {
        break;
      }
    }
  }
  if ((node2 === null || node2.data === null) && wildcardNode !== null) {
    node2 = wildcardNode;
    params[node2.paramName || "_"] = wildCardParam;
    paramsFound = true;
  }
  if (!node2) {
    return null;
  }
  if (paramsFound) {
    return {
      ...node2.data,
      params: paramsFound ? params : void 0
    };
  }
  return node2.data;
}
function insert(ctx, path2, data) {
  let isStaticRoute = true;
  const sections = path2.split("/");
  let node2 = ctx.rootNode;
  let _unnamedPlaceholderCtr = 0;
  for (const section of sections) {
    let childNode;
    if (childNode = node2.children.get(section)) {
      node2 = childNode;
    } else {
      const type2 = getNodeType(section);
      childNode = createRadixNode({ type: type2, parent: node2 });
      node2.children.set(section, childNode);
      if (type2 === NODE_TYPES.PLACEHOLDER) {
        childNode.paramName = section === "*" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);
        node2.placeholderChildNode = childNode;
        isStaticRoute = false;
      } else if (type2 === NODE_TYPES.WILDCARD) {
        node2.wildcardChildNode = childNode;
        childNode.paramName = section.slice(
          3
          /* "**:" */
        ) || "_";
        isStaticRoute = false;
      }
      node2 = childNode;
    }
  }
  node2.data = data;
  if (isStaticRoute === true) {
    ctx.staticRoutesMap[path2] = node2;
  }
  return node2;
}
function remove$1(ctx, path2) {
  let success = false;
  const sections = path2.split("/");
  let node2 = ctx.rootNode;
  for (const section of sections) {
    node2 = node2.children.get(section);
    if (!node2) {
      return success;
    }
  }
  if (node2.data) {
    const lastSection = sections[sections.length - 1];
    node2.data = null;
    if (Object.keys(node2.children).length === 0) {
      const parentNode = node2.parent;
      parentNode.children.delete(lastSection);
      parentNode.wildcardChildNode = null;
      parentNode.placeholderChildNode = null;
    }
    success = true;
  }
  return success;
}
function createRadixNode(options2 = {}) {
  return {
    type: options2.type || NODE_TYPES.NORMAL,
    parent: options2.parent || null,
    children: /* @__PURE__ */ new Map(),
    data: options2.data || null,
    paramName: options2.paramName || null,
    wildcardChildNode: null,
    placeholderChildNode: null
  };
}
function getNodeType(str2) {
  if (str2.startsWith("**")) {
    return NODE_TYPES.WILDCARD;
  }
  if (str2[0] === ":" || str2 === "*") {
    return NODE_TYPES.PLACEHOLDER;
  }
  return NODE_TYPES.NORMAL;
}
const leafMapToStore = (leafMap) => {
  const routerMap = {};
  Object.entries(leafMap).forEach(([host, routeData]) => {
    const router = createRouter({
      routes: routeData
    });
    routerMap[host] = router;
  });
  return routerMap;
};
const mergeAuthentication = (dest, src) => {
  if (!src.authentication)
    return;
  if (!dest.authentication)
    dest.authentication = {};
  Object.entries(src.authentication).forEach(([key2, value]) => {
    dest.authentication[key2] = value;
  });
};
const mergeRequest = (dest, src = {}) => {
  Object.entries(src).forEach(([mediaType, srcData]) => {
    var _a4;
    if (!srcData || !srcData.body)
      return;
    if ((_a4 = dest["request"]) == null ? void 0 : _a4[mediaType]) {
      dest["request"][mediaType] = srcData;
    } else {
      dest["request"][mediaType].body = dist.mergeSchemas([
        dest["request"][mediaType].body,
        srcData.body
      ]);
      dest["request"][mediaType].mostRecent = srcData.mostRecent;
    }
  });
};
const mergeResponse = (dest, src = {}) => {
  Object.entries(src).forEach(([statusCode, srcMediaTypeObj]) => {
    var _a4;
    if (!((_a4 = dest["response"]) == null ? void 0 : _a4[statusCode])) {
      dest["response"][statusCode] = srcMediaTypeObj;
      return;
    }
    Object.entries(srcMediaTypeObj).forEach(([mediaType, mediaTypeData]) => {
      var _a5, _b3;
      const srcData = srcMediaTypeObj[mediaType];
      if (!((_b3 = (_a5 = dest["response"]) == null ? void 0 : _a5[statusCode]) == null ? void 0 : _b3[mediaType])) {
        dest["response"][statusCode][mediaType] = srcData;
        return;
      } else {
        dest["response"][statusCode][mediaType].body = dist.mergeSchemas([
          dest["response"][statusCode][mediaType].body,
          srcData.body || {}
        ]);
        dest["response"][statusCode][mediaType].mostRecent = mediaTypeData.mostRecent;
      }
    });
  });
};
const mergeLeaves = (dest, src) => {
  mergeAuthentication(dest, src);
  for (const [method, methodObj] of Object.entries(src.methods)) {
    if (!dest.methods[method]) {
      dest.methods[method] = methodObj;
      continue;
    }
    const srcSchema = src.methods[method];
    const destSchema = dest.methods[method];
    if (destSchema.request || srcSchema.request) {
      mergeRequest(destSchema, srcSchema.request);
    }
    if (destSchema.queryParameters || srcSchema.queryParameters) {
      const schemas2 = [
        destSchema.queryParameters,
        srcSchema.queryParameters
      ].filter(Boolean);
      destSchema.queryParameters = dist.mergeSchemas(schemas2);
    }
    if (destSchema.requestHeaders || srcSchema.requestHeaders) {
      const schemas2 = [
        destSchema.requestHeaders,
        srcSchema.requestHeaders
      ].filter(Boolean);
      destSchema.requestHeaders = dist.mergeSchemas(schemas2);
    }
    if (destSchema.responseHeaders || srcSchema.responseHeaders) {
      const schemas2 = [
        destSchema.responseHeaders,
        srcSchema.responseHeaders
      ].filter(Boolean);
      destSchema.responseHeaders = dist.mergeSchemas(schemas2);
    }
    mergeResponse(destSchema, methodObj.response);
  }
  return dest;
};
function upsert({
  harRequest,
  responseBody,
  store: store3,
  options: options2
}) {
  const url = new URL(harRequest.request.url);
  const { host } = url;
  const pathname = decodeUriComponent(url.pathname);
  const parts = pathToArray(pathname);
  if (parts.length === 0)
    return null;
  if (!store3[host]) {
    store3[host] = createRouter();
  }
  const insertLeaf = createLeaf({ harRequest, responseBody, options: options2 });
  const router = store3[host];
  const matchedRoute = router.lookup(pathname);
  const nextLeaf = matchedRoute ? mergeLeaves(matchedRoute.data, insertLeaf) : insertLeaf;
  const parameterisedPath = (matchedRoute == null ? void 0 : matchedRoute.data.pathname) || pathname;
  nextLeaf.pathname = parameterisedPath;
  router.insert(parameterisedPath, { data: nextLeaf });
  return {
    insertedPath: parameterisedPath,
    insertedLeaf: nextLeaf,
    insertedHost: host
  };
}
const paramRe = /:param(\d+)/;
const paramReExact = /^:param(\d+)$/;
const isParameter = (path2) => {
  return paramReExact.test(path2);
};
const getParameterisedPath = (path2, matchedRoute) => {
  if (!(matchedRoute == null ? void 0 : matchedRoute.params))
    return path2;
  const nextPath = pathToArray(path2);
  const paramNames = Object.keys(matchedRoute.params);
  for (const paramName of paramNames) {
    const position2 = Number(paramName.replace(paramRe, "$1"));
    nextPath[position2] = `:${paramName}`;
  }
  return arrayToPath(nextPath);
};
const getNextPath = (index2, path2, matchedRoute) => {
  const pathParamaterised = getParameterisedPath(path2, matchedRoute);
  const nextPathArr = pathToArray(pathParamaterised);
  nextPathArr[index2] = getParamName(index2);
  const nextPath = arrayToPath(nextPathArr);
  return nextPath;
};
const insertLeafMap = ({
  leafMap,
  leaf,
  host,
  path: path2
}) => {
  if (!leafMap[host])
    leafMap[host] = {};
  leafMap[host][path2] = { data: leaf };
};
const getPartType = (part) => {
  const re2 = /^:param\d+$/;
  return re2.test(part) ? PartType.Dynamic : PartType.Static;
};
const pathToParts = (path2) => {
  return pathToArray(path2).map((part) => ({
    part,
    type: getPartType(part)
  }));
};
const formatPathname = (parts) => `/${parts.join("/").slice(1)}`;
const recurse = (node2, parts, walked = []) => {
  const pathnames = [];
  if (!parts.length || !node2.children.size)
    return pathnames;
  const isLast = parts.length === 1;
  const part = parts[0];
  const matchAny = isParameter(part);
  if (isLast) {
    for (const [lastPart, child] of node2.children.entries()) {
      if (child.data) {
        const value = {
          pathname: formatPathname([...walked, lastPart]),
          leaf: child.data.data
        };
        pathnames.push(value);
      }
    }
  } else if (matchAny) {
    for (const [part2, child] of node2.children.entries()) {
      pathnames.push(...recurse(child, parts.slice(1), [...walked, part2]));
    }
  } else if (node2.children.has(part)) {
    const child = node2.children.get(part);
    pathnames.push(...recurse(child, parts.slice(1), [...walked, part]));
  }
  return pathnames;
};
const findPathnamesInRouter = (routerCtx, path2) => {
  return recurse(routerCtx.rootNode, path2.split("/"));
};
const pruneRouter = (node2, parts) => {
  var _a4, _b3;
  if (!parts.length || !node2.children.size)
    return;
  const isLast = parts.length === 1;
  const part = parts[0];
  const matchAny = isParameter(part);
  if (!matchAny && !node2.children.has(part))
    return;
  if (!isLast) {
    if (matchAny) {
      for (const child of node2.children.values()) {
        pruneRouter(child, parts.slice(1));
      }
    } else if (node2.children.has(part)) {
      const child = node2.children.get(part);
      if (child) {
        pruneRouter(child, parts.slice(1));
      }
    }
  }
  const noChildren = ((_a4 = node2.children.get(part)) == null ? void 0 : _a4.children.size) === 0;
  const noData = !((_b3 = node2.children.get(part)) == null ? void 0 : _b3.data);
  if (noChildren && noData) {
    node2.children.delete(part);
  }
};
const pruneRouterWrapper = (node2, parts) => {
  pruneRouter(node2, ["", ...parts]);
};
var store2$1 = { exports: {} };
/*! store2 - v2.14.2 - 2022-07-18
* Copyright (c) 2022 Nathan Bubna; Licensed (MIT OR GPL-3.0) */
(function(module) {
  (function(window2, define) {
    var _2 = {
      version: "2.14.2",
      areas: {},
      apis: {},
      nsdelim: ".",
      // utilities
      inherit: function(api, o) {
        for (var p2 in api) {
          if (!o.hasOwnProperty(p2)) {
            Object.defineProperty(o, p2, Object.getOwnPropertyDescriptor(api, p2));
          }
        }
        return o;
      },
      stringify: function(d2, fn2) {
        return d2 === void 0 || typeof d2 === "function" ? d2 + "" : JSON.stringify(d2, fn2 || _2.replace);
      },
      parse: function(s, fn2) {
        try {
          return JSON.parse(s, fn2 || _2.revive);
        } catch (e2) {
          return s;
        }
      },
      // extension hooks
      fn: function(name2, fn2) {
        _2.storeAPI[name2] = fn2;
        for (var api in _2.apis) {
          _2.apis[api][name2] = fn2;
        }
      },
      get: function(area, key2) {
        return area.getItem(key2);
      },
      set: function(area, key2, string2) {
        area.setItem(key2, string2);
      },
      remove: function(area, key2) {
        area.removeItem(key2);
      },
      key: function(area, i) {
        return area.key(i);
      },
      length: function(area) {
        return area.length;
      },
      clear: function(area) {
        area.clear();
      },
      // core functions
      Store: function(id2, area, namespace2) {
        var store4 = _2.inherit(_2.storeAPI, function(key2, data, overwrite) {
          if (arguments.length === 0) {
            return store4.getAll();
          }
          if (typeof data === "function") {
            return store4.transact(key2, data, overwrite);
          }
          if (data !== void 0) {
            return store4.set(key2, data, overwrite);
          }
          if (typeof key2 === "string" || typeof key2 === "number") {
            return store4.get(key2);
          }
          if (typeof key2 === "function") {
            return store4.each(key2);
          }
          if (!key2) {
            return store4.clear();
          }
          return store4.setAll(key2, data);
        });
        store4._id = id2;
        try {
          var testKey = "__store2_test";
          area.setItem(testKey, "ok");
          store4._area = area;
          area.removeItem(testKey);
        } catch (e2) {
          store4._area = _2.storage("fake");
        }
        store4._ns = namespace2 || "";
        if (!_2.areas[id2]) {
          _2.areas[id2] = store4._area;
        }
        if (!_2.apis[store4._ns + store4._id]) {
          _2.apis[store4._ns + store4._id] = store4;
        }
        return store4;
      },
      storeAPI: {
        // admin functions
        area: function(id2, area) {
          var store4 = this[id2];
          if (!store4 || !store4.area) {
            store4 = _2.Store(id2, area, this._ns);
            if (!this[id2]) {
              this[id2] = store4;
            }
          }
          return store4;
        },
        namespace: function(namespace2, singleArea, delim) {
          delim = delim || this._delim || _2.nsdelim;
          if (!namespace2) {
            return this._ns ? this._ns.substring(0, this._ns.length - delim.length) : "";
          }
          var ns = namespace2, store4 = this[ns];
          if (!store4 || !store4.namespace) {
            store4 = _2.Store(this._id, this._area, this._ns + ns + delim);
            store4._delim = delim;
            if (!this[ns]) {
              this[ns] = store4;
            }
            if (!singleArea) {
              for (var name2 in _2.areas) {
                store4.area(name2, _2.areas[name2]);
              }
            }
          }
          return store4;
        },
        isFake: function(force) {
          if (force) {
            this._real = this._area;
            this._area = _2.storage("fake");
          } else if (force === false) {
            this._area = this._real || this._area;
          }
          return this._area.name === "fake";
        },
        toString: function() {
          return "store" + (this._ns ? "." + this.namespace() : "") + "[" + this._id + "]";
        },
        // storage functions
        has: function(key2) {
          if (this._area.has) {
            return this._area.has(this._in(key2));
          }
          return !!(this._in(key2) in this._area);
        },
        size: function() {
          return this.keys().length;
        },
        each: function(fn2, fill) {
          for (var i = 0, m2 = _2.length(this._area); i < m2; i++) {
            var key2 = this._out(_2.key(this._area, i));
            if (key2 !== void 0) {
              if (fn2.call(this, key2, this.get(key2), fill) === false) {
                break;
              }
            }
            if (m2 > _2.length(this._area)) {
              m2--;
              i--;
            }
          }
          return fill || this;
        },
        keys: function(fillList) {
          return this.each(function(k2, v2, list2) {
            list2.push(k2);
          }, fillList || []);
        },
        get: function(key2, alt) {
          var s = _2.get(this._area, this._in(key2)), fn2;
          if (typeof alt === "function") {
            fn2 = alt;
            alt = null;
          }
          return s !== null ? _2.parse(s, fn2) : alt != null ? alt : s;
        },
        getAll: function(fillObj) {
          return this.each(function(k2, v2, all) {
            all[k2] = v2;
          }, fillObj || {});
        },
        transact: function(key2, fn2, alt) {
          var val = this.get(key2, alt), ret = fn2(val);
          this.set(key2, ret === void 0 ? val : ret);
          return this;
        },
        set: function(key2, data, overwrite) {
          var d2 = this.get(key2), replacer;
          if (d2 != null && overwrite === false) {
            return data;
          }
          if (typeof overwrite === "function") {
            replacer = overwrite;
            overwrite = void 0;
          }
          return _2.set(this._area, this._in(key2), _2.stringify(data, replacer), overwrite) || d2;
        },
        setAll: function(data, overwrite) {
          var changed, val;
          for (var key2 in data) {
            val = data[key2];
            if (this.set(key2, val, overwrite) !== val) {
              changed = true;
            }
          }
          return changed;
        },
        add: function(key2, data, replacer) {
          var d2 = this.get(key2);
          if (d2 instanceof Array) {
            data = d2.concat(data);
          } else if (d2 !== null) {
            var type2 = typeof d2;
            if (type2 === typeof data && type2 === "object") {
              for (var k2 in data) {
                d2[k2] = data[k2];
              }
              data = d2;
            } else {
              data = d2 + data;
            }
          }
          _2.set(this._area, this._in(key2), _2.stringify(data, replacer));
          return data;
        },
        remove: function(key2, alt) {
          var d2 = this.get(key2, alt);
          _2.remove(this._area, this._in(key2));
          return d2;
        },
        clear: function() {
          if (!this._ns) {
            _2.clear(this._area);
          } else {
            this.each(function(k2) {
              _2.remove(this._area, this._in(k2));
            }, 1);
          }
          return this;
        },
        clearAll: function() {
          var area = this._area;
          for (var id2 in _2.areas) {
            if (_2.areas.hasOwnProperty(id2)) {
              this._area = _2.areas[id2];
              this.clear();
            }
          }
          this._area = area;
          return this;
        },
        // internal use functions
        _in: function(k2) {
          if (typeof k2 !== "string") {
            k2 = _2.stringify(k2);
          }
          return this._ns ? this._ns + k2 : k2;
        },
        _out: function(k2) {
          return this._ns ? k2 && k2.indexOf(this._ns) === 0 ? k2.substring(this._ns.length) : void 0 : (
            // so each() knows to skip it
            k2
          );
        }
      },
      // end _.storeAPI
      storage: function(name2) {
        return _2.inherit(_2.storageAPI, { items: {}, name: name2 });
      },
      storageAPI: {
        length: 0,
        has: function(k2) {
          return this.items.hasOwnProperty(k2);
        },
        key: function(i) {
          var c2 = 0;
          for (var k2 in this.items) {
            if (this.has(k2) && i === c2++) {
              return k2;
            }
          }
        },
        setItem: function(k2, v2) {
          if (!this.has(k2)) {
            this.length++;
          }
          this.items[k2] = v2;
        },
        removeItem: function(k2) {
          if (this.has(k2)) {
            delete this.items[k2];
            this.length--;
          }
        },
        getItem: function(k2) {
          return this.has(k2) ? this.items[k2] : null;
        },
        clear: function() {
          for (var k2 in this.items) {
            this.removeItem(k2);
          }
        }
      }
      // end _.storageAPI
    };
    var store3 = (
      // safely set this up (throws error in IE10/32bit mode for local files)
      _2.Store("local", function() {
        try {
          return localStorage;
        } catch (e2) {
        }
      }())
    );
    store3.local = store3;
    store3._ = _2;
    store3.area("session", function() {
      try {
        return sessionStorage;
      } catch (e2) {
      }
    }());
    store3.area("page", _2.storage("page"));
    if (typeof define === "function" && define.amd !== void 0) {
      define("store2", [], function() {
        return store3;
      });
    } else if (module.exports) {
      module.exports = store3;
    } else {
      if (window2.store) {
        _2.conflict = window2.store;
      }
      window2.store = store3;
    }
  })(commonjsGlobal, commonjsGlobal && commonjsGlobal.define);
})(store2$1);
var store2Exports = store2$1.exports;
const store2 = /* @__PURE__ */ getDefaultExportFromCjs(store2Exports);
const namespace = "openapi-devtools-options";
const key$1 = "options";
const store = store2.namespace(namespace);
const defaultOptions = {
  enableMoreInfo: false
};
const get$1 = () => {
  const options2 = store.get(key$1);
  if (options2)
    return options2;
  store.set(key$1, defaultOptions);
  return defaultOptions;
};
const set$1 = (value) => {
  const options2 = get$1();
  const newOptions = { ...options2, ...value };
  store.set(key$1, newOptions);
};
const clear2 = () => {
  store.clear();
};
const persistOptions = {
  get: get$1,
  set: set$1,
  clear: clear2
};
function remove2(ctx, path2) {
  let success = false;
  const sections = path2.split("/");
  let node2 = ctx.rootNode;
  for (const section of sections) {
    node2 = node2.children.get(section);
    if (!node2) {
      return success;
    }
  }
  if (node2.data) {
    const lastSection = sections[-1];
    node2.data = null;
    if (node2.children.size === 0) {
      const parentNode = node2.parent;
      parentNode.children.delete(lastSection);
      parentNode.wildcardChildNode = null;
      parentNode.placeholderChildNode = null;
    }
    success = true;
  }
  return success;
}
var validator$1 = { exports: {} };
var toDate = { exports: {} };
var assertString = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString2;
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function assertString2(input) {
    var isString2 = typeof input === "string" || input instanceof String;
    if (!isString2) {
      var invalidType = _typeof2(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(assertString, assertString.exports);
var assertStringExports = assertString.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toDate2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toDate2(date) {
    (0, _assertString2.default)(date);
    date = Date.parse(date);
    return !isNaN(date) ? new Date(date) : null;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toDate, toDate.exports);
var toDateExports = toDate.exports;
var toFloat = { exports: {} };
var isFloat$1 = {};
var alpha$1 = {};
Object.defineProperty(alpha$1, "__esModule", {
  value: true
});
alpha$1.commaDecimal = alpha$1.dotDecimal = alpha$1.bengaliLocales = alpha$1.farsiLocales = alpha$1.arabicLocales = alpha$1.englishLocales = alpha$1.decimal = alpha$1.alphanumeric = alpha$1.alpha = void 0;
var alpha = {
  "en-US": /^[A-Z]+$/i,
  "az-AZ": /^[A-VXYZ]+$/i,
  "bg-BG": /^[-]+$/i,
  "cs-CZ": /^[A-Z]+$/i,
  "da-DK": /^[A-Z]+$/i,
  "de-DE": /^[A-Z]+$/i,
  "el-GR": /^[-]+$/i,
  "es-ES": /^[A-Z]+$/i,
  "fa-IR": /^[]+$/i,
  "fi-FI": /^[A-Z]+$/i,
  "fr-FR": /^[A-Z]+$/i,
  "it-IT": /^[A-Z]+$/i,
  "ja-JP": /^[----]+$/i,
  "nb-NO": /^[A-Z]+$/i,
  "nl-NL": /^[A-Z]+$/i,
  "nn-NO": /^[A-Z]+$/i,
  "hu-HU": /^[A-Z]+$/i,
  "pl-PL": /^[A-Z]+$/i,
  "pt-PT": /^[A-Z]+$/i,
  "ru-RU": /^[-]+$/i,
  "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[A-Z]+$/i,
  "sk-SK": /^[A-Z]+$/i,
  "sr-RS@latin": /^[A-Z]+$/i,
  "sr-RS": /^[-]+$/i,
  "sv-SE": /^[A-Z]+$/i,
  "th-TH": /^[-\s]+$/i,
  "tr-TR": /^[A-Z]+$/i,
  "uk-UA": /^[-I]+$/i,
  "vi-VN": /^[A-Z]+$/i,
  "ko-KR": /^[---]*$/,
  "ku-IQ": /^[]+$/i,
  ar: /^[]+$/,
  he: /^[-]+$/,
  fa: /^['']+$/i,
  bn: /^['']+$/,
  "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
  "si-LK": /^[\u0D80-\u0DFF]+$/
};
alpha$1.alpha = alpha;
var alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZ]+$/i,
  "bg-BG": /^[0-9-]+$/i,
  "cs-CZ": /^[0-9A-Z]+$/i,
  "da-DK": /^[0-9A-Z]+$/i,
  "de-DE": /^[0-9A-Z]+$/i,
  "el-GR": /^[0-9-]+$/i,
  "es-ES": /^[0-9A-Z]+$/i,
  "fi-FI": /^[0-9A-Z]+$/i,
  "fr-FR": /^[0-9A-Z]+$/i,
  "it-IT": /^[0-9A-Z]+$/i,
  "ja-JP": /^[0-9-----]+$/i,
  "hu-HU": /^[0-9A-Z]+$/i,
  "nb-NO": /^[0-9A-Z]+$/i,
  "nl-NL": /^[0-9A-Z]+$/i,
  "nn-NO": /^[0-9A-Z]+$/i,
  "pl-PL": /^[0-9A-Z]+$/i,
  "pt-PT": /^[0-9A-Z]+$/i,
  "ru-RU": /^[0-9-]+$/i,
  "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[0-9A-Z]+$/i,
  "sk-SK": /^[0-9A-Z]+$/i,
  "sr-RS@latin": /^[0-9A-Z]+$/i,
  "sr-RS": /^[0-9-]+$/i,
  "sv-SE": /^[0-9A-Z]+$/i,
  "th-TH": /^[-\s]+$/i,
  "tr-TR": /^[0-9A-Z]+$/i,
  "uk-UA": /^[0-9-I]+$/i,
  "ko-KR": /^[0-9---]*$/,
  "ku-IQ": /^[0-9]+$/i,
  "vi-VN": /^[0-9A-Z]+$/i,
  ar: /^[0-9]+$/,
  he: /^[0-9-]+$/,
  fa: /^['0-9']+$/i,
  bn: /^['']+$/,
  "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
  "si-LK": /^[0-9\u0D80-\u0DFF]+$/
};
alpha$1.alphanumeric = alphanumeric;
var decimal = {
  "en-US": ".",
  ar: ""
};
alpha$1.decimal = decimal;
var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
alpha$1.englishLocales = englishLocales;
for (var locale, i$1 = 0; i$1 < englishLocales.length; i$1++) {
  locale = "en-".concat(englishLocales[i$1]);
  alpha[locale] = alpha["en-US"];
  alphanumeric[locale] = alphanumeric["en-US"];
  decimal[locale] = decimal["en-US"];
}
var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
alpha$1.arabicLocales = arabicLocales;
for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
}
var farsiLocales = ["IR", "AF"];
alpha$1.farsiLocales = farsiLocales;
for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
  _locale2 = "fa-".concat(farsiLocales[_i2]);
  alphanumeric[_locale2] = alphanumeric.fa;
  decimal[_locale2] = decimal.ar;
}
var bengaliLocales = ["BD", "IN"];
alpha$1.bengaliLocales = bengaliLocales;
for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
  _locale3 = "bn-".concat(bengaliLocales[_i3]);
  alpha[_locale3] = alpha.bn;
  alphanumeric[_locale3] = alphanumeric.bn;
  decimal[_locale3] = decimal["en-US"];
}
var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
alpha$1.dotDecimal = dotDecimal;
var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
alpha$1.commaDecimal = commaDecimal;
for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
  decimal[dotDecimal[_i4]] = decimal["en-US"];
}
for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
  decimal[commaDecimal[_i5]] = ",";
}
alpha["fr-CA"] = alpha["fr-FR"];
alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];
alpha["fa-AF"] = alpha.fa;
Object.defineProperty(isFloat$1, "__esModule", {
  value: true
});
isFloat$1.default = isFloat;
isFloat$1.locales = void 0;
var _assertString$b = _interopRequireDefault$b(assertStringExports);
var _alpha$2 = alpha$1;
function _interopRequireDefault$b(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isFloat(str2, options2) {
  (0, _assertString$b.default)(str2);
  options2 = options2 || {};
  var float2 = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options2.locale ? _alpha$2.decimal[options2.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
  if (str2 === "" || str2 === "." || str2 === "," || str2 === "-" || str2 === "+") {
    return false;
  }
  var value = parseFloat(str2.replace(",", "."));
  return float2.test(str2) && (!options2.hasOwnProperty("min") || value >= options2.min) && (!options2.hasOwnProperty("max") || value <= options2.max) && (!options2.hasOwnProperty("lt") || value < options2.lt) && (!options2.hasOwnProperty("gt") || value > options2.gt);
}
var locales$5 = Object.keys(_alpha$2.decimal);
isFloat$1.locales = locales$5;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toFloat2;
  var _isFloat = _interopRequireDefault2(isFloat$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toFloat2(str2) {
    if (!(0, _isFloat.default)(str2))
      return NaN;
    return parseFloat(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toFloat, toFloat.exports);
var toFloatExports = toFloat.exports;
var toInt = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toInt2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toInt2(str2, radix) {
    (0, _assertString2.default)(str2);
    return parseInt(str2, radix || 10);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toInt, toInt.exports);
var toIntExports = toInt.exports;
var toBoolean = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBoolean2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function toBoolean2(str2, strict) {
    (0, _assertString2.default)(str2);
    if (strict) {
      return str2 === "1" || /^true$/i.test(str2);
    }
    return str2 !== "0" && !/^false$/i.test(str2) && str2 !== "";
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toBoolean, toBoolean.exports);
var toBooleanExports = toBoolean.exports;
var equals = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = equals2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function equals2(str2, comparison) {
    (0, _assertString2.default)(str2);
    return str2 === comparison;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(equals, equals.exports);
var equalsExports = equals.exports;
var contains = { exports: {} };
var toString$2 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toString2;
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function toString2(input) {
    if (_typeof2(input) === "object" && input !== null) {
      if (typeof input.toString === "function") {
        input = input.toString();
      } else {
        input = "[object Object]";
      }
    } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
      input = "";
    }
    return String(input);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(toString$2, toString$2.exports);
var toStringExports = toString$2.exports;
var merge = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge2;
  function merge2() {
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults2 = arguments.length > 1 ? arguments[1] : void 0;
    for (var key2 in defaults2) {
      if (typeof obj[key2] === "undefined") {
        obj[key2] = defaults2[key2];
      }
    }
    return obj;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(merge, merge.exports);
var mergeExports = merge.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = contains2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toString = _interopRequireDefault2(toStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var defaulContainsOptions = {
    ignoreCase: false,
    minOccurrences: 1
  };
  function contains2(str2, elem, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, defaulContainsOptions);
    if (options2.ignoreCase) {
      return str2.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options2.minOccurrences;
    }
    return str2.split((0, _toString.default)(elem)).length > options2.minOccurrences;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(contains, contains.exports);
var containsExports = contains.exports;
var matches = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matches2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function matches2(str2, pattern, modifiers) {
    (0, _assertString2.default)(str2);
    if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
      pattern = new RegExp(pattern, modifiers);
    }
    return !!str2.match(pattern);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(matches, matches.exports);
var matchesExports = matches.exports;
var isEmail = { exports: {} };
var isByteLength = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function isByteLength2(str2, options2) {
    (0, _assertString2.default)(str2);
    var min2;
    var max2;
    if (_typeof2(options2) === "object") {
      min2 = options2.min || 0;
      max2 = options2.max;
    } else {
      min2 = arguments[1];
      max2 = arguments[2];
    }
    var len = encodeURI(str2).split(/%..|./).length - 1;
    return len >= min2 && (typeof max2 === "undefined" || len <= max2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isByteLength, isByteLength.exports);
var isByteLengthExports = isByteLength.exports;
var isFQDN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false,
    ignore_max_length: false
  };
  function isFQDN2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, default_fqdn_options);
    if (options2.allow_trailing_dot && str2[str2.length - 1] === ".") {
      str2 = str2.substring(0, str2.length - 1);
    }
    if (options2.allow_wildcard === true && str2.indexOf("*.") === 0) {
      str2 = str2.substring(2);
    }
    var parts = str2.split(".");
    var tld = parts[parts.length - 1];
    if (options2.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!options2.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options2.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63 && !options2.ignore_max_length) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options2.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isFQDN, isFQDN.exports);
var isFQDNExports = isFQDN.exports;
var isIP = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
  function isIP2(str2) {
    var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString2.default)(str2);
    version2 = String(version2);
    if (!version2) {
      return isIP2(str2, 4) || isIP2(str2, 6);
    }
    if (version2 === "4") {
      return IPv4AddressRegExp.test(str2);
    }
    if (version2 === "6") {
      return IPv6AddressRegExp.test(str2);
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIP, isIP.exports);
var isIPExports = isIP.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isByteLength = _interopRequireDefault2(isByteLengthExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_email_options = {
    allow_display_name: false,
    allow_underscores: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: "",
    ignore_max_length: false,
    host_blacklist: [],
    host_whitelist: []
  };
  var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength = 254;
  function validateDisplayName(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
    if (!display_name_without_quotes.trim()) {
      return false;
    }
    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
      if (display_name_without_quotes === display_name) {
        return false;
      }
      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
      if (!all_start_with_back_slash) {
        return false;
      }
    }
    return true;
  }
  function isEmail2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, default_email_options);
    if (options2.require_display_name || options2.allow_display_name) {
      var display_email = str2.match(splitNameAddress);
      if (display_email) {
        var display_name = display_email[1];
        str2 = str2.replace(display_name, "").replace(/(^<|>$)/g, "");
        if (display_name.endsWith(" ")) {
          display_name = display_name.slice(0, -1);
        }
        if (!validateDisplayName(display_name)) {
          return false;
        }
      } else if (options2.require_display_name) {
        return false;
      }
    }
    if (!options2.ignore_max_length && str2.length > defaultMaxEmailLength) {
      return false;
    }
    var parts = str2.split("@");
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();
    if (options2.host_blacklist.includes(lower_domain)) {
      return false;
    }
    if (options2.host_whitelist.length > 0 && !options2.host_whitelist.includes(lower_domain)) {
      return false;
    }
    var user = parts.join("@");
    if (options2.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }
    if (options2.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    }))) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options2.require_tld,
      ignore_max_length: options2.ignore_max_length,
      allow_underscores: options2.allow_underscores
    })) {
      if (!options2.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.slice(1, -1);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options2.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }
    var pattern = options2.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split(".");
    for (var _i = 0; _i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }
    if (options2.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options2.blacklisted_chars, "]+"), "g")) !== -1)
        return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEmail, isEmail.exports);
var isEmailExports = isEmail.exports;
var isURL = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray2(arr, i) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit2(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d2 = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d2 = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d2)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  function checkHost(host, matches2) {
    for (var i = 0; i < matches2.length; i++) {
      var match2 = matches2[i];
      if (host === match2 || isRegExp(match2) && match2.test(host)) {
        return true;
      }
    }
    return false;
  }
  function isURL2(url, options2) {
    (0, _assertString2.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options2 = (0, _merge.default)(options2, default_url_options);
    if (options2.validate_length && url.length >= 2083) {
      return false;
    }
    if (!options2.allow_fragments && url.includes("#")) {
      return false;
    }
    if (!options2.allow_query_components && (url.includes("?") || url.includes("&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url.split("#");
    url = split.shift();
    split = url.split("?");
    url = split.shift();
    split = url.split("://");
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options2.require_valid_protocol && options2.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options2.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === "//") {
      if (!options2.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url.slice(2);
    }
    url = split.join("://");
    if (url === "") {
      return false;
    }
    split = url.split("/");
    url = split.shift();
    if (url === "" && !options2.require_host) {
      return true;
    }
    split = url.split("@");
    if (split.length > 1) {
      if (options2.disallow_auth) {
        return false;
      }
      if (split[0] === "") {
        return false;
      }
      auth = split.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray2(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(":");
      host = split.shift();
      if (split.length) {
        port_str = split.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options2.require_port) {
      return false;
    }
    if (options2.host_whitelist) {
      return checkHost(host, options2.host_whitelist);
    }
    if (host === "" && !options2.require_host) {
      return true;
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options2) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options2.host_blacklist && checkHost(host, options2.host_blacklist)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isURL, isURL.exports);
var isURLExports = isURL.exports;
var isMACAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMACAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
  var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
  var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
  var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
  var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
  var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
  function isMACAddress2(str2, options2) {
    (0, _assertString2.default)(str2);
    if (options2 !== null && options2 !== void 0 && options2.eui) {
      options2.eui = String(options2.eui);
    }
    if (options2 !== null && options2 !== void 0 && options2.no_colons || options2 !== null && options2 !== void 0 && options2.no_separators) {
      if (options2.eui === "48") {
        return macAddress48NoSeparators.test(str2);
      }
      if (options2.eui === "64") {
        return macAddress64NoSeparators.test(str2);
      }
      return macAddress48NoSeparators.test(str2) || macAddress64NoSeparators.test(str2);
    }
    if ((options2 === null || options2 === void 0 ? void 0 : options2.eui) === "48") {
      return macAddress48.test(str2) || macAddress48WithDots.test(str2);
    }
    if ((options2 === null || options2 === void 0 ? void 0 : options2.eui) === "64") {
      return macAddress64.test(str2) || macAddress64WithDots.test(str2);
    }
    return isMACAddress2(str2, {
      eui: "48"
    }) || isMACAddress2(str2, {
      eui: "64"
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMACAddress, isMACAddress.exports);
var isMACAddressExports = isMACAddress.exports;
var isIPRange = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIPRange2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var subnetMaybe = /^\d{1,3}$/;
  var v4Subnet = 32;
  var v6Subnet = 128;
  function isIPRange2(str2) {
    var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString2.default)(str2);
    var parts = str2.split("/");
    if (parts.length !== 2) {
      return false;
    }
    if (!subnetMaybe.test(parts[1])) {
      return false;
    }
    if (parts[1].length > 1 && parts[1].startsWith("0")) {
      return false;
    }
    var isValidIP = (0, _isIP.default)(parts[0], version2);
    if (!isValidIP) {
      return false;
    }
    var expectedSubnet = null;
    switch (String(version2)) {
      case "4":
        expectedSubnet = v4Subnet;
        break;
      case "6":
        expectedSubnet = v6Subnet;
        break;
      default:
        expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
    }
    return parts[1] <= expectedSubnet && parts[1] >= 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIPRange, isIPRange.exports);
var isIPRangeExports = isIPRange.exports;
var isDate = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDate2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray2(arr, i) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit2(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d2 = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d2 = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d2)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it2;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = o[Symbol.iterator]();
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f2() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var default_date_options = {
    format: "YYYY/MM/DD",
    delimiters: ["/", "-"],
    strictMode: false
  };
  function isValidFormat(format2) {
    return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format2);
  }
  function zip(date, format2) {
    var zippedArr = [], len = Math.min(date.length, format2.length);
    for (var i = 0; i < len; i++) {
      zippedArr.push([date[i], format2[i]]);
    }
    return zippedArr;
  }
  function isDate2(input, options2) {
    if (typeof options2 === "string") {
      options2 = (0, _merge.default)({
        format: options2
      }, default_date_options);
    } else {
      options2 = (0, _merge.default)(options2, default_date_options);
    }
    if (typeof input === "string" && isValidFormat(options2.format)) {
      var formatDelimiter = options2.delimiters.find(function(delimiter2) {
        return options2.format.indexOf(delimiter2) !== -1;
      });
      var dateDelimiter = options2.strictMode ? formatDelimiter : options2.delimiters.find(function(delimiter2) {
        return input.indexOf(delimiter2) !== -1;
      });
      var dateAndFormat = zip(input.split(dateDelimiter), options2.format.toLowerCase().split(formatDelimiter));
      var dateObj = {};
      var _iterator = _createForOfIteratorHelper2(dateAndFormat), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray2(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
          if (dateWord.length !== formatWord.length) {
            return false;
          }
          dateObj[formatWord.charAt(0)] = dateWord;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var fullYear = dateObj.y;
      if (dateObj.y.length === 2) {
        var parsedYear = parseInt(dateObj.y, 10);
        if (isNaN(parsedYear)) {
          return false;
        }
        var currentYearLastTwoDigits = (/* @__PURE__ */ new Date()).getFullYear() % 100;
        if (parsedYear < currentYearLastTwoDigits) {
          fullYear = "20".concat(dateObj.y);
        } else {
          fullYear = "19".concat(dateObj.y);
        }
      }
      return new Date("".concat(fullYear, "-").concat(dateObj.m, "-").concat(dateObj.d)).getDate() === +dateObj.d;
    }
    if (!options2.strictMode) {
      return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDate, isDate.exports);
var isDateExports = isDate.exports;
var isTime = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTime2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_time_options = {
    hourFormat: "hour24",
    mode: "default"
  };
  var formats = {
    hour24: {
      default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
      withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
    },
    hour12: {
      default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
      withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
    }
  };
  function isTime2(input, options2) {
    options2 = (0, _merge.default)(options2, default_time_options);
    if (typeof input !== "string")
      return false;
    return formats[options2.hourFormat][options2.mode].test(input);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isTime, isTime.exports);
var isTimeExports = isTime.exports;
var isBoolean$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBoolean2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var defaultOptions2 = {
    loose: false
  };
  var strictBooleans = ["true", "false", "1", "0"];
  var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
  function isBoolean2(str2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions2;
    (0, _assertString2.default)(str2);
    if (options2.loose) {
      return looseBooleans.includes(str2.toLowerCase());
    }
    return strictBooleans.includes(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBoolean$1, isBoolean$1.exports);
var isBooleanExports = isBoolean$1.exports;
var isLocale = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLocale2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
  var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
  var script = "([A-Za-z]{4})";
  var region = "([A-Za-z]{2}|\\d{3})";
  var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
  var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
  var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
  var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
  var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
  var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
  var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
  var delimiter2 = "(-|_)";
  var langtag = "".concat(language, "(").concat(delimiter2).concat(script, ")?(").concat(delimiter2).concat(region, ")?(").concat(delimiter2).concat(variant, ")*(").concat(delimiter2).concat(extension, ")*(").concat(delimiter2).concat(privateuse, ")?");
  var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
  function isLocale2(str2) {
    (0, _assertString2.default)(str2);
    return languageTagRegex.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLocale, isLocale.exports);
var isLocaleExports = isLocale.exports;
var isAlpha$1 = {};
Object.defineProperty(isAlpha$1, "__esModule", {
  value: true
});
isAlpha$1.default = isAlpha;
isAlpha$1.locales = void 0;
var _assertString$a = _interopRequireDefault$a(assertStringExports);
var _alpha$1 = alpha$1;
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isAlpha(_str) {
  var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  (0, _assertString$a.default)(_str);
  var str2 = _str;
  var ignore = options2.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str2 = str2.replace(ignore, "");
    } else if (typeof ignore === "string") {
      str2 = str2.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
    } else {
      throw new Error("ignore should be instance of a String or RegExp");
    }
  }
  if (locale in _alpha$1.alpha) {
    return _alpha$1.alpha[locale].test(str2);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales$4 = Object.keys(_alpha$1.alpha);
isAlpha$1.locales = locales$4;
var isAlphanumeric$1 = {};
Object.defineProperty(isAlphanumeric$1, "__esModule", {
  value: true
});
isAlphanumeric$1.default = isAlphanumeric;
isAlphanumeric$1.locales = void 0;
var _assertString$9 = _interopRequireDefault$9(assertStringExports);
var _alpha = alpha$1;
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isAlphanumeric(_str) {
  var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  (0, _assertString$9.default)(_str);
  var str2 = _str;
  var ignore = options2.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str2 = str2.replace(ignore, "");
    } else if (typeof ignore === "string") {
      str2 = str2.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
    } else {
      throw new Error("ignore should be instance of a String or RegExp");
    }
  }
  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str2);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales$3 = Object.keys(_alpha.alphanumeric);
isAlphanumeric$1.locales = locales$3;
var isNumeric = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNumeric2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _alpha2 = alpha$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var numericNoSymbols = /^[0-9]+$/;
  function isNumeric2(str2, options2) {
    (0, _assertString2.default)(str2);
    if (options2 && options2.no_symbols) {
      return numericNoSymbols.test(str2);
    }
    return new RegExp("^[+-]?([0-9]*[".concat((options2 || {}).locale ? _alpha2.decimal[options2.locale] : ".", "])?[0-9]+$")).test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isNumeric, isNumeric.exports);
var isNumericExports = isNumeric.exports;
var isPassportNumber = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPassportNumber2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var passportRegexByCountryCode = {
    AM: /^[A-Z]{2}\d{7}$/,
    // ARMENIA
    AR: /^[A-Z]{3}\d{6}$/,
    // ARGENTINA
    AT: /^[A-Z]\d{7}$/,
    // AUSTRIA
    AU: /^[A-Z]\d{7}$/,
    // AUSTRALIA
    AZ: /^[A-Z]{2,3}\d{7,8}$/,
    // AZERBAIJAN
    BE: /^[A-Z]{2}\d{6}$/,
    // BELGIUM
    BG: /^\d{9}$/,
    // BULGARIA
    BR: /^[A-Z]{2}\d{6}$/,
    // BRAZIL
    BY: /^[A-Z]{2}\d{7}$/,
    // BELARUS
    CA: /^[A-Z]{2}\d{6}$/,
    // CANADA
    CH: /^[A-Z]\d{7}$/,
    // SWITZERLAND
    CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
    // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
    CY: /^[A-Z](\d{6}|\d{8})$/,
    // CYPRUS
    CZ: /^\d{8}$/,
    // CZECH REPUBLIC
    DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
    // GERMANY
    DK: /^\d{9}$/,
    // DENMARK
    DZ: /^\d{9}$/,
    // ALGERIA
    EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
    // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
    ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
    // SPAIN
    FI: /^[A-Z]{2}\d{7}$/,
    // FINLAND
    FR: /^\d{2}[A-Z]{2}\d{5}$/,
    // FRANCE
    GB: /^\d{9}$/,
    // UNITED KINGDOM
    GR: /^[A-Z]{2}\d{7}$/,
    // GREECE
    HR: /^\d{9}$/,
    // CROATIA
    HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
    // HUNGARY
    IE: /^[A-Z0-9]{2}\d{7}$/,
    // IRELAND
    IN: /^[A-Z]{1}-?\d{7}$/,
    // INDIA
    ID: /^[A-C]\d{7}$/,
    // INDONESIA
    IR: /^[A-Z]\d{8}$/,
    // IRAN
    IS: /^(A)\d{7}$/,
    // ICELAND
    IT: /^[A-Z0-9]{2}\d{7}$/,
    // ITALY
    JM: /^[Aa]\d{7}$/,
    // JAMAICA
    JP: /^[A-Z]{2}\d{7}$/,
    // JAPAN
    KR: /^[MS]\d{8}$/,
    // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
    KZ: /^[a-zA-Z]\d{7}$/,
    // KAZAKHSTAN
    LI: /^[a-zA-Z]\d{5}$/,
    // LIECHTENSTEIN
    LT: /^[A-Z0-9]{8}$/,
    // LITHUANIA
    LU: /^[A-Z0-9]{8}$/,
    // LUXEMBURG
    LV: /^[A-Z0-9]{2}\d{7}$/,
    // LATVIA
    LY: /^[A-Z0-9]{8}$/,
    // LIBYA
    MT: /^\d{7}$/,
    // MALTA
    MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
    // MOZAMBIQUE
    MY: /^[AHK]\d{8}$/,
    // MALAYSIA
    MX: /^\d{10,11}$/,
    // MEXICO
    NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
    // NETHERLANDS
    NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
    // NEW ZEALAND
    PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
    // PHILIPPINES
    PK: /^[A-Z]{2}\d{7}$/,
    // PAKISTAN
    PL: /^[A-Z]{2}\d{7}$/,
    // POLAND
    PT: /^[A-Z]\d{6}$/,
    // PORTUGAL
    RO: /^\d{8,9}$/,
    // ROMANIA
    RU: /^\d{9}$/,
    // RUSSIAN FEDERATION
    SE: /^\d{8}$/,
    // SWEDEN
    SL: /^(P)[A-Z]\d{7}$/,
    // SLOVENIA
    SK: /^[0-9A-Z]\d{7}$/,
    // SLOVAKIA
    TH: /^[A-Z]{1,2}\d{6,7}$/,
    // THAILAND
    TR: /^[A-Z]\d{8}$/,
    // TURKEY
    UA: /^[A-Z]{2}\d{6}$/,
    // UKRAINE
    US: /^\d{9}$/
    // UNITED STATES
  };
  function isPassportNumber2(str2, countryCode) {
    (0, _assertString2.default)(str2);
    var normalizedStr = str2.replace(/\s/g, "").toUpperCase();
    return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isPassportNumber, isPassportNumber.exports);
var isPassportNumberExports = isPassportNumber.exports;
var isPort = { exports: {} };
var isInt = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isInt2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var int2 = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
  var intLeadingZeroes = /^[-+]?[0-9]+$/;
  function isInt2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = options2 || {};
    var regex = options2.hasOwnProperty("allow_leading_zeroes") && !options2.allow_leading_zeroes ? int2 : intLeadingZeroes;
    var minCheckPassed = !options2.hasOwnProperty("min") || str2 >= options2.min;
    var maxCheckPassed = !options2.hasOwnProperty("max") || str2 <= options2.max;
    var ltCheckPassed = !options2.hasOwnProperty("lt") || str2 < options2.lt;
    var gtCheckPassed = !options2.hasOwnProperty("gt") || str2 > options2.gt;
    return regex.test(str2) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isInt, isInt.exports);
var isIntExports = isInt.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPort2;
  var _isInt = _interopRequireDefault2(isIntExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isPort2(str2) {
    return (0, _isInt.default)(str2, {
      min: 0,
      max: 65535
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isPort, isPort.exports);
var isPortExports = isPort.exports;
var isLowercase = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLowercase2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isLowercase2(str2) {
    (0, _assertString2.default)(str2);
    return str2 === str2.toLowerCase();
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLowercase, isLowercase.exports);
var isLowercaseExports = isLowercase.exports;
var isUppercase = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUppercase2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isUppercase2(str2) {
    (0, _assertString2.default)(str2);
    return str2 === str2.toUpperCase();
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isUppercase, isUppercase.exports);
var isUppercaseExports = isUppercase.exports;
var isIMEI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIMEI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var imeiRegexWithoutHypens = /^[0-9]{15}$/;
  var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
  function isIMEI2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = options2 || {};
    var imeiRegex = imeiRegexWithoutHypens;
    if (options2.allow_hyphens) {
      imeiRegex = imeiRegexWithHypens;
    }
    if (!imeiRegex.test(str2)) {
      return false;
    }
    str2 = str2.replace(/-/g, "");
    var sum = 0, mul = 2, l2 = 14;
    for (var i = 0; i < l2; i++) {
      var digit = str2.substring(l2 - i - 1, l2 - i);
      var tp = parseInt(digit, 10) * mul;
      if (tp >= 10) {
        sum += tp % 10 + 1;
      } else {
        sum += tp;
      }
      if (mul === 1) {
        mul += 1;
      } else {
        mul -= 1;
      }
    }
    var chk = (10 - sum % 10) % 10;
    if (chk !== parseInt(str2.substring(14, 15), 10)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIMEI, isIMEI.exports);
var isIMEIExports = isIMEI.exports;
var isAscii = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAscii2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ascii = /^[\x00-\x7F]+$/;
  function isAscii2(str2) {
    (0, _assertString2.default)(str2);
    return ascii.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isAscii, isAscii.exports);
var isAsciiExports = isAscii.exports;
var isFullWidth$1 = {};
Object.defineProperty(isFullWidth$1, "__esModule", {
  value: true
});
isFullWidth$1.default = isFullWidth;
isFullWidth$1.fullWidth = void 0;
var _assertString$8 = _interopRequireDefault$8(assertStringExports);
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
isFullWidth$1.fullWidth = fullWidth;
function isFullWidth(str2) {
  (0, _assertString$8.default)(str2);
  return fullWidth.test(str2);
}
var isHalfWidth$1 = {};
Object.defineProperty(isHalfWidth$1, "__esModule", {
  value: true
});
isHalfWidth$1.default = isHalfWidth;
isHalfWidth$1.halfWidth = void 0;
var _assertString$7 = _interopRequireDefault$7(assertStringExports);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
isHalfWidth$1.halfWidth = halfWidth;
function isHalfWidth(str2) {
  (0, _assertString$7.default)(str2);
  return halfWidth.test(str2);
}
var isVariableWidth = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVariableWidth2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isFullWidth = isFullWidth$1;
  var _isHalfWidth = isHalfWidth$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isVariableWidth2(str2) {
    (0, _assertString2.default)(str2);
    return _isFullWidth.fullWidth.test(str2) && _isHalfWidth.halfWidth.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isVariableWidth, isVariableWidth.exports);
var isVariableWidthExports = isVariableWidth.exports;
var isMultibyte = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMultibyte2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var multibyte = /[^\x00-\x7F]/;
  function isMultibyte2(str2) {
    (0, _assertString2.default)(str2);
    return multibyte.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMultibyte, isMultibyte.exports);
var isMultibyteExports = isMultibyte.exports;
var isSemVer = { exports: {} };
var multilineRegex = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = multilineRegexp;
  function multilineRegexp(parts, flags) {
    var regexpAsStringLiteral = parts.join("");
    return new RegExp(regexpAsStringLiteral, flags);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(multilineRegex, multilineRegex.exports);
var multilineRegexExports = multilineRegex.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSemVer2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _multilineRegex = _interopRequireDefault2(multilineRegexExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
  function isSemVer2(str2) {
    (0, _assertString2.default)(str2);
    return semanticVersioningRegex.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSemVer, isSemVer.exports);
var isSemVerExports = isSemVer.exports;
var isSurrogatePair = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSurrogatePair2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
  function isSurrogatePair2(str2) {
    (0, _assertString2.default)(str2);
    return surrogatePair.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSurrogatePair, isSurrogatePair.exports);
var isSurrogatePairExports = isSurrogatePair.exports;
var isDecimal = { exports: {} };
var includes = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var includes2 = function includes3(arr, val) {
    return arr.some(function(arrVal) {
      return val === arrVal;
    });
  };
  var _default2 = includes2;
  exports.default = _default2;
  module.exports = exports.default;
  module.exports.default = exports.default;
})(includes, includes.exports);
var includesExports = includes.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDecimal2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _includes = _interopRequireDefault2(includesExports);
  var _alpha2 = alpha$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function decimalRegExp(options2) {
    var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha2.decimal[options2.locale], "[0-9]{").concat(options2.decimal_digits, "})").concat(options2.force_decimal ? "" : "?", "$"));
    return regExp;
  }
  var default_decimal_options = {
    force_decimal: false,
    decimal_digits: "1,",
    locale: "en-US"
  };
  var blacklist2 = ["", "-", "+"];
  function isDecimal2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, default_decimal_options);
    if (options2.locale in _alpha2.decimal) {
      return !(0, _includes.default)(blacklist2, str2.replace(/ /g, "")) && decimalRegExp(options2).test(str2);
    }
    throw new Error("Invalid locale '".concat(options2.locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDecimal, isDecimal.exports);
var isDecimalExports = isDecimal.exports;
var isHexadecimal = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexadecimal2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
  function isHexadecimal2(str2) {
    (0, _assertString2.default)(str2);
    return hexadecimal.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHexadecimal, isHexadecimal.exports);
var isHexadecimalExports = isHexadecimal.exports;
var isOctal = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isOctal2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var octal = /^(0o)?[0-7]+$/i;
  function isOctal2(str2) {
    (0, _assertString2.default)(str2);
    return octal.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isOctal, isOctal.exports);
var isOctalExports = isOctal.exports;
var isDivisibleBy = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDivisibleBy2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toFloat = _interopRequireDefault2(toFloatExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isDivisibleBy2(str2, num) {
    (0, _assertString2.default)(str2);
    return (0, _toFloat.default)(str2) % parseInt(num, 10) === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDivisibleBy, isDivisibleBy.exports);
var isDivisibleByExports = isDivisibleBy.exports;
var isHexColor = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexColor2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
  function isHexColor2(str2) {
    (0, _assertString2.default)(str2);
    return hexcolor.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHexColor, isHexColor.exports);
var isHexColorExports = isHexColor.exports;
var isRgbColor = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRgbColor2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
  var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
  var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  function isRgbColor2(str2) {
    var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    (0, _assertString2.default)(str2);
    if (!includePercentValues) {
      return rgbColor.test(str2) || rgbaColor.test(str2);
    }
    return rgbColor.test(str2) || rgbaColor.test(str2) || rgbColorPercent.test(str2) || rgbaColorPercent.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isRgbColor, isRgbColor.exports);
var isRgbColorExports = isRgbColor.exports;
var isHSL = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHSL2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
  var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
  function isHSL2(str2) {
    (0, _assertString2.default)(str2);
    var strippedStr = str2.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
    if (strippedStr.indexOf(",") !== -1) {
      return hslComma.test(strippedStr);
    }
    return hslSpace.test(strippedStr);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHSL, isHSL.exports);
var isHSLExports = isHSL.exports;
var isISRC = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISRC2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
  function isISRC2(str2) {
    (0, _assertString2.default)(str2);
    return isrc.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISRC, isISRC.exports);
var isISRCExports = isISRC.exports;
var isIBAN$1 = {};
Object.defineProperty(isIBAN$1, "__esModule", {
  value: true
});
isIBAN$1.default = isIBAN;
isIBAN$1.locales = void 0;
var _assertString$6 = _interopRequireDefault$6(assertStringExports);
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var ibanRegexThroughCountryCode = {
  AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
  AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
  AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  AT: /^(AT[0-9]{2})\d{16}$/,
  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  BA: /^(BA[0-9]{2})\d{16}$/,
  BE: /^(BE[0-9]{2})\d{12}$/,
  BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
  BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  CR: /^(CR[0-9]{2})\d{18}$/,
  CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  CZ: /^(CZ[0-9]{2})\d{20}$/,
  DE: /^(DE[0-9]{2})\d{18}$/,
  DK: /^(DK[0-9]{2})\d{14}$/,
  DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
  EE: /^(EE[0-9]{2})\d{16}$/,
  EG: /^(EG[0-9]{2})\d{25}$/,
  ES: /^(ES[0-9]{2})\d{20}$/,
  FI: /^(FI[0-9]{2})\d{14}$/,
  FO: /^(FO[0-9]{2})\d{14}$/,
  FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
  GL: /^(GL[0-9]{2})\d{14}$/,
  GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
  HR: /^(HR[0-9]{2})\d{17}$/,
  HU: /^(HU[0-9]{2})\d{24}$/,
  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
  IL: /^(IL[0-9]{2})\d{19}$/,
  IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
  IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
  IS: /^(IS[0-9]{2})\d{22}$/,
  IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
  KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
  LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  LT: /^(LT[0-9]{2})\d{16}$/,
  LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
  MA: /^(MA[0-9]{26})$/,
  MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
  ME: /^(ME[0-9]{2})\d{18}$/,
  MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
  MR: /^(MR[0-9]{2})\d{23}$/,
  MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
  MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
  MZ: /^(MZ[0-9]{2})\d{21}$/,
  NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
  NO: /^(NO[0-9]{2})\d{11}$/,
  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  PL: /^(PL[0-9]{2})\d{24}$/,
  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
  PT: /^(PT[0-9]{2})\d{21}$/,
  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
  RS: /^(RS[0-9]{2})\d{18}$/,
  SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
  SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
  SE: /^(SE[0-9]{2})\d{20}$/,
  SI: /^(SI[0-9]{2})\d{15}$/,
  SK: /^(SK[0-9]{2})\d{20}$/,
  SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  TL: /^(TL[0-9]{2})\d{19}$/,
  TN: /^(TN[0-9]{2})\d{20}$/,
  TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
  UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
  VA: /^(VA[0-9]{2})\d{18}$/,
  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  XK: /^(XK[0-9]{2})\d{16}$/
};
function hasOnlyValidCountryCodes(countryCodeArray) {
  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
    return !(countryCode in ibanRegexThroughCountryCode);
  });
  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
    return false;
  }
  return true;
}
function hasValidIbanFormat(str2, options2) {
  var strippedStr = str2.replace(/[\s\-]+/gi, "").toUpperCase();
  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
  var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
  if (options2.whitelist) {
    if (!hasOnlyValidCountryCodes(options2.whitelist)) {
      return false;
    }
    var isoCountryCodeInWhiteList = options2.whitelist.includes(isoCountryCode);
    if (!isoCountryCodeInWhiteList) {
      return false;
    }
  }
  if (options2.blacklist) {
    var isoCountryCodeInBlackList = options2.blacklist.includes(isoCountryCode);
    if (isoCountryCodeInBlackList) {
      return false;
    }
  }
  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
}
function hasValidIbanChecksum(str2) {
  var strippedStr = str2.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char2) {
    return char2.charCodeAt(0) - 55;
  });
  var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
    return Number(acc + value) % 97;
  }, "");
  return remainder === 1;
}
function isIBAN(str2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  (0, _assertString$6.default)(str2);
  return hasValidIbanFormat(str2, options2) && hasValidIbanChecksum(str2);
}
var locales$2 = Object.keys(ibanRegexThroughCountryCode);
isIBAN$1.locales = locales$2;
var isBIC = { exports: {} };
var isISO31661Alpha2$1 = {};
Object.defineProperty(isISO31661Alpha2$1, "__esModule", {
  value: true
});
isISO31661Alpha2$1.default = isISO31661Alpha2;
isISO31661Alpha2$1.CountryCodes = void 0;
var _assertString$5 = _interopRequireDefault$5(assertStringExports);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
function isISO31661Alpha2(str2) {
  (0, _assertString$5.default)(str2);
  return validISO31661Alpha2CountriesCodes.has(str2.toUpperCase());
}
var CountryCodes = validISO31661Alpha2CountriesCodes;
isISO31661Alpha2$1.CountryCodes = CountryCodes;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBIC2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isISO31661Alpha = isISO31661Alpha2$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
  function isBIC2(str2) {
    (0, _assertString2.default)(str2);
    var countryCode = str2.slice(4, 6).toUpperCase();
    if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
      return false;
    }
    return isBICReg.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBIC, isBIC.exports);
var isBICExports = isBIC.exports;
var isMD5 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMD52;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var md5 = /^[a-f0-9]{32}$/;
  function isMD52(str2) {
    (0, _assertString2.default)(str2);
    return md5.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMD5, isMD5.exports);
var isMD5Exports = isMD5.exports;
var isHash = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHash2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var lengths = {
    md5: 32,
    md4: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8
  };
  function isHash2(str2, algorithm) {
    (0, _assertString2.default)(str2);
    var hash2 = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
    return hash2.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isHash, isHash.exports);
var isHashExports = isHash.exports;
var isJWT = { exports: {} };
var isBase64 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase642;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var notBase64 = /[^A-Z0-9+\/=]/i;
  var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
  var defaultBase64Options = {
    urlSafe: false
  };
  function isBase642(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, defaultBase64Options);
    var len = str2.length;
    if (options2.urlSafe) {
      return urlSafeBase64.test(str2);
    }
    if (len % 4 !== 0 || notBase64.test(str2)) {
      return false;
    }
    var firstPaddingChar = str2.indexOf("=");
    return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str2[len - 1] === "=";
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase64, isBase64.exports);
var isBase64Exports = isBase64.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJWT2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isBase = _interopRequireDefault2(isBase64Exports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isJWT2(str2) {
    (0, _assertString2.default)(str2);
    var dotSplit = str2.split(".");
    var len = dotSplit.length;
    if (len !== 3) {
      return false;
    }
    return dotSplit.reduce(function(acc, currElem) {
      return acc && (0, _isBase.default)(currElem, {
        urlSafe: true
      });
    }, true);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isJWT, isJWT.exports);
var isJWTExports = isJWT.exports;
var isJSON = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJSON2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  var default_json_options = {
    allow_primitives: false
  };
  function isJSON2(str2, options2) {
    (0, _assertString2.default)(str2);
    try {
      options2 = (0, _merge.default)(options2, default_json_options);
      var primitives = [];
      if (options2.allow_primitives) {
        primitives = [null, false, true];
      }
      var obj = JSON.parse(str2);
      return primitives.includes(obj) || !!obj && _typeof2(obj) === "object";
    } catch (e2) {
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isJSON, isJSON.exports);
var isJSONExports = isJSON.exports;
var isEmpty = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmpty2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_is_empty_options = {
    ignore_whitespace: false
  };
  function isEmpty2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, default_is_empty_options);
    return (options2.ignore_whitespace ? str2.trim().length : str2.length) === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEmpty, isEmpty.exports);
var isEmptyExports = isEmpty.exports;
var isLength = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLength2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function isLength2(str2, options2) {
    (0, _assertString2.default)(str2);
    var min2;
    var max2;
    if (_typeof2(options2) === "object") {
      min2 = options2.min || 0;
      max2 = options2.max;
    } else {
      min2 = arguments[1] || 0;
      max2 = arguments[2];
    }
    var presentationSequences = str2.match(/(\uFE0F|\uFE0E)/g) || [];
    var surrogatePairs = str2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
    var len = str2.length - presentationSequences.length - surrogatePairs.length;
    return len >= min2 && (typeof max2 === "undefined" || len <= max2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLength, isLength.exports);
var isLengthExports = isLength.exports;
var isUUID = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUUID2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var uuid2 = {
    1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
  };
  function isUUID2(str2, version2) {
    (0, _assertString2.default)(str2);
    var pattern = uuid2[![void 0, null].includes(version2) ? version2 : "all"];
    return !!pattern && pattern.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isUUID, isUUID.exports);
var isUUIDExports = isUUID.exports;
var isMongoId = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMongoId2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isHexadecimal = _interopRequireDefault2(isHexadecimalExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isMongoId2(str2) {
    (0, _assertString2.default)(str2);
    return (0, _isHexadecimal.default)(str2) && str2.length === 24;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMongoId, isMongoId.exports);
var isMongoIdExports = isMongoId.exports;
var isAfter = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAfter2;
  var _toDate = _interopRequireDefault2(toDateExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isAfter2(date, options2) {
    var comparisonDate = (options2 === null || options2 === void 0 ? void 0 : options2.comparisonDate) || options2 || Date().toString();
    var comparison = (0, _toDate.default)(comparisonDate);
    var original = (0, _toDate.default)(date);
    return !!(original && comparison && original > comparison);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isAfter, isAfter.exports);
var isAfterExports = isAfter.exports;
var isBefore = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBefore2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toDate = _interopRequireDefault2(toDateExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isBefore2(str2) {
    var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
    (0, _assertString2.default)(str2);
    var comparison = (0, _toDate.default)(date);
    var original = (0, _toDate.default)(str2);
    return !!(original && comparison && original < comparison);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBefore, isBefore.exports);
var isBeforeExports = isBefore.exports;
var isIn = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIn2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _toString = _interopRequireDefault2(toStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function isIn2(str2, options2) {
    (0, _assertString2.default)(str2);
    var i;
    if (Object.prototype.toString.call(options2) === "[object Array]") {
      var array2 = [];
      for (i in options2) {
        if ({}.hasOwnProperty.call(options2, i)) {
          array2[i] = (0, _toString.default)(options2[i]);
        }
      }
      return array2.indexOf(str2) >= 0;
    } else if (_typeof2(options2) === "object") {
      return options2.hasOwnProperty(str2);
    } else if (options2 && typeof options2.indexOf === "function") {
      return options2.indexOf(str2) >= 0;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIn, isIn.exports);
var isInExports = isIn.exports;
var isLuhnNumber = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLuhnNumber2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isLuhnNumber2(str2) {
    (0, _assertString2.default)(str2);
    var sanitized = str2.replace(/[- ]+/g, "");
    var sum = 0;
    var digit;
    var tmpNum;
    var shouldDouble;
    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLuhnNumber, isLuhnNumber.exports);
var isLuhnNumberExports = isLuhnNumber.exports;
var isCreditCard = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isLuhnNumber = _interopRequireDefault2(isLuhnNumberExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var cards = {
    amex: /^3[47][0-9]{13}$/,
    dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
    discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
    jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
    mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
    // /^[25][1-7][0-9]{14}$/;
    unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
    visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
  };
  var allCards = function() {
    var tmpCardsArray = [];
    for (var cardProvider in cards) {
      if (cards.hasOwnProperty(cardProvider)) {
        tmpCardsArray.push(cards[cardProvider]);
      }
    }
    return tmpCardsArray;
  }();
  function isCreditCard2(card) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(card);
    var provider = options2.provider;
    var sanitized = card.replace(/[- ]+/g, "");
    if (provider && provider.toLowerCase() in cards) {
      if (!cards[provider.toLowerCase()].test(sanitized)) {
        return false;
      }
    } else if (provider && !(provider.toLowerCase() in cards)) {
      throw new Error("".concat(provider, " is not a valid credit card provider."));
    } else if (!allCards.some(function(cardProvider) {
      return cardProvider.test(sanitized);
    })) {
      return false;
    }
    return (0, _isLuhnNumber.default)(card);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isCreditCard, isCreditCard.exports);
var isCreditCardExports = isCreditCard.exports;
var isIdentityCard = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIdentityCard2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _isInt = _interopRequireDefault2(isIntExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validators = {
    PL: function PL2(str2) {
      (0, _assertString2.default)(str2);
      var weightOfDigits = {
        1: 1,
        2: 3,
        3: 7,
        4: 9,
        5: 1,
        6: 3,
        7: 7,
        8: 9,
        9: 1,
        10: 3,
        11: 0
      };
      if (str2 != null && str2.length === 11 && (0, _isInt.default)(str2, {
        allow_leading_zeroes: true
      })) {
        var digits = str2.split("").slice(0, -1);
        var sum = digits.reduce(function(acc, digit, index2) {
          return acc + Number(digit) * weightOfDigits[index2 + 1];
        }, 0);
        var modulo = sum % 10;
        var lastDigit = Number(str2.charAt(str2.length - 1));
        if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
          return true;
        }
      }
      return false;
    },
    ES: function ES2(str2) {
      (0, _assertString2.default)(str2);
      var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
      var charsValue = {
        X: 0,
        Y: 1,
        Z: 2
      };
      var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
      var sanitized = str2.trim().toUpperCase();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var number2 = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char2) {
        return charsValue[char2];
      });
      return sanitized.endsWith(controlDigits[number2 % 23]);
    },
    FI: function FI2(str2) {
      (0, _assertString2.default)(str2);
      if (str2.length !== 11) {
        return false;
      }
      if (!str2.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
        return false;
      }
      var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
      var idAsNumber = parseInt(str2.slice(0, 6), 10) * 1e3 + parseInt(str2.slice(7, 10), 10);
      var remainder = idAsNumber % 31;
      var checkDigit = checkDigits[remainder];
      return checkDigit === str2.slice(10, 11);
    },
    IN: function IN2(str2) {
      var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
      var d2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
      var p2 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
      var sanitized = str2.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var c2 = 0;
      var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
      invertedArray.forEach(function(val, i) {
        c2 = d2[c2][p2[i % 8][val]];
      });
      return c2 === 0;
    },
    IR: function IR(str2) {
      if (!str2.match(/^\d{10}$/))
        return false;
      str2 = "0000".concat(str2).slice(str2.length - 6);
      if (parseInt(str2.slice(3, 9), 10) === 0)
        return false;
      var lastNumber = parseInt(str2.slice(9, 10), 10);
      var sum = 0;
      for (var i = 0; i < 9; i++) {
        sum += parseInt(str2.slice(i, i + 1), 10) * (10 - i);
      }
      sum %= 11;
      return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
    },
    IT: function IT2(str2) {
      if (str2.length !== 9)
        return false;
      if (str2 === "CA00000AA")
        return false;
      return str2.search(/C[A-Z][0-9]{5}[A-Z]{2}/i) > -1;
    },
    NO: function NO2(str2) {
      var sanitized = str2.trim();
      if (isNaN(Number(sanitized)))
        return false;
      if (sanitized.length !== 11)
        return false;
      if (sanitized === "00000000000")
        return false;
      var f2 = sanitized.split("").map(Number);
      var k1 = (11 - (3 * f2[0] + 7 * f2[1] + 6 * f2[2] + 1 * f2[3] + 8 * f2[4] + 9 * f2[5] + 4 * f2[6] + 5 * f2[7] + 2 * f2[8]) % 11) % 11;
      var k2 = (11 - (5 * f2[0] + 4 * f2[1] + 3 * f2[2] + 2 * f2[3] + 7 * f2[4] + 6 * f2[5] + 5 * f2[6] + 4 * f2[7] + 3 * f2[8] + 2 * k1) % 11) % 11;
      if (k1 !== f2[9] || k2 !== f2[10])
        return false;
      return true;
    },
    TH: function TH(str2) {
      if (!str2.match(/^[1-8]\d{12}$/))
        return false;
      var sum = 0;
      for (var i = 0; i < 12; i++) {
        sum += parseInt(str2[i], 10) * (13 - i);
      }
      return str2[12] === ((11 - sum % 11) % 10).toString();
    },
    LK: function LK(str2) {
      var old_nic = /^[1-9]\d{8}[vx]$/i;
      var new_nic = /^[1-9]\d{11}$/i;
      if (str2.length === 10 && old_nic.test(str2))
        return true;
      else if (str2.length === 12 && new_nic.test(str2))
        return true;
      return false;
    },
    "he-IL": function heIL(str2) {
      var DNI = /^\d{9}$/;
      var sanitized = str2.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var id2 = sanitized;
      var sum = 0, incNum;
      for (var i = 0; i < id2.length; i++) {
        incNum = Number(id2[i]) * (i % 2 + 1);
        sum += incNum > 9 ? incNum - 9 : incNum;
      }
      return sum % 10 === 0;
    },
    "ar-LY": function arLY(str2) {
      var NIN = /^(1|2)\d{11}$/;
      var sanitized = str2.trim();
      if (!NIN.test(sanitized)) {
        return false;
      }
      return true;
    },
    "ar-TN": function arTN(str2) {
      var DNI = /^\d{8}$/;
      var sanitized = str2.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      return true;
    },
    "zh-CN": function zhCN(str2) {
      var provincesAndCities = [
        "11",
        // 
        "12",
        // 
        "13",
        // 
        "14",
        // 
        "15",
        // 
        "21",
        // 
        "22",
        // 
        "23",
        // 
        "31",
        // 
        "32",
        // 
        "33",
        // 
        "34",
        // 
        "35",
        // 
        "36",
        // 
        "37",
        // 
        "41",
        // 
        "42",
        // 
        "43",
        // 
        "44",
        // 
        "45",
        // 
        "46",
        // 
        "50",
        // 
        "51",
        // 
        "52",
        // 
        "53",
        // 
        "54",
        // 
        "61",
        // 
        "62",
        // 
        "63",
        // 
        "64",
        // 
        "65",
        // 
        "71",
        // 
        "81",
        // 
        "82",
        // 
        "91"
        // 
      ];
      var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
      var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
      var checkAddressCode = function checkAddressCode2(addressCode) {
        return provincesAndCities.includes(addressCode);
      };
      var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
        var yyyy = parseInt(birDayCode.substring(0, 4), 10);
        var mm = parseInt(birDayCode.substring(4, 6), 10);
        var dd2 = parseInt(birDayCode.substring(6), 10);
        var xdata = new Date(yyyy, mm - 1, dd2);
        if (xdata > /* @__PURE__ */ new Date()) {
          return false;
        } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd2) {
          return true;
        }
        return false;
      };
      var getParityBit = function getParityBit2(idCardNo) {
        var id17 = idCardNo.substring(0, 17);
        var power = 0;
        for (var i = 0; i < 17; i++) {
          power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
        }
        var mod = power % 11;
        return parityBit[mod];
      };
      var checkParityBit = function checkParityBit2(idCardNo) {
        return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
      };
      var check15IdCardNo = function check15IdCardNo2(idCardNo) {
        var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
        if (!check)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check = checkAddressCode(addressCode);
        if (!check)
          return false;
        var birDayCode = "19".concat(idCardNo.substring(6, 12));
        check = checkBirthDayCode(birDayCode);
        if (!check)
          return false;
        return true;
      };
      var check18IdCardNo = function check18IdCardNo2(idCardNo) {
        var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
        if (!check)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check = checkAddressCode(addressCode);
        if (!check)
          return false;
        var birDayCode = idCardNo.substring(6, 14);
        check = checkBirthDayCode(birDayCode);
        if (!check)
          return false;
        return checkParityBit(idCardNo);
      };
      var checkIdCardNo = function checkIdCardNo2(idCardNo) {
        var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
        if (!check)
          return false;
        if (idCardNo.length === 15) {
          return check15IdCardNo(idCardNo);
        }
        return check18IdCardNo(idCardNo);
      };
      return checkIdCardNo(str2);
    },
    "zh-HK": function zhHK(str2) {
      str2 = str2.trim();
      var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
      var regexIsDigit = /^[0-9]$/;
      str2 = str2.toUpperCase();
      if (!regexHKID.test(str2))
        return false;
      str2 = str2.replace(/\[|\]|\(|\)/g, "");
      if (str2.length === 8)
        str2 = "3".concat(str2);
      var checkSumVal = 0;
      for (var i = 0; i <= 7; i++) {
        var convertedChar = void 0;
        if (!regexIsDigit.test(str2[i]))
          convertedChar = (str2[i].charCodeAt(0) - 55) % 11;
        else
          convertedChar = str2[i];
        checkSumVal += convertedChar * (9 - i);
      }
      checkSumVal %= 11;
      var checkSumConverted;
      if (checkSumVal === 0)
        checkSumConverted = "0";
      else if (checkSumVal === 1)
        checkSumConverted = "A";
      else
        checkSumConverted = String(11 - checkSumVal);
      if (checkSumConverted === str2[str2.length - 1])
        return true;
      return false;
    },
    "zh-TW": function zhTW(str2) {
      var ALPHABET_CODES = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        G: 16,
        H: 17,
        I: 34,
        J: 18,
        K: 19,
        L: 20,
        M: 21,
        N: 22,
        O: 35,
        P: 23,
        Q: 24,
        R: 25,
        S: 26,
        T: 27,
        U: 28,
        V: 29,
        W: 32,
        X: 30,
        Y: 31,
        Z: 33
      };
      var sanitized = str2.trim().toUpperCase();
      if (!/^[A-Z][0-9]{9}$/.test(sanitized))
        return false;
      return Array.from(sanitized).reduce(function(sum, number2, index2) {
        if (index2 === 0) {
          var code = ALPHABET_CODES[number2];
          return code % 10 * 9 + Math.floor(code / 10);
        }
        if (index2 === 9) {
          return (10 - sum % 10 - Number(number2)) % 10 === 0;
        }
        return sum + Number(number2) * (9 - index2);
      }, 0);
    }
  };
  function isIdentityCard2(str2, locale) {
    (0, _assertString2.default)(str2);
    if (locale in validators) {
      return validators[locale](str2);
    } else if (locale === "any") {
      for (var key2 in validators) {
        if (validators.hasOwnProperty(key2)) {
          var validator2 = validators[key2];
          if (validator2(str2)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isIdentityCard, isIdentityCard.exports);
var isIdentityCardExports = isIdentityCard.exports;
var isEAN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEAN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var LENGTH_EAN_8 = 8;
  var LENGTH_EAN_14 = 14;
  var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
  function getPositionWeightThroughLengthAndIndex(length2, index2) {
    if (length2 === LENGTH_EAN_8 || length2 === LENGTH_EAN_14) {
      return index2 % 2 === 0 ? 3 : 1;
    }
    return index2 % 2 === 0 ? 1 : 3;
  }
  function calculateCheckDigit(ean) {
    var checksum = ean.slice(0, -1).split("").map(function(char2, index2) {
      return Number(char2) * getPositionWeightThroughLengthAndIndex(ean.length, index2);
    }).reduce(function(acc, partialSum) {
      return acc + partialSum;
    }, 0);
    var remainder = 10 - checksum % 10;
    return remainder < 10 ? remainder : 0;
  }
  function isEAN2(str2) {
    (0, _assertString2.default)(str2);
    var actualCheckDigit = Number(str2.slice(-1));
    return validEanRegex.test(str2) && actualCheckDigit === calculateCheckDigit(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEAN, isEAN.exports);
var isEANExports = isEAN.exports;
var isISIN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISIN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
  function isISIN2(str2) {
    (0, _assertString2.default)(str2);
    if (!isin.test(str2)) {
      return false;
    }
    var double = true;
    var sum = 0;
    for (var i = str2.length - 2; i >= 0; i--) {
      if (str2[i] >= "A" && str2[i] <= "Z") {
        var value = str2[i].charCodeAt(0) - 55;
        var lo = value % 10;
        var hi2 = Math.trunc(value / 10);
        for (var _i = 0, _arr = [lo, hi2]; _i < _arr.length; _i++) {
          var digit = _arr[_i];
          if (double) {
            if (digit >= 5) {
              sum += 1 + (digit - 5) * 2;
            } else {
              sum += digit * 2;
            }
          } else {
            sum += digit;
          }
          double = !double;
        }
      } else {
        var _digit = str2[i].charCodeAt(0) - "0".charCodeAt(0);
        if (double) {
          if (_digit >= 5) {
            sum += 1 + (_digit - 5) * 2;
          } else {
            sum += _digit * 2;
          }
        } else {
          sum += _digit;
        }
        double = !double;
      }
    }
    var check = Math.trunc((sum + 9) / 10) * 10 - sum;
    return +str2[str2.length - 1] === check;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISIN, isISIN.exports);
var isISINExports = isISIN.exports;
var isISBN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISBN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
  var possibleIsbn13 = /^(?:[0-9]{13})$/;
  var factor = [1, 3];
  function isISBN2(isbn, options2) {
    (0, _assertString2.default)(isbn);
    var version2 = String((options2 === null || options2 === void 0 ? void 0 : options2.version) || options2);
    if (!(options2 !== null && options2 !== void 0 && options2.version || options2)) {
      return isISBN2(isbn, {
        version: 10
      }) || isISBN2(isbn, {
        version: 13
      });
    }
    var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
    var checksum = 0;
    if (version2 === "10") {
      if (!possibleIsbn10.test(sanitizedIsbn)) {
        return false;
      }
      for (var i = 0; i < version2 - 1; i++) {
        checksum += (i + 1) * sanitizedIsbn.charAt(i);
      }
      if (sanitizedIsbn.charAt(9) === "X") {
        checksum += 10 * 10;
      } else {
        checksum += 10 * sanitizedIsbn.charAt(9);
      }
      if (checksum % 11 === 0) {
        return true;
      }
    } else if (version2 === "13") {
      if (!possibleIsbn13.test(sanitizedIsbn)) {
        return false;
      }
      for (var _i = 0; _i < 12; _i++) {
        checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
      }
      if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
        return true;
      }
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISBN, isISBN.exports);
var isISBNExports = isISBN.exports;
var isISSN = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISSN2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var issn = "^\\d{4}-?\\d{3}[\\dX]$";
  function isISSN2(str2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(str2);
    var testIssn = issn;
    testIssn = options2.require_hyphen ? testIssn.replace("?", "") : testIssn;
    testIssn = options2.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
    if (!testIssn.test(str2)) {
      return false;
    }
    var digits = str2.replace("-", "").toUpperCase();
    var checksum = 0;
    for (var i = 0; i < digits.length; i++) {
      var digit = digits[i];
      checksum += (digit === "X" ? 10 : +digit) * (8 - i);
    }
    return checksum % 11 === 0;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISSN, isISSN.exports);
var isISSNExports = isISSN.exports;
var isTaxID = { exports: {} };
var algorithms$1 = {};
Object.defineProperty(algorithms$1, "__esModule", {
  value: true
});
algorithms$1.iso7064Check = iso7064Check;
algorithms$1.luhnCheck = luhnCheck;
algorithms$1.reverseMultiplyAndSum = reverseMultiplyAndSum;
algorithms$1.verhoeffCheck = verhoeffCheck;
function iso7064Check(str2) {
  var checkvalue = 10;
  for (var i = 0; i < str2.length - 1; i++) {
    checkvalue = (parseInt(str2[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str2[i], 10) + checkvalue) % 10 * 2 % 11;
  }
  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
  return checkvalue === parseInt(str2[10], 10);
}
function luhnCheck(str2) {
  var checksum = 0;
  var second = false;
  for (var i = str2.length - 1; i >= 0; i--) {
    if (second) {
      var product = parseInt(str2[i], 10) * 2;
      if (product > 9) {
        checksum += product.toString().split("").map(function(a) {
          return parseInt(a, 10);
        }).reduce(function(a, b2) {
          return a + b2;
        }, 0);
      } else {
        checksum += product;
      }
    } else {
      checksum += parseInt(str2[i], 10);
    }
    second = !second;
  }
  return checksum % 10 === 0;
}
function reverseMultiplyAndSum(digits, base) {
  var total = 0;
  for (var i = 0; i < digits.length; i++) {
    total += digits[i] * (base - i);
  }
  return total;
}
function verhoeffCheck(str2) {
  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
  var str_copy = str2.split("").reverse().join("");
  var checksum = 0;
  for (var i = 0; i < str_copy.length; i++) {
    checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];
  }
  return checksum === 0;
}
(function(module, exports) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTaxID2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var algorithms2 = _interopRequireWildcard2(algorithms$1);
  var _isDate = _interopRequireDefault2(isDateExports);
  function _getRequireWildcardCache2() {
    if (typeof WeakMap !== "function")
      return null;
    var cache2 = /* @__PURE__ */ new WeakMap();
    _getRequireWildcardCache2 = function _getRequireWildcardCache3() {
      return cache2;
    };
    return cache2;
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2();
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key2, desc);
        } else {
          newObj[key2] = obj[key2];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _toConsumableArray2(arr) {
    return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
  }
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o, minLen);
  }
  function _iterableToArray2(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles2(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function bgBgCheck(tin) {
    var century_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 40) {
      month -= 40;
      century_year = "20".concat(century_year);
    } else if (month > 20) {
      month -= 20;
      century_year = "18".concat(century_year);
    } else {
      century_year = "19".concat(century_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
    var checksum = 0;
    for (var i = 0; i < multip_lookup.length; i++) {
      checksum += digits[i] * multip_lookup[i];
    }
    checksum = checksum % 11 === 10 ? 0 : checksum % 11;
    return checksum === digits[9];
  }
  function isCanadianSIN(input) {
    var digitsArray = input.split("");
    var even = digitsArray.filter(function(_2, idx) {
      return idx % 2;
    }).map(function(i) {
      return Number(i) * 2;
    }).join("").split("");
    var total = digitsArray.filter(function(_2, idx) {
      return !(idx % 2);
    }).concat(even).map(function(i) {
      return Number(i);
    }).reduce(function(acc, cur) {
      return acc + cur;
    });
    return total % 10 === 0;
  }
  function csCzCheck(tin) {
    tin = tin.replace(/\W/, "");
    var full_year = parseInt(tin.slice(0, 2), 10);
    if (tin.length === 10) {
      if (full_year < 54) {
        full_year = "20".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
    } else {
      if (tin.slice(6) === "000") {
        return false;
      }
      if (full_year < 54) {
        full_year = "19".concat(full_year);
      } else {
        return false;
      }
    }
    if (full_year.length === 3) {
      full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
    }
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 50) {
      month -= 50;
    }
    if (month > 20) {
      if (parseInt(full_year, 10) < 2004) {
        return false;
      }
      month -= 20;
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    if (tin.length === 10) {
      if (parseInt(tin, 10) % 11 !== 0) {
        var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
        if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
          if (parseInt(tin.slice(9), 10) !== 0) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  function deAtCheck(tin) {
    return algorithms2.luhnCheck(tin);
  }
  function deDeCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var occurences = [];
    for (var i = 0; i < digits.length - 1; i++) {
      occurences.push("");
      for (var j = 0; j < digits.length - 1; j++) {
        if (digits[i] === digits[j]) {
          occurences[i] += j;
        }
      }
    }
    occurences = occurences.filter(function(a) {
      return a.length > 1;
    });
    if (occurences.length !== 2 && occurences.length !== 3) {
      return false;
    }
    if (occurences[0].length === 3) {
      var trip_locations = occurences[0].split("").map(function(a) {
        return parseInt(a, 10);
      });
      var recurrent = 0;
      for (var _i = 0; _i < trip_locations.length - 1; _i++) {
        if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
          recurrent += 1;
        }
      }
      if (recurrent === 2) {
        return false;
      }
    }
    return algorithms2.iso7064Check(tin);
  }
  function dkDkCheck(tin) {
    tin = tin.replace(/\W/, "");
    var year = parseInt(tin.slice(4, 6), 10);
    var century_digit = tin.slice(6, 7);
    switch (century_digit) {
      case "0":
      case "1":
      case "2":
      case "3":
        year = "19".concat(year);
        break;
      case "4":
      case "9":
        if (year < 37) {
          year = "20".concat(year);
        } else {
          year = "19".concat(year);
        }
        break;
      default:
        if (year < 37) {
          year = "20".concat(year);
        } else if (year > 58) {
          year = "18".concat(year);
        } else {
          return false;
        }
        break;
    }
    if (year.length === 3) {
      year = [year.slice(0, 2), "0", year.slice(2)].join("");
    }
    var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum = 0;
    var weight = 4;
    for (var i = 0; i < 9; i++) {
      checksum += digits[i] * weight;
      weight -= 1;
      if (weight === 1) {
        weight = 7;
      }
    }
    checksum %= 11;
    if (checksum === 1) {
      return false;
    }
    return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
  }
  function elCyCheck(tin) {
    var digits = tin.slice(0, 8).split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum = 0;
    for (var i = 1; i < digits.length; i += 2) {
      checksum += digits[i];
    }
    for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
      if (digits[_i2] < 2) {
        checksum += 1 - digits[_i2];
      } else {
        checksum += 2 * (digits[_i2] - 2) + 5;
        if (digits[_i2] > 4) {
          checksum += 2;
        }
      }
    }
    return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
  }
  function elGrCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum = 0;
    for (var i = 0; i < 8; i++) {
      checksum += digits[i] * Math.pow(2, 8 - i);
    }
    return checksum % 11 % 10 === digits[8];
  }
  function enIeCheck(tin) {
    var checksum = algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
      return parseInt(a, 10);
    }), 8);
    if (tin.length === 9 && tin[8] !== "W") {
      checksum += (tin[8].charCodeAt(0) - 64) * 9;
    }
    checksum %= 23;
    if (checksum === 0) {
      return tin[7].toUpperCase() === "W";
    }
    return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
  }
  var enUsCampusPrefix = {
    andover: ["10", "12"],
    atlanta: ["60", "67"],
    austin: ["50", "53"],
    brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
    cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
    fresno: ["15", "24"],
    internet: ["20", "26", "27", "45", "46", "47"],
    kansas: ["40", "44"],
    memphis: ["94", "95"],
    ogden: ["80", "90"],
    philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
    sba: ["31"]
  };
  function enUsGetPrefixes() {
    var prefixes = [];
    for (var location in enUsCampusPrefix) {
      if (enUsCampusPrefix.hasOwnProperty(location)) {
        prefixes.push.apply(prefixes, _toConsumableArray2(enUsCampusPrefix[location]));
      }
    }
    return prefixes;
  }
  function enUsCheck(tin) {
    return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
  }
  function esEsCheck(tin) {
    var chars = tin.toUpperCase().split("");
    if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
      var lead_replace = 0;
      switch (chars[0]) {
        case "Y":
          lead_replace = 1;
          break;
        case "Z":
          lead_replace = 2;
          break;
      }
      chars.splice(0, 1, lead_replace);
    } else {
      while (chars.length < 9) {
        chars.unshift(0);
      }
    }
    var lookup2 = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
    chars = chars.join("");
    var checksum = parseInt(chars.slice(0, 8), 10) % 23;
    return chars[8] === lookup2[checksum];
  }
  function etEeCheck(tin) {
    var full_year = tin.slice(1, 3);
    var century_digit = tin.slice(0, 1);
    switch (century_digit) {
      case "1":
      case "2":
        full_year = "18".concat(full_year);
        break;
      case "3":
      case "4":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum = 0;
    var weight = 1;
    for (var i = 0; i < 10; i++) {
      checksum += digits[i] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum % 11 === 10) {
      checksum = 0;
      weight = 3;
      for (var _i3 = 0; _i3 < 10; _i3++) {
        checksum += digits[_i3] * weight;
        weight += 1;
        if (weight === 10) {
          weight = 1;
        }
      }
      if (checksum % 11 === 10) {
        return digits[10] === 0;
      }
    }
    return checksum % 11 === digits[10];
  }
  function fiFiCheck(tin) {
    var full_year = tin.slice(4, 6);
    var century_symbol = tin.slice(6, 7);
    switch (century_symbol) {
      case "+":
        full_year = "18".concat(full_year);
        break;
      case "-":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
    if (checksum < 10) {
      return checksum === parseInt(tin.slice(10), 10);
    }
    checksum -= 10;
    var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
    return letters_lookup[checksum] === tin.slice(10);
  }
  function frBeCheck(tin) {
    if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
      var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
    }
    var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
    var checkdigits = parseInt(tin.slice(9, 11), 10);
    if (checksum !== checkdigits) {
      checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
      if (checksum !== checkdigits) {
        return false;
      }
    }
    return true;
  }
  function frFrCheck(tin) {
    tin = tin.replace(/\s/g, "");
    var checksum = parseInt(tin.slice(0, 10), 10) % 511;
    var checkdigits = parseInt(tin.slice(10, 13), 10);
    return checksum === checkdigits;
  }
  function frLuCheck(tin) {
    var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    if (!algorithms2.luhnCheck(tin.slice(0, 12))) {
      return false;
    }
    return algorithms2.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
  }
  function hrHrCheck(tin) {
    return algorithms2.iso7064Check(tin);
  }
  function huHuCheck(tin) {
    var digits = tin.split("").map(function(a) {
      return parseInt(a, 10);
    });
    var checksum = 8;
    for (var i = 1; i < 9; i++) {
      checksum += digits[i] * (i + 1);
    }
    return checksum % 11 === digits[9];
  }
  function itItNameCheck(name2) {
    var vowelflag = false;
    var xflag = false;
    for (var i = 0; i < 3; i++) {
      if (!vowelflag && /[AEIOU]/.test(name2[i])) {
        vowelflag = true;
      } else if (!xflag && vowelflag && name2[i] === "X") {
        xflag = true;
      } else if (i > 0) {
        if (vowelflag && !xflag) {
          if (!/[AEIOU]/.test(name2[i])) {
            return false;
          }
        }
        if (xflag) {
          if (!/X/.test(name2[i])) {
            return false;
          }
        }
      }
    }
    return true;
  }
  function itItCheck(tin) {
    var chars = tin.toUpperCase().split("");
    if (!itItNameCheck(chars.slice(0, 3))) {
      return false;
    }
    if (!itItNameCheck(chars.slice(3, 6))) {
      return false;
    }
    var number_locations = [6, 7, 9, 10, 12, 13, 14];
    var number_replace = {
      L: "0",
      M: "1",
      N: "2",
      P: "3",
      Q: "4",
      R: "5",
      S: "6",
      T: "7",
      U: "8",
      V: "9"
    };
    for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
      var i = _number_locations[_i4];
      if (chars[i] in number_replace) {
        chars.splice(i, 1, number_replace[chars[i]]);
      }
    }
    var month_replace = {
      A: "01",
      B: "02",
      C: "03",
      D: "04",
      E: "05",
      H: "06",
      L: "07",
      M: "08",
      P: "09",
      R: "10",
      S: "11",
      T: "12"
    };
    var month = month_replace[chars[8]];
    var day = parseInt(chars[9] + chars[10], 10);
    if (day > 40) {
      day -= 40;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
    if (!(0, _isDate.default)(date, "YY/MM/DD")) {
      return false;
    }
    var checksum = 0;
    for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
      var char_to_int = parseInt(chars[_i5], 10);
      if (isNaN(char_to_int)) {
        char_to_int = chars[_i5].charCodeAt(0) - 65;
      }
      checksum += char_to_int;
    }
    var odd_convert = {
      // Maps of characters at odd places
      A: 1,
      B: 0,
      C: 5,
      D: 7,
      E: 9,
      F: 13,
      G: 15,
      H: 17,
      I: 19,
      J: 21,
      K: 2,
      L: 4,
      M: 18,
      N: 20,
      O: 11,
      P: 3,
      Q: 6,
      R: 8,
      S: 12,
      T: 14,
      U: 16,
      V: 10,
      W: 22,
      X: 25,
      Y: 24,
      Z: 23,
      0: 1,
      1: 0
    };
    for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
      var _char_to_int = 0;
      if (chars[_i6] in odd_convert) {
        _char_to_int = odd_convert[chars[_i6]];
      } else {
        var multiplier = parseInt(chars[_i6], 10);
        _char_to_int = 2 * multiplier + 1;
        if (multiplier > 4) {
          _char_to_int += 2;
        }
      }
      checksum += _char_to_int;
    }
    if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
      return false;
    }
    return true;
  }
  function lvLvCheck(tin) {
    tin = tin.replace(/\W/, "");
    var day = tin.slice(0, 2);
    if (day !== "32") {
      var month = tin.slice(2, 4);
      if (month !== "00") {
        var full_year = tin.slice(4, 6);
        switch (tin[6]) {
          case "0":
            full_year = "18".concat(full_year);
            break;
          case "1":
            full_year = "19".concat(full_year);
            break;
          default:
            full_year = "20".concat(full_year);
            break;
        }
        var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
      }
      var checksum = 1101;
      var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
      for (var i = 0; i < tin.length - 1; i++) {
        checksum -= parseInt(tin[i], 10) * multip_lookup[i];
      }
      return parseInt(tin[10], 10) === checksum % 11;
    }
    return true;
  }
  function mtMtCheck(tin) {
    if (tin.length !== 9) {
      var chars = tin.toUpperCase().split("");
      while (chars.length < 8) {
        chars.unshift(0);
      }
      switch (tin[7]) {
        case "A":
        case "P":
          if (parseInt(chars[6], 10) === 0) {
            return false;
          }
          break;
        default: {
          var first_part = parseInt(chars.join("").slice(0, 5), 10);
          if (first_part > 32e3) {
            return false;
          }
          var second_part = parseInt(chars.join("").slice(5, 7), 10);
          if (first_part === second_part) {
            return false;
          }
        }
      }
    }
    return true;
  }
  function nlNlCheck(tin) {
    return algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
      return parseInt(a, 10);
    }), 9) % 11 === parseInt(tin[8], 10);
  }
  function plPlCheck(tin) {
    if (tin.length === 10) {
      var lookup2 = [6, 5, 7, 2, 3, 4, 5, 6, 7];
      var _checksum = 0;
      for (var i = 0; i < lookup2.length; i++) {
        _checksum += parseInt(tin[i], 10) * lookup2[i];
      }
      _checksum %= 11;
      if (_checksum === 10) {
        return false;
      }
      return _checksum === parseInt(tin[9], 10);
    }
    var full_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 80) {
      full_year = "18".concat(full_year);
      month -= 80;
    } else if (month > 60) {
      full_year = "22".concat(full_year);
      month -= 60;
    } else if (month > 40) {
      full_year = "21".concat(full_year);
      month -= 40;
    } else if (month > 20) {
      full_year = "20".concat(full_year);
      month -= 20;
    } else {
      full_year = "19".concat(full_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    var checksum = 0;
    var multiplier = 1;
    for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
      checksum += parseInt(tin[_i7], 10) * multiplier % 10;
      multiplier += 2;
      if (multiplier > 10) {
        multiplier = 1;
      } else if (multiplier === 5) {
        multiplier += 2;
      }
    }
    checksum = 10 - checksum % 10;
    return checksum === parseInt(tin[10], 10);
  }
  function ptBrCheck(tin) {
    if (tin.length === 11) {
      var _sum;
      var remainder;
      _sum = 0;
      if (
        // Reject known invalid CPFs
        tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000"
      )
        return false;
      for (var i = 1; i <= 9; i++) {
        _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
      }
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(9, 10), 10))
        return false;
      _sum = 0;
      for (var _i8 = 1; _i8 <= 10; _i8++) {
        _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
      }
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(10, 11), 10))
        return false;
      return true;
    }
    if (
      // Reject know invalid CNPJs
      tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999"
    ) {
      return false;
    }
    var length2 = tin.length - 2;
    var identifiers = tin.substring(0, length2);
    var verificators = tin.substring(length2);
    var sum = 0;
    var pos = length2 - 7;
    for (var _i9 = length2; _i9 >= 1; _i9--) {
      sum += identifiers.charAt(length2 - _i9) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(0), 10)) {
      return false;
    }
    length2 += 1;
    identifiers = tin.substring(0, length2);
    sum = 0;
    pos = length2 - 7;
    for (var _i10 = length2; _i10 >= 1; _i10--) {
      sum += identifiers.charAt(length2 - _i10) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(1), 10)) {
      return false;
    }
    return true;
  }
  function ptPtCheck(tin) {
    var checksum = 11 - algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
      return parseInt(a, 10);
    }), 9) % 11;
    if (checksum > 9) {
      return parseInt(tin[8], 10) === 0;
    }
    return checksum === parseInt(tin[8], 10);
  }
  function roRoCheck(tin) {
    if (tin.slice(0, 4) !== "9000") {
      var full_year = tin.slice(1, 3);
      switch (tin[0]) {
        case "1":
        case "2":
          full_year = "19".concat(full_year);
          break;
        case "3":
        case "4":
          full_year = "18".concat(full_year);
          break;
        case "5":
        case "6":
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
      if (date.length === 8) {
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
      var checksum = 0;
      for (var i = 0; i < multipliers.length; i++) {
        checksum += digits[i] * multipliers[i];
      }
      if (checksum % 11 === 10) {
        return digits[12] === 1;
      }
      return digits[12] === checksum % 11;
    }
    return true;
  }
  function skSkCheck(tin) {
    if (tin.length === 9) {
      tin = tin.replace(/\W/, "");
      if (tin.slice(6) === "000") {
        return false;
      }
      var full_year = parseInt(tin.slice(0, 2), 10);
      if (full_year > 53) {
        return false;
      }
      if (full_year < 10) {
        full_year = "190".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 50) {
        month -= 50;
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
    }
    return true;
  }
  function slSiCheck(tin) {
    var checksum = 11 - algorithms2.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
      return parseInt(a, 10);
    }), 8) % 11;
    if (checksum === 10) {
      return parseInt(tin[7], 10) === 0;
    }
    return checksum === parseInt(tin[7], 10);
  }
  function svSeCheck(tin) {
    var tin_copy = tin.slice(0);
    if (tin.length > 11) {
      tin_copy = tin_copy.slice(2);
    }
    var full_year = "";
    var month = tin_copy.slice(2, 4);
    var day = parseInt(tin_copy.slice(4, 6), 10);
    if (tin.length > 11) {
      full_year = tin.slice(0, 4);
    } else {
      full_year = tin.slice(0, 2);
      if (tin.length === 11 && day < 60) {
        var current_year = (/* @__PURE__ */ new Date()).getFullYear().toString();
        var current_century = parseInt(current_year.slice(0, 2), 10);
        current_year = parseInt(current_year, 10);
        if (tin[6] === "-") {
          if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
            full_year = "".concat(current_century - 1).concat(full_year);
          } else {
            full_year = "".concat(current_century).concat(full_year);
          }
        } else {
          full_year = "".concat(current_century - 1).concat(full_year);
          if (current_year - parseInt(full_year, 10) < 100) {
            return false;
          }
        }
      }
    }
    if (day > 60) {
      day -= 60;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date = "".concat(full_year, "/").concat(month, "/").concat(day);
    if (date.length === 8) {
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
    } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
      return false;
    }
    return algorithms2.luhnCheck(tin.replace(/\W/, ""));
  }
  var taxIdFormat = {
    "bg-BG": /^\d{10}$/,
    "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
    "de-AT": /^\d{9}$/,
    "de-DE": /^[1-9]\d{10}$/,
    "dk-DK": /^\d{6}-{0,1}\d{4}$/,
    "el-CY": /^[09]\d{7}[A-Z]$/,
    "el-GR": /^([0-4]|[7-9])\d{8}$/,
    "en-CA": /^\d{9}$/,
    "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
    "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
    "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
    "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
    "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
    "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
    "fr-BE": /^\d{11}$/,
    "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
    // Conforms both to official spec and provided example
    "fr-LU": /^\d{13}$/,
    "hr-HR": /^\d{11}$/,
    "hu-HU": /^8\d{9}$/,
    "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
    "lv-LV": /^\d{6}-{0,1}\d{5}$/,
    // Conforms both to DG TAXUD spec and original research
    "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
    "nl-NL": /^\d{9}$/,
    "pl-PL": /^\d{10,11}$/,
    "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
    "pt-PT": /^\d{9}$/,
    "ro-RO": /^\d{13}$/,
    "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
    "sl-SI": /^[1-9]\d{7}$/,
    "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/
  };
  taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
  taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
  taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
  taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
  var taxIdCheck = {
    "bg-BG": bgBgCheck,
    "cs-CZ": csCzCheck,
    "de-AT": deAtCheck,
    "de-DE": deDeCheck,
    "dk-DK": dkDkCheck,
    "el-CY": elCyCheck,
    "el-GR": elGrCheck,
    "en-CA": isCanadianSIN,
    "en-IE": enIeCheck,
    "en-US": enUsCheck,
    "es-ES": esEsCheck,
    "et-EE": etEeCheck,
    "fi-FI": fiFiCheck,
    "fr-BE": frBeCheck,
    "fr-FR": frFrCheck,
    "fr-LU": frLuCheck,
    "hr-HR": hrHrCheck,
    "hu-HU": huHuCheck,
    "it-IT": itItCheck,
    "lv-LV": lvLvCheck,
    "mt-MT": mtMtCheck,
    "nl-NL": nlNlCheck,
    "pl-PL": plPlCheck,
    "pt-BR": ptBrCheck,
    "pt-PT": ptPtCheck,
    "ro-RO": roRoCheck,
    "sk-SK": skSkCheck,
    "sl-SI": slSiCheck,
    "sv-SE": svSeCheck
  };
  taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
  taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
  taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
  taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
  var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
  var sanitizeRegexes = {
    "de-AT": allsymbols,
    "de-DE": /[\/\\]/g,
    "fr-BE": allsymbols
  };
  sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
  function isTaxID2(str2) {
    var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
    (0, _assertString2.default)(str2);
    var strcopy = str2.slice(0);
    if (locale in taxIdFormat) {
      if (locale in sanitizeRegexes) {
        strcopy = strcopy.replace(sanitizeRegexes[locale], "");
      }
      if (!taxIdFormat[locale].test(strcopy)) {
        return false;
      }
      if (locale in taxIdCheck) {
        return taxIdCheck[locale](strcopy);
      }
      return true;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isTaxID, isTaxID.exports);
var isTaxIDExports = isTaxID.exports;
var isMobilePhone$1 = {};
Object.defineProperty(isMobilePhone$1, "__esModule", {
  value: true
});
isMobilePhone$1.default = isMobilePhone;
isMobilePhone$1.locales = void 0;
var _assertString$4 = _interopRequireDefault$4(assertStringExports);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var phones = {
  "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
  "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
  "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
  "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
  "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
  "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
  "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
  "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
  "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
  "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
  "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
  "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
  "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
  "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
  "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
  "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
  "ar-TN": /^(\+?216)?[2459]\d{7}$/,
  "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
  "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
  "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
  "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
  "ca-AD": /^(\+376)?[346]\d{5}$/,
  "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
  "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
  "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
  "de-LU": /^(\+352)?((6\d1)\d{6})$/,
  "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
  "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
  "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
  "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
  "en-AU": /^(\+?61|0)4\d{8}$/,
  "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
  "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
  "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
  "en-GB": /^(\+?44|0)7\d{9}$/,
  "en-GG": /^(\+?44|0)1481\d{6}$/,
  "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
  "en-GY": /^(\+592|0)6\d{6}$/,
  "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
  "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
  "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
  "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
  "en-JM": /^(\+?876)?\d{7}$/,
  "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
  "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
  "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
  "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
  "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
  "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
  "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
  "en-MU": /^(\+?230|0)?\d{8}$/,
  "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
  "en-NG": /^(\+?234|0)?[789]\d{9}$/,
  "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
  "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
  "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
  "en-PH": /^(09|\+639)\d{9}$/,
  "en-RW": /^(\+?250|0)?[7]\d{8}$/,
  "en-SG": /^(\+65)?[3689]\d{7}$/,
  "en-SL": /^(\+?232|0)\d{8}$/,
  "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
  "en-UG": /^(\+?256|0)?[7]\d{8}$/,
  "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  "en-ZA": /^(\+?27|0)\d{9}$/,
  "en-ZM": /^(\+?26)?09[567]\d{7}$/,
  "en-ZW": /^(\+263)[0-9]{9}$/,
  "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
  "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
  "es-BO": /^(\+?591)?(6|7)\d{7}$/,
  "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
  "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
  "es-CR": /^(\+506)?[2-8]\d{7}$/,
  "es-CU": /^(\+53|0053)?5\d{7}$/,
  "es-DO": /^(\+?1)?8[024]9\d{7}$/,
  "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
  "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
  "es-ES": /^(\+?34)?[6|7]\d{8}$/,
  "es-PE": /^(\+?51)?9\d{8}$/,
  "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
  "es-NI": /^(\+?505)\d{7,8}$/,
  "es-PA": /^(\+?507)\d{7,8}$/,
  "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
  "es-SV": /^(\+?503)?[67]\d{7}$/,
  "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
  "es-VE": /^(\+?58)?(2|4)\d{9}$/,
  "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
  "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
  "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "fr-BF": /^(\+226|0)[67]\d{7}$/,
  "fr-BJ": /^(\+229)\d{8}$/,
  "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
  "fr-CM": /^(\+?237)6[0-9]{8}$/,
  "fr-FR": /^(\+?33|0)[67]\d{8}$/,
  "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
  "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
  "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
  "fr-PF": /^(\+?689)?8[789]\d{6}$/,
  "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
  "fr-WF": /^(\+681)?\d{6}$/,
  "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
  "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  "ir-IR": /^(\+98|0)?9\d{9}$/,
  "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
  "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
  "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
  "kk-KZ": /^(\+?7|8)?7\d{9}$/,
  "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
  "lt-LT": /^(\+370|8)\d{8}$/,
  "lv-LV": /^(\+?371)2\d{7}$/,
  "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
  "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
  "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
  "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
  "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
  "nb-NO": /^(\+?47)?[49]\d{7}$/,
  "ne-NP": /^(\+?977)?9[78]\d{8}$/,
  "nl-BE": /^(\+?32|0)4\d{8}$/,
  "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
  "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
  "nn-NO": /^(\+?47)?[49]\d{7}$/,
  "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
  "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
  "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
  "pt-AO": /^(\+244)\d{9}$/,
  "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
  "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
  "ru-RU": /^(\+?7|8)?9\d{9}$/,
  "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
  "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
  "sq-AL": /^(\+355|0)6[789]\d{6}$/,
  "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
  "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
  "th-TH": /^(\+66|66|0)\d{9}$/,
  "tr-TR": /^(\+?90|0)?5\d{9}$/,
  "tk-TM": /^(\+993|993|8)\d{8}$/,
  "uk-UA": /^(\+?38|8)?0\d{9}$/,
  "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
  "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
  "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
  "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
  "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
  "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
  "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
  "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
};
phones["en-CA"] = phones["en-US"];
phones["fr-CA"] = phones["en-CA"];
phones["fr-BE"] = phones["nl-BE"];
phones["zh-HK"] = phones["en-HK"];
phones["zh-MO"] = phones["en-MO"];
phones["ga-IE"] = phones["en-IE"];
phones["fr-CH"] = phones["de-CH"];
phones["it-CH"] = phones["fr-CH"];
function isMobilePhone(str2, locale, options2) {
  (0, _assertString$4.default)(str2);
  if (options2 && options2.strictMode && !str2.startsWith("+")) {
    return false;
  }
  if (Array.isArray(locale)) {
    return locale.some(function(key3) {
      if (phones.hasOwnProperty(key3)) {
        var phone2 = phones[key3];
        if (phone2.test(str2)) {
          return true;
        }
      }
      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str2);
  } else if (!locale || locale === "any") {
    for (var key2 in phones) {
      if (phones.hasOwnProperty(key2)) {
        var phone = phones[key2];
        if (phone.test(str2)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales$1 = Object.keys(phones);
isMobilePhone$1.locales = locales$1;
var isEthereumAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEthereumAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var eth = /^(0x)[0-9a-f]{40}$/i;
  function isEthereumAddress2(str2) {
    (0, _assertString2.default)(str2);
    return eth.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isEthereumAddress, isEthereumAddress.exports);
var isEthereumAddressExports = isEthereumAddress.exports;
var isCurrency = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCurrency2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function currencyRegex(options2) {
    var decimal_digits = "\\d{".concat(options2.digits_after_decimal[0], "}");
    options2.digits_after_decimal.forEach(function(digit, index2) {
      if (index2 !== 0)
        decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
    });
    var symbol = "(".concat(options2.symbol.replace(/\W/, function(m2) {
      return "\\".concat(m2);
    }), ")").concat(options2.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options2.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options2.decimal_separator, "(").concat(decimal_digits, "))").concat(options2.require_decimal ? "" : "?");
    var pattern = whole_dollar_amount + (options2.allow_decimal || options2.require_decimal ? decimal_amount : "");
    if (options2.allow_negatives && !options2.parens_for_negatives) {
      if (options2.negative_sign_after_digits) {
        pattern += negative;
      } else if (options2.negative_sign_before_digits) {
        pattern = negative + pattern;
      }
    }
    if (options2.allow_negative_sign_placeholder) {
      pattern = "( (?!\\-))?".concat(pattern);
    } else if (options2.allow_space_after_symbol) {
      pattern = " ?".concat(pattern);
    } else if (options2.allow_space_after_digits) {
      pattern += "( (?!$))?";
    }
    if (options2.symbol_after_digits) {
      pattern += symbol;
    } else {
      pattern = symbol + pattern;
    }
    if (options2.allow_negatives) {
      if (options2.parens_for_negatives) {
        pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
      } else if (!(options2.negative_sign_before_digits || options2.negative_sign_after_digits)) {
        pattern = negative + pattern;
      }
    }
    return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
  }
  var default_currency_options = {
    symbol: "$",
    require_symbol: false,
    allow_space_after_symbol: false,
    symbol_after_digits: false,
    allow_negatives: true,
    parens_for_negatives: false,
    negative_sign_before_digits: false,
    negative_sign_after_digits: false,
    allow_negative_sign_placeholder: false,
    thousands_separator: ",",
    decimal_separator: ".",
    allow_decimal: true,
    require_decimal: false,
    digits_after_decimal: [2],
    allow_space_after_digits: false
  };
  function isCurrency2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, default_currency_options);
    return currencyRegex(options2).test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isCurrency, isCurrency.exports);
var isCurrencyExports = isCurrency.exports;
var isBtcAddress = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBtcAddress2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
  var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
  function isBtcAddress2(str2) {
    (0, _assertString2.default)(str2);
    return bech32.test(str2) || base58.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBtcAddress, isBtcAddress.exports);
var isBtcAddressExports = isBtcAddress.exports;
var isISO6346$1 = {};
Object.defineProperty(isISO6346$1, "__esModule", {
  value: true
});
isISO6346$1.isISO6346 = isISO6346;
isISO6346$1.isFreightContainerID = void 0;
var _assertString$3 = _interopRequireDefault$3(assertStringExports);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
var isDigit = /^[0-9]$/;
function isISO6346(str2) {
  (0, _assertString$3.default)(str2);
  str2 = str2.toUpperCase();
  if (!isISO6346Str.test(str2))
    return false;
  if (str2.length === 11) {
    var sum = 0;
    for (var i = 0; i < str2.length - 1; i++) {
      if (!isDigit.test(str2[i])) {
        var convertedCode = void 0;
        var letterCode = str2.charCodeAt(i) - 55;
        if (letterCode < 11)
          convertedCode = letterCode;
        else if (letterCode >= 11 && letterCode <= 20)
          convertedCode = 12 + letterCode % 11;
        else if (letterCode >= 21 && letterCode <= 30)
          convertedCode = 23 + letterCode % 21;
        else
          convertedCode = 34 + letterCode % 31;
        sum += convertedCode * Math.pow(2, i);
      } else
        sum += str2[i] * Math.pow(2, i);
    }
    var checkSumDigit = sum % 11;
    return Number(str2[str2.length - 1]) === checkSumDigit;
  }
  return true;
}
var isFreightContainerID = isISO6346;
isISO6346$1.isFreightContainerID = isFreightContainerID;
var isISO6391 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO63912;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var isISO6391Set = /* @__PURE__ */ new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
  function isISO63912(str2) {
    (0, _assertString2.default)(str2);
    return isISO6391Set.has(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO6391, isISO6391.exports);
var isISO6391Exports = isISO6391.exports;
var isISO8601 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO86012;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var isValidDate = function isValidDate2(str2) {
    var ordinalMatch = str2.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
      var oYear = Number(ordinalMatch[1]);
      var oDay = Number(ordinalMatch[2]);
      if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
        return oDay <= 366;
      return oDay <= 365;
    }
    var match2 = str2.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    var year = match2[1];
    var month = match2[2];
    var day = match2[3];
    var monthString = month ? "0".concat(month).slice(-2) : month;
    var dayString = day ? "0".concat(day).slice(-2) : day;
    var d2 = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
    if (month && day) {
      return d2.getUTCFullYear() === year && d2.getUTCMonth() + 1 === month && d2.getUTCDate() === day;
    }
    return true;
  };
  function isISO86012(str2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString2.default)(str2);
    var check = options2.strictSeparator ? iso8601StrictSeparator.test(str2) : iso8601.test(str2);
    if (check && options2.strict)
      return isValidDate(str2);
    return check;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO8601, isISO8601.exports);
var isISO8601Exports = isISO8601.exports;
var isRFC3339 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRFC33392;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var dateFullYear = /[0-9]{4}/;
  var dateMonth = /(0[1-9]|1[0-2])/;
  var dateMDay = /([12]\d|0[1-9]|3[01])/;
  var timeHour = /([01][0-9]|2[0-3])/;
  var timeMinute = /[0-5][0-9]/;
  var timeSecond = /([0-5][0-9]|60)/;
  var timeSecFrac = /(\.[0-9]+)?/;
  var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
  var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
  var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
  var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
  var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
  var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
  function isRFC33392(str2) {
    (0, _assertString2.default)(str2);
    return rfc3339.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isRFC3339, isRFC3339.exports);
var isRFC3339Exports = isRFC3339.exports;
var isISO31661Alpha3 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO31661Alpha32;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
  function isISO31661Alpha32(str2) {
    (0, _assertString2.default)(str2);
    return validISO31661Alpha3CountriesCodes.has(str2.toUpperCase());
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isISO31661Alpha3, isISO31661Alpha3.exports);
var isISO31661Alpha3Exports = isISO31661Alpha3.exports;
var isISO4217$1 = {};
Object.defineProperty(isISO4217$1, "__esModule", {
  value: true
});
isISO4217$1.default = isISO4217;
isISO4217$1.CurrencyCodes = void 0;
var _assertString$2 = _interopRequireDefault$2(assertStringExports);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var validISO4217CurrencyCodes = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
function isISO4217(str2) {
  (0, _assertString$2.default)(str2);
  return validISO4217CurrencyCodes.has(str2.toUpperCase());
}
var CurrencyCodes = validISO4217CurrencyCodes;
isISO4217$1.CurrencyCodes = CurrencyCodes;
var isBase32 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase322;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var base32 = /^[A-Z2-7]+=*$/;
  var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
  var defaultBase32Options = {
    crockford: false
  };
  function isBase322(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, defaultBase32Options);
    if (options2.crockford) {
      return crockfordBase32.test(str2);
    }
    var len = str2.length;
    if (len % 8 === 0 && base32.test(str2)) {
      return true;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase32, isBase32.exports);
var isBase32Exports = isBase32.exports;
var isBase58 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase582;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
  function isBase582(str2) {
    (0, _assertString2.default)(str2);
    if (base58Reg.test(str2)) {
      return true;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isBase58, isBase58.exports);
var isBase58Exports = isBase58.exports;
var isDataURI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDataURI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
  var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
  var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
  function isDataURI2(str2) {
    (0, _assertString2.default)(str2);
    var data = str2.split(",");
    if (data.length < 2) {
      return false;
    }
    var attributes = data.shift().trim().split(";");
    var schemeAndMediaType = attributes.shift();
    if (schemeAndMediaType.slice(0, 5) !== "data:") {
      return false;
    }
    var mediaType = schemeAndMediaType.slice(5);
    if (mediaType !== "" && !validMediaType.test(mediaType)) {
      return false;
    }
    for (var i = 0; i < attributes.length; i++) {
      if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
        return false;
      }
    }
    for (var _i = 0; _i < data.length; _i++) {
      if (!validData.test(data[_i])) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isDataURI, isDataURI.exports);
var isDataURIExports = isDataURI.exports;
var isMagnetURI = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMagnetURI2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
  function isMagnetURI2(url) {
    (0, _assertString2.default)(url);
    if (url.indexOf("magnet:?") !== 0) {
      return false;
    }
    return magnetURIComponent.test(url);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMagnetURI, isMagnetURI.exports);
var isMagnetURIExports = isMagnetURI.exports;
var isMailtoURI = { exports: {} };
var trim = { exports: {} };
var rtrim = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rtrim2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function rtrim2(str2, chars) {
    (0, _assertString2.default)(str2);
    if (chars) {
      var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
      return str2.replace(pattern, "");
    }
    var strIndex = str2.length - 1;
    while (/\s/.test(str2.charAt(strIndex))) {
      strIndex -= 1;
    }
    return str2.slice(0, strIndex + 1);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(rtrim, rtrim.exports);
var rtrimExports = rtrim.exports;
var ltrim = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ltrim2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function ltrim2(str2, chars) {
    (0, _assertString2.default)(str2);
    var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
    return str2.replace(pattern, "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(ltrim, ltrim.exports);
var ltrimExports = ltrim.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = trim2;
  var _rtrim = _interopRequireDefault2(rtrimExports);
  var _ltrim = _interopRequireDefault2(ltrimExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function trim2(str2, chars) {
    return (0, _rtrim.default)((0, _ltrim.default)(str2, chars), chars);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(trim, trim.exports);
var trimExports = trim.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMailtoURI2;
  var _trim = _interopRequireDefault2(trimExports);
  var _isEmail = _interopRequireDefault2(isEmailExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray2(arr, i) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit2(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d2 = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d2 = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d2)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it2;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e2(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = o[Symbol.iterator]();
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e2(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f2() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function parseMailtoQueryString(queryString) {
    var allowedParams = /* @__PURE__ */ new Set(["subject", "body", "cc", "bcc"]), query = {
      cc: "",
      bcc: ""
    };
    var isParseFailed = false;
    var queryParams = queryString.split("&");
    if (queryParams.length > 4) {
      return false;
    }
    var _iterator = _createForOfIteratorHelper2(queryParams), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var q2 = _step.value;
        var _q$split = q2.split("="), _q$split2 = _slicedToArray2(_q$split, 2), key2 = _q$split2[0], value = _q$split2[1];
        if (key2 && !allowedParams.has(key2)) {
          isParseFailed = true;
          break;
        }
        if (value && (key2 === "cc" || key2 === "bcc")) {
          query[key2] = value;
        }
        if (key2) {
          allowedParams.delete(key2);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return isParseFailed ? false : query;
  }
  function isMailtoURI2(url, options2) {
    (0, _assertString2.default)(url);
    if (url.indexOf("mailto:") !== 0) {
      return false;
    }
    var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray2(_url$replace$split, 2), _url$replace$split2$ = _url$replace$split2[0], to = _url$replace$split2$ === void 0 ? "" : _url$replace$split2$, _url$replace$split2$2 = _url$replace$split2[1], queryString = _url$replace$split2$2 === void 0 ? "" : _url$replace$split2$2;
    if (!to && !queryString) {
      return true;
    }
    var query = parseMailtoQueryString(queryString);
    if (!query) {
      return false;
    }
    return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
      email = (0, _trim.default)(email, " ");
      if (email) {
        return (0, _isEmail.default)(email, options2);
      }
      return true;
    });
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMailtoURI, isMailtoURI.exports);
var isMailtoURIExports = isMailtoURI.exports;
var isMimeType = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMimeType2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
  var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
  var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
  function isMimeType2(str2) {
    (0, _assertString2.default)(str2);
    return mimeTypeSimple.test(str2) || mimeTypeText.test(str2) || mimeTypeMultipart.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isMimeType, isMimeType.exports);
var isMimeTypeExports = isMimeType.exports;
var isLatLong = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLatLong2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
  var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
  var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
  var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
  var defaultLatLongOptions = {
    checkDMS: false
  };
  function isLatLong2(str2, options2) {
    (0, _assertString2.default)(str2);
    options2 = (0, _merge.default)(options2, defaultLatLongOptions);
    if (!str2.includes(","))
      return false;
    var pair = str2.split(",");
    if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
      return false;
    if (options2.checkDMS) {
      return latDMS.test(pair[0]) && longDMS.test(pair[1]);
    }
    return lat.test(pair[0]) && long.test(pair[1]);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLatLong, isLatLong.exports);
var isLatLongExports = isLatLong.exports;
var isPostalCode$1 = {};
Object.defineProperty(isPostalCode$1, "__esModule", {
  value: true
});
isPostalCode$1.default = isPostalCode;
isPostalCode$1.locales = void 0;
var _assertString$1 = _interopRequireDefault$1(assertStringExports);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  AZ: /^AZ\d{4}$/,
  BA: /^([7-8]\d{4}$)/,
  BE: fourDigit,
  BG: fourDigit,
  BR: /^\d{5}-\d{3}$/,
  BY: /^2[1-4]\d{4}$/,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DO: fiveDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HT: /^HT\d{4}$/,
  HU: fourDigit,
  ID: fiveDigit,
  IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
  IL: /^(\d{5}|\d{7})$/,
  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  KR: /^(\d{5}|\d{6})$/,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  LK: fiveDigit,
  MG: threeDigit,
  MX: fiveDigit,
  MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
  MY: fiveDigit,
  NL: /^\d{4}\s?[a-z]{2}$/i,
  NO: fourDigit,
  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
  NZ: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PR: /^00[679]\d{2}([ -]\d{4})?$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^[1-9]\d{2}\s?\d{2}$/,
  SG: sixDigit,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TH: fiveDigit,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales = Object.keys(patterns);
isPostalCode$1.locales = locales;
function isPostalCode(str2, locale) {
  (0, _assertString$1.default)(str2);
  if (locale in patterns) {
    return patterns[locale].test(str2);
  } else if (locale === "any") {
    for (var key2 in patterns) {
      if (patterns.hasOwnProperty(key2)) {
        var pattern = patterns[key2];
        if (pattern.test(str2)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var _escape = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = escape2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function escape2(str2) {
    (0, _assertString2.default)(str2);
    return str2.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(_escape, _escape.exports);
var _escapeExports = _escape.exports;
var _unescape = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unescape2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function unescape2(str2) {
    (0, _assertString2.default)(str2);
    return str2.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(_unescape, _unescape.exports);
var _unescapeExports = _unescape.exports;
var stripLow = { exports: {} };
var blacklist = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = blacklist2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function blacklist2(str2, chars) {
    (0, _assertString2.default)(str2);
    return str2.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(blacklist, blacklist.exports);
var blacklistExports = blacklist.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = stripLow2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  var _blacklist = _interopRequireDefault2(blacklistExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stripLow2(str2, keep_new_lines) {
    (0, _assertString2.default)(str2);
    var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
    return (0, _blacklist.default)(str2, chars);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(stripLow, stripLow.exports);
var stripLowExports = stripLow.exports;
var whitelist = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = whitelist2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function whitelist2(str2, chars) {
    (0, _assertString2.default)(str2);
    return str2.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(whitelist, whitelist.exports);
var whitelistExports = whitelist.exports;
var isWhitelisted = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWhitelisted2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isWhitelisted2(str2, chars) {
    (0, _assertString2.default)(str2);
    for (var i = str2.length - 1; i >= 0; i--) {
      if (chars.indexOf(str2[i]) === -1) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isWhitelisted, isWhitelisted.exports);
var isWhitelistedExports = isWhitelisted.exports;
var normalizeEmail = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeEmail2;
  var _merge = _interopRequireDefault2(mergeExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_normalize_email_options = {
    // The following options apply to all email addresses
    // Lowercases the local part of the email address.
    // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
    // The domain is always lowercased, as per RFC 1035
    all_lowercase: true,
    // The following conversions are specific to GMail
    // Lowercases the local part of the GMail address (known to be case-insensitive)
    gmail_lowercase: true,
    // Removes dots from the local part of the email address, as that's ignored by GMail
    gmail_remove_dots: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    gmail_remove_subaddress: true,
    // Conversts the googlemail.com domain to gmail.com
    gmail_convert_googlemaildotcom: true,
    // The following conversions are specific to Outlook.com / Windows Live / Hotmail
    // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
    outlookdotcom_lowercase: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    outlookdotcom_remove_subaddress: true,
    // The following conversions are specific to Yahoo
    // Lowercases the local part of the Yahoo address (known to be case-insensitive)
    yahoo_lowercase: true,
    // Removes the subaddress (e.g. "-foo") from the email address
    yahoo_remove_subaddress: true,
    // The following conversions are specific to Yandex
    // Lowercases the local part of the Yandex address (known to be case-insensitive)
    yandex_lowercase: true,
    // The following conversions are specific to iCloud
    // Lowercases the local part of the iCloud address (known to be case-insensitive)
    icloud_lowercase: true,
    // Removes the subaddress (e.g. "+foo") from the email address
    icloud_remove_subaddress: true
  };
  var icloud_domains = ["icloud.com", "me.com"];
  var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
  var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
  var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
  function dotsReplacer(match2) {
    if (match2.length > 1) {
      return match2;
    }
    return "";
  }
  function normalizeEmail2(email, options2) {
    options2 = (0, _merge.default)(options2, default_normalize_email_options);
    var raw_parts = email.split("@");
    var domain = raw_parts.pop();
    var user = raw_parts.join("@");
    var parts = [user, domain];
    parts[1] = parts[1].toLowerCase();
    if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
      if (options2.gmail_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (options2.gmail_remove_dots) {
        parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
      }
      if (!parts[0].length) {
        return false;
      }
      if (options2.all_lowercase || options2.gmail_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = options2.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
    } else if (icloud_domains.indexOf(parts[1]) >= 0) {
      if (options2.icloud_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options2.all_lowercase || options2.icloud_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
      if (options2.outlookdotcom_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options2.all_lowercase || options2.outlookdotcom_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
      if (options2.yahoo_remove_subaddress) {
        var components2 = parts[0].split("-");
        parts[0] = components2.length > 1 ? components2.slice(0, -1).join("-") : components2[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options2.all_lowercase || options2.yahoo_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yandex_domains.indexOf(parts[1]) >= 0) {
      if (options2.all_lowercase || options2.yandex_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = "yandex.ru";
    } else if (options2.all_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    return parts.join("@");
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(normalizeEmail, normalizeEmail.exports);
var normalizeEmailExports = normalizeEmail.exports;
var isSlug = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSlug2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
  function isSlug2(str2) {
    (0, _assertString2.default)(str2);
    return charsetRegex.test(str2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isSlug, isSlug.exports);
var isSlugExports = isSlug.exports;
var isLicensePlate = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLicensePlate2;
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var validators = {
    "cs-CZ": function csCZ(str2) {
      return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str2);
    },
    "de-DE": function deDE(str2) {
      return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str2);
    },
    "de-LI": function deLI(str2) {
      return /^FL[- ]?\d{1,5}[UZ]?$/.test(str2);
    },
    "en-IN": function enIN(str2) {
      return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str2);
    },
    "es-AR": function esAR(str2) {
      return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str2);
    },
    "fi-FI": function fiFI(str2) {
      return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str2);
    },
    "hu-HU": function huHU(str2) {
      return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str2);
    },
    "pt-BR": function ptBR(str2) {
      return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str2);
    },
    "pt-PT": function ptPT(str2) {
      return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(str2);
    },
    "sq-AL": function sqAL(str2) {
      return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str2);
    },
    "sv-SE": function svSE(str2) {
      return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(str2.trim());
    }
  };
  function isLicensePlate2(str2, locale) {
    (0, _assertString2.default)(str2);
    if (locale in validators) {
      return validators[locale](str2);
    } else if (locale === "any") {
      for (var key2 in validators) {
        var validator2 = validators[key2];
        if (validator2(str2)) {
          return true;
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isLicensePlate, isLicensePlate.exports);
var isLicensePlateExports = isLicensePlate.exports;
var isStrongPassword = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isStrongPassword2;
  var _merge = _interopRequireDefault2(mergeExports);
  var _assertString2 = _interopRequireDefault2(assertStringExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var upperCaseRegex = /^[A-Z]$/;
  var lowerCaseRegex = /^[a-z]$/;
  var numberRegex = /^[0-9]$/;
  var symbolRegex = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/;
  var defaultOptions2 = {
    minLength: 8,
    minLowercase: 1,
    minUppercase: 1,
    minNumbers: 1,
    minSymbols: 1,
    returnScore: false,
    pointsPerUnique: 1,
    pointsPerRepeat: 0.5,
    pointsForContainingLower: 10,
    pointsForContainingUpper: 10,
    pointsForContainingNumber: 10,
    pointsForContainingSymbol: 10
  };
  function countChars(str2) {
    var result = {};
    Array.from(str2).forEach(function(char2) {
      var curVal = result[char2];
      if (curVal) {
        result[char2] += 1;
      } else {
        result[char2] = 1;
      }
    });
    return result;
  }
  function analyzePassword(password) {
    var charMap = countChars(password);
    var analysis = {
      length: password.length,
      uniqueChars: Object.keys(charMap).length,
      uppercaseCount: 0,
      lowercaseCount: 0,
      numberCount: 0,
      symbolCount: 0
    };
    Object.keys(charMap).forEach(function(char2) {
      if (upperCaseRegex.test(char2)) {
        analysis.uppercaseCount += charMap[char2];
      } else if (lowerCaseRegex.test(char2)) {
        analysis.lowercaseCount += charMap[char2];
      } else if (numberRegex.test(char2)) {
        analysis.numberCount += charMap[char2];
      } else if (symbolRegex.test(char2)) {
        analysis.symbolCount += charMap[char2];
      }
    });
    return analysis;
  }
  function scorePassword(analysis, scoringOptions) {
    var points = 0;
    points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
    points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
    if (analysis.lowercaseCount > 0) {
      points += scoringOptions.pointsForContainingLower;
    }
    if (analysis.uppercaseCount > 0) {
      points += scoringOptions.pointsForContainingUpper;
    }
    if (analysis.numberCount > 0) {
      points += scoringOptions.pointsForContainingNumber;
    }
    if (analysis.symbolCount > 0) {
      points += scoringOptions.pointsForContainingSymbol;
    }
    return points;
  }
  function isStrongPassword2(str2) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    (0, _assertString2.default)(str2);
    var analysis = analyzePassword(str2);
    options2 = (0, _merge.default)(options2 || {}, defaultOptions2);
    if (options2.returnScore) {
      return scorePassword(analysis, options2);
    }
    return analysis.length >= options2.minLength && analysis.lowercaseCount >= options2.minLowercase && analysis.uppercaseCount >= options2.minUppercase && analysis.numberCount >= options2.minNumbers && analysis.symbolCount >= options2.minSymbols;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
})(isStrongPassword, isStrongPassword.exports);
var isStrongPasswordExports = isStrongPassword.exports;
var isVAT$1 = {};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
Object.defineProperty(isVAT$1, "__esModule", {
  value: true
});
isVAT$1.default = isVAT;
isVAT$1.vatMatchers = void 0;
var _assertString = _interopRequireDefault(assertStringExports);
var algorithms = _interopRequireWildcard(algorithms$1);
function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function")
    return null;
  var cache2 = /* @__PURE__ */ new WeakMap();
  _getRequireWildcardCache = function _getRequireWildcardCache2() {
    return cache2;
  };
  return cache2;
}
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache();
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key2, desc);
      } else {
        newObj[key2] = obj[key2];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var CH = function CH2(str2) {
  var hasValidCheckNumber = function hasValidCheckNumber2(digits) {
    var lastDigit = digits.pop();
    var weights = [5, 4, 3, 2, 7, 6, 5, 4];
    var calculatedCheckNumber = (11 - digits.reduce(function(acc, el2, idx) {
      return acc + el2 * weights[idx];
    }, 0) % 11) % 11;
    return lastDigit === calculatedCheckNumber;
  };
  return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str2) && hasValidCheckNumber(str2.match(/\d/g).map(function(el2) {
    return +el2;
  }));
};
var PT = function PT2(str2) {
  var match2 = str2.match(/^(PT)?(\d{9})$/);
  if (!match2) {
    return false;
  }
  var tin = match2[2];
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
    return parseInt(a, 10);
  }), 9) % 11;
  if (checksum > 9) {
    return parseInt(tin[8], 10) === 0;
  }
  return checksum === parseInt(tin[8], 10);
};
var vatMatchers = {
  /**
   * European Union VAT identification numbers
   */
  AT: function AT(str2) {
    return /^(AT)?U\d{8}$/.test(str2);
  },
  BE: function BE(str2) {
    return /^(BE)?\d{10}$/.test(str2);
  },
  BG: function BG(str2) {
    return /^(BG)?\d{9,10}$/.test(str2);
  },
  HR: function HR(str2) {
    return /^(HR)?\d{11}$/.test(str2);
  },
  CY: function CY(str2) {
    return /^(CY)?\w{9}$/.test(str2);
  },
  CZ: function CZ(str2) {
    return /^(CZ)?\d{8,10}$/.test(str2);
  },
  DK: function DK(str2) {
    return /^(DK)?\d{8}$/.test(str2);
  },
  EE: function EE(str2) {
    return /^(EE)?\d{9}$/.test(str2);
  },
  FI: function FI(str2) {
    return /^(FI)?\d{8}$/.test(str2);
  },
  FR: function FR(str2) {
    return /^(FR)?\w{2}\d{9}$/.test(str2);
  },
  DE: function DE(str2) {
    return /^(DE)?\d{9}$/.test(str2);
  },
  EL: function EL(str2) {
    return /^(EL)?\d{9}$/.test(str2);
  },
  HU: function HU(str2) {
    return /^(HU)?\d{8}$/.test(str2);
  },
  IE: function IE(str2) {
    return /^(IE)?\d{7}\w{1}(W)?$/.test(str2);
  },
  IT: function IT(str2) {
    return /^(IT)?\d{11}$/.test(str2);
  },
  LV: function LV(str2) {
    return /^(LV)?\d{11}$/.test(str2);
  },
  LT: function LT(str2) {
    return /^(LT)?\d{9,12}$/.test(str2);
  },
  LU: function LU(str2) {
    return /^(LU)?\d{8}$/.test(str2);
  },
  MT: function MT(str2) {
    return /^(MT)?\d{8}$/.test(str2);
  },
  NL: function NL(str2) {
    return /^(NL)?\d{9}B\d{2}$/.test(str2);
  },
  PL: function PL(str2) {
    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str2);
  },
  PT,
  RO: function RO(str2) {
    return /^(RO)?\d{2,10}$/.test(str2);
  },
  SK: function SK(str2) {
    return /^(SK)?\d{10}$/.test(str2);
  },
  SI: function SI(str2) {
    return /^(SI)?\d{8}$/.test(str2);
  },
  ES: function ES(str2) {
    return /^(ES)?\w\d{7}[A-Z]$/.test(str2);
  },
  SE: function SE(str2) {
    return /^(SE)?\d{12}$/.test(str2);
  },
  /**
   * VAT numbers of non-EU countries
   */
  AL: function AL(str2) {
    return /^(AL)?\w{9}[A-Z]$/.test(str2);
  },
  MK: function MK(str2) {
    return /^(MK)?\d{13}$/.test(str2);
  },
  AU: function AU(str2) {
    return /^(AU)?\d{11}$/.test(str2);
  },
  BY: function BY(str2) {
    return /^( )?\d{9}$/.test(str2);
  },
  CA: function CA(str2) {
    return /^(CA)?\d{9}$/.test(str2);
  },
  IS: function IS(str2) {
    return /^(IS)?\d{5,6}$/.test(str2);
  },
  IN: function IN(str2) {
    return /^(IN)?\d{15}$/.test(str2);
  },
  ID: function ID(str2) {
    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str2);
  },
  IL: function IL(str2) {
    return /^(IL)?\d{9}$/.test(str2);
  },
  KZ: function KZ(str2) {
    return /^(KZ)?\d{9}$/.test(str2);
  },
  NZ: function NZ(str2) {
    return /^(NZ)?\d{9}$/.test(str2);
  },
  NG: function NG(str2) {
    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str2);
  },
  NO: function NO(str2) {
    return /^(NO)?\d{9}MVA$/.test(str2);
  },
  PH: function PH(str2) {
    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str2);
  },
  RU: function RU(str2) {
    return /^(RU)?(\d{10}|\d{12})$/.test(str2);
  },
  SM: function SM(str2) {
    return /^(SM)?\d{5}$/.test(str2);
  },
  SA: function SA(str2) {
    return /^(SA)?\d{15}$/.test(str2);
  },
  RS: function RS(str2) {
    return /^(RS)?\d{9}$/.test(str2);
  },
  CH,
  TR: function TR(str2) {
    return /^(TR)?\d{10}$/.test(str2);
  },
  UA: function UA(str2) {
    return /^(UA)?\d{12}$/.test(str2);
  },
  GB: function GB(str2) {
    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str2);
  },
  UZ: function UZ(str2) {
    return /^(UZ)?\d{9}$/.test(str2);
  },
  /**
   * VAT numbers of Latin American countries
   */
  AR: function AR(str2) {
    return /^(AR)?\d{11}$/.test(str2);
  },
  BO: function BO(str2) {
    return /^(BO)?\d{7}$/.test(str2);
  },
  BR: function BR(str2) {
    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str2);
  },
  CL: function CL(str2) {
    return /^(CL)?\d{8}-\d{1}$/.test(str2);
  },
  CO: function CO(str2) {
    return /^(CO)?\d{10}$/.test(str2);
  },
  CR: function CR(str2) {
    return /^(CR)?\d{9,12}$/.test(str2);
  },
  EC: function EC(str2) {
    return /^(EC)?\d{13}$/.test(str2);
  },
  SV: function SV(str2) {
    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str2);
  },
  GT: function GT(str2) {
    return /^(GT)?\d{7}-\d{1}$/.test(str2);
  },
  HN: function HN(str2) {
    return /^(HN)?$/.test(str2);
  },
  MX: function MX(str2) {
    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str2);
  },
  NI: function NI(str2) {
    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str2);
  },
  PA: function PA(str2) {
    return /^(PA)?$/.test(str2);
  },
  PY: function PY(str2) {
    return /^(PY)?\d{6,8}-\d{1}$/.test(str2);
  },
  PE: function PE(str2) {
    return /^(PE)?\d{11}$/.test(str2);
  },
  DO: function DO(str2) {
    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str2);
  },
  UY: function UY(str2) {
    return /^(UY)?\d{12}$/.test(str2);
  },
  VE: function VE(str2) {
    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str2);
  }
};
isVAT$1.vatMatchers = vatMatchers;
function isVAT(str2, countryCode) {
  (0, _assertString.default)(str2);
  (0, _assertString.default)(countryCode);
  if (countryCode in vatMatchers) {
    return vatMatchers[countryCode](str2);
  }
  throw new Error("Invalid country code: '".concat(countryCode, "'"));
}
(function(module, exports) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _toDate = _interopRequireDefault2(toDateExports);
  var _toFloat = _interopRequireDefault2(toFloatExports);
  var _toInt = _interopRequireDefault2(toIntExports);
  var _toBoolean = _interopRequireDefault2(toBooleanExports);
  var _equals = _interopRequireDefault2(equalsExports);
  var _contains = _interopRequireDefault2(containsExports);
  var _matches = _interopRequireDefault2(matchesExports);
  var _isEmail = _interopRequireDefault2(isEmailExports);
  var _isURL = _interopRequireDefault2(isURLExports);
  var _isMACAddress = _interopRequireDefault2(isMACAddressExports);
  var _isIP = _interopRequireDefault2(isIPExports);
  var _isIPRange = _interopRequireDefault2(isIPRangeExports);
  var _isFQDN = _interopRequireDefault2(isFQDNExports);
  var _isDate = _interopRequireDefault2(isDateExports);
  var _isTime = _interopRequireDefault2(isTimeExports);
  var _isBoolean = _interopRequireDefault2(isBooleanExports);
  var _isLocale = _interopRequireDefault2(isLocaleExports);
  var _isAlpha = _interopRequireWildcard2(isAlpha$1);
  var _isAlphanumeric = _interopRequireWildcard2(isAlphanumeric$1);
  var _isNumeric = _interopRequireDefault2(isNumericExports);
  var _isPassportNumber = _interopRequireDefault2(isPassportNumberExports);
  var _isPort = _interopRequireDefault2(isPortExports);
  var _isLowercase = _interopRequireDefault2(isLowercaseExports);
  var _isUppercase = _interopRequireDefault2(isUppercaseExports);
  var _isIMEI = _interopRequireDefault2(isIMEIExports);
  var _isAscii = _interopRequireDefault2(isAsciiExports);
  var _isFullWidth = _interopRequireDefault2(isFullWidth$1);
  var _isHalfWidth = _interopRequireDefault2(isHalfWidth$1);
  var _isVariableWidth = _interopRequireDefault2(isVariableWidthExports);
  var _isMultibyte = _interopRequireDefault2(isMultibyteExports);
  var _isSemVer = _interopRequireDefault2(isSemVerExports);
  var _isSurrogatePair = _interopRequireDefault2(isSurrogatePairExports);
  var _isInt = _interopRequireDefault2(isIntExports);
  var _isFloat = _interopRequireWildcard2(isFloat$1);
  var _isDecimal = _interopRequireDefault2(isDecimalExports);
  var _isHexadecimal = _interopRequireDefault2(isHexadecimalExports);
  var _isOctal = _interopRequireDefault2(isOctalExports);
  var _isDivisibleBy = _interopRequireDefault2(isDivisibleByExports);
  var _isHexColor = _interopRequireDefault2(isHexColorExports);
  var _isRgbColor = _interopRequireDefault2(isRgbColorExports);
  var _isHSL = _interopRequireDefault2(isHSLExports);
  var _isISRC = _interopRequireDefault2(isISRCExports);
  var _isIBAN = _interopRequireWildcard2(isIBAN$1);
  var _isBIC = _interopRequireDefault2(isBICExports);
  var _isMD = _interopRequireDefault2(isMD5Exports);
  var _isHash = _interopRequireDefault2(isHashExports);
  var _isJWT = _interopRequireDefault2(isJWTExports);
  var _isJSON = _interopRequireDefault2(isJSONExports);
  var _isEmpty = _interopRequireDefault2(isEmptyExports);
  var _isLength = _interopRequireDefault2(isLengthExports);
  var _isByteLength = _interopRequireDefault2(isByteLengthExports);
  var _isUUID = _interopRequireDefault2(isUUIDExports);
  var _isMongoId = _interopRequireDefault2(isMongoIdExports);
  var _isAfter = _interopRequireDefault2(isAfterExports);
  var _isBefore = _interopRequireDefault2(isBeforeExports);
  var _isIn = _interopRequireDefault2(isInExports);
  var _isLuhnNumber = _interopRequireDefault2(isLuhnNumberExports);
  var _isCreditCard = _interopRequireDefault2(isCreditCardExports);
  var _isIdentityCard = _interopRequireDefault2(isIdentityCardExports);
  var _isEAN = _interopRequireDefault2(isEANExports);
  var _isISIN = _interopRequireDefault2(isISINExports);
  var _isISBN = _interopRequireDefault2(isISBNExports);
  var _isISSN = _interopRequireDefault2(isISSNExports);
  var _isTaxID = _interopRequireDefault2(isTaxIDExports);
  var _isMobilePhone = _interopRequireWildcard2(isMobilePhone$1);
  var _isEthereumAddress = _interopRequireDefault2(isEthereumAddressExports);
  var _isCurrency = _interopRequireDefault2(isCurrencyExports);
  var _isBtcAddress = _interopRequireDefault2(isBtcAddressExports);
  var _isISO = isISO6346$1;
  var _isISO2 = _interopRequireDefault2(isISO6391Exports);
  var _isISO3 = _interopRequireDefault2(isISO8601Exports);
  var _isRFC = _interopRequireDefault2(isRFC3339Exports);
  var _isISO31661Alpha = _interopRequireDefault2(isISO31661Alpha2$1);
  var _isISO31661Alpha2 = _interopRequireDefault2(isISO31661Alpha3Exports);
  var _isISO4 = _interopRequireDefault2(isISO4217$1);
  var _isBase = _interopRequireDefault2(isBase32Exports);
  var _isBase2 = _interopRequireDefault2(isBase58Exports);
  var _isBase3 = _interopRequireDefault2(isBase64Exports);
  var _isDataURI = _interopRequireDefault2(isDataURIExports);
  var _isMagnetURI = _interopRequireDefault2(isMagnetURIExports);
  var _isMailtoURI = _interopRequireDefault2(isMailtoURIExports);
  var _isMimeType = _interopRequireDefault2(isMimeTypeExports);
  var _isLatLong = _interopRequireDefault2(isLatLongExports);
  var _isPostalCode = _interopRequireWildcard2(isPostalCode$1);
  var _ltrim = _interopRequireDefault2(ltrimExports);
  var _rtrim = _interopRequireDefault2(rtrimExports);
  var _trim = _interopRequireDefault2(trimExports);
  var _escape2 = _interopRequireDefault2(_escapeExports);
  var _unescape2 = _interopRequireDefault2(_unescapeExports);
  var _stripLow = _interopRequireDefault2(stripLowExports);
  var _whitelist = _interopRequireDefault2(whitelistExports);
  var _blacklist = _interopRequireDefault2(blacklistExports);
  var _isWhitelisted = _interopRequireDefault2(isWhitelistedExports);
  var _normalizeEmail = _interopRequireDefault2(normalizeEmailExports);
  var _isSlug = _interopRequireDefault2(isSlugExports);
  var _isLicensePlate = _interopRequireDefault2(isLicensePlateExports);
  var _isStrongPassword = _interopRequireDefault2(isStrongPasswordExports);
  var _isVAT = _interopRequireDefault2(isVAT$1);
  function _getRequireWildcardCache2() {
    if (typeof WeakMap !== "function")
      return null;
    var cache2 = /* @__PURE__ */ new WeakMap();
    _getRequireWildcardCache2 = function _getRequireWildcardCache3() {
      return cache2;
    };
    return cache2;
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2();
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key2, desc);
        } else {
          newObj[key2] = obj[key2];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var version2 = "13.11.0";
  var validator2 = {
    version: version2,
    toDate: _toDate.default,
    toFloat: _toFloat.default,
    toInt: _toInt.default,
    toBoolean: _toBoolean.default,
    equals: _equals.default,
    contains: _contains.default,
    matches: _matches.default,
    isEmail: _isEmail.default,
    isURL: _isURL.default,
    isMACAddress: _isMACAddress.default,
    isIP: _isIP.default,
    isIPRange: _isIPRange.default,
    isFQDN: _isFQDN.default,
    isBoolean: _isBoolean.default,
    isIBAN: _isIBAN.default,
    isBIC: _isBIC.default,
    isAlpha: _isAlpha.default,
    isAlphaLocales: _isAlpha.locales,
    isAlphanumeric: _isAlphanumeric.default,
    isAlphanumericLocales: _isAlphanumeric.locales,
    isNumeric: _isNumeric.default,
    isPassportNumber: _isPassportNumber.default,
    isPort: _isPort.default,
    isLowercase: _isLowercase.default,
    isUppercase: _isUppercase.default,
    isAscii: _isAscii.default,
    isFullWidth: _isFullWidth.default,
    isHalfWidth: _isHalfWidth.default,
    isVariableWidth: _isVariableWidth.default,
    isMultibyte: _isMultibyte.default,
    isSemVer: _isSemVer.default,
    isSurrogatePair: _isSurrogatePair.default,
    isInt: _isInt.default,
    isIMEI: _isIMEI.default,
    isFloat: _isFloat.default,
    isFloatLocales: _isFloat.locales,
    isDecimal: _isDecimal.default,
    isHexadecimal: _isHexadecimal.default,
    isOctal: _isOctal.default,
    isDivisibleBy: _isDivisibleBy.default,
    isHexColor: _isHexColor.default,
    isRgbColor: _isRgbColor.default,
    isHSL: _isHSL.default,
    isISRC: _isISRC.default,
    isMD5: _isMD.default,
    isHash: _isHash.default,
    isJWT: _isJWT.default,
    isJSON: _isJSON.default,
    isEmpty: _isEmpty.default,
    isLength: _isLength.default,
    isLocale: _isLocale.default,
    isByteLength: _isByteLength.default,
    isUUID: _isUUID.default,
    isMongoId: _isMongoId.default,
    isAfter: _isAfter.default,
    isBefore: _isBefore.default,
    isIn: _isIn.default,
    isLuhnNumber: _isLuhnNumber.default,
    isCreditCard: _isCreditCard.default,
    isIdentityCard: _isIdentityCard.default,
    isEAN: _isEAN.default,
    isISIN: _isISIN.default,
    isISBN: _isISBN.default,
    isISSN: _isISSN.default,
    isMobilePhone: _isMobilePhone.default,
    isMobilePhoneLocales: _isMobilePhone.locales,
    isPostalCode: _isPostalCode.default,
    isPostalCodeLocales: _isPostalCode.locales,
    isEthereumAddress: _isEthereumAddress.default,
    isCurrency: _isCurrency.default,
    isBtcAddress: _isBtcAddress.default,
    isISO6346: _isISO.isISO6346,
    isFreightContainerID: _isISO.isFreightContainerID,
    isISO6391: _isISO2.default,
    isISO8601: _isISO3.default,
    isRFC3339: _isRFC.default,
    isISO31661Alpha2: _isISO31661Alpha.default,
    isISO31661Alpha3: _isISO31661Alpha2.default,
    isISO4217: _isISO4.default,
    isBase32: _isBase.default,
    isBase58: _isBase2.default,
    isBase64: _isBase3.default,
    isDataURI: _isDataURI.default,
    isMagnetURI: _isMagnetURI.default,
    isMailtoURI: _isMailtoURI.default,
    isMimeType: _isMimeType.default,
    isLatLong: _isLatLong.default,
    ltrim: _ltrim.default,
    rtrim: _rtrim.default,
    trim: _trim.default,
    escape: _escape2.default,
    unescape: _unescape2.default,
    stripLow: _stripLow.default,
    whitelist: _whitelist.default,
    blacklist: _blacklist.default,
    isWhitelisted: _isWhitelisted.default,
    normalizeEmail: _normalizeEmail.default,
    toString,
    isSlug: _isSlug.default,
    isStrongPassword: _isStrongPassword.default,
    isTaxID: _isTaxID.default,
    isDate: _isDate.default,
    isTime: _isTime.default,
    isLicensePlate: _isLicensePlate.default,
    isVAT: _isVAT.default,
    ibanLocales: _isIBAN.locales
  };
  var _default2 = validator2;
  exports.default = _default2;
  module.exports = exports.default;
  module.exports.default = exports.default;
})(validator$1, validator$1.exports);
var validatorExports = validator$1.exports;
const validator = /* @__PURE__ */ getDefaultExportFromCjs(validatorExports);
const validationRules = [validator.isUUID];
const fastPathParameterIndices = (pathname) => {
  const indices = [];
  const parts = pathname.split("/").slice(1);
  for (let idx = 0; idx < parts.length; idx++) {
    const part = parts[idx];
    if (validationRules.some((rule) => rule(part))) {
      indices.push(idx);
    }
  }
  return indices;
};
const leafMapToEndpoints = (leafMap) => {
  const endpoints = [];
  for (const [host, pathData] of Object.entries(leafMap)) {
    for (const [path2, leaf] of Object.entries(pathData)) {
      const endpoint = {
        host,
        parts: pathToParts(path2),
        pathname: path2,
        data: leaf.data
      };
      endpoints.push(endpoint);
    }
  }
  return endpoints;
};
var jsonify = {};
var parse$1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse)
    return parse$1;
  hasRequiredParse = 1;
  var at2;
  var ch2;
  var escapee = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
  };
  var text;
  function error(m2) {
    throw {
      name: "SyntaxError",
      message: m2,
      at: at2,
      text
    };
  }
  function next2(c2) {
    if (c2 && c2 !== ch2) {
      error("Expected '" + c2 + "' instead of '" + ch2 + "'");
    }
    ch2 = text.charAt(at2);
    at2 += 1;
    return ch2;
  }
  function number2() {
    var num;
    var str2 = "";
    if (ch2 === "-") {
      str2 = "-";
      next2("-");
    }
    while (ch2 >= "0" && ch2 <= "9") {
      str2 += ch2;
      next2();
    }
    if (ch2 === ".") {
      str2 += ".";
      while (next2() && ch2 >= "0" && ch2 <= "9") {
        str2 += ch2;
      }
    }
    if (ch2 === "e" || ch2 === "E") {
      str2 += ch2;
      next2();
      if (ch2 === "-" || ch2 === "+") {
        str2 += ch2;
        next2();
      }
      while (ch2 >= "0" && ch2 <= "9") {
        str2 += ch2;
        next2();
      }
    }
    num = Number(str2);
    if (!isFinite(num)) {
      error("Bad number");
    }
    return num;
  }
  function string2() {
    var hex2;
    var i;
    var str2 = "";
    var uffff;
    if (ch2 === '"') {
      while (next2()) {
        if (ch2 === '"') {
          next2();
          return str2;
        } else if (ch2 === "\\") {
          next2();
          if (ch2 === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex2 = parseInt(next2(), 16);
              if (!isFinite(hex2)) {
                break;
              }
              uffff = uffff * 16 + hex2;
            }
            str2 += String.fromCharCode(uffff);
          } else if (typeof escapee[ch2] === "string") {
            str2 += escapee[ch2];
          } else {
            break;
          }
        } else {
          str2 += ch2;
        }
      }
    }
    error("Bad string");
  }
  function white() {
    while (ch2 && ch2 <= " ") {
      next2();
    }
  }
  function word() {
    switch (ch2) {
      case "t":
        next2("t");
        next2("r");
        next2("u");
        next2("e");
        return true;
      case "f":
        next2("f");
        next2("a");
        next2("l");
        next2("s");
        next2("e");
        return false;
      case "n":
        next2("n");
        next2("u");
        next2("l");
        next2("l");
        return null;
      default:
        error("Unexpected '" + ch2 + "'");
    }
  }
  function array2() {
    var arr = [];
    if (ch2 === "[") {
      next2("[");
      white();
      if (ch2 === "]") {
        next2("]");
        return arr;
      }
      while (ch2) {
        arr.push(value());
        white();
        if (ch2 === "]") {
          next2("]");
          return arr;
        }
        next2(",");
        white();
      }
    }
    error("Bad array");
  }
  function object2() {
    var key2;
    var obj = {};
    if (ch2 === "{") {
      next2("{");
      white();
      if (ch2 === "}") {
        next2("}");
        return obj;
      }
      while (ch2) {
        key2 = string2();
        white();
        next2(":");
        if (Object.prototype.hasOwnProperty.call(obj, key2)) {
          error('Duplicate key "' + key2 + '"');
        }
        obj[key2] = value();
        white();
        if (ch2 === "}") {
          next2("}");
          return obj;
        }
        next2(",");
        white();
      }
    }
    error("Bad object");
  }
  function value() {
    white();
    switch (ch2) {
      case "{":
        return object2();
      case "[":
        return array2();
      case '"':
        return string2();
      case "-":
        return number2();
      default:
        return ch2 >= "0" && ch2 <= "9" ? number2() : word();
    }
  }
  parse$1 = function(source, reviver) {
    var result;
    text = source;
    at2 = 0;
    ch2 = " ";
    result = value();
    white();
    if (ch2) {
      error("Syntax error");
    }
    return typeof reviver === "function" ? function walk2(holder, key2) {
      var k2;
      var v2;
      var val = holder[key2];
      if (val && typeof val === "object") {
        for (k2 in value) {
          if (Object.prototype.hasOwnProperty.call(val, k2)) {
            v2 = walk2(val, k2);
            if (typeof v2 === "undefined") {
              delete val[k2];
            } else {
              val[k2] = v2;
            }
          }
        }
      }
      return reviver.call(holder, key2, val);
    }({ "": result }, "") : result;
  };
  return parse$1;
}
var stringify$3;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify)
    return stringify$3;
  hasRequiredStringify = 1;
  var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var gap;
  var indent;
  var meta = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  };
  var rep;
  function quote(string2) {
    escapable.lastIndex = 0;
    return escapable.test(string2) ? '"' + string2.replace(escapable, function(a) {
      var c2 = meta[a];
      return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string2 + '"';
  }
  function str2(key2, holder) {
    var i;
    var k2;
    var v2;
    var length2;
    var mind = gap;
    var partial;
    var value = holder[key2];
    if (value && typeof value === "object" && typeof value.toJSON === "function") {
      value = value.toJSON(key2);
    }
    if (typeof rep === "function") {
      value = rep.call(holder, key2, value);
    }
    switch (typeof value) {
      case "string":
        return quote(value);
      case "number":
        return isFinite(value) ? String(value) : "null";
      case "boolean":
      case "null":
        return String(value);
      case "object":
        if (!value) {
          return "null";
        }
        gap += indent;
        partial = [];
        if (Object.prototype.toString.apply(value) === "[object Array]") {
          length2 = value.length;
          for (i = 0; i < length2; i += 1) {
            partial[i] = str2(i, value) || "null";
          }
          v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
          gap = mind;
          return v2;
        }
        if (rep && typeof rep === "object") {
          length2 = rep.length;
          for (i = 0; i < length2; i += 1) {
            k2 = rep[i];
            if (typeof k2 === "string") {
              v2 = str2(k2, value);
              if (v2) {
                partial.push(quote(k2) + (gap ? ": " : ":") + v2);
              }
            }
          }
        } else {
          for (k2 in value) {
            if (Object.prototype.hasOwnProperty.call(value, k2)) {
              v2 = str2(k2, value);
              if (v2) {
                partial.push(quote(k2) + (gap ? ": " : ":") + v2);
              }
            }
          }
        }
        v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
        gap = mind;
        return v2;
    }
  }
  stringify$3 = function(value, replacer, space2) {
    var i;
    gap = "";
    indent = "";
    if (typeof space2 === "number") {
      for (i = 0; i < space2; i += 1) {
        indent += " ";
      }
    } else if (typeof space2 === "string") {
      indent = space2;
    }
    rep = replacer;
    if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
      throw new Error("JSON.stringify");
    }
    return str2("", { "": value });
  };
  return stringify$3;
}
var hasRequiredJsonify;
function requireJsonify() {
  if (hasRequiredJsonify)
    return jsonify;
  hasRequiredJsonify = 1;
  jsonify.parse = requireParse();
  jsonify.stringify = requireStringify();
  return jsonify;
}
var json = typeof JSON !== "undefined" ? JSON : requireJsonify();
var isArray$2 = Array.isArray || function(x2) {
  return {}.toString.call(x2) === "[object Array]";
};
var objectKeys = Object.keys || function(obj) {
  var has3 = Object.prototype.hasOwnProperty || function() {
    return true;
  };
  var keys2 = [];
  for (var key2 in obj) {
    if (has3.call(obj, key2)) {
      keys2.push(key2);
    }
  }
  return keys2;
};
var jsonStableStringify = function(obj, opts) {
  if (!opts) {
    opts = {};
  }
  if (typeof opts === "function") {
    opts = { cmp: opts };
  }
  var space2 = opts.space || "";
  if (typeof space2 === "number") {
    space2 = Array(space2 + 1).join(" ");
  }
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var replacer = opts.replacer || function(key2, value) {
    return value;
  };
  var cmp = opts.cmp && function(f2) {
    return function(node2) {
      return function(a, b2) {
        var aobj = { key: a, value: node2[a] };
        var bobj = { key: b2, value: node2[b2] };
        return f2(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify16(parent, key2, node2, level) {
    var indent = space2 ? "\n" + new Array(level + 1).join(space2) : "";
    var colonSeparator = space2 ? ": " : ":";
    if (node2 && node2.toJSON && typeof node2.toJSON === "function") {
      node2 = node2.toJSON();
    }
    node2 = replacer.call(parent, key2, node2);
    if (node2 === void 0) {
      return;
    }
    if (typeof node2 !== "object" || node2 === null) {
      return json.stringify(node2);
    }
    if (isArray$2(node2)) {
      var out = [];
      for (var i = 0; i < node2.length; i++) {
        var item = stringify16(node2, i, node2[i], level + 1) || json.stringify(null);
        out.push(indent + space2 + item);
      }
      return "[" + out.join(",") + indent + "]";
    }
    if (seen.indexOf(node2) !== -1) {
      if (cycles) {
        return json.stringify("__cycle__");
      }
      throw new TypeError("Converting circular structure to JSON");
    } else {
      seen.push(node2);
    }
    var keys2 = objectKeys(node2).sort(cmp && cmp(node2));
    var out = [];
    for (var i = 0; i < keys2.length; i++) {
      var key2 = keys2[i];
      var value = stringify16(node2, key2, node2[key2], level + 1);
      if (!value) {
        continue;
      }
      var keyValue = json.stringify(key2) + colonSeparator + value;
      out.push(indent + space2 + keyValue);
    }
    seen.splice(seen.indexOf(node2), 1);
    return "{" + out.join(",") + indent + "}";
  }({ "": obj }, "", obj, 0);
};
const stringify$2 = /* @__PURE__ */ getDefaultExportFromCjs(jsonStableStringify);
class RequestStore {
  constructor(storeOptions = persistOptions.get()) {
    __publicField(this, "store");
    __publicField(this, "leafMap");
    __publicField(this, "disabledHosts");
    __publicField(this, "storeOptions");
    __publicField(this, "options", (options2) => {
      if (!options2)
        return this.storeOptions;
      this.storeOptions = { ...this.storeOptions, ...options2 };
      persistOptions.set(this.storeOptions);
      return Object.freeze(this.storeOptions);
    });
    __publicField(this, "export", () => {
      return stringify$2({
        leafMap: this.leafMap,
        disabledHosts: Array.from(this.disabledHosts)
      }).trim();
    });
    this.leafMap = {};
    this.store = {};
    this.disabledHosts = /* @__PURE__ */ new Set();
    this.storeOptions = storeOptions;
  }
  import(json2) {
    try {
      const { leafMap, disabledHosts } = JSON.parse(json2);
      this.disabledHosts = new Set(disabledHosts);
      this.store = leafMapToStore(leafMap);
      this.leafMap = leafMap;
      return true;
    } catch {
      return false;
    }
  }
  clear() {
    this.store = {};
    this.leafMap = {};
    this.disabledHosts = /* @__PURE__ */ new Set();
  }
  endpoints() {
    const withoutDisabled = lodashExports.omit(
      this.leafMap,
      Array.from(this.disabledHosts)
    );
    return leafMapToEndpoints(withoutDisabled);
  }
  get() {
    return lodashExports.omit(this.store, Array.from(this.disabledHosts));
  }
  hosts() {
    return Object.keys(this.store);
  }
  insert(harRequest, content) {
    if (!isValidRequest(harRequest, content))
      return false;
    harRequest.request.url = decodeUriComponent(harRequest.request.url);
    const responseBody = parseJSON(content);
    const result = upsert({
      harRequest,
      responseBody,
      store: this.store,
      options: this.storeOptions
    });
    if (!result)
      return false;
    const { insertedPath, insertedLeaf, insertedHost } = result;
    insertLeafMap({
      leafMap: this.leafMap,
      host: insertedHost,
      leaf: insertedLeaf,
      path: insertedPath
    });
    let pathname = insertedPath;
    for (const idx of fastPathParameterIndices(pathname)) {
      const newPathname = this.parameterise(idx, pathname, insertedHost);
      if (newPathname)
        pathname = newPathname;
    }
    return true;
  }
  parameterise(index2, path2, host) {
    const result = parameterise({ store: this.store, index: index2, path: path2, host });
    if (!result)
      return null;
    const { removedPaths, insertedPath, insertedLeaf } = result;
    const unsetLeafMap = (path22) => lodashExports.unset(this.leafMap[host], path22);
    removedPaths.concat([path2]).forEach(unsetLeafMap);
    insertLeafMap({
      leafMap: this.leafMap,
      host,
      leaf: insertedLeaf,
      path: insertedPath
    });
    return insertedPath;
  }
  setDisabledHosts(disabledHosts) {
    this.disabledHosts = disabledHosts;
  }
}
const requestStore = new RequestStore();
const defaultContextValue = {
  endpoints: [],
  endpointsByHost: [],
  setEndpointsByHost: () => {
  },
  allHosts: /* @__PURE__ */ new Set(),
  setAllHosts: () => {
  },
  disabledHosts: /* @__PURE__ */ new Set(),
  setDisabledHosts: () => {
  },
  parameterise: () => null,
  import: () => false,
  export: () => "",
  options: () => defaultOptions
};
const Context = reactExports.createContext(defaultContextValue);
const wrapper$3 = "_wrapper_10ehg_1";
const classes$3 = {
  wrapper: wrapper$3
};
var ViewOffIcon = createIcon({
  displayName: "ViewOffIcon",
  path: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "currentColor", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23.2,10.549a20.954,20.954,0,0,0-4.3-3.6l4-3.995a1,1,0,1,0-1.414-1.414l-.018.018a.737.737,0,0,1-.173.291l-19.5,19.5c-.008.007-.018.009-.026.017a1,1,0,0,0,1.631,1.088l4.146-4.146a11.26,11.26,0,0,0,4.31.939h.3c4.256,0,8.489-2.984,11.051-5.8A2.171,2.171,0,0,0,23.2,10.549ZM16.313,13.27a4.581,4.581,0,0,1-3,3.028,4.3,4.3,0,0,1-3.1-.19.253.253,0,0,1-.068-.407l5.56-5.559a.252.252,0,0,1,.407.067A4.3,4.3,0,0,1,16.313,13.27Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.615,13.4a.244.244,0,0,0,.061-.24A4.315,4.315,0,0,1,7.5,12,4.5,4.5,0,0,1,12,7.5a4.276,4.276,0,0,1,1.16.173.244.244,0,0,0,.24-.062l1.941-1.942a.254.254,0,0,0-.1-.421A10.413,10.413,0,0,0,12,4.75C7.7,4.692,3.4,7.7.813,10.549a2.15,2.15,0,0,0-.007,2.9,21.209,21.209,0,0,0,3.438,3.03.256.256,0,0,0,.326-.029Z" })
  ] })
});
var ViewIcon = createIcon({
  displayName: "ViewIcon",
  path: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "currentColor", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23.432,10.524C20.787,7.614,16.4,4.538,12,4.6,7.6,4.537,3.213,7.615.568,10.524a2.211,2.211,0,0,0,0,2.948C3.182,16.351,7.507,19.4,11.839,19.4h.308c4.347,0,8.671-3.049,11.288-5.929A2.21,2.21,0,0,0,23.432,10.524ZM7.4,12A4.6,4.6,0,1,1,12,16.6,4.6,4.6,0,0,1,7.4,12Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "2" })
  ] })
});
var SettingsIcon = createIcon({
  viewBox: "0 0 14 14",
  d: "M14,7.77 L14,6.17 L12.06,5.53 L11.61,4.44 L12.49,2.6 L11.36,1.47 L9.55,2.38 L8.46,1.93 L7.77,0.01 L6.17,0.01 L5.54,1.95 L4.43,2.4 L2.59,1.52 L1.46,2.65 L2.37,4.46 L1.92,5.55 L0,6.23 L0,7.82 L1.94,8.46 L2.39,9.55 L1.51,11.39 L2.64,12.52 L4.45,11.61 L5.54,12.06 L6.23,13.98 L7.82,13.98 L8.45,12.04 L9.56,11.59 L11.4,12.47 L12.53,11.34 L11.61,9.53 L12.08,8.44 L14,7.75 L14,7.77 Z M7,10 C5.34,10 4,8.66 4,7 C4,5.34 5.34,4 7,4 C8.66,4 10,5.34 10,7 C10,8.66 8.66,10 7,10 Z",
  displayName: "SettingsIcon"
});
var InfoOutlineIcon = createIcon({
  displayName: "InfoOutlineIcon",
  path: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "g",
    {
      fill: "currentColor",
      stroke: "currentColor",
      strokeLinecap: "square",
      strokeWidth: "2",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", fill: "none", r: "11", stroke: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { fill: "none", x1: "11.959", x2: "11.959", y1: "11", y2: "17" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11.959", cy: "7", r: "1", stroke: "none" })
      ]
    }
  )
});
var DeleteIcon = createIcon({
  displayName: "DeleteIcon",
  path: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.452 7.5H4.547a.5.5 0 00-.5.545l1.287 14.136A2 2 0 007.326 24h9.347a2 2 0 001.992-1.819L19.95 8.045a.5.5 0 00-.129-.382.5.5 0 00-.369-.163zm-9.2 13a.75.75 0 01-1.5 0v-9a.75.75 0 011.5 0zm5 0a.75.75 0 01-1.5 0v-9a.75.75 0 011.5 0zM22 4h-4.75a.25.25 0 01-.25-.25V2.5A2.5 2.5 0 0014.5 0h-5A2.5 2.5 0 007 2.5v1.25a.25.25 0 01-.25.25H2a1 1 0 000 2h20a1 1 0 000-2zM9 3.75V2.5a.5.5 0 01.5-.5h5a.5.5 0 01.5.5v1.25a.25.25 0 01-.25.25h-5.5A.25.25 0 019 3.75z" }) })
});
var ChevronDownIcon = createIcon({
  displayName: "ChevronDownIcon",
  d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
});
const StartBtn = ({ onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Start recording", placement: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    "aria-label": "Start recording",
    onClick,
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewIcon, {}),
    colorScheme: "teal"
  }
) });
const StopBtn = ({ onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Stop recording", placement: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    "aria-label": "Stop recording",
    onClick,
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewOffIcon, {}),
    colorScheme: "blue"
  }
) });
const SettingsBtn = ({ onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Configure dynamic paths and filter hosts", placement: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    "aria-label": "Configure dynamic paths and filter hosts",
    onClick,
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon, {}),
    colorScheme: "gray"
  }
) });
const ClearBtn = ({ onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Clear data and start again", placement: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    "aria-label": "Clear data and start again",
    onClick,
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}),
    colorScheme: "red"
  }
) });
function ownKeys2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
var _excluded$7 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$7);
  var _useState = reactExports.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = reactExports.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = reactExports.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = reactExports.useCallback(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = reactExports.useCallback(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = reactExports.useCallback(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = reactExports.useCallback(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function getNodeName(node2) {
  if (isNode$1(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null ? void 0 : (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode$1(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
function isNode$1(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0;
  let height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css4 = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left2;
      y2 += top2;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top: top2,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left2 + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries2) {
      const ratio = entries2[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference2, floating, update2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref3) => {
      let [firstEntry] = _ref3;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var index$1 = reactExports.useLayoutEffect;
var _excluded$4$1 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop$1 = function noop2() {
};
function applyPrefixToName(prefix2, name2) {
  if (!name2) {
    return prefix2;
  } else if (name2[0] === "-") {
    return prefix2 + name2;
  } else {
    return prefix2 + "__" + name2;
  }
}
function classNames(prefix2, state2) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state2 && prefix2) {
    for (var key2 in state2) {
      if (state2.hasOwnProperty(key2) && state2[key2]) {
        arr.push("".concat(applyPrefixToName(prefix2, key2)));
      }
    }
  }
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray$1(value))
    return value.filter(Boolean);
  if (_typeof$2(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4$1);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name2, classNamesState) {
  var cx2 = props.cx, getStyles2 = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles2(name2, props),
    className: cx2(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name2, props), className)
  };
};
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
function normalizedHeight(el2) {
  if (isDocumentElement(el2)) {
    return window.innerHeight;
  }
  return el2.clientHeight;
}
function getScrollTop(el2) {
  if (isDocumentElement(el2)) {
    return window.pageYOffset;
  }
  return el2.scrollTop;
}
function scrollTo(el2, top2) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top2);
    return;
  }
  el2.scrollTop = top2;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop$1;
  var start2 = getScrollTop(element);
  var change = to - start2;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start2, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e2) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop$1, options);
  w.removeEventListener("p", noop$1, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray$1(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key2 = _ref22[0];
    return !properties.includes(key2);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key2 = _ref4[0], val = _ref4[1];
    newProps[key2] = val;
    return newProps;
  }, {});
};
var _excluded$3$1 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref22, unstyled) {
  var _objectSpread2$1;
  var placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty$1(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty$1(_objectSpread2$1, "position", "absolute"), _defineProperty$1(_objectSpread2$1, "width", "100%"), _defineProperty$1(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ reactExports.createContext(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme2 = props.theme;
  var _ref3 = reactExports.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = reactExports.useRef(null);
  var _useState = reactExports.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme2.spacing.controlHeight;
  index$1(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state2 = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state2.maxHeight);
    setPlacement(state2.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state2.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList3(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends$8({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3$1);
  return jsx("div", _extends$8({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends$8({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset2 = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset2,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = reactExports.useRef(null);
  var cleanupRef = reactExports.useRef(null);
  var _useState5 = reactExports.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = reactExports.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = reactExports.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = reactExports.useCallback(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset2 = rect[placement] + scrollDistance;
    if (offset2 !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset: offset2,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index$1(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = reactExports.useCallback(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index$1(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = reactExports.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends$8({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled2 = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled2 ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled2 = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends$8({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled2,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends$8({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2$1 = ["size"], _excluded2$2 = ["innerProps", "isRtl", "size"];
var _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
};
var Svg = function Svg2(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2$1);
  return jsx("svg", _extends$8({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends$8({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends$8({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled2 = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled2 ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends$8({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes$1(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay2 = _ref6.delay, offset2 = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$4({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset2 ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2$2);
  return jsx("div", _extends$8({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css(_ref3, unstyled) {
  var isDisabled2 = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled2 ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled2 ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control$1 = function Control(props) {
  var children = props.children, isDisabled2 = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends$8({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled2,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps, {
    "aria-disabled": isDisabled2 || void 0
  }), children);
};
var Control$1$1 = Control$1;
var _excluded$1$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx2 = props.cx, getStyles2 = props.getStyles, getClassNames = props.getClassNames, Heading3 = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label2 = props.label, theme2 = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading3, _extends$8({}, headingProps, {
    selectProps,
    theme: theme2,
    getStyles: getStyles2,
    getClassNames,
    cx: cx2
  }), label2), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1$1);
  return jsx("div", _extends$8({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group;
var _excluded$6 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled2 = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled2 ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden2) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden2 ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input3(props) {
  var cx2 = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled2 = _cleanCommonProps.isDisabled, isHidden2 = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$6);
  return jsx("div", _extends$8({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends$8({
    className: cx2({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden2),
    disabled: isDisabled2
  }, innerProps)));
};
var Input$1 = Input;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends$8({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled2 = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container2 = components2.Container, Label = components2.Label, Remove = components2.Remove;
  return jsx(Container2, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled2
    })), innerProps),
    selectProps
  }, jsx(Label, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled2 = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled2 ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled2 ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled2 = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled2,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled2
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css2 = function css3(_ref3, unstyled) {
  var isDisabled2 = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled2 ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled2 = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends$8({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled2
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};
var safeIsNaN$1 = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$1(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN$1(first) && safeIsNaN$1(second)) {
    return true;
  }
  return false;
}
function areInputsEqual$1(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual$1(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne$1(resultFn, isEqual3) {
  if (isEqual3 === void 0) {
    isEqual3 = areInputsEqual$1;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual3(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear3() {
    cache2 = null;
  };
  return memoized;
}
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends$8({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled2 = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled2 ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action2 = props.action, _props$label = props.label, label2 = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled2 = props.isDisabled;
    switch (action2) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label2, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled2 ? "option ".concat(label2, " is disabled. Select another option.") : "option ".concat(label2, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus3(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label2 = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled2 = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label2, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled2 ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label2, " ").concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = reactExports.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = reactExports.useMemo(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label2 = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label: label2,
        labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = reactExports.useMemo(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = reactExports.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = reactExports.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics2(str2) {
  return str2.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne$1(stripDiacritics);
var trimString = function trimString2(str2) {
  return str2.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config2) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config2), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify16 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify16(option)) : stringify16(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded$5 = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded$5);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends$8({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$4({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  if (event.cancelable)
    event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = reactExports.useRef(false);
  var isTop = reactExports.useRef(false);
  var touchStart = reactExports.useRef(0);
  var scrollTarget = reactExports.useRef(null);
  var handleEventDelta = reactExports.useCallback(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = reactExports.useCallback(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = reactExports.useCallback(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = reactExports.useCallback(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el2.addEventListener("wheel", onWheel, notPassive);
    el2.addEventListener("touchstart", onTouchStart, notPassive);
    el2.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    el2.removeEventListener("wheel", onWheel, false);
    el2.removeEventListener("touchstart", onTouchStart, false);
    el2.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  e2.preventDefault();
}
function allowTouchMove(e2) {
  e2.stopPropagation();
}
function preventInertiaScroll() {
  var top2 = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top2 + this.offsetHeight;
  if (top2 === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top2 - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = reactExports.useRef({});
  var scrollTarget = reactExports.useRef(null);
  var addScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key2) {
        var val = targetStyle && targetStyle[key2];
        originalStyles.current[key2] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key2) {
        var val = LOCK_STYLES[key2];
        if (targetStyle) {
          targetStyle[key2] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key2) {
        var val = originalStyles.current[key2];
        if (targetStyle) {
          targetStyle[key2] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput2(event) {
  var element = event.target;
  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
};
var _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name2 = _ref3.name, onFocus4 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name: name2,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus4,
    css: _ref2,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps$1 = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count2 = _ref3.count;
    return "".concat(count2, " result").concat(count2 !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled2 = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label2 = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled: isDisabled2,
    isSelected,
    label: label2,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label2 = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label2,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state2, nextSelectValue) {
  var focusedValue = state2.focusedValue, lastSelectValue = state2.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state2, options2) {
  var lastFocusedOption = state2.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name2 = _this$props.name;
      actionMeta.name = name2;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action2, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action2,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name2 = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled2 = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled2) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name: name2
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key2, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key2](props, unstyled);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key2];
      return custom ? custom(base, props) : base;
    };
    _this.getClassNames = function(key2, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key2]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches;
      var touch2 = touches && touches.item(0);
      if (!touch2) {
        return;
      }
      _this.initialTouchX = touch2.clientX;
      _this.initialTouchY = touch2.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch2 = touches && touches.item(0);
      if (!touch2) {
        return;
      }
      var deltaX = Math.abs(touch2.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch2.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled2 = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled2)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled2 = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled2 && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled2 && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled2 && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction2) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction2) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction2 === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction2 === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction2 === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction2 === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction2 === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme3() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx2 = this.cx, getStyles2 = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx: cx2,
        getStyles: getStyles2,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled2 = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id2 = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ reactExports.createElement(DummyInput, _extends$8({
            id: id2,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop$1,
            onFocus: this.onInputFocus,
            disabled: isDisabled2,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ reactExports.createElement(Input4, _extends$8({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled: isDisabled2,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled2 = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ reactExports.createElement(Placeholder3, _extends$8({}, commonProps, {
          key: "placeholder",
          isDisabled: isDisabled2,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key2 = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ reactExports.createElement(MultiValue3, _extends$8({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled: isDisabled2,
            key: key2,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e2) {
                e2.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ reactExports.createElement(SingleValue3, _extends$8({}, commonProps, {
        data: singleValue,
        isDisabled: isDisabled2
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled2 = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled2 || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(ClearIndicator3, _extends$8({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled2 = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(LoadingIndicator3, _extends$8({}, commonProps, {
        innerProps,
        isDisabled: isDisabled2,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled2 = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ reactExports.createElement(IndicatorSeparator3, _extends$8({}, commonProps, {
        isDisabled: isDisabled2,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled2 = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(DropdownIndicator3, _extends$8({}, commonProps, {
        innerProps,
        isDisabled: isDisabled2,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList4 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = function render2(props, id2) {
        var type2 = props.type, data = props.data, isDisabled2 = props.isDisabled, isSelected = props.isSelected, label2 = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled2 ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled2 ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id2);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ reactExports.createElement(Option3, _extends$8({}, commonProps, {
          innerProps,
          data,
          isDisabled: isDisabled2,
          isSelected,
          key: optionId,
          label: label2,
          type: type2,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ reactExports.createElement(Group3, _extends$8({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ reactExports.createElement(MenuPlacer, _extends$8({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ reactExports.createElement(Menu3, _extends$8({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ reactExports.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ reactExports.createElement(MenuList4, _extends$8({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ reactExports.createElement(MenuPortal3, _extends$8({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled2 = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name2 = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled2) {
        return /* @__PURE__ */ reactExports.createElement(RequiredInput$1, {
          name: name2,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name2 || isDisabled2)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ reactExports.createElement("input", {
            name: name2,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i) {
            return /* @__PURE__ */ reactExports.createElement("input", {
              key: "i-".concat(i),
              name: name2,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ reactExports.createElement("input", {
            name: name2,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ reactExports.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ reactExports.createElement("input", {
          name: name2,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ reactExports.createElement(LiveRegion$1, _extends$8({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled2 = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ reactExports.createElement(SelectContainer3, _extends$8({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled: isDisabled2,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ reactExports.createElement(Control3, _extends$8({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: isDisabled2,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ reactExports.createElement(ValueContainer3, _extends$8({}, commonProps, {
        isDisabled: isDisabled2
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ reactExports.createElement(IndicatorsContainer3, _extends$8({}, commonProps, {
        isDisabled: isDisabled2
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state2) {
      var prevProps = state2.prevProps, clearFocusValueOnUpdate = state2.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state2.inputIsHiddenAfterUpdate, ariaSelection = state2.ariaSelection, isFocused = state2.isFocused, prevWasFocused = state2.prevWasFocused;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state2, selectValue) : null;
        var focusedOption = getNextFocusedOption(state2, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(reactExports.Component);
Select.defaultProps = defaultProps$1;
var StateManagedSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends$8({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref3, prevState) {
    var nextIn = _ref3.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref22 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref22[0], maybeAppearing = _ref22[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$5(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop3() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop3,
  onEntering: noop3,
  onEntered: noop3,
  onExit: noop3,
  onExiting: noop3,
  onExited: noop3
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key2) {
    return key2 in next2 ? next2[key2] : prev2[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child = children[key2];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$1(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref3) {
    var prevChildMapping = _ref3.children, handleExited = _ref3.handleExited, firstRender = _ref3.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends$8({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$5(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
var _excluded$4 = ["in", "onExited", "appear", "enter", "exit"];
var AnimatedInput = function AnimatedInput2(WrappedComponent) {
  return function(_ref3) {
    _ref3.in;
    _ref3.onExited;
    _ref3.appear;
    _ref3.enter;
    _ref3.exit;
    var props = _objectWithoutProperties(_ref3, _excluded$4);
    return /* @__PURE__ */ reactExports.createElement(WrappedComponent, props);
  };
};
var AnimatedInput$1 = AnimatedInput;
var _excluded$3 = ["component", "duration", "in", "onExited"];
var Fade = function Fade3(_ref3) {
  var Tag = _ref3.component, _ref$duration = _ref3.duration, duration = _ref$duration === void 0 ? 1 : _ref$duration, inProp = _ref3.in;
  _ref3.onExited;
  var props = _objectWithoutProperties(_ref3, _excluded$3);
  var nodeRef = reactExports.useRef(null);
  var transition2 = {
    entering: {
      opacity: 0
    },
    entered: {
      opacity: 1,
      transition: "opacity ".concat(duration, "ms")
    },
    exiting: {
      opacity: 0
    },
    exited: {
      opacity: 0
    }
  };
  return /* @__PURE__ */ reactExports.createElement(Transition$1, {
    mountOnEnter: true,
    unmountOnExit: true,
    in: inProp,
    timeout: duration,
    nodeRef
  }, function(state2) {
    var innerProps = {
      style: _objectSpread2({}, transition2[state2]),
      ref: nodeRef
    };
    return /* @__PURE__ */ reactExports.createElement(Tag, _extends$8({
      innerProps
    }, props));
  });
};
var collapseDuration = 260;
var Collapse = function Collapse2(_ref22) {
  var children = _ref22.children, _in = _ref22.in, _onExited = _ref22.onExited;
  var ref = reactExports.useRef(null);
  var _useState = reactExports.useState("auto"), _useState2 = _slicedToArray(_useState, 2), width = _useState2[0], setWidth = _useState2[1];
  reactExports.useEffect(function() {
    var el2 = ref.current;
    if (!el2)
      return;
    var rafId = window.requestAnimationFrame(function() {
      return setWidth(el2.getBoundingClientRect().width);
    });
    return function() {
      return window.cancelAnimationFrame(rafId);
    };
  }, []);
  var getStyleFromStatus = function getStyleFromStatus2(status) {
    switch (status) {
      default:
        return {
          width
        };
      case "exiting":
        return {
          width: 0,
          transition: "width ".concat(collapseDuration, "ms ease-out")
        };
      case "exited":
        return {
          width: 0
        };
    }
  };
  return /* @__PURE__ */ reactExports.createElement(Transition$1, {
    enter: false,
    mountOnEnter: true,
    unmountOnExit: true,
    in: _in,
    onExited: function onExited() {
      var el2 = ref.current;
      if (!el2)
        return;
      _onExited === null || _onExited === void 0 ? void 0 : _onExited(el2);
    },
    timeout: collapseDuration,
    nodeRef: ref
  }, function(status) {
    return /* @__PURE__ */ reactExports.createElement("div", {
      ref,
      style: _objectSpread2({
        overflow: "hidden",
        whiteSpace: "nowrap"
      }, getStyleFromStatus(status))
    }, children);
  });
};
var _excluded$2 = ["in", "onExited"];
var AnimatedMultiValue = function AnimatedMultiValue2(WrappedComponent) {
  return function(_ref3) {
    var inProp = _ref3.in, onExited = _ref3.onExited, props = _objectWithoutProperties(_ref3, _excluded$2);
    return /* @__PURE__ */ reactExports.createElement(Collapse, {
      in: inProp,
      onExited
    }, /* @__PURE__ */ reactExports.createElement(WrappedComponent, _extends$8({
      cropWithEllipsis: inProp
    }, props)));
  };
};
var AnimatedMultiValue$1 = AnimatedMultiValue;
var AnimatedPlaceholder = function AnimatedPlaceholder2(WrappedComponent) {
  return function(props) {
    return /* @__PURE__ */ reactExports.createElement(Fade, _extends$8({
      component: WrappedComponent,
      duration: props.isMulti ? collapseDuration : 1
    }, props));
  };
};
var AnimatedPlaceholder$1 = AnimatedPlaceholder;
var AnimatedSingleValue = function AnimatedSingleValue2(WrappedComponent) {
  return function(props) {
    return /* @__PURE__ */ reactExports.createElement(Fade, _extends$8({
      component: WrappedComponent
    }, props));
  };
};
var AnimatedSingleValue$1 = AnimatedSingleValue;
var _excluded$1 = ["component"], _excluded2 = ["children"];
var AnimatedValueContainer = function AnimatedValueContainer2(WrappedComponent) {
  return function(props) {
    return props.isMulti ? /* @__PURE__ */ reactExports.createElement(IsMultiValueContainer, _extends$8({
      component: WrappedComponent
    }, props)) : /* @__PURE__ */ reactExports.createElement(TransitionGroup$1, _extends$8({
      component: WrappedComponent
    }, props));
  };
};
var IsMultiValueContainer = function IsMultiValueContainer2(_ref3) {
  var component = _ref3.component, restProps = _objectWithoutProperties(_ref3, _excluded$1);
  var multiProps = useIsMultiValueContainer(restProps);
  return /* @__PURE__ */ reactExports.createElement(TransitionGroup$1, _extends$8({
    component
  }, multiProps));
};
var useIsMultiValueContainer = function useIsMultiValueContainer2(_ref22) {
  var children = _ref22.children, props = _objectWithoutProperties(_ref22, _excluded2);
  var isMulti = props.isMulti, hasValue = props.hasValue, innerProps = props.innerProps, _props$selectProps = props.selectProps, components2 = _props$selectProps.components, controlShouldRenderValue = _props$selectProps.controlShouldRenderValue;
  var _useState = reactExports.useState(isMulti && controlShouldRenderValue && hasValue), _useState2 = _slicedToArray(_useState, 2), cssDisplayFlex = _useState2[0], setCssDisplayFlex = _useState2[1];
  var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), removingValue = _useState4[0], setRemovingValue = _useState4[1];
  reactExports.useEffect(function() {
    if (hasValue && !cssDisplayFlex) {
      setCssDisplayFlex(true);
    }
  }, [hasValue, cssDisplayFlex]);
  reactExports.useEffect(function() {
    if (removingValue && !hasValue && cssDisplayFlex) {
      setCssDisplayFlex(false);
    }
    setRemovingValue(false);
  }, [removingValue, hasValue, cssDisplayFlex]);
  var onExited = function onExited2() {
    return setRemovingValue(true);
  };
  var childMapper = function childMapper2(child) {
    if (isMulti && /* @__PURE__ */ reactExports.isValidElement(child)) {
      if (child.type === components2.MultiValue) {
        return /* @__PURE__ */ reactExports.cloneElement(child, {
          onExited
        });
      }
      if (child.type === components2.Placeholder && cssDisplayFlex) {
        return null;
      }
    }
    return child;
  };
  var newInnerProps = _objectSpread2(_objectSpread2({}, innerProps), {}, {
    style: _objectSpread2(_objectSpread2({}, innerProps === null || innerProps === void 0 ? void 0 : innerProps.style), {}, {
      display: isMulti && hasValue || cssDisplayFlex ? "flex" : "grid"
    })
  });
  var newProps = _objectSpread2(_objectSpread2({}, props), {}, {
    innerProps: newInnerProps,
    children: reactExports.Children.toArray(children).map(childMapper)
  });
  return newProps;
};
var AnimatedValueContainer$1 = AnimatedValueContainer;
var _excluded = ["Input", "MultiValue", "Placeholder", "SingleValue", "ValueContainer"];
var makeAnimated = function makeAnimated2() {
  var externalComponents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var components2 = defaultComponents({
    components: externalComponents
  });
  var Input4 = components2.Input, MultiValue3 = components2.MultiValue, Placeholder3 = components2.Placeholder, SingleValue3 = components2.SingleValue, ValueContainer3 = components2.ValueContainer, rest = _objectWithoutProperties(components2, _excluded);
  return _objectSpread2({
    Input: AnimatedInput$1(Input4),
    MultiValue: AnimatedMultiValue$1(MultiValue3),
    Placeholder: AnimatedPlaceholder$1(Placeholder3),
    SingleValue: AnimatedSingleValue$1(SingleValue3),
    ValueContainer: AnimatedValueContainer$1(ValueContainer3)
  }, rest);
};
var AnimatedComponents = makeAnimated();
AnimatedComponents.Input;
AnimatedComponents.MultiValue;
AnimatedComponents.Placeholder;
AnimatedComponents.SingleValue;
AnimatedComponents.ValueContainer;
var index = memoizeOne$1(makeAnimated);
var safeIsNaN = Number.isNaN || function ponyfill2(value) {
  return typeof value === "number" && value !== value;
};
function isEqual2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual2(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual3) {
  if (isEqual3 === void 0) {
    isEqual3 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual3(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay2) {
  var start2 = now();
  function tick() {
    if (now() - start2 >= delay2) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div2 = document.createElement("div");
    var style = div2.style;
    style.width = "50px";
    style.height = "50px";
    style.overflow = "scroll";
    document.body.appendChild(div2);
    size = div2.offsetWidth - div2.clientWidth;
    document.body.removeChild(div2);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey(index2, data) {
  return index2;
};
function createListComponent(_ref3) {
  var _class;
  var getItemOffset2 = _ref3.getItemOffset, getEstimatedTotalSize2 = _ref3.getEstimatedTotalSize, getItemSize2 = _ref3.getItemSize, getOffsetForIndexAndAlignment2 = _ref3.getOffsetForIndexAndAlignment, getStartIndexForOffset2 = _ref3.getStartIndexForOffset, getStopIndexForStartIndex2 = _ref3.getStopIndexForStartIndex, initInstanceProps2 = _ref3.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref3.shouldResetStyleCacheOnItemSizeChange, validateProps2 = _ref3.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose$1(List, _PureComponent);
    function List(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps2(_this.props, _assertThisInitialized$1(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized$1(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(index2) {
        var _this$props = _this.props, direction2 = _this$props.direction, itemSize = _this$props.itemSize, layout2 = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction2);
        var style;
        if (itemStyleCache.hasOwnProperty(index2)) {
          style = itemStyleCache[index2];
        } else {
          var _offset = getItemOffset2(_this.props, index2, _this._instanceProps);
          var size2 = getItemSize2(_this.props, index2, _this._instanceProps);
          var isHorizontal = direction2 === "horizontal" || layout2 === "horizontal";
          var isRtl = direction2 === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index2] = style = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction2 = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollLeft ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps2(nextProps);
      return null;
    };
    var _proto = List.prototype;
    _proto.scrollTo = function scrollTo2(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index2, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout2 = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index2 = Math.max(0, Math.min(index2, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout2 === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment2(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction2 = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout2 = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout2 === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction2 = _this$props4.direction, layout2 = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout2 === "horizontal") {
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction2 = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout2 = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction2 === "horizontal" || layout2 === "horizontal";
      var onScroll2 = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push(reactExports.createElement(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize2(this.props, this._instanceProps);
      return reactExports.createElement(outerElementType || outerTagName || "div", {
        className,
        onScroll: onScroll2,
        ref: this._outerRefSetter,
        style: _extends$8({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: direction2
        }, style)
      }, reactExports.createElement(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset2(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex2(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List;
  }(reactExports.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps(_ref22, _ref3) {
  _ref22.children;
  _ref22.direction;
  _ref22.height;
  _ref22.layout;
  _ref22.innerTagName;
  _ref22.outerTagName;
  _ref22.width;
  _ref3.instance;
};
var FixedSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset(_ref3, index2) {
    var itemSize = _ref3.itemSize;
    return index2 * itemSize;
  },
  getItemSize: function getItemSize(_ref22, index2) {
    var itemSize = _ref22.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
    var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction2 = _ref4.direction, height = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout2 = _ref4.layout, width = _ref4.width;
    var isHorizontal = direction2 === "horizontal" || layout2 === "horizontal";
    var size2 = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
    var maxOffset = Math.min(lastItemOffset, index2 * itemSize);
    var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset2) {
    var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
    var direction2 = _ref6.direction, height = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout2 = _ref6.layout, width = _ref6.width;
    var isHorizontal = direction2 === "horizontal" || layout2 === "horizontal";
    var offset2 = startIndex * itemSize;
    var size2 = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
    return Math.max(0, Math.min(
      itemCount - 1,
      startIndex + numVisibleItems - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref7) {
    _ref7.itemSize;
  }
});
const wrapper$2 = "_wrapper_jlkyj_10";
const autosizer = "_autosizer_jlkyj_15";
const autosizerchild = "_autosizerchild_jlkyj_20";
const listchild = "_listchild_jlkyj_25";
const search$1 = "_search_jlkyj_32";
const classes$2 = {
  "static": "_static_jlkyj_2",
  wrapper: wrapper$2,
  autosizer,
  autosizerchild,
  listchild,
  search: search$1
};
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key2) => `Invalid value for key ${key2}`;
const PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key2) => `Property 'weight' in key '${key2}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key2) => {
      let obj = createKey(key2);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key2) => {
      key2.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key2) {
  let path2 = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key2) || isArray(key2)) {
    src = key2;
    path2 = createKeyPath(key2);
    id2 = createKeyId(key2);
  } else {
    if (!hasOwn.call(key2, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name2 = key2.name;
    src = name2;
    if (hasOwn.call(key2, "weight")) {
      weight = key2.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
      }
    }
    path2 = createKeyPath(name2);
    id2 = createKeyId(name2);
    getFn = key2.getFn;
  }
  return { path: path2, id: id2, weight, src, getFn };
}
function createKeyPath(key2) {
  return isArray(key2) ? key2 : key2.split(".");
}
function createKeyId(key2) {
  return isArray(key2) ? key2.join(".") : key2;
}
function get3(obj, path2) {
  let list2 = [];
  let arr = false;
  const deepGet = (obj2, path3, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path3[index2]) {
      list2.push(obj2);
    } else {
      let key2 = path3[index2];
      const value = obj2[key2];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path3.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list2.push(toString$1(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path3, index2 + 1);
        }
      } else if (path3.length) {
        deepGet(value, path3, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path2) ? path2.split(".") : path2, 0);
  return arr ? list2 : list2[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b2) => a.score === b2.score ? a.idx < b2.idx ? -1 : 1 : a.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get3,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m2 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m2) / m2);
      cache2.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache2.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key2, idx) => {
      this._keysMap[key2.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record2 = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record2);
  }
  _addObject(doc, docIndex) {
    let record2 = { i: docIndex, $: {} };
    this.keys.forEach((key2, keyIndex) => {
      let value = key2.getFn ? key2.getFn(doc) : this.getFn(doc, key2.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else
            ;
        }
        record2.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record2.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record2);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end2 = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match2 = matchmask[i];
    if (match2 && start2 === -1) {
      start2 = i;
    } else if (!match2 && start2 !== -1) {
      end2 = i - 1;
      if (end2 - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end2]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
    indices.push([start2, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index2 + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char2 = pattern.charAt(i);
    mask[char2] = (mask[char2] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end2 = len - remainder;
      while (i < end2) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location)) > -1) {
      location = index2 + patternLen;
      indices.push([index2, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options2 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isMultiMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options2));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isSingleMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options2));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options2) {
    return options2.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type2 = searcher.constructor.type;
            if (MultiMatchSet.has(type2)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options2) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options2)) {
      return new searcherClass(pattern, options2);
    }
  }
  return new BitapSearch(pattern, options2);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key2) => ({
    [key2]: query[key2]
  }))
});
function parse(query, options2, { auto: auto2 = true } = {}) {
  const next2 = (query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key2 = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key2];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key2));
      }
      const obj = {
        keyId: createKeyId(key2),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options2);
      }
      return obj;
    }
    let node2 = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key2) => {
      const value = query2[key2];
      if (isArray(value)) {
        value.forEach((item) => {
          node2.children.push(next2(item));
        });
      }
    });
    return node2;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key: key2, norm: norm2, score }) => {
      const weight = key2 ? key2.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches2 = result.matches;
  data.matches = [];
  if (!isDefined(matches2)) {
    return;
  }
  matches2.forEach((match2) => {
    if (!isDefined(match2.indices) || !match2.indices.length) {
      return;
    }
    const { indices, value } = match2;
    let obj = {
      indices,
      value
    };
    if (match2.key) {
      obj.key = match2.key.src;
    }
    if (match2.idx > -1) {
      obj.refIndex = match2.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options2 = {}, index2) {
    this.options = { ...Config, ...options2 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node2, item, idx) => {
      if (!node2.children) {
        const { keyId, searcher } = node2;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node2.children.length; i < len; i += 1) {
        const child = node2.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node2.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key2, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key: key2,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key: key2, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches2 = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches2.push({
            score,
            key: key2,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches2.push({ score, key: key2, value: text, norm: norm2, indices });
      }
    }
    return matches2;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
let windowObject;
if (typeof window !== "undefined") {
  windowObject = window;
} else if (typeof self !== "undefined") {
  windowObject = self;
} else {
  windowObject = global;
}
let cancelFrame = null;
let requestFrame = null;
const TIMEOUT_DURATION = 20;
const clearTimeoutFn = windowObject.clearTimeout;
const setTimeoutFn = windowObject.setTimeout;
const cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;
const requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;
if (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {
  cancelFrame = clearTimeoutFn;
  requestFrame = function requestAnimationFrameViaSetTimeout(callback) {
    return setTimeoutFn(callback, TIMEOUT_DURATION);
  };
} else {
  cancelFrame = function cancelFrame2([animationFrameID, timeoutID]) {
    cancelAnimationFrameFn(animationFrameID);
    clearTimeoutFn(timeoutID);
  };
  requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {
    const animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {
      clearTimeoutFn(timeoutID);
      callback();
    });
    const timeoutID = setTimeoutFn(function timeoutCallback() {
      cancelAnimationFrameFn(animationFrameID);
      callback();
    }, TIMEOUT_DURATION);
    return [animationFrameID, timeoutID];
  };
}
function createDetectElementResize(nonce) {
  let animationKeyframes;
  let animationName;
  let animationStartEvent;
  let animationStyle;
  let checkTriggers;
  let resetTriggers;
  let scrollListener;
  const attachEvent = typeof document !== "undefined" && document.attachEvent;
  if (!attachEvent) {
    resetTriggers = function(element) {
      const triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + "px";
      expandChild.style.height = expand.offsetHeight + 1 + "px";
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };
    checkTriggers = function(element) {
      return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
    };
    scrollListener = function(e2) {
      if (e2.target.className && typeof e2.target.className.indexOf === "function" && e2.target.className.indexOf("contract-trigger") < 0 && e2.target.className.indexOf("expand-trigger") < 0) {
        return;
      }
      const element = this;
      resetTriggers(this);
      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }
      this.__resizeRAF__ = requestFrame(function animationFrame() {
        if (checkTriggers(element)) {
          element.__resizeLast__.width = element.offsetWidth;
          element.__resizeLast__.height = element.offsetHeight;
          element.__resizeListeners__.forEach(function forEachResizeListener(fn2) {
            fn2.call(element, e2);
          });
        }
      });
    };
    let animation2 = false;
    let keyframeprefix = "";
    animationStartEvent = "animationstart";
    const domPrefixes = "Webkit Moz O ms".split(" ");
    let startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" ");
    let pfx = "";
    {
      const elm = document.createElement("fakeelement");
      if (elm.style.animationName !== void 0) {
        animation2 = true;
      }
      if (animation2 === false) {
        for (let i = 0; i < domPrefixes.length; i++) {
          if (elm.style[domPrefixes[i] + "AnimationName"] !== void 0) {
            pfx = domPrefixes[i];
            keyframeprefix = "-" + pfx.toLowerCase() + "-";
            animationStartEvent = startEvents[i];
            animation2 = true;
            break;
          }
        }
      }
    }
    animationName = "resizeanim";
    animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
    animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  }
  const createStyles = function(doc) {
    if (!doc.getElementById("detectElementResize")) {
      const css4 = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
      style.id = "detectElementResize";
      style.type = "text/css";
      if (nonce != null) {
        style.setAttribute("nonce", nonce);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css4;
      } else {
        style.appendChild(doc.createTextNode(css4));
      }
      head.appendChild(style);
    }
  };
  const addResizeListener = function(element, fn2) {
    if (attachEvent) {
      element.attachEvent("onresize", fn2);
    } else {
      if (!element.__resizeTriggers__) {
        const doc = element.ownerDocument;
        const elementStyle = windowObject.getComputedStyle(element);
        if (elementStyle && elementStyle.position === "static") {
          element.style.position = "relative";
        }
        createStyles(doc);
        element.__resizeLast__ = {};
        element.__resizeListeners__ = [];
        (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
        const expandTrigger = doc.createElement("div");
        expandTrigger.className = "expand-trigger";
        expandTrigger.appendChild(doc.createElement("div"));
        const contractTrigger = doc.createElement("div");
        contractTrigger.className = "contract-trigger";
        element.__resizeTriggers__.appendChild(expandTrigger);
        element.__resizeTriggers__.appendChild(contractTrigger);
        element.appendChild(element.__resizeTriggers__);
        resetTriggers(element);
        element.addEventListener("scroll", scrollListener, true);
        if (animationStartEvent) {
          element.__resizeTriggers__.__animationListener__ = function animationListener(e2) {
            if (e2.animationName === animationName) {
              resetTriggers(element);
            }
          };
          element.__resizeTriggers__.addEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
        }
      }
      element.__resizeListeners__.push(fn2);
    }
  };
  const removeResizeListener = function(element, fn2) {
    if (attachEvent) {
      element.detachEvent("onresize", fn2);
    } else {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn2), 1);
      if (!element.__resizeListeners__.length) {
        element.removeEventListener("scroll", scrollListener, true);
        if (element.__resizeTriggers__.__animationListener__) {
          element.__resizeTriggers__.removeEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
          element.__resizeTriggers__.__animationListener__ = null;
        }
        try {
          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
        } catch (e2) {
        }
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}
class AutoSizer extends reactExports.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      height: this.props.defaultHeight || 0,
      scaledHeight: this.props.defaultHeight || 0,
      scaledWidth: this.props.defaultWidth || 0,
      width: this.props.defaultWidth || 0
    };
    this._autoSizer = null;
    this._detectElementResize = null;
    this._parentNode = null;
    this._resizeObserver = null;
    this._timeoutId = null;
    this._onResize = () => {
      this._timeoutId = null;
      const {
        disableHeight,
        disableWidth,
        onResize
      } = this.props;
      if (this._parentNode) {
        var _style$paddingLeft, _style$paddingRight, _style$paddingTop, _style$paddingBottom;
        const style = window.getComputedStyle(this._parentNode) || {};
        const paddingLeft = parseFloat((_style$paddingLeft = style.paddingLeft) !== null && _style$paddingLeft !== void 0 ? _style$paddingLeft : "0");
        const paddingRight = parseFloat((_style$paddingRight = style.paddingRight) !== null && _style$paddingRight !== void 0 ? _style$paddingRight : "0");
        const paddingTop = parseFloat((_style$paddingTop = style.paddingTop) !== null && _style$paddingTop !== void 0 ? _style$paddingTop : "0");
        const paddingBottom = parseFloat((_style$paddingBottom = style.paddingBottom) !== null && _style$paddingBottom !== void 0 ? _style$paddingBottom : "0");
        const rect = this._parentNode.getBoundingClientRect();
        const scaledHeight = rect.height - paddingTop - paddingBottom;
        const scaledWidth = rect.width - paddingLeft - paddingRight;
        const height = this._parentNode.offsetHeight - paddingTop - paddingBottom;
        const width = this._parentNode.offsetWidth - paddingLeft - paddingRight;
        if (!disableHeight && (this.state.height !== height || this.state.scaledHeight !== scaledHeight) || !disableWidth && (this.state.width !== width || this.state.scaledWidth !== scaledWidth)) {
          this.setState({
            height,
            width,
            scaledHeight,
            scaledWidth
          });
          if (typeof onResize === "function") {
            onResize({
              height,
              scaledHeight,
              scaledWidth,
              width
            });
          }
        }
      }
    };
    this._setRef = (autoSizer) => {
      this._autoSizer = autoSizer;
    };
  }
  componentDidMount() {
    const {
      nonce
    } = this.props;
    if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
      this._parentNode = this._autoSizer.parentNode;
      if (this._parentNode != null) {
        if (typeof ResizeObserver !== "undefined") {
          this._resizeObserver = new ResizeObserver(() => {
            this._timeoutId = setTimeout(this._onResize, 0);
          });
          this._resizeObserver.observe(this._parentNode);
        } else {
          this._detectElementResize = createDetectElementResize(nonce);
          this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
        }
        this._onResize();
      }
    }
  }
  componentWillUnmount() {
    if (this._parentNode) {
      if (this._detectElementResize) {
        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
      }
      if (this._timeoutId !== null) {
        clearTimeout(this._timeoutId);
      }
      if (this._resizeObserver) {
        this._resizeObserver.observe(this._parentNode);
        this._resizeObserver.disconnect();
      }
    }
  }
  render() {
    const {
      children,
      defaultHeight,
      defaultWidth,
      disableHeight = false,
      disableWidth = false,
      nonce,
      onResize,
      style = {},
      tagName = "div",
      ...rest
    } = this.props;
    const {
      height,
      scaledHeight,
      scaledWidth,
      width
    } = this.state;
    const outerStyle = {
      overflow: "visible"
    };
    const childParams = {};
    let bailoutOnChildren = false;
    if (!disableHeight) {
      if (height === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.height = 0;
      childParams.height = height;
      childParams.scaledHeight = scaledHeight;
    }
    if (!disableWidth) {
      if (width === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.width = 0;
      childParams.width = width;
      childParams.scaledWidth = scaledWidth;
    }
    return reactExports.createElement(tagName, {
      ref: this._setRef,
      style: {
        ...outerStyle,
        ...style
      },
      ...rest
    }, !bailoutOnChildren && children(childParams));
  }
}
var truncateMiddle = function(str2, frontLen, backLen, truncateStr) {
  if (str2 === null) {
    return "";
  }
  var strLen = str2.length;
  frontLen = ~~frontLen;
  backLen = ~~backLen;
  truncateStr = truncateStr || "&hellip;";
  if (frontLen === 0 && backLen === 0 || frontLen >= strLen || backLen >= strLen || frontLen + backLen >= strLen) {
    return str2;
  } else if (backLen === 0) {
    return str2.slice(0, frontLen) + truncateStr;
  } else {
    return str2.slice(0, frontLen) + truncateStr + str2.slice(strLen - backLen);
  }
};
const truncateMiddle$1 = /* @__PURE__ */ getDefaultExportFromCjs(truncateMiddle);
const TEAL = "#319795";
const BLUE = "#3182CE";
const WHITE = "#EDF2F7";
const getClassnameFromPartType = (type2) => {
  if (type2 === PartType.Static) {
    return classes$2.static;
  }
  return "";
};
const ControlDynamic = () => {
  const { endpoints, parameterise: parameterise2 } = reactExports.useContext(Context);
  const [search2, setSearch] = reactExports.useState("");
  const filteredEndpoints = reactExports.useMemo(() => {
    if (!search2)
      return endpoints;
    const fuseOptions = {
      keys: ["pathname"]
    };
    const fuse = new Fuse(endpoints, fuseOptions);
    const result = fuse.search(search2).map((r2) => r2.item);
    return result;
  }, [search2, endpoints]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        placeholder: "Search for endpoint...",
        value: search2,
        onChange: (e2) => setSearch(e2.target.value),
        className: classes$2.search
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes$2.wrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AutoSizer, { className: classes$2.autosizer, children: ({ height, width }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      FixedSizeList,
      {
        className: classes$2.autosizerchild,
        height,
        itemCount: filteredEndpoints.length,
        itemSize: height / 8,
        width,
        itemData: filteredEndpoints,
        itemKey: (index2) => filteredEndpoints[index2].pathname,
        children: ({ index: index2, data, style }) => {
          const endpoint = data[index2];
          const backgroundColor = index2 % 2 === 0 ? WHITE : void 0;
          const outerKey = endpoint.host + endpoint.pathname;
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style, className: classes$2.autosizerchild, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wrap,
            {
              className: classes$2.listchild,
              backgroundColor,
              spacing: 0,
              children: endpoint.parts.map(({ part, type: type2 }, parameterIsIdx) => {
                const onClick = type2 === PartType.Dynamic ? () => {
                } : () => {
                  parameterise2(
                    parameterIsIdx,
                    endpoint.pathname,
                    endpoint.host
                  );
                };
                const color2 = type2 === PartType.Dynamic ? TEAL : BLUE;
                const key2 = parameterIsIdx + part;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: part, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WrapItem,
                  {
                    color: color2,
                    fontSize: "md",
                    className: getClassnameFromPartType(type2),
                    onClick,
                    children: `/${truncateMiddle$1(part, 12, 5, "...")}`
                  },
                  outerKey + part
                ) }, key2);
              })
            },
            outerKey
          ) });
        }
      }
    ) }) })
  ] });
};
function ControlConfigImport() {
  const ctx = reactExports.useContext(Context);
  const toast = useToast();
  const { isOpen, onOpen, onClose } = useDisclosure$1();
  const [value, setValue] = reactExports.useState("");
  const onCloseModal = () => {
    onClose();
    setValue("");
  };
  const initialRef = reactExports.useRef(null);
  const finalRef = reactExports.useRef(null);
  const onImport = () => {
    const result = ctx.import(value);
    if (result) {
      toast({
        title: "Imported.",
        status: "success",
        duration: 2e3,
        isClosable: true
      });
    } else {
      toast({
        title: "Could not import.",
        status: "error",
        duration: 2e3,
        isClosable: true
      });
    }
    onCloseModal();
    return result;
  };
  const onExport = () => {
    const stateStr = ctx.export();
    copy$2(stateStr);
    toast({
      title: "Copied to clipboard.",
      status: "success",
      duration: 2e3,
      isClosable: true
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Import a state string that was previously exported. This will open a modal, paste in the string to load the state.", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "md", onClick: onOpen, colorScheme: "teal", children: "Import" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Export will copy a state string to your clipboard. Save this somewhere on your computer. You can load it by clicking import and pasting the string.", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "md", onClick: onExport, colorScheme: "teal", children: "Export" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Modal,
      {
        initialFocusRef: initialRef,
        finalFocusRef: finalRef,
        isOpen,
        onClose: onCloseModal,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModalOverlay, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { children: "Import state string" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ModalCloseButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ModalBody, { pb: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                value,
                onChange: (e2) => setValue(e2.target.value),
                ref: initialRef,
                placeholder: "Paste the state string here..."
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalFooter, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onImport, colorScheme: "blue", mr: 3, children: "Import" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onCloseModal, children: "Cancel" })
            ] })
          ] })
        ]
      }
    )
  ] });
}
const label = "_label_1rucx_1";
const actions = "_actions_1rucx_5";
const styles$1 = {
  label,
  actions
};
const QUICKTYPE_URL = "https://app.quicktype.io/";
const generateCodeTooltip = `Paste JSON schemas into ${QUICKTYPE_URL} and convert into client code for 20+ languages, including TypeScript, Java, Rust, and Swift.`;
const ControlConfigActions = () => {
  const toast = useToast();
  const onClickGenerateCode = () => {
    copy$2(QUICKTYPE_URL);
    toast({
      title: `Copied ${QUICKTYPE_URL} to clipboard. Open it in a new tab.`,
      status: "success",
      duration: 2e3,
      isClosable: true
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuButton,
      {
        className: styles$1.actions,
        as: Button,
        rightIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {}),
        children: "Actions"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: generateCodeTooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: onClickGenerateCode, children: "Generate Code" }) }) })
  ] });
};
const TOGGLEMOREID = "toggle-more-info";
const ControlConfig = () => {
  const ctx = reactExports.useContext(Context);
  const [moreInfoEnabled, setMoreInfoEnabled] = reactExports.useState(
    ctx.options().enableMoreInfo
  );
  const onToggleMoreInfo = () => {
    const enableMoreInfo = !ctx.options().enableMoreInfo;
    ctx.options({ enableMoreInfo });
    setMoreInfoEnabled(enableMoreInfo);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { justifyContent: "space-between", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ControlConfigActions, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { display: "flex", alignItems: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: "Include the most recent request and response as examples in the specification. This is kept separate as it could contain private keys etc. Your choice will persist across sessions.", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: styles$1.label, htmlFor: TOGGLEMOREID, mb: "0", children: "More info" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Switch,
          {
            id: TOGGLEMOREID,
            onChange: onToggleMoreInfo,
            isChecked: moreInfoEnabled
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HStack, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ControlConfigImport, {}) })
  ] });
};
const animatedComponents = index();
const bMinusA = (a, b2) => b2.filter((x2) => !a.has(x2));
const ControlDrawer = ({ isOpen, onClose }) => {
  const context = reactExports.useContext(Context);
  const toast = useToast();
  const hosts = Array.from(context.allHosts);
  hosts.sort();
  const enabledHosts = bMinusA(context.disabledHosts, hosts);
  const value = Array.from(enabledHosts).map((host) => ({
    label: host,
    value: host
  }));
  const onChange2 = (valuesLabels) => {
    if (valuesLabels.length === 0) {
      toast({
        title: "Could not apply.",
        description: "You must select at least one host.",
        status: "error",
        duration: 5e3,
        isClosable: true
      });
      return;
    }
    const values2 = valuesLabels.map(({ value: value2 }) => value2);
    const disabledHosts = new Set(bMinusA(new Set(values2), hosts));
    context.setDisabledHosts(disabledHosts);
  };
  const options2 = hosts.map(
    (host) => ({ value: host, label: host })
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Drawer, { isOpen, placement: "right", onClose, size: "lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalOverlay, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalCloseButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ModalHeader, { children: "Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalBody, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ControlConfig, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h2", size: "sm", marginBottom: "1em", marginTop: "1em", children: "Filter Hosts" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          StateManagedSelect$1,
          {
            onChange: onChange2,
            value,
            options: options2,
            isMulti: true,
            name: "colors",
            className: "basic-multi-select",
            classNamePrefix: "select",
            components: animatedComponents
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { justifyContent: "space-between", alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h2", size: "sm", margin: "1em 0", children: "Set Path Parameters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              label: "Click on a part in a pathname to make it a path parameter. I.e. in /posts/1, /posts/2, click 1 or 2 to create a single endpoint /posts/:param1. This is a one way operation.",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlineIcon, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ControlDynamic, {})
      ] })
    ] })
  ] });
};
const Control2 = ({ start: start2, stop, clear: clear3, status }) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes$3.wrapper, children: [
      status === Status.STOPPED ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartBtn, { onClick: start2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StopBtn, { onClick: stop }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsBtn, { onClick: () => setIsOpen(true) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ClearBtn, { onClick: clear3 })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ControlDrawer, { isOpen, onClose: () => setIsOpen(false) })
  ] });
};
const wrapper$1 = "_wrapper_1aaj5_1";
const classes$1 = {
  wrapper: wrapper$1
};
const Start = ({ start: start2 }) => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const onClick = () => {
    if (!isLoading)
      start2();
    setIsLoading(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes$1.wrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      leftIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewIcon, {}),
      isLoading,
      loadingText: "Waiting for first request...",
      onClick,
      disabled: isLoading,
      colorScheme: "teal",
      children: "Start Recording"
    }
  ) });
};
const wrapper = "_wrapper_7m4vv_1";
const classes = {
  wrapper
};
const ALIAS = Symbol.for("yaml.alias");
const DOC = Symbol.for("yaml.document");
const MAP = Symbol.for("yaml.map");
const PAIR = Symbol.for("yaml.pair");
const SCALAR = Symbol.for("yaml.scalar");
const SEQ = Symbol.for("yaml.seq");
const NODE_TYPE = Symbol.for("yaml.node.type");
const isAlias = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS;
const isDocument = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC;
const isMap = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP;
const isPair = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR;
const isScalar = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR;
const isSeq = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ;
function isCollection(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
const hasAnchor = (node2) => (isScalar(node2) || isCollection(node2)) && !!node2.anchor;
const BREAK = Symbol("break visit");
const SKIP = Symbol("skip children");
const REMOVE = Symbol("remove node");
function visit2(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd2 = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd2 === REMOVE)
      node2.contents = null;
  } else
    visit_(null, node2, visitor_, Object.freeze([]));
}
visit2.BREAK = BREAK;
visit2.SKIP = SKIP;
visit2.REMOVE = REMOVE;
function visit_(key2, node2, visitor, path2) {
  const ctrl = callVisitor(key2, node2, visitor, path2);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key2, path2, ctrl);
    return visit_(key2, ctrl, visitor, path2);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node2)) {
      path2 = Object.freeze(path2.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci2 = visit_(i, node2.items[i], visitor, path2);
        if (typeof ci2 === "number")
          i = ci2 - 1;
        else if (ci2 === BREAK)
          return BREAK;
        else if (ci2 === REMOVE) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path2 = Object.freeze(path2.concat(node2));
      const ck2 = visit_("key", node2.key, visitor, path2);
      if (ck2 === BREAK)
        return BREAK;
      else if (ck2 === REMOVE)
        node2.key = null;
      const cv = visit_("value", node2.value, visitor, path2);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node2.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key2, node2, visitor, path2) {
  var _a4, _b3, _c2, _d2, _e2;
  if (typeof visitor === "function")
    return visitor(key2, node2, path2);
  if (isMap(node2))
    return (_a4 = visitor.Map) == null ? void 0 : _a4.call(visitor, key2, node2, path2);
  if (isSeq(node2))
    return (_b3 = visitor.Seq) == null ? void 0 : _b3.call(visitor, key2, node2, path2);
  if (isPair(node2))
    return (_c2 = visitor.Pair) == null ? void 0 : _c2.call(visitor, key2, node2, path2);
  if (isScalar(node2))
    return (_d2 = visitor.Scalar) == null ? void 0 : _d2.call(visitor, key2, node2, path2);
  if (isAlias(node2))
    return (_e2 = visitor.Alias) == null ? void 0 : _e2.call(visitor, key2, node2, path2);
  return void 0;
}
function replaceNode(key2, path2, node2) {
  const parent = path2[path2.length - 1];
  if (isCollection(parent)) {
    parent.items[key2] = node2;
  } else if (isPair(parent)) {
    if (key2 === "key")
      parent.key = node2;
    else
      parent.value = node2;
  } else if (isDocument(parent)) {
    parent.contents = node2;
  } else {
    const pt2 = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt2} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch2) => escapeChars[ch2]);
class Directives {
  constructor(yaml, tags2) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags2);
  }
  clone() {
    const copy2 = new Directives(this.yaml, this.tags);
    copy2.docStart = this.docStart;
    return copy2;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line2, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line2.trim().split(/[ \t]+/);
    const name2 = parts.shift();
    switch (name2) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix2] = parts;
        this.tags[handle] = prefix2;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version2] = parts;
        if (version2 === "1.1" || version2 === "1.2") {
          this.yaml.version = version2;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version2);
          onError(6, `Unsupported YAML version ${version2}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name2}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix2 = this.tags[handle];
    if (prefix2) {
      try {
        return prefix2 + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix2] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix2))
        return handle + escapeTagName(tag.substring(prefix2.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags2 = {};
      visit2(doc.contents, (_key, node2) => {
        if (isNode(node2) && node2.tag)
          tags2[node2.tag] = true;
      });
      tagNames = Object.keys(tags2);
    } else
      tagNames = [];
    for (const [handle, prefix2] of tagEntries) {
      if (handle === "!!" && prefix2 === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix2)))
        lines.push(`%TAG ${handle} ${prefix2}`);
    }
    return lines.join("\n");
  }
}
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa2 = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa2}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit2(root, {
    Value(_key, node2) {
      if (node2.anchor)
        anchors.add(node2.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix2, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix2}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix2) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix2, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
function applyReviver(reviver, obj, key2, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key2, val);
}
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i) => toJS(v2, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}
class NodeBase {
  constructor(type2) {
    Object.defineProperty(this, NODE_TYPE, { value: type2 });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count2, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count2);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
}
class Alias extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit2(doc, {
      Node: (_key, node2) => {
        if (node2 === this)
          return visit2.BREAK;
        if (node2.anchor === this.source)
          found = node2;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount2(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
}
function getAliasCount2(doc, node2, anchors) {
  if (isAlias(node2)) {
    const source = node2.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node2)) {
    let count2 = 0;
    for (const item of node2.items) {
      const c2 = getAliasCount2(doc, item, anchors);
      if (c2 > count2)
        count2 = c2;
    }
    return count2;
  } else if (isPair(node2)) {
    const kc2 = getAliasCount2(doc, node2.key, anchors);
    const vc2 = getAliasCount2(doc, node2.value, anchors);
    return Math.max(kc2, vc2);
  }
  return 1;
}
const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
class Scalar extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags2) {
  if (tagName) {
    const match2 = tags2.filter((t2) => t2.tag === tagName);
    const tagObj = match2.find((t2) => !t2.format) ?? match2[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags2.find((t2) => {
    var _a4;
    return ((_a4 = t2.identify) == null ? void 0 : _a4.call(t2, value)) && !t2.format;
  });
}
function createNode4(value, tagName, ctx) {
  var _a4, _b3, _c2;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map3 = (_b3 = (_a4 = ctx.schema[MAP]).createNode) == null ? void 0 : _b3.call(_a4, ctx.schema, null, ctx);
    map3.items.push(value);
    return map3;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node3 = new Scalar(value);
      if (ref)
        ref.node = node3;
      return node3;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node2 = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c2 = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c2.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node2.tag = tagName;
  else if (!tagObj.default)
    node2.tag = tagObj.tag;
  if (ref)
    ref.node = node2;
  return node2;
}
function collectionFromPath(schema2, path2, value) {
  let v2 = value;
  for (let i = path2.length - 1; i >= 0; --i) {
    const k2 = path2[i];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a = [];
      a[k2] = v2;
      v2 = a;
    } else {
      v2 = /* @__PURE__ */ new Map([[k2, v2]]);
    }
  }
  return createNode4(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath2 = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
class Collection extends NodeBase {
  constructor(type2, schema2) {
    super(type2);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema2) {
    const copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy2.schema = schema2;
    copy2.items = copy2.items.map((it2) => isNode(it2) || isPair(it2) ? it2.clone(schema2) : it2);
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path2, value) {
    if (isEmptyPath2(path2))
      this.add(value);
    else {
      const [key2, ...rest] = path2;
      const node2 = this.get(key2, true);
      if (isCollection(node2))
        node2.addIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path2) {
    const [key2, ...rest] = path2;
    if (rest.length === 0)
      return this.delete(key2);
    const node2 = this.get(key2, true);
    if (isCollection(node2))
      return node2.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path2, keepScalar) {
    const [key2, ...rest] = path2;
    const node2 = this.get(key2, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node2) ? node2.value : node2;
    else
      return isCollection(node2) ? node2.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node2) => {
      if (!isPair(node2))
        return false;
      const n2 = node2.value;
      return n2 == null || allowScalar && isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path2) {
    const [key2, ...rest] = path2;
    if (rest.length === 0)
      return this.has(key2);
    const node2 = this.get(key2, true);
    return isCollection(node2) ? node2.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path2, value) {
    const [key2, ...rest] = path2;
    if (rest.length === 0) {
      this.set(key2, value);
    } else {
      const node2 = this.get(key2, true);
      if (isCollection(node2))
        node2.setIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
}
Collection.maxFlowStringSingleLineLength = 60;
const stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
const lineComment = (str2, indent, comment2) => str2.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str2.endsWith(" ") ? "" : " ") + comment2;
const FOLD_FLOW = "flow";
const FOLD_BLOCK = "block";
const FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev2 = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i = consumeMoreIndentedLines2(text, i);
    if (i !== -1)
      end2 = i + endStep;
  }
  for (let ch2; ch2 = text[i += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch2 === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch2 === "\n") {
      if (mode2 === FOLD_BLOCK)
        i = consumeMoreIndentedLines2(text, i);
      end2 = i + endStep;
      split = void 0;
    } else {
      if (ch2 === " " && prev2 && prev2 !== " " && prev2 !== "\n" && prev2 !== "	") {
        const next2 = text[i + 1];
        if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
          split = i;
      }
      if (i >= end2) {
        if (split) {
          folds.push(split);
          end2 = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev2 === " " || prev2 === "	") {
            prev2 = ch2;
            ch2 = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end2 = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev2 = ch2;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end3 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end3)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end3)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines2(text, i) {
  let ch2 = text[i + 1];
  while (ch2 === " " || ch2 === "	") {
    do {
      ch2 = text[i += 1];
    } while (ch2 && ch2 !== "\n");
    ch2 = text[i + 1];
  }
  return i;
}
const getFoldOptions2 = (ctx, isBlock) => ({
  indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
const containsDocumentMarker2 = (str2) => /^(%|---|\.\.\.)/m.test(str2);
function lineLengthOverLimit(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start2 = 0; i < strLen; ++i) {
    if (str2[i] === "\n") {
      if (i - start2 > limit)
        return true;
      start2 = i + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json2 = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker2(value) ? "  " : "");
  let str2 = "";
  let start2 = 0;
  for (let i = 0, ch2 = json2[i]; ch2; ch2 = json2[++i]) {
    if (ch2 === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str2 += json2.slice(start2, i) + "\\ ";
      i += 1;
      start2 = i;
      ch2 = "\\";
    }
    if (ch2 === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str2 += json2.slice(start2, i);
            const code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json2.substr(i, 6);
            }
            i += 5;
            start2 = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str2 += json2.slice(start2, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str2 += "\n";
              i += 2;
            }
            str2 += indent;
            if (json2[i + 2] === " ")
              str2 += "\\";
            i += 1;
            start2 = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str2 = start2 ? str2 + json2.slice(start2) : json2;
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions2(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker2(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions2(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs2;
  if (singleQuote === false)
    qs2 = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString;
    else
      qs2 = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs2(value, ctx);
}
let blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker2(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type2 === Scalar.BLOCK_FOLDED ? false : type2 === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch2 = value[endStart - 1];
    if (ch2 !== "\n" && ch2 !== "	" && ch2 !== " ")
      break;
  }
  let end2 = value.substring(endStart);
  const endNlPos = end2.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end2 || endNlPos !== end2.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end2) {
    value = value.slice(0, -end2.length);
    if (end2[end2.length - 1] === "\n")
      end2 = end2.slice(0, -1);
    end2 = end2.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch2 = value[startEnd];
    if (ch2 === " ")
      startWithSpace = true;
    else if (ch2 === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value = value.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start2}${value}${end2}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start2}${value}${end2}`, indent, FOLD_BLOCK, getFoldOptions2(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type: type2, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type2 !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker2(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str2 = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test2 = (tag) => {
      var _a4;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a4 = tag.test) == null ? void 0 : _a4.test(str2));
    };
    const { compat: compat3, tags: tags2 } = ctx.doc.schema;
    if (tags2.some(test2) || (compat3 == null ? void 0 : compat3.some(test2)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions2(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type: type2 } = item;
  if (type2 !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type2 = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type2);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags2, item) {
  var _a4;
  if (item.tag) {
    const match2 = tags2.filter((t2) => t2.tag === item.tag);
    if (match2.length > 0)
      return match2.find((t2) => t2.format === item.format) ?? match2[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match2 = tags2.filter((t2) => {
      var _a5;
      return (_a5 = t2.identify) == null ? void 0 : _a5.call(t2, obj);
    });
    tagObj = match2.find((t2) => t2.format === item.format) ?? match2.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags2.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name2 = ((_a4 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a4.name) ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node2, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node2) || isCollection(node2)) && node2.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
  var _a4;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a4 = ctx.resolvedAliases) == null ? void 0 : _a4.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node2 = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node2);
  const props = stringifyProps(node2, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx, onComment, onChompKeep) : isScalar(node2) ? stringifyString(node2, ctx, onComment, onChompKeep) : node2.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str2;
  return isScalar(node2) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
}
function stringifyPair({ key: key2, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key2) && key2.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key2)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key2 || keyComment && value == null && !ctx.inFlow || isCollection(key2) || (isScalar(key2) ? key2.type === Scalar.BLOCK_FOLDED || key2.type === Scalar.BLOCK_LITERAL : typeof key2 === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str2 = stringify$1(key2, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str2 = `? ${str2}`;
    if (keyComment && !keyCommentDone) {
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str2;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    str2 = `? ${str2}
${indent}:`;
  } else {
    str2 = `${str2}:`;
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str2.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$1(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow3 = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow3) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str2 += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str2 += lineComment(str2, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str2;
}
function warn(logLevel, warning2) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning2);
    else
      console.warn(warning2);
  }
}
const MERGE_KEY = "<<";
function addPairToJSMap(ctx, map3, { key: key2, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key2)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it2 of value.items)
        mergeToJSMap(ctx, map3, it2);
    else if (Array.isArray(value))
      for (const it2 of value)
        mergeToJSMap(ctx, map3, it2);
    else
      mergeToJSMap(ctx, map3, value);
  } else {
    const jsKey = toJS(key2, "", ctx);
    if (map3 instanceof Map) {
      map3.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map3 instanceof Set) {
      map3.add(jsKey);
    } else {
      const stringKey = stringifyKey2(key2, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map3)
        Object.defineProperty(map3, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map3[stringKey] = jsValue;
    }
  }
  return map3;
}
const isMergeKey = (key2) => key2 === MERGE_KEY || isScalar(key2) && key2.value === MERGE_KEY && (!key2.type || key2.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map3, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key2, value2] of srcMap) {
    if (map3 instanceof Map) {
      if (!map3.has(key2))
        map3.set(key2, value2);
    } else if (map3 instanceof Set) {
      map3.add(key2);
    } else if (!Object.prototype.hasOwnProperty.call(map3, key2)) {
      Object.defineProperty(map3, key2, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map3;
}
function stringifyKey2(key2, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key2) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node2 of ctx.anchors.keys())
      strCtx.anchors.add(node2.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key2.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key2, value, ctx) {
  const k2 = createNode4(key2, void 0, ctx);
  const v2 = createNode4(value, void 0, ctx);
  return new Pair(k2, v2);
}
class Pair {
  constructor(key2, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key2;
    this.value = value;
  }
  clone(schema2) {
    let { key: key2, value } = this;
    if (isNode(key2))
      key2 = key2.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new Pair(key2, value);
  }
  toJSON(_2, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
function stringifyCollection(collection, ctx, options2) {
  const flow3 = ctx.inFlow ?? collection.flow;
  const stringify16 = flow3 ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify16(collection, ctx, options2);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment3 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik2 = isNode(item.key) ? item.key : null;
      if (ik2) {
        if (!chompKeep && ik2.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik2.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str3 = stringify$1(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str3 += lineComment(str3, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str3);
  }
  let str2;
  if (lines.length === 0) {
    str2 = flowChars.start + flowChars.end;
  } else {
    str2 = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line2 = lines[i];
      str2 += line2 ? `
${indent}${line2}` : "\n";
    }
  }
  if (comment2) {
    str2 += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str2;
}
function stringifyFlowCollection({ comment: comment2, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment3 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik2 = isNode(item.key) ? item.key : null;
      if (ik2) {
        if (ik2.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik2.commentBefore, false);
        if (ik2.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment3 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik2 == null ? void 0 : ik2.comment)) {
        comment3 = ik2.comment;
      }
    }
    if (comment3)
      reqNewline = true;
    let str3 = stringify$1(item, itemCtx, () => comment3 = null);
    if (i < items.length - 1)
      str3 += ",";
    if (comment3)
      str3 += lineComment(str3, itemIndent, commentString(comment3));
    if (!reqNewline && (lines.length > linesAtValue || str3.includes("\n")))
      reqNewline = true;
    lines.push(str3);
    linesAtValue = lines.length;
  }
  let str2;
  const { start: start2, end: end2 } = flowChars;
  if (lines.length === 0) {
    str2 = start2 + end2;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line2) => sum + line2.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str2 = start2;
      for (const line2 of lines)
        str2 += line2 ? `
${indentStep}${indent}${line2}` : "\n";
      str2 += `
${indent}${end2}`;
    } else {
      str2 = `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
    }
  }
  if (comment2) {
    str2 += lineComment(str2, indent, commentString(comment2));
    if (onComment)
      onComment();
  }
  return str2;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic2 = indentComment(commentString(comment2), indent);
    lines.push(ic2.trimStart());
  }
}
function findPair(items, key2) {
  const k2 = isScalar(key2) ? key2.value : key2;
  for (const it2 of items) {
    if (isPair(it2)) {
      if (it2.key === key2 || it2.key === k2)
        return it2;
      if (isScalar(it2.key) && it2.key.value === k2)
        return it2;
    }
  }
  return void 0;
}
class YAMLMap extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema2, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map3 = new this(schema2);
    const add2 = (key2, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key2, value);
      else if (Array.isArray(replacer) && !replacer.includes(key2))
        return;
      if (value !== void 0 || keepUndefined)
        map3.items.push(createPair(key2, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key2, value] of obj)
        add2(key2, value);
    } else if (obj && typeof obj === "object") {
      for (const key2 of Object.keys(obj))
        add2(key2, obj[key2]);
    }
    if (typeof schema2.sortMapEntries === "function") {
      map3.items.sort(schema2.sortMapEntries);
    }
    return map3;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a4;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev2 = findPair(this.items, _pair.key);
    const sortEntries = (_a4 = this.schema) == null ? void 0 : _a4.sortMapEntries;
    if (prev2) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev2.value) && isScalarValue(_pair.value))
        prev2.value.value = _pair.value;
      else
        prev2.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key2) {
    const it2 = findPair(this.items, key2);
    if (!it2)
      return false;
    const del = this.items.splice(this.items.indexOf(it2), 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    const it2 = findPair(this.items, key2);
    const node2 = it2 == null ? void 0 : it2.value;
    return (!keepScalar && isScalar(node2) ? node2.value : node2) ?? void 0;
  }
  has(key2) {
    return !!findPair(this.items, key2);
  }
  set(key2, value) {
    this.add(new Pair(key2, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_2, ctx, Type2) {
    const map3 = Type2 ? new Type2() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map3);
    for (const item of this.items)
      addPairToJSMap(ctx, map3, item);
    return map3;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
}
const map2 = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map3, onError) {
    if (!isMap(map3))
      onError("Expected a mapping for this tag");
    return map3;
  },
  createNode: (schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx)
};
class YAMLSeq extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key2) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return void 0;
    const it2 = this.items[idx];
    return !keepScalar && isScalar(it2) ? it2.value : it2;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key2) {
    const idx = asItemIndex(key2);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key2, value) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key2}.`);
    const prev2 = this.items[idx];
    if (isScalar(prev2) && isScalarValue(value))
      prev2.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_2, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema2, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema2);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it2 of obj) {
        if (typeof replacer === "function") {
          const key2 = obj instanceof Set ? it2 : String(i++);
          it2 = replacer.call(obj, key2, it2);
        }
        seq2.items.push(createNode4(it2, void 0, ctx));
      }
    }
    return seq2;
  }
}
function asItemIndex(key2) {
  let idx = isScalar(key2) ? key2.value : key2;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
const seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx)
};
const string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str2) => str2,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
const nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
const boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str2) => new Scalar(str2[0] === "t" || str2[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i = n2.indexOf(".");
    if (i < 0) {
      i = n2.length;
      n2 += ".";
    }
    let d2 = minFractionDigits - (n2.length - i - 1);
    while (d2-- > 0)
      n2 += "0";
  }
  return n2;
}
const floatNaN$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str2) => parseFloat(str2),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
const float$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str2) {
    const node2 = new Scalar(parseFloat(str2));
    const dot = str2.indexOf(".");
    if (dot !== -1 && str2[str2.length - 1] === "0")
      node2.minFractionDigits = str2.length - dot - 1;
    return node2;
  },
  stringify: stringifyNumber
};
const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
const intResolve$1 = (str2, offset2, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset2), radix);
function intStringify$1(node2, radix, prefix2) {
  const { value } = node2;
  if (intIdentify$2(value) && value >= 0)
    return prefix2 + value.toString(radix);
  return stringifyNumber(node2);
}
const intOct$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 8, opt),
  stringify: (node2) => intStringify$1(node2, 8, "0o")
};
const int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 16, opt),
  stringify: (node2) => intStringify$1(node2, 16, "0x")
};
const schema$2 = [
  map2,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
const stringifyJSON2 = ({ value }) => JSON.stringify(value);
const jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str2) => str2,
    stringify: stringifyJSON2
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON2
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str2) => str2 === "true",
    stringify: stringifyJSON2
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
    stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str2) => parseFloat(str2),
    stringify: stringifyJSON2
  }
];
const jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str2, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    return str2;
  }
};
const schema$1 = [map2, seq].concat(jsonScalars, jsonError);
const binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str2 = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str2.length);
      for (let i = 0; i < str2.length; ++i)
        buffer[i] = str2.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str2;
    if (typeof Buffer === "function") {
      str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str2 = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type2)
      type2 = Scalar.BLOCK_LITERAL;
    if (type2 !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n2 = Math.ceil(str2.length / lineWidth);
      const lines = new Array(n2);
      for (let i = 0, o = 0; i < n2; ++i, o += lineWidth) {
        lines[i] = str2.substr(o, lineWidth);
      }
      str2 = lines.join(type2 === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type: type2, value: str2 }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it2 of iterable) {
      if (typeof replacer === "function")
        it2 = replacer.call(iterable, String(i++), it2);
      let key2, value;
      if (Array.isArray(it2)) {
        if (it2.length === 2) {
          key2 = it2[0];
          value = it2[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it2}`);
      } else if (it2 && it2 instanceof Object) {
        const keys2 = Object.keys(it2);
        if (keys2.length === 1) {
          key2 = keys2[0];
          value = it2[key2];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys2.length} keys`);
        }
      } else {
        key2 = it2;
      }
      pairs2.items.push(createPair(key2, value, ctx));
    }
  return pairs2;
}
const pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_2, ctx) {
    if (!ctx)
      return super.toJSON(_2);
    const map3 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map3);
    for (const pair of this.items) {
      let key2, value;
      if (isPair(pair)) {
        key2 = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key2, ctx);
      } else {
        key2 = toJS(pair, "", ctx);
      }
      if (map3.has(key2))
        throw new Error("Ordered maps must not include duplicate keys");
      map3.set(key2, value);
    }
    return map3;
  }
  static from(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key: key2 } of pairs2.items) {
      if (isScalar(key2)) {
        if (seenKeys.includes(key2.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key2.value}`);
        } else {
          seenKeys.push(key2.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
};
function boolStringify2({ value, source }, ctx) {
  const boolObj2 = value ? trueTag : falseTag;
  if (source && boolObj2.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify2
};
const falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify2
};
const floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
const float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str2) {
    const node2 = new Scalar(parseFloat(str2.replace(/_/g, "")));
    const dot = str2.indexOf(".");
    if (dot !== -1) {
      const f2 = str2.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node2.minFractionDigits = f2.length;
    }
    return node2;
  },
  stringify: stringifyNumber
};
const intIdentify4 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str2, offset2, radix, { intAsBigInt }) {
  const sign = str2[0];
  if (sign === "-" || sign === "+")
    offset2 += 1;
  str2 = str2.substring(offset2).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str2 = `0b${str2}`;
        break;
      case 8:
        str2 = `0o${str2}`;
        break;
      case 16:
        str2 = `0x${str2}`;
        break;
    }
    const n3 = BigInt(str2);
    return sign === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str2, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify(node2, radix, prefix2) {
  const { value } = node2;
  if (intIdentify4(value)) {
    const str2 = value.toString(radix);
    return value < 0 ? "-" + prefix2 + str2.substr(1) : prefix2 + str2;
  }
  return stringifyNumber(node2);
}
const intBin = {
  identify: intIdentify4,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str2, _onError, opt) => intResolve2(str2, 2, 2, opt),
  stringify: (node2) => intStringify(node2, 2, "0b")
};
const intOct = {
  identify: intIdentify4,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str2, _onError, opt) => intResolve2(str2, 1, 8, opt),
  stringify: (node2) => intStringify(node2, 8, "0")
};
const int = {
  identify: intIdentify4,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str2, _onError, opt) => intResolve2(str2, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex = {
  identify: intIdentify4,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str2, _onError, opt) => intResolve2(str2, 2, 16, opt),
  stringify: (node2) => intStringify(node2, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key2) {
    let pair;
    if (isPair(key2))
      pair = key2;
    else if (key2 && typeof key2 === "object" && "key" in key2 && "value" in key2 && key2.value === null)
      pair = new Pair(key2.key, null);
    else
      pair = new Pair(key2, null);
    const prev2 = findPair(this.items, pair.key);
    if (!prev2)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key2, keepPair) {
    const pair = findPair(this.items, key2);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key2, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev2 = findPair(this.items, key2);
    if (prev2 && !value) {
      this.items.splice(this.items.indexOf(prev2), 1);
    } else if (!prev2 && value) {
      this.items.push(new Pair(key2));
    }
  }
  toJSON(_2, ctx) {
    return super.toJSON(_2, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema2, iterable, ctx) {
    const { replacer } = ctx;
    const set5 = new this(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set5.items.push(createPair(value, null, ctx));
      }
    return set5;
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set4 = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
  resolve(map3, onError) {
    if (isMap(map3)) {
      if (map3.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map3);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map3;
  }
};
function parseSexagesimal2(str2, asBigInt) {
  const sign = str2[0];
  const parts = sign === "-" || sign === "+" ? str2.substring(1) : str2;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal2(node2) {
  let { value } = node2;
  let num = (n2) => n2;
  if (typeof value === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node2);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n2) => String(n2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal2(str2, intAsBigInt),
  stringify: stringifySexagesimal2
};
const floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str2) => parseSexagesimal2(str2, false),
  stringify: stringifySexagesimal2
};
const timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str2) {
    const match2 = str2.match(timestamp.test);
    if (!match2)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match2.map(Number);
    const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match2[8];
    if (tz && tz !== "Z") {
      let d2 = parseSexagesimal2(tz, false);
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
const schema = [
  map2,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  omap,
  pairs,
  set4,
  intTime,
  floatTime,
  timestamp
];
const schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map2, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
const tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map: map2,
  null: nullTag,
  omap,
  pairs,
  seq,
  set: set4,
  timestamp
};
const coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set4,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags2 = schemas.get(schemaName);
  if (!tags2) {
    if (Array.isArray(customTags))
      tags2 = [];
    else {
      const keys2 = Array.from(schemas.keys()).filter((key2) => key2 !== "yaml11").map((key2) => JSON.stringify(key2)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys2} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags2 = tags2.concat(tag);
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  return tags2.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys2 = Object.keys(tagsByName).map((key2) => JSON.stringify(key2)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys2}`);
  });
}
const sortMapEntriesByKey2 = (a, b2) => a.key < b2.key ? -1 : a.key > b2.key ? 1 : 0;
class Schema {
  constructor({ compat: compat3, customTags, merge: merge2, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat3) ? getTags(compat3, "compat") : compat3 ? getTags(null, compat3) : null;
    this.merge = !!merge2;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map2 });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey2 : null;
  }
  clone() {
    const copy2 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy2.tags = this.tags.slice();
    return copy2;
  }
}
function stringifyDocument(doc, options2) {
  var _a4;
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$1(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$1(doc.contents, ctx));
  }
  if ((_a4 = doc.directives) == null ? void 0 : _a4.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc2 = doc.comment;
    if (dc2 && chompKeep)
      dc2 = dc2.replace(/^\n+/, "");
    if (dc2) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc2), ""));
    }
  }
  return lines.join("\n") + "\n";
}
class Document {
  constructor(value, replacer, options2) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options2);
    this.options = opt;
    let { version: version2 } = opt;
    if (options2 == null ? void 0 : options2._directives) {
      this.directives = options2._directives.atDocument();
      if (this.directives.yaml.explicit)
        version2 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version2 });
    this.setSchema(version2, options2);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options2);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy2 = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy2.commentBefore = this.commentBefore;
    copy2.comment = this.comment;
    copy2.errors = this.errors.slice();
    copy2.warnings = this.warnings.slice();
    copy2.options = Object.assign({}, this.options);
    if (this.directives)
      copy2.directives = this.directives.clone();
    copy2.schema = this.schema.clone();
    copy2.contents = isNode(this.contents) ? this.contents.clone(copy2.schema) : this.contents;
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path2, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path2, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node2, name2) {
    if (!node2.anchor) {
      const prev2 = anchorNames(this);
      node2.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name2 || prev2.has(name2) ? findNewAnchor(name2 || "a", prev2) : name2;
    }
    return new Alias(node2.anchor);
  }
  createNode(value, replacer, options2) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow: flow3, keepUndefined, onTagObj, tag } = options2 ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node2 = createNode4(value, tag, ctx);
    if (flow3 && isCollection(node2))
      node2.flow = true;
    setAnchors();
    return node2;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key2, value, options2 = {}) {
    const k2 = this.createNode(key2, null, options2);
    const v2 = this.createNode(value, null, options2);
    return new Pair(k2, v2);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key2) {
    return assertCollection(this.contents) ? this.contents.delete(key2) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path2) {
    if (isEmptyPath2(path2)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key2, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key2, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path2, keepScalar) {
    if (isEmptyPath2(path2))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key2) {
    return isCollection(this.contents) ? this.contents.has(key2) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path2) {
    if (isEmptyPath2(path2))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path2) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key2, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key2], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key2, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path2, value) {
    if (isEmptyPath2(path2)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path2), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path2, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version2, options2 = {}) {
    if (typeof version2 === "number")
      version2 = String(version2);
    let opt;
    switch (version2) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version2;
        else
          this.directives = new Directives({ version: version2 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version2);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options2.schema instanceof Object)
      this.schema = options2.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options2));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json2,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count2, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count2);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options2 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
      const s = JSON.stringify(options2.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options2);
  }
}
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function stringify15(value, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options2).toString(options2);
}
class e {
  static create(o) {
    return new e(o);
  }
  constructor(o) {
    this.rootDoc = o || {
      openapi: "3.1.0",
      info: {
        title: "app",
        version: "version"
      },
      paths: {},
      components: {
        schemas: {},
        responses: {},
        parameters: {},
        examples: {},
        requestBodies: {},
        headers: {},
        securitySchemes: {},
        links: {},
        callbacks: {}
      },
      tags: [],
      servers: []
    };
  }
  getSpec() {
    return this.rootDoc;
  }
  getSpecAsJson(o, t2) {
    return JSON.stringify(this.rootDoc, o, t2);
  }
  getSpecAsYaml() {
    return stringify15(this.rootDoc);
  }
  static isValidOpenApiVersion(o) {
    o = o || "";
    const t2 = /(\d+)\.(\d+).(\d+)/.exec(o);
    return !!(t2 && parseInt(t2[1], 10) >= 3);
  }
  addOpenApiVersion(o) {
    if (!e.isValidOpenApiVersion(o))
      throw new Error(
        "Invalid OpenApi version: " + o + ". Follow convention: 3.x.y"
      );
    return this.rootDoc.openapi = o, this;
  }
  addInfo(o) {
    return this.rootDoc.info = o, this;
  }
  addContact(o) {
    return this.rootDoc.info.contact = o, this;
  }
  addLicense(o) {
    return this.rootDoc.info.license = o, this;
  }
  addTitle(o) {
    return this.rootDoc.info.title = o, this;
  }
  addDescription(o) {
    return this.rootDoc.info.description = o, this;
  }
  addTermsOfService(o) {
    return this.rootDoc.info.termsOfService = o, this;
  }
  addVersion(o) {
    return this.rootDoc.info.version = o, this;
  }
  addPath(o, t2) {
    return this.rootDoc.paths = this.rootDoc.paths || {}, this.rootDoc.paths[o] = { ...this.rootDoc.paths[o] || {}, ...t2 }, this;
  }
  addSchema(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.schemas = this.rootDoc.components.schemas || {}, this.rootDoc.components.schemas[o] = t2, this;
  }
  addResponse(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.responses = this.rootDoc.components.responses || {}, this.rootDoc.components.responses[o] = t2, this;
  }
  addParameter(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.parameters = this.rootDoc.components.parameters || {}, this.rootDoc.components.parameters[o] = t2, this;
  }
  addExample(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.examples = this.rootDoc.components.examples || {}, this.rootDoc.components.examples[o] = t2, this;
  }
  addRequestBody(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.requestBodies = this.rootDoc.components.requestBodies || {}, this.rootDoc.components.requestBodies[o] = t2, this;
  }
  addHeader(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.headers = this.rootDoc.components.headers || {}, this.rootDoc.components.headers[o] = t2, this;
  }
  addSecurityScheme(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.securitySchemes = this.rootDoc.components.securitySchemes || {}, this.rootDoc.components.securitySchemes[o] = t2, this;
  }
  addLink(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.links = this.rootDoc.components.links || {}, this.rootDoc.components.links[o] = t2, this;
  }
  addCallback(o, t2) {
    return this.rootDoc.components = this.rootDoc.components || {}, this.rootDoc.components.callbacks = this.rootDoc.components.callbacks || {}, this.rootDoc.components.callbacks[o] = t2, this;
  }
  addServer(o) {
    return this.rootDoc.servers = this.rootDoc.servers || [], this.rootDoc.servers.push(o), this;
  }
  addTag(o) {
    return this.rootDoc.tags = this.rootDoc.tags || [], this.rootDoc.tags.push(o), this;
  }
  addExternalDocs(o) {
    return this.rootDoc.externalDocs = o, this;
  }
  addWebhook(o, t2) {
    var r2;
    return (r2 = this.rootDoc).webhooks ?? (r2.webhooks = {}), this.rootDoc.webhooks[o] = t2, this;
  }
}
const createSecuritySchemeTypes = (auth) => {
  if (!auth)
    return;
  const isBearer = auth.authType === AuthType.HTTP_HEADER_BEARER;
  const isBasic = auth.authType === AuthType.HTTP_HEADER_BASIC;
  const isDigest = auth.authType === AuthType.HTTP_HEADER_DIGEST;
  if (isBearer || isBasic || isDigest) {
    const httpAuth = {
      type: auth.type,
      in: auth.in,
      scheme: auth.scheme
    };
    return httpAuth;
  }
  const isAPIKeyHeader = auth.authType.startsWith(AuthType.APIKEY_HEADER_);
  const isAPIKeyCookie = auth.authType.startsWith(AuthType.APIKEY_COOKIE_);
  if (isAPIKeyHeader || isAPIKeyCookie) {
    const apiKeyHeader = {
      type: auth.type,
      in: auth.in,
      name: auth.name
    };
    return apiKeyHeader;
  }
};
const shouldIncludeRequestBody = (method) => {
  return !(/* @__PURE__ */ new Set(["get", "delete", "head"])).has(method.toLowerCase());
};
const createRequestTypes = (requestType, options2) => {
  if (!requestType)
    return;
  const contentObject = {};
  Object.entries(requestType).forEach(([mediaType, data]) => {
    const mediaTypeObject = {
      schema: data.body,
      ...!!options2.enableMoreInfo && { example: data.mostRecent }
    };
    contentObject[mediaType] = mediaTypeObject;
  });
  const requestBodyObject = {
    content: contentObject
  };
  return requestBodyObject;
};
const createResponseTypes = (responseType, headers, options2) => {
  const headersObject = {};
  if (headers && headers.properties) {
    if (headers.properties) {
      Object.entries(headers.properties).forEach(([name2, schema2]) => {
        const headerObj = {
          required: false,
          schema: schema2
        };
        headersObject[name2] = headerObj;
      });
    }
  }
  const responsesObject = {};
  Object.entries(responseType).forEach(([statusCode, mediaTypeObj]) => {
    Object.entries(mediaTypeObj).forEach(([mediaType, data]) => {
      const contentObject = {};
      const mediaTypeObject = {
        schema: data.body,
        ...!!options2.enableMoreInfo && { example: data.mostRecent }
      };
      contentObject[mediaType] = mediaTypeObject;
      const responseObject = {
        content: contentObject,
        description: "",
        headers: headersObject
      };
      responsesObject[statusCode] = responseObject;
    });
  });
  return responsesObject;
};
const createBuilderAndDocRoot = (endpoints) => {
  const builder = e.create({
    openapi: "3.1.0",
    info: {
      title: "OpenAPI Specification",
      version: "1.0.0",
      description: `A specification generated by [openapi-devtools](https://github.com/AndrewWalsh/openapi-devtools). Contains ${endpoints.length} endpoint${endpoints.length === 1 ? "" : "s"}.`
    },
    paths: {}
  });
  return builder;
};
const createPathParameterTypes = (endpoint) => {
  const dynamicParts = endpoint.parts.filter(
    ({ type: type2 }) => type2 === PartType.Dynamic
  );
  const parameters = dynamicParts.map(({ part: name2 }) => ({
    name: name2,
    in: "path",
    required: true,
    schema: {
      type: "string"
    }
  }));
  return parameters;
};
const createQueryParameterTypes = (queryParameters) => {
  if (!(queryParameters == null ? void 0 : queryParameters.properties))
    return [];
  const namesAndSchemas = Object.entries(queryParameters.properties);
  return namesAndSchemas.map(([name2, schema2]) => {
    const parameterObject = {
      name: name2,
      in: "query",
      required: false,
      schema: schema2
    };
    return parameterObject;
  });
};
const formatAuthType = (str2) => {
  return str2.toLowerCase();
};
const endpointsToOAI31 = (endpoints, options2 = defaultOptions) => {
  var _a4;
  const builder = createBuilderAndDocRoot(endpoints);
  const uniqueHosts = /* @__PURE__ */ new Set();
  const uniqueAuth = /* @__PURE__ */ new Map();
  for (const endpoint of endpoints) {
    const fullPath = `/${endpoint.parts.map((p2) => p2.part).join("/")}`;
    const pathParameterObjects = createPathParameterTypes(endpoint);
    uniqueHosts.add(endpoint.host);
    const auth = endpoint.data.authentication;
    if (auth) {
      Object.values(auth).forEach((value) => {
        const securitySchema = createSecuritySchemeTypes(value);
        if (securitySchema) {
          uniqueAuth.set(formatAuthType(value.authType), securitySchema);
        }
      });
    }
    for (const method of Object.keys(endpoint.data.methods)) {
      const methodLower = method.toLowerCase();
      const endpointMethod = endpoint.data.methods[method];
      const queryParameterObjects = createQueryParameterTypes(
        endpointMethod.queryParameters
      );
      const requestBody = createRequestTypes(endpointMethod.request, options2);
      const responses = createResponseTypes(
        endpointMethod.response,
        endpointMethod.responseHeaders,
        options2
      );
      const security = [];
      if (!lodashExports.isEmpty(endpoint.data.authentication)) {
        Object.values(endpoint.data.authentication).forEach((value) => {
          security.push({ [formatAuthType(value.authType)]: [] });
        });
      }
      const operation = {
        summary: fullPath,
        description: `**Host**: http://${endpoint.host}`,
        responses,
        ...security && { security }
      };
      const allParameterObjects = [
        ...pathParameterObjects,
        ...queryParameterObjects
      ];
      if (allParameterObjects.length) {
        operation.parameters = allParameterObjects;
      }
      if (requestBody && shouldIncludeRequestBody(method)) {
        operation.requestBody = requestBody;
      }
      const pathItemObject = {
        [methodLower]: operation
      };
      const path2 = endpoint.pathname;
      const { rootDoc } = builder;
      rootDoc.paths = rootDoc.paths || {};
      const specPath = (_a4 = rootDoc.paths) == null ? void 0 : _a4[path2];
      if (specPath) {
        specPath[methodLower] = operation;
      } else {
        rootDoc.paths[path2] = pathItemObject;
      }
    }
  }
  uniqueAuth.forEach((auth, key2) => {
    if (!builder.rootDoc.components) {
      builder.rootDoc.components = {};
    }
    if (!builder.rootDoc.components.securitySchemes) {
      builder.rootDoc.components.securitySchemes = {};
    }
    builder.rootDoc.components.securitySchemes[key2] = auth;
  });
  return builder;
};
const compareEndpoints = (e1, e2) => {
  const re2 = /:param\d+/g;
  const firstPath = e1.pathname.replace(re2, "");
  const secondPath = e2.pathname.replace(re2, "");
  return firstPath.localeCompare(secondPath);
};
const sortEndpoints = (endpoints) => {
  endpoints.sort(compareEndpoints);
  return endpoints;
};
function Main() {
  const [spec, setSpec] = reactExports.useState(null);
  const [endpoints, setEndpoints] = reactExports.useState([]);
  const [endpointsByHost, setEndpointsByHost] = reactExports.useState([]);
  const [allHosts, setAllHosts] = reactExports.useState(/* @__PURE__ */ new Set());
  const [disabledHosts, setDisabledHosts] = reactExports.useState(/* @__PURE__ */ new Set());
  const initialStatus = lodashExports.isEmpty(requestStore.get()) ? Status.INIT : Status.RECORDING;
  const [status, setStatus] = reactExports.useState(initialStatus);
  const requestFinishedHandler = reactExports.useCallback(
    (harRequest) => {
      async function getCurrentTab() {
        try {
          harRequest.getContent((content) => {
            try {
              const contentStr = content || "";
              const wasInserted = requestStore.insert(harRequest, contentStr);
              if (!wasInserted)
                return;
              setSpecEndpoints();
              const host = safelyGetURLHost(harRequest.request.url);
              if (host && !allHosts.has(host)) {
                setAllHosts((prev2) => new Set(prev2).add(host));
              }
            } catch {
              return;
            }
          });
        } catch {
          return;
        }
      }
      getCurrentTab();
    },
    []
  );
  reactExports.useEffect(() => {
    return () => {
      chrome.devtools.network.onRequestFinished.removeListener(
        requestFinishedHandler
      );
    };
  }, []);
  const setSpecEndpoints = reactExports.useCallback(async () => {
    const nextEndpoints = requestStore.endpoints();
    setSpec(endpointsToOAI31(nextEndpoints, requestStore.options()).getSpec());
    setEndpoints(sortEndpoints(nextEndpoints));
  }, []);
  reactExports.useEffect(() => {
    requestStore.setDisabledHosts(disabledHosts);
    setSpecEndpoints();
  }, [disabledHosts]);
  reactExports.useEffect(() => {
    switch (status) {
      case Status.INIT:
        chrome.devtools.network.onRequestFinished.removeListener(
          requestFinishedHandler
        );
        requestStore.clear();
        setSpec(null);
        setAllHosts(/* @__PURE__ */ new Set());
        setDisabledHosts(/* @__PURE__ */ new Set());
        break;
      case Status.STOPPED:
        chrome.devtools.network.onRequestFinished.removeListener(
          requestFinishedHandler
        );
        break;
      case Status.RECORDING:
        chrome.devtools.network.onRequestFinished.removeListener(
          requestFinishedHandler
        );
        chrome.devtools.network.onRequestFinished.addListener(
          requestFinishedHandler
        );
        break;
    }
  }, [status]);
  const parameterise2 = reactExports.useCallback(
    (index2, path2, host) => {
      requestStore.parameterise(index2, path2, host);
      setSpecEndpoints();
      return null;
    },
    []
  );
  const start2 = reactExports.useCallback(() => {
    setStatus(Status.RECORDING);
  }, []);
  const stop = reactExports.useCallback(() => {
    setStatus(Status.STOPPED);
  }, []);
  const clear3 = reactExports.useCallback(() => {
    setStatus(Status.INIT);
  }, []);
  const importFn = reactExports.useCallback((json2) => {
    const result = requestStore.import(json2);
    setSpecEndpoints();
    setAllHosts(new Set(requestStore.hosts()));
    return result;
  }, []);
  if (status === Status.INIT) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Start, { start: start2 });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Context.Provider,
    {
      value: {
        allHosts,
        setAllHosts,
        endpointsByHost,
        setEndpointsByHost,
        disabledHosts,
        setDisabledHosts,
        parameterise: parameterise2,
        endpoints,
        export: requestStore.export,
        import: importFn,
        options: requestStore.options
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.wrapper, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Control2, { start: start2, stop, clear: clear3, status }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          redoc_browser_libExports.RedocStandalone,
          {
            spec: spec || {},
            options: {
              hideHostname: true,
              sortEnumValuesAlphabetically: true,
              sortOperationsAlphabetically: true,
              sortPropsAlphabetically: true,
              hideLoading: true,
              nativeScrollbars: true,
              downloadFileName: "openapi-devtools-spec.json",
              expandDefaultServerVariables: false,
              expandSingleSchemaField: false
            }
          }
        )
      ] })
    }
  );
}
const container = "_container_1hrww_2";
const styles = {
  container
};
const outline = defineStyle({
  border: "2px dashed",
  borderRadius: 0,
  fontWeight: "semibold"
});
const closeButtonTheme = defineStyleConfig({
  variants: { outline }
});
const theme = extendTheme({
  components: { CloseButton: closeButtonTheme }
});
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { theme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Main, {}) });
}
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
);
//# sourceMappingURL=panel-5aa7c38e.js.map
